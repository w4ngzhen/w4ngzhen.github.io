<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Spring Bean装配笔记 | CompileMind</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Spring,Bean," />
  

  <meta name="description" content="Spring中的Bean是一个很重要的概念。Spring作为一个Bean容器，它可以管理对象和对象之间的依赖关系，我们不需要自己建立对象，把这部分工作全部转交给容器完成，具有低耦合，对代码没有侵略性。 目前本人的水平还不足以透彻的分析Spring是如何来构建Bean的装配的概念的，这里仅来记录总结Spring中多种Bean的装配方式。 Spring的配置方式有Java类配置形式与XML配置两种形式">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Bean装配笔记">
<meta property="og:url" content="http://compilemind.com/2018/03/10/2018-03-10-Spring%20Bean%E8%A3%85%E9%85%8D%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="CompileMind">
<meta property="og:description" content="Spring中的Bean是一个很重要的概念。Spring作为一个Bean容器，它可以管理对象和对象之间的依赖关系，我们不需要自己建立对象，把这部分工作全部转交给容器完成，具有低耦合，对代码没有侵略性。 目前本人的水平还不足以透彻的分析Spring是如何来构建Bean的装配的概念的，这里仅来记录总结Spring中多种Bean的装配方式。 Spring的配置方式有Java类配置形式与XML配置两种形式">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-03-09T16:00:00.000Z">
<meta property="article:modified_time" content="2020-08-24T11:05:26.464Z">
<meta property="article:author" content="w4ngzhen">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Bean">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  

  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.1.0"></head>

<body>


  

  <div class="post-header">
   

</div>




<div class="content content-post CENTER">
   <article id="post-2018-03-10-Spring Bean装配笔记" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Spring Bean装配笔记</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.03.10</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>w4ngzhen</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>Spring中的Bean是一个很重要的概念。Spring作为一个Bean容器，它可以管理对象和对象之间的依赖关系，我们不需要自己建立对象，把这部分工作全部转交给容器完成，具有低耦合，对代码没有侵略性。</p>
<p>目前本人的水平还不足以透彻的分析Spring是如何来构建Bean的装配的概念的，这里仅来记录总结Spring中多种Bean的装配方式。</p>
<p>Spring的配置方式有Java类配置形式与XML配置两种形式。大致提一下，不赘述，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java类config形式，需要@Configuration注解来声明</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类路径下的XML形式</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans ...&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>Spring提供了三种装配机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">隐式的bean发现机制和自动装配</span><br><span class="line">在Java中进行显示配置</span><br><span class="line">在XML中进行显示配置</span><br></pre></td></tr></table></figure>
<p><strong>隐式的bean发现机制和自动装配</strong></p>
<p><strong>隐式bean发现与自动装配即我们完全不必在配置类或者配置文件中定义bean属性（但是这两者必要提供一种）。</strong> 如何定义一个Java类是bean？我们可以在类上使用@Component注解声明一个bean。<br>首先定义一个接口：Playable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Playable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们定一个CD类，实现该接口，并添加@Component注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CD</span> <span class="keyword">implements</span> <span class="title">Playable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CD is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此定义，即可表明CD是一个bean。接下来如何开启扫描？</p>
<p>如果使用Java类配置的方式来配置Spring，我们可以使用@ComponentScan注解在配置类上，告诉Spring开启了组建扫描。并且进行形如如下的bean配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 务必注意此处的自动扫描的基础包</span></span><br><span class="line"><span class="comment">// 因为通常配置类与其他类的包在不同的地方</span></span><br><span class="line"><span class="comment">// 默认的包路径是当前配置类所在包下</span></span><br><span class="line"><span class="meta">@ComponentScan(backPakages = &quot;xxx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用XMl来定义，则如下定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span></span></span><br></pre></td></tr></table></figure>
<p>接下来编写测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = MyConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Playable playable; <span class="comment">// 运行时，将扫描到的在容器中的CD bean装配到这里的playable</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNULL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertNotNull(playable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果自然是PASS</span></span><br></pre></td></tr></table></figure>

<p>这里在配置类中我们完全没有定义任何的bean，Spring自动为我们扫描出对应的组件进行自动装配（Autowired）到测试类中。</p>
<p>CD这个类过于简单了，现在重构CD，使其拥有一个title属性，用以表示CD的名字。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CD</span> <span class="keyword">implements</span> <span class="title">Playable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CD</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CD:&quot;</span> + title + <span class="string">&quot; is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们再次运行测试代码，会发现报错：</p>
<p>Unsatisfied dependency expressed through constructor parameter 0;// 大意是提示我们，CD这个类没有默认的参数个数为0的构造器。这里我们大致可以猜测，Spring在进行普通的构建对象时，是调用的该类的默认构造函数，在Java中我们知道，在一个类中若定义了任意形式的构造函数，原先的默认无参构造函数自然失效，而我们定义了有参数的构造函数，所以这里Spring调用不了无参构造函数，顾不能为我们构造这个bean。解决办法就是添加一个无参构造函数。</p>
<p>但是问题还没有彻底解决，这里Spring只是为我们创建了一个title没有初始化的CD实例对象，我们应该如何去初始化这个title呢？注入的是一个普通的对象，我们同样可以使用@Autowired注入，但是这里只是一个字面量String，如何注入？其实我们可以采用一种更加直观的方式来注入——<strong>显式配置</strong></p>
<p><strong>通过显式配置</strong></p>
<p>配置类形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;zhen&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Playable <span class="title">cd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CD(<span class="string">&quot;JayChou&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面通过@Bean来声明下面我们将要定义一个bean，紧接着定义一个方法，返回值为Playable（这里没有严格的要求是接口类还是本身实现类，满足语法即可），方法名即为该bean对应的id，参数虽没有定义，但是不代表不能有，这里可以注入其它的bean。方法体中的内容自然是返回具体的实现类了，然而这里就很灵活，我们可以将字符串通过这里构造函数传入，假如我们的CD类中如果有setTitle方法，甚至还可以像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Playable <span class="title">cd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CD cd = <span class="keyword">new</span> CD(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    cd.setTitle(<span class="string">&quot;JayChou&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件XML如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cd&quot;</span> <span class="attr">class</span>=<span class="string">&quot;zhen.CD&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;JayChou&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对比上面的两种显示注入的用法，对应也是很清楚的，Java类中的方法名即为bean id，返回对象对应的类即为XML中的class属性。同时，根据构造函数参数类型的不同，也有不同的形式，这里本篇笔记不多提，以后会有相关的笔记探讨的。</p>
<p>但是请注意，如果Java类配置文件中已经有一个@Bean，同时还启动了自动扫描，在原先的组件类上添加了@Component注解，Spring是会我们创建两个同为CD类实例bean的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意已经添加了@Component注解</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CD</span> <span class="keyword">implements</span> <span class="title">Playable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title = <span class="string">&quot;Default Title&quot;</span>;</span><br><span class="line">    <span class="comment">//  定义一个可以设置的title的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CD:&quot;</span> + title + <span class="string">&quot; is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置类中开启了组建扫描，且也定义了一个bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;zhen&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Playable <span class="title">cd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CD cd = <span class="keyword">new</span> CD();</span><br><span class="line">        cd.setTitle(<span class="string">&quot;JayChou&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试类不变的情况下，运行测试代码，会报错：</p>
<p>No qualifying bean of type ‘zhen.component.Playable’ available: expected single matching bean but found 2: CD,cd</p>
<p>这行报错告诉我们，发现了两个bean：CD cd都满足Playable，都可以注入到此处。 <strong>（注意，如果一个类有@Component组件注解，该类的bean id默认为类名首字母小写，这里CD由于其本身两个字母都是大写，Spring所以给其的默认名没有将首字母小写，一定注意命名特殊性）</strong> 到底该选谁呢？如果我们不指定，Spring也不能为我们做主。如果我们将测试类中的Playable playable改为Playable cd 或者 CD，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = MyConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">// 为了配合下面输出title进行验证</span></span><br><span class="line">    <span class="comment">// 这里我将类型改为了CD，且CD类中的私有title我修改为了公有</span></span><br><span class="line">    CD cd;</span><br><span class="line">    <span class="comment">// CD CD;</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNULL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(cd.title); <span class="comment">// 输出 “CD:JayChou is playing...”</span></span><br><span class="line">        <span class="comment">// System.out.println(CD.title); // 输出 &quot;CD:Default String is playing...&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面均通过</span></span><br><span class="line">        Assert.assertNotNull(cd);</span><br><span class="line">        <span class="comment">// Assert.assertNotNull(CD);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的现象，我们可以推测Spring在注入的时候，首先根据@Autowired下面的引用名来查找对应类型的bean id，如果没有，再找同类型的bean（这里要补充一下，@Autowired是根据类型来匹配注入的）</p>
<p>以上笔记大致总结了一下Spring bean装配问题，然而还有问题没有解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面提到过的报错，Spring如果找到了多个同类型的bean会提示报错，在没有声明的情况下，Spring不知道到底改选哪一个，这就是自动装配的歧义性问题。</span><br></pre></td></tr></table></figure>
<p>以上两个问题，我会继续做笔记的。</p>

    
  </div>

</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
