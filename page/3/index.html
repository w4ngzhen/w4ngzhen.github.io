<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"compilemind.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CompileMind">
<meta property="og:url" content="http://compilemind.com/page/3/index.html">
<meta property="og:site_name" content="CompileMind">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="w4ngzhen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://compilemind.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>CompileMind</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CompileMind</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/07/29/2018-07-29-%E5%81%9A%E4%BD%A0%E6%89%80%E5%81%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/29/2018-07-29-%E5%81%9A%E4%BD%A0%E6%89%80%E5%81%9A/" class="post-title-link" itemprop="url">做你所做</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-29 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-29T00:00:00+08:00">2018-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="昨夜"><a href="#昨夜" class="headerlink" title="昨夜"></a>昨夜</h4><p>昨晚我失眠了，因为在自己的机器上装东西，顺便看了小米的纪录片《一团火》。也许是太久没有看到关于非产品方面的小米了，也许是太想要看到小米一路走来的路了，看完后我内心久久不能平复。待到后半夜，我内心依然如纪录片一般“一团火”。那一群人，那样的坚定，让我羡慕与感动。</p>
<h4 id="眼下"><a href="#眼下" class="headerlink" title="眼下"></a>眼下</h4><p>今天是入职第二周周末，之所以没有在前些日子就写博文，因为那段时间单纯的是报道——领东西——装机器——配环境——培训，似乎每一位到新环境工作的人总要经历的东西，还有什么可写的呢？真正让我内心激动的是昨夜的“一团火”还有这几天以来的感受，回想起去年实习的日子，我庆幸于没有因为苟且而留在那里。而在这里，我的体会是满足的，是充实的。</p>
<h5 id="“温柔”"><a href="#“温柔”" class="headerlink" title="“温柔”"></a>“温柔”</h5><p>每一位同事都给我一种“温柔”的感觉，这“温柔”绝不是那些小说女主角一般的依偎与可爱，更贴切的是一种淡然自若。他们的眉头也偶有骤紧，但绝不会是重压下的无法呼吸，而是紧凑而繁忙的工作带给他们的充实。其次的工作环境与氛围也是”温柔“的。在我看来，工作环境对于一个人的内心或多或少都有影响。这里给了我很舒服的感觉，一种温馨的，好似家一般的感觉。或许是因为并不是单纯的开发中心的原因吧，少了理工的那种统一呆板，更多的是像成都一般的闲适。</p>
<h5 id="Not-Hei"><a href="#Not-Hei" class="headerlink" title="Not Hei"></a>Not Hei</h5><p>回想起去年的在苏州某为的实习，好似我在黑它一般。没有人情味的工作，没有人情味的活动。好像每一个人在工作，但仅仅是每”一个“人。那段时间，我好担忧，因为进入的第一周，我就似乎看到了假如我在这里工作以后，一年两年三年的日子。以至于实习结束的时候，我没有丝毫的充实感。跟导师发出道别消息的那一刹那，我甚至没有一丝的眷念。接下来，回家，收拾行李，买回学校的车票，一切在欣欣然之中。</p>
<p>是过于言重了吗？可我就如把一件难缠的事情磕磕碰碰磨平了一般解脱了！心情线在实习开始的顶点一路缓缓跌下，然后结束实习，又直入云霄了：）。就如鸡汤常说的，很多事情，只有经历了才知道。对，我经历了某为的实习之后，再也不想回去了！</p>
<p>前段时间入职之前，我依然有些许的担忧——是不是还像去年那样，氛围、人情味毫无，如果那样，我该怎么办啊！事实证明，我多虑了：）。最近刚好在组内有幸参加了六月的回顾会，”老老大“让每一位员工说说自己这一个月的时间的心情变化。作为新人，当然没有处理项目的复杂心情，也只能谈一谈如之前后的一些所以想：</p>
<p>去年在别处的实习与这段是时间的入职感受截然不同。这里的工作氛围、人与人之间的交互，让我感到十分的舒适。同样，只要是我需要接触的技术，在入门以及较为深入的学习之后，总能够给予我足够的兴趣与信心。因为好多都不懂，所以好多都想要学习。于是继续学习，继续总结心得，进而激发了更多的兴趣。如此良性的循环 + 工作环境氛围 =&gt; 继续以一个乐观的心态去面对工作中的一切。其实这种类似的话也曾在许多鸡汤中见过，那时还觉得不过尔尔，可是当我真正去体会的时候，”在听已是曲中人“，：）。</p>
<h5 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h5><p>我也不知道什么时候，我的心态就变得如此乐观。但一次与高中挚友的交谈，我们大概得出了一个为什么的结论：因为家人的支持。我感激于我的家人在背后给予了我莫大的帮助，无论精神上还是物质上。对于精神层面，他们总是希望我能够在无论是生活还是工作上都学到东西，希望我能够关注过程带来的收获，而不仅仅看结果；而从物质上来说，他们无私的为我创造条件，让我不要花过多的时间来关注物质方面的需求，从而能全身心的投入到工作学习中。这两方面其实是相互结合的。说了好多大话，可这就是我最真切的感受。：）。</p>
<h4 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h4><p>未来会是怎样呢？</p>
<p>当我们受制于生活的”苦难“</p>
<p>是不满命运的挣脱</p>
<p>还是”哪里跌倒哪里趴着“的苟且</p>
<p>当我们总是沉迷于表象安逸</p>
<p>是当一位睁着眼睛的瞎子</p>
<p>还是做一名不停反思的Thinker</p>
<p>当我们发现经常无所事事</p>
<p>是走一步看一步的慵懒</p>
<p>还是勇敢迈出第一步去充实自己</p>
<p>我会告诫自己：Keep Real, Keep 3</p>
<hr>
<h5 id="符号说明：）"><a href="#符号说明：）" class="headerlink" title="符号说明：）"></a>符号说明：）</h5><p><strong>：）</strong>：嘻嘻</p>
<p><strong>+</strong>：结合</p>
<p><strong>=&gt;</strong>：促使</p>
<p><strong>3</strong>：011</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/07/02/2018-07-02-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AF%B9%E4%BA%8E%E7%94%9F%E6%88%90Bean%E7%9A%84%E5%BD%B1%E5%93%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/02/2018-07-02-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AF%B9%E4%BA%8E%E7%94%9F%E6%88%90Bean%E7%9A%84%E5%BD%B1%E5%93%8D/" class="post-title-link" itemprop="url">Spring配置文件结构对于生成Bean的影响</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-02 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-02T00:00:00+08:00">2018-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于前段时间忙于毕设，导致Spring学习的东西忘了很多，所以最近又开始从头看Spring的基础。基础的Bean的装配不再多说了。这一次，主要是深入一点了解Spring配置文件结构搭配对于Bean装配的影响。</p>
<p>首先，我们设定一个简单的场景：播放器播放歌曲。所以基于此，我们定义两个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"><span class="comment">// CD接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"><span class="comment">// 媒体播放器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>按照是实际来讲，我们定义一个BlankDisc，空白的唱片，其包含三个属性：title、artist和tracks，分别代表了唱片的标题、歌手以及歌曲目录：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.cd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> demo.CompactDisc;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankDisc</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String artist;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; tracks; <span class="comment">// 简化结构，只存放歌曲目录名称并保存为List</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(String title, String artist, List&lt;String&gt; tracks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.artist = artist;</span><br><span class="line">        <span class="keyword">this</span>.tracks = tracks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing &quot;</span> + title + <span class="string">&quot; \n\tby &quot;</span> + artist);</span><br><span class="line">        tracks.stream().forEach(t -&gt; System.out.println(<span class="string">&quot; \t&gt;&gt;&gt; &quot;</span> + t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同样的，实现MediaPlayer接口，定义实际的唱片播放器，能够持有cd的引用，同时，这里我们并没有通过构造器来定义，原因是唱片播放器并非一定放有cd（当然代码没有对null进行约束，这是不好的，实际编写请勿这样编写）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> demo.CompactDisc;</span><br><span class="line"><span class="keyword">import</span> demo.MediaPlayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCd</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CDPlayer 开始播放: &quot;</span>);</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来，要说明的是，Spring支持xml与Java文件同时存在的配置方式，这里我们也会这么做，尽可能的复杂化配置依赖，因为本片文章就是探讨各种配置文件交叉依赖的情形，并理清依赖的思路。</p>
<p>首先我们将CD类Bean与CDPlayer类Bean分离开来。</p>
<h4 id="首先是CD类Bean"><a href="#首先是CD类Bean" class="headerlink" title="首先是CD类Bean"></a>首先是CD类Bean</h4><h5 id="Java类型配置文件"><a href="#Java类型配置文件" class="headerlink" title="Java类型配置文件"></a>Java类型配置文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> demo.cd.BlankDisc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BlankDisc <span class="title">yeHuiMei</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; tracks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tracks.add(<span class="string">&quot;以父之名&quot;</span>);</span><br><span class="line">        tracks.add(<span class="string">&quot;懦夫&quot;</span>);</span><br><span class="line">        tracks.add(<span class="string">&quot;晴天&quot;</span>);</span><br><span class="line">        tracks.add(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(<span class="string">&quot;YeHuiMei&quot;</span>, <span class="string">&quot;JayChou&quot;</span>, tracks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个配置文件中，只定义了一个Bean，Bean id名称为yeHuiMei（方法名），同时也将相关的属性设置完毕。</p>
<h5 id="xml类型配置文件"><a href="#xml类型配置文件" class="headerlink" title="xml类型配置文件"></a>xml类型配置文件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;onTheRun&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;demo.cd.BlankDisc&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">value</span>=<span class="string">&quot;On The Run&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;artist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;JayChou&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;tracks&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>牛仔很忙<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>彩虹<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>青花瓷<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>...<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个xml配置文件中，我定义了一个名为onTheRun的Bean，同时也设置了对应的属性。</p>
<h4 id="CDPlayer的Bean"><a href="#CDPlayer的Bean" class="headerlink" title="CDPlayer的Bean"></a>CDPlayer的Bean</h4><h5 id="Java类型配置文件-1"><a href="#Java类型配置文件-1" class="headerlink" title="Java类型配置文件"></a>Java类型配置文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayerInJava</span><span class="params">(<span class="meta">@Qualifier(&quot;onTheRun&quot;)</span> CompactDisc cd)</span> </span>&#123;</span><br><span class="line">        CDPlayer cdPlayer = <span class="keyword">new</span> CDPlayer();</span><br><span class="line">        cdPlayer.setCd(cd);</span><br><span class="line">        <span class="keyword">return</span> cdPlayer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="xml类型配置文件-1"><a href="#xml类型配置文件-1" class="headerlink" title="xml类型配置文件"></a>xml类型配置文件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cdPlayerInXML&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo.player.CDPlayer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cd&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;yeHuiMei&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>目前配置文件搞定了，并且我们现在的配置以来结构如下：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/dependency.png" alt="dependency"></p>
<p>当然，目前还是有一定的问题的，因为很显然，我们的配置文件都独立与彼此。尽管在CDPlayer中的配置文件通过相关的语法制定了CD Bean的选择（@Qualifier和ref），但是我们可以看到文件本身并没有明确的引入另外的配置文件，所以在IDEA中通常会有这样的提示：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/norefinjava.png" alt="norefinjava"><br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/norefinxml.png" alt="norefinxml"><br>同时打开，IDEA的项目结构Project Structs（win默认ctrl+shift+alt+s），点击左侧的Modules，可以看到Spring项目上右下角IDEA提示我们“Unmapped Spring configuration files”并列举除了上述的四个文件。</p>
<p>我们点击上面的+将所有的配置文件追踪上，刚刚所有的索引问题都OK了。此时，我们任意找到一个xml文件，可以看到左上方有一个小标志，点击并选择第一个：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/clickdpdiagram.png" alt="clickdpdiagram"><br>打开之后就能够看到整个项目对于配置文件的依赖：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/dpdiagram.png" alt="dpdiagram"><br>可以看到我们的项目（springdemo）具有一个是上下文应用模块，这个应用上下文包含了四份配置文件。但一定要注意，在后续我们加载配置文件的时候，必须要将有依赖关系的配置文件全部加载进来才能够读取到对应的Bean。这里我们进行一个简单的测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// 设置所要加载的配置文件</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:cdconfig.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;onTheRun&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个测试是可以直接通过的，因为这里我们加载的是cdconfig.xml配置文件，里面我们定义了名为onTheRun的Bean，所以打印还有非空测试也通过：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/cdxmltest.png" alt="cdxmltest"><br>然而接下来我们更换配置文件为cdplayerconfig.xml，相关注入如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:cdplayerconfig.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;cdPlayerInXML&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer mp;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mediaPlayerNotNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(mp);</span><br><span class="line">        mp.play();</span><br><span class="line">        assertNotNull(mp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我们指定注入的就是xml中的CDPlayer Bean，然而，并不能通过测试，在错误提示中，我们可以找到这样一行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot resolve reference to bean <span class="string">&#x27;yeHuiMei&#x27;</span> <span class="keyword">while</span> setting bean property <span class="string">&#x27;cd&#x27;</span>; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named <span class="string">&#x27;yeHuiMei&#x27;</span> is defined</span><br><span class="line">	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:<span class="number">328</span>)</span><br></pre></td></tr></table></figure><br>前面我们知道，cdPlayerInXML这个bean中我们还注入了Java配置文件下的名为yeHuiMei Bean，而在测试的过程中，我们只加载了cdplayerconfig.xml这个配置文件。所以实际上除了这个配置文件意外的其他bean都没有被Spring生成并放入Bean容器中。</p>
<p>也许会有疑问，在上面的Bean依赖图中，我们看到所有的配置文件都有已经被放入到了Spring Application Context中，为什么不被自动加载呢？道理很简单，这只是IDE的辅助而已。IDEA中的那个部分只是IDEA自身的一些辅助功能比如静态检查，所以需要我们手动的将这些文件给添加进去。当我们还是移除掉刚刚的结构之后，进行第一次的只对没有依赖的CDBean进行测试依然有效。</p>
<p>一定要明确，Spring的注入是发生在代码中的！不要被IDE遮蔽了双眼！这里何时会被注入呢？当我们配置了Spring的配置文件并将其加载进来了，当Spring遇到@Autowired等注入注解的时候，就会为我们注入Bean。</p>
<p>通常，当我们有多个配置文件的是，最优的结构思路是将多个配置文件导入到一个专门的独立的配置文件中，就像下面这样，我将开始的四个配置文件全部导入到一个名为AllConfig的Java配置文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;CDConfig.class, CDPlayerConfig.class&#125;)</span></span><br><span class="line"><span class="comment">// 一定要注意！！！classpath:后面一定不要带空格！否则会被识别为【[空格]cdconfig.xml】这样的文件名而不被找到，血的教训。</span></span><br><span class="line"><span class="meta">@ImportResource(&#123;&quot;classpath:cdconfig.xml&quot;, &quot;classpath:cdplayerconfig.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后在测试文件中我们将加载配置文件为Java配置文件AllConfig，此时，所有的以来问题全部解决：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;AllConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;onTheRun&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;cdPlayerInXML&quot;)</span><span class="comment">// 一开始由于配置文件没有引入全导致注入失败</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer mp;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mediaPlayerNotNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(mp);</span><br><span class="line">        mp.play();</span><br><span class="line">        assertNotNull(mp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/passed.png" alt="passed"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/06/17/2018-06-17-%E6%AF%95%E4%B8%9A%E6%89%80%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/17/2018-06-17-%E6%AF%95%E4%B8%9A%E6%89%80%E6%83%B3/" class="post-title-link" itemprop="url">毕业所想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-17 00:00:00" itemprop="dateCreated datePublished" datetime="2018-06-17T00:00:00+08:00">2018-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>距离上一次博文过了接近一个月了，这期间毕设虽忙，但不至于忙到连博文都写不了的地步。早就在寻思着什么时候更一篇文章，但是就是懒，好像每天忙完毕设的事情之后，就感觉自己今天做完一件事，就可以休息了，就可以放纵自己了。其实不过都是借口罢了。趁着这个时间，写写东西，回顾一下写过的东西，觉得写的东西还是太分散了，或者说，目前为止都没有一个明确的写作目标，这里也表明一下，顺便也为今后的写作约束一下自己。</p>
<h4 id="我的博客到底要有些什么？"><a href="#我的博客到底要有些什么？" class="headerlink" title="我的博客到底要有些什么？"></a>我的博客到底要有些什么？</h4><p>这段时间看Effective Java，看Scala，做做练习，其实一直都是有心得体会的，不过都只是一些小的点，没有像之前的一些博文心得，有宏观的大的系统知识结构，特别是Effective Java，本身就是对于Java的各个方面来总结的，更是说不上宏大了。于是，对于通过博文来总结这些心得体会，如果硬要写出一篇来，总感觉到时候会纯粹地拼凑。我不想我的博文到头来<strong>纯粹</strong>成为一些Tips的合集（以前写的Linux命令就有这种嫌疑）。过了这么久了，我希望我的博文能够提升一下水平，加入更多的自己的元素在其中，当然，Tips类型的还是会有的，因为我坚持一个观点：<strong>当你需要花一定的时间反复琢磨、寻找解决问题的方法的时候，就是你需要记录的时候。</strong>所以，当我花费了一定的时间去配置某些东西的时候，我就会写一篇博文来进行记录，一来是训练自己的写作表述能力（虽然找资源，装环境这种博文提升不了太多的写作能力），二来是保持写作的心态。此外，我虽然是一位普通的程序员，但是心里还是有文学写作的心的。回忆起初中时期，就写过一本诗集，很可惜未保存好而遗失了。所以，我的博文同样会有一些偏向于更为文学的东西存在，譬如诗、杂记等，希望能够纪念且告诫自己不要因为成为一名程序员而遗失对于生活，对于人生的思考与感悟。</p>
<p>综上（好生刻板的文字），我的博文会<strong>尽量</strong>控制70%是包含有自己见解的技术类博文，20%时日常开发过程中的配置记录等相关的文章，剩下的10%则是更为文学的文章。</p>
<h4 id="再谈毕业所感所想"><a href="#再谈毕业所感所想" class="headerlink" title="再谈毕业所感所想"></a>再谈毕业所感所想</h4><p>这一天总归是要到来的。14年的盛夏来到了大学，是平淡的，是卑微的。还记得初到校园时候的迷茫，拿着预存有200快的校园卡，跑到教育超市买了一堆东西，发现超支了，尴尬的找附近的一位他同样是新生的女同学借了饭卡代刷。面容早已忘记了，但相比此时此刻，她也在忙于离校的琐事吧。这段时间老是和杨同学聊天，这四年到底怎么过来的，怎么一晃眼就要毕业了，最后嬉笑着打住了话题。</p>
<p>是啊，怎么过来的呢？能够回想起这四年的点点滴滴，但也觉得太快了一点。大一的军训，大一的晚自习，大一对自己写的信；大二的上课的回答，大二时候的起早贪黑的学习；大三的课设，大三的比赛；大四的实习，大四的毕设（right now），一切都是历历在目。是因为大学的生活不像高中那样的三点一线，这些事情就变“稀薄”了吗？还是因为我们的心在成长，面对未来有了更多的从容不迫了吗？说不出来，大一到大四就这么过来了，这四年，这八个学期就这么过来了。有时候时间的改变，就这么过来了，就好像两个人相互的日久生情的喜欢，就这么过来了。</p>
<p>有那么一瞬间，我还有点羡慕就在学校所在省的同学们。这毕业一别之后，他们再见的概率超过50%，就算没有，也能创造见面的机会，毕竟如今发达的交通让他们能再短时间相见。而我就不一样了，家乡距此超过两千公里，见面是多么的不容易。也许这一别，同一个宿舍的也许还能因为某些重大的事情而见面，不是同一个宿舍的，就是永远的不再相见了。想来也是神奇，有这样一群人，你和他曾有过四年的交集，这一别之后，就再无交集了。</p>
<p>大学的生活对于绝大多数的人来说就是一两个宿舍的小圈子。我们往往在这一个小圈子中自由的生活着，交流着。于是，临近惜别之时，就会有一些人没能参与到班级的聚会中，想来挺替他们感到遗憾的，但也能理解。大学的同学之间的交情往往还不到初高中的一半，凝聚力自然也没有初高中那么强。想起初中写过辣鸡电影剧本，“担任”导演一职，一大波同学饶有兴致地参与扮演、拍摄（我可能对电影制作有什么误解，哈哈）。但至少还是有一群可爱地大学同学们啊！不过对于我来说，也许是要永别了。</p>
<p>作为一名即将毕业成为程序员的我，当然经常看到别说程序员怎么怎么呆板，怎么怎么冰冷。我想要做的就是成为一名积极的程序员，成为一名通俗一点来讲，“多才多艺”的程序员。所以，我始终会坚持锻炼，始终会尝试不同于一般程序员所干的事情，譬如文学方面的写作、声乐的学习。我想要成为一名乐观主义者，而不是一名单纯的极客。这始终是我的理想。我想我能够带给人们的无限的可能，这样也许说的太宏观了，太雄伟了。具体一点，我希望我的家人，我的另一半能够看到丰富多彩的我，而不是众口中的“普通”程序员。我希望，我是一个理想的，有思考的，有<strong>活力</strong>的，爱生活的人！今后的博文，我也许会介绍我曾经触碰过的很多东西，虽然有一点“不务正业”。</p>
<p>拒绝无病呻吟。我对于别人的无病呻吟虽谈不上鄙夷，但至少总是会不去理会他们，当一个“瞎子”忽视就好。一谈到写文章，就往往会和这些东西或多或少有些联系。所以我也时常告诫自己，不要带上这样的情绪。带上这些情绪，我们往往会“迷失”自己，进而形成一种“自我感动”的情形。还是那句话，我是一个乐观实用主义者，不要因为琐事而丧失自己的前进的心态。面对任何困难，不要无病呻吟，动手去做，去处理，不要等到一切都逼近的时候才后知后觉，才忙碌，才一阵匆忙之后，说出无病呻吟的话语，这样真的只是“感动自己”。</p>
<h4 id="毕"><a href="#毕" class="headerlink" title="毕"></a>毕</h4><p>仲夏将至，夜不能寐。其由唯二，一来夏蚊成雷，挥之不去，甚是烦恼；二来完业临近，欲与学业惜别，些许惆怅。遂起身信步于闲庭之中，观夜中明星，忆四载春秋，不禁感慨万千。吾已二十有二，求学多年，虽无当今能人之卓越，也不失一心向前之意志。<br>人生漫漫，从未停息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/05/18/2018-05-18-Java%E6%9E%9A%E4%B8%BE%E7%BB%86%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/18/2018-05-18-Java%E6%9E%9A%E4%B8%BE%E7%BB%86%E8%8A%82/" class="post-title-link" itemprop="url">Java枚举细节</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-18T00:00:00+08:00">2018-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="枚举的简单使用"><a href="#枚举的简单使用" class="headerlink" title="枚举的简单使用"></a>枚举的简单使用</h4><p>在java中，我们可以使用enum关键字来定义枚举：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>就像上面一样，我们定义了一个名为Color的枚举类，包含了RED、GREEN、BLUE三个常量。当我们使用枚举类的时候，直接通过枚举类名.枚举常量即可。就像如下的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Color c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> RED: System.out.println(<span class="string">&quot;It&#x27;s RED&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GREEN: System.out.println(<span class="string">&quot;It&#x27;s GREEN&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: System.out.println(<span class="string">&quot;It&#x27;s BLUE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">f(Color.RED);</span><br><span class="line"><span class="comment">// 输出 &quot;It&#x27;s RED&quot;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="枚举的本质"><a href="#枚举的本质" class="headerlink" title="枚举的本质"></a>枚举的本质</h4><p>虽然Java提供枚举类的定义，但是实际上他并不是Java中一个新的对象类型，我们通过对Color枚举类进行反编译，得到如下的反编译结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ javap Color.class </span><br><span class="line"><span class="comment">// 反编译结果</span></span><br><span class="line">Compiled from <span class="string">&quot;Color.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationAndAnnotation</span>.<span class="title">Color</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">EnumerationAndAnnotation</span>.<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumerationAndAnnotation.Color RED;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumerationAndAnnotation.Color GREEN;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumerationAndAnnotation.Color BLUE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EnumerationAndAnnotation.Color[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EnumerationAndAnnotation.<span class="function">Color <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到，枚举类实际上在编译的过程中，被编译器进行调整，它并不是一个新的类型，本质上依然是一个类（Color），这个类继承了java.lang.Enum<T>，而对于每一个枚举常量，实际上是public static final修饰的枚举类的静态实例对象。</p>
<p>同时注意，编译器会为我们添加两个新的static方法：values() 和 valueOf(java.lang.String)，其实分别作用是返回枚举类中定义的所有的枚举常量，以及根据枚举名来获取枚举常量（注意，这里就是定义枚举常量的枚举名）。</p>
<p>当然，由于每一个枚举常量实际上是实现了java.lang.Enum<T>的枚举类的一个静态实例对象，而这个过程是编译器为我们进行的，所以，自然，我们可以在枚举类中定义任何的方法、变量，以及构造函数的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED(<span class="string">&quot;RED&quot;</span>), GREEN(<span class="string">&quot;GREEN&quot;</span>), BLUE(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义类中的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String colorName;</span><br><span class="line">    <span class="comment">// 定义构造函数，注意上面的枚举常量必须满足这种构造方式</span></span><br><span class="line">    Color(String colorName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.colorName = colorName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义实例对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printColorName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Color name is &quot;</span> + colorName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colorName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>自然，我们可以枚举常量当作一个枚举的实例化对象，调用枚举类中的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Color.RED); <span class="comment">// RED</span></span><br><span class="line">    Color.RED.printColorName();	<span class="comment">// Color name is RED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="为什么枚举构造器不能访问枚举的静态域"><a href="#为什么枚举构造器不能访问枚举的静态域" class="headerlink" title="为什么枚举构造器不能访问枚举的静态域"></a>为什么枚举构造器不能访问枚举的静态域</h4><p>查看下面这段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    Color() &#123;</span><br><span class="line">        System.out.println(value); <span class="comment">// 编译错误！构造器无法访问静态变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到这里编译不通过，提示我们<strong>枚举构造器</strong>不能够访问枚举的静态域（以及静态变量）。我们知道，一般的类中，静态域以及静态变量是优于实例对象的变量、方法的初始化的。这里简要复习一下类中变量的加载机制：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助静态变量的初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String init)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init()&quot;</span> + init);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fa</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父类静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Init initFa = <span class="keyword">new</span> Init(<span class="string">&quot;Fa&#x27;s static&quot;</span>);</span><br><span class="line">    <span class="comment">// 父类实例变量</span></span><br><span class="line">    Init initFa2 = <span class="keyword">new</span> Init(<span class="string">&quot;Fa&#x27;s no static&quot;</span>);</span><br><span class="line">    <span class="comment">// 父类静态域</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fa&#x27;s static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父类构造方法</span></span><br><span class="line">    Fa() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fa()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Su</span> <span class="keyword">extends</span> <span class="title">Fa</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类静态域</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Su&#x27;s static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Init initSu = <span class="keyword">new</span> Init(<span class="string">&quot;Su&#x27;s static&quot;</span>);</span><br><span class="line">    <span class="comment">// 子类实例变量</span></span><br><span class="line">    Init initSu2 = <span class="keyword">new</span> Init(<span class="string">&quot;Su&#x27;s no static&quot;</span>);</span><br><span class="line">    <span class="comment">// 子类构造函数</span></span><br><span class="line">    Su() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Su()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来，我们new出Su实例对象，并观察输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Su();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">Init()Fa&#x27;s static 	// 1</span></span><br><span class="line"><span class="comment">Fa&#x27;s static			// 2</span></span><br><span class="line"><span class="comment">Su&#x27;s static			// 3</span></span><br><span class="line"><span class="comment">Init()Su&#x27;s static	// 4</span></span><br><span class="line"><span class="comment">Init()Fa&#x27;s no static// 5</span></span><br><span class="line"><span class="comment">Fa()				// 6</span></span><br><span class="line"><span class="comment">Init()Su&#x27;s no static// 7</span></span><br><span class="line"><span class="comment">Su()				// 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>我们可以看到，有static修饰的始终优于实例对象的相关的初始化的，在输出中 1 - 4 是static修饰部分，5 - 8是实例域部分。此外，在继承情形下，父类由于子，输出中 1- 2 是父类static域的初始化，3 - 4 是子类static域的初始化。在static域加载完成之后，才开始加载父类非static域，最后加载子类的非static域。注意，都为static修饰的情况下，加载顺序根绝定义时候的顺序而来，1、2与3、4就可以看出。</p>
<p>看到这里，也许会有点疑问，既然静态域加载优于实例域（包含构造函数），那为什么在枚举类中就不行呢？让我们回到前面对枚举类的反编译，其实答案就出来了。反编译的过程我们可以看到，我们的枚举常量实际上是我们枚举类的静态实例化对象，在编译器的修改下，我们运行加载枚举类的过程中，枚举常量是static修饰的，其他静态域也是static修饰的，枚举常量又排在其他静态域的前面，按照上面的额初始化顺序，首先就会调用构造器实例化枚举常量对象，此时，枚举类中的其他静态域都还没来得及初始化，自然在构造函数中不能访问静态域了。有人可能想说，那我静态域放到枚举常量前面，让他先加载怎么样？很遗憾，Java不允许这样做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123; <span class="comment">// 编译不通过！！！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用抽象函数为枚举统一方法"><a href="#使用抽象函数为枚举统一方法" class="headerlink" title="使用抽象函数为枚举统一方法"></a>使用抽象函数为枚举统一方法</h4><p>上面的内容探讨了枚举类的一些基础，这里提一些关于使用枚举的代码策略设计。<br>有的时候，我们想要给枚举常量定义某一些通用的方法，同时，针对不同的枚举，该通用方法呈现不同的具体内容。例如，我现在有一个如下的Color枚举类，当针对不同的Color常量的时候，能有一个方式给我返回该颜色的十六进制颜色码。也许你会如下来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHexCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;#FF0000&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;#00FF00&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;#0000FF&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上的方式较为简洁与易读，但是存在问题：枚举常量越来越多，case会不断增长，如果编写代码的过程由于不注意，增加颜色常量的时候，忘记了增加对应的case，那么编译是不会有任何的问题的，但是却隐含的将增加的颜色常量也返回的是BLUE的十六进制颜色码。</p>
<p>鉴于上述的问题，我们需要某种方式来防止我们犯错，能够想到的，就是通过编译器来告诉我们。于是，我们在枚举类中定一个抽象方法getHexCode，于是乎，对于每一个枚举常量，编译器会提示我们实现具体实例的getHexCode：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getHexCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#FF0000&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, GREEN &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getHexCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#00FF00&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, BLUE &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getHexCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#0000FF&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">getHexCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这样的定义下，代码牺牲了一定的简洁性，但是易读性丝毫不输于最开始的方式。针对Color枚举类，我们定义了抽象方法，表明了对于Color中的每一个枚举常量，都应该有getHexCode方法，返回自己的十六进制颜色码。如果我们新添加了枚举常量，而没有实现该方法，编译器会报错警告我们。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/05/03/2018-05-03-Java%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/03/2018-05-03-Java%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82/" class="post-title-link" itemprop="url">Java泛型中的细节</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-03 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-03T00:00:00+08:00">2018-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="如果没有泛型"><a href="#如果没有泛型" class="headerlink" title="如果没有泛型"></a>如果没有泛型</h3><p>学习Java，必不可少的一个过程就是需要掌握泛型。泛型起源于JDK1.5，为什么我们要使用泛型呢？泛型可以使编译器知道一个对象的限定类型是什么，这样编译器就可以在一个高的程度上验证这个类型消除了强制类型转换，使得代码可读性好，而这个过程是发生在编译时期的，即在编译时期发现代码中类型转换的错误所在，及时发现，而不必等到运行时期抛出运行时期的类型转换异常。</p>
<p>泛型主要运用在譬如Java中的容器API等需要对多个对象进行管理的部分。</p>
<p>早期（不支持泛型的时期）的Java代码，我们在使用容器的时候，需要在类型转换前手动的进行类型转换验证工作来防止异常。假设目前我们定义了一个Apple类，含有一个pare（削皮）方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple is pared&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下里，我们定义了一个方法void pareAll(List apples);传入包含有多个Apple实例的List，并逐一对每一个Apple进行pare操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pareAll</span><span class="params">(List apples)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object a : apples) &#123;</span><br><span class="line">            Apple aa = (Apple)a;</span><br><span class="line">            aa.pare();</span><br><span class="line">            <span class="comment">// 为了清晰认识出错的地方，我没有采用下面的代码</span></span><br><span class="line">            <span class="comment">// ((Apple)a).pare();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List apples = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        pareAll(apples);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先明确一点，List、Set、Map等早期只能默认其实是Object类型的集合，即由于类型转换，像上面的List能够存放Object及其子类的对象，所以你当然可以添加多个Apple对象实例（上转型）。而在pareAll方法体中，由于我们刚刚说过，List存放的是上转型后的Object类型的对象，所以当我们获取List的对象的时候，自然只能拿到Object类型的对象，之后需要我们手动的进行下转型：((Apple)a).pare()。这段代码我们运行一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple is pared</span><br><span class="line">Apple is pared</span><br></pre></td></tr></table></figure><br>似乎没有问题，然而，由于容器能够接受的是Object对象，所以，我们再定一个譬如Banana类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Banana is pared&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后将这个类也添加List中去，由于上转型，这里完全没有编译的错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List apples = <span class="keyword">new</span> ArrayList();</span><br><span class="line">apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">apples.add(<span class="keyword">new</span> Banana()); <span class="comment">// 编译通过！</span></span><br><span class="line">pareAll(apples);</span><br></pre></td></tr></table></figure><br>然而在运行的时候，去出现了错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Apple is pared</span><br><span class="line">Apple is pared</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: Banana cannot be cast to Apple</span><br><span class="line"><span class="comment">// 编译器告诉我们 Apple aa = (Apple)a;这里一段代码出错了</span></span><br></pre></td></tr></table></figure><br>首先，将List中的所有Object对象转换为Apple对象的时候，并没有出错，同时还正确输出了。但是，我们上面曾添加过Banana对象，在进行转换的过程中，却发生了类型转化的运行时异常。怎样解决这个问题？我们可以使用instanceof关键字，这个关键字可以判断一个对象是否是某一个类的实例化，所以我们修改pareAll方法，添加上实例判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果对象是Apple类的实例化，才进行转换</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Apple) &#123;</span><br><span class="line">    ((Apple)a).pare();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>既然用这种方式就可以解决类型转换异常，那么为什么还要有泛型呢？首先，有了泛型进行麻烦的类型判断了；其次，通过编译器的支持，当我们使用泛型的时候，编译器会在编译时期就为我们解决好类型的问题，这样一来，可以保证，在运行时期，肯定不会因为类型转换出现异常。</p>
<h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><p>JDK1.5给我们带来了泛型，当我们使用容器类的时候，自然更加推荐使用带有泛型的容器类，那么为什么那些不具备泛型的容器类还存在呢？因为早期还有很多遗留代，为了考虑兼容问题，所以才需要保留它们。</p>
<p>说了这么多，我们来看如何在刚刚的情境中，使用泛型来为我们带来便利与类型安全：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用泛型</span></span><br><span class="line">    List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Banana()); <span class="comment">// 这一句话就会出现编译错误</span></span><br><span class="line">    pareAll(apples);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在Java中，在jdk自带的容器类加上尖括号&lt;&gt;，里面加上我们要明确的类名即可。而在pareAll方法，我们首先修改形参为List\<Apple> apples，这样一来明确告诉编译器，我传入的是只能装Apple类型对象的List，如此一来，类型的判断就可以不用出现了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pareAll</span><span class="params">(List&lt;Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先形参改变了，其次for中的类型发生了变化，注意与原来的区分和理解</span></span><br><span class="line">    <span class="keyword">for</span> (Apple a : apples) &#123;</span><br><span class="line">        a.pare();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h4><h5 id="定义一般的泛型类"><a href="#定义一般的泛型类" class="headerlink" title="定义一般的泛型类"></a>定义一般的泛型类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gen</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像我们在使用泛型容器一样，在类的后面加上尖括号，并且使用一个合法定义符号，表明Gen是一个泛型类，对于T来说，到底是什么类型，目前还不知道，只有当我需要使用的时候才确定的下来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：jdk1.7之后类型推断的加入，使得我们可以省略后面的类型定义</span></span><br><span class="line">    <span class="comment">// 这里我明确定义Gen的类型是String</span></span><br><span class="line">    <span class="comment">// 所以当我想要传入一个int类型的数字时，编译会不通过</span></span><br><span class="line">    Gen&lt;String&gt; x = <span class="keyword">new</span> Gen&lt;&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// Gen&lt;String&gt; x = new Gen&lt;&gt;(2); 编译不通过</span></span><br><span class="line">    x.print(); <span class="comment">// 输出“hello”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="定义有边界的泛型类"><a href="#定义有边界的泛型类" class="headerlink" title="定义有边界的泛型类"></a>定义有边界的泛型类</h5><p>有的时候，即使是我们想要定义一个泛型的类，但并不意味着我们就想要任何一个类型都可以作为我们想要定义的泛型类的参数，这个时候怎么办？这就需要我们定义起边界，即这个泛型类能容许你能够定义具体的什么类型。首先我们定义三个基础的类：分别为Father、Son、MrWang。Father类是Sun超类，MrWang类与这两个类无关：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MrWang</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>接下来我们定义具有边界的泛型类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法为&lt;泛型符号 extends 已存在类型&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Father</span>&gt; </span>&#123;</span><br><span class="line">    T x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gen</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>于是，我们在使用我们定义的泛型类的时候，就会有所限制了：我们只能定义类型为Father以及Father子类的泛型类，除此之外都不行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Gen&lt;Son&gt; g1;</span><br><span class="line">    Gen&lt;Father&gt; g2;</span><br><span class="line">    Gen&lt;MrWang&gt; g3; <span class="comment">// 编译出错！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="泛型类的本质"><a href="#泛型类的本质" class="headerlink" title="泛型类的本质"></a>泛型类的本质</h5><p>在上面我们提到了两种泛型，一种是原始泛型类（\<T>），另一种是为了对泛型参数进行限制而使用的边界（\<T extends BorderClass>）；我们通过相关的定义可以知道，泛型只在编译阶段起作用，他只对编译阶段进行类型的限制，从而实现类型安全。实际上，任何的泛型类到运行的时候，都会将其泛型类型<strong>擦除</strong>到边界。对于一般的泛型类来说，在运行阶段会擦除到Object类型为止；而进行限制的使用extends的泛型则会擦除到其边界为止。综合来说就是，一般泛型类与限制了边界的泛型类都可以统一为\<T extends BorderClass>。只是前者的BorderClass就是Object（因为任何对象都继承自Object），而后者是特定的边界类。再具体一点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先这里有一个Father类，其定义如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fatherMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Son继承自Father类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 定义一个有边界的类以及一个没有边界的泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasBorder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Father</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尽管是泛型T，但是由于制定了边界</span></span><br><span class="line">        <span class="comment">// 所以我们可以确定知道运行时，其类型会擦除到Father类</span></span><br><span class="line">        <span class="comment">// 所以x一定有fatherMethod方法</span></span><br><span class="line">        x.fatherMethod();</span><br><span class="line">        <span class="comment">// 此外还有Object类中的譬如toString、hashCode等方法</span></span><br><span class="line">        x.toString();</span><br><span class="line">        x.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoBorder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于没有指定泛型的边界，T在运行时会擦除到Object</span></span><br><span class="line">        <span class="comment">// 所以只能看到Object中的一些方法</span></span><br><span class="line">        x.toString();</span><br><span class="line">        x.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义泛型方法"><a href="#定义泛型方法" class="headerlink" title="定义泛型方法"></a>定义泛型方法</h4><p>泛型方法的定义则是在方法的返回值前添加\<T>来定义的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意&lt;K&gt;是紧跟返回类型的</span></span><br><span class="line">[<span class="keyword">public</span> | ...] [<span class="keyword">static</span>] [<span class="keyword">final</span>] [<span class="keyword">synchronized</span>] &lt;K&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(K x)</span> </span>&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回类型同样可以是泛型</span></span><br><span class="line">[<span class="keyword">public</span> | ...] [<span class="keyword">static</span>] [<span class="keyword">final</span>] [<span class="keyword">synchronized</span>] &lt;K&gt; <span class="function">K <span class="title">f</span><span class="params">(K x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用泛型方法的时候，我们可以在方法前来定义具体的类型来确定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.&lt;Apple&gt;f(<span class="keyword">new</span> Apple())</span><br><span class="line"><span class="comment">// 由于类型推到，当我们传入一个Apple对象的时候，Java会为我们自动推导其类型，所以可以省略：</span></span><br><span class="line">obj.f(<span class="keyword">new</span> Apple());</span><br></pre></td></tr></table></figure><br>但是请注意，在一个泛型类中再定义泛型方法，它们是没有联系的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gen</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">f</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">g</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上面的泛型类中，我们定义了两个方法：f、g，注意前者并没有在返回类型前添加<T>，后者有\<T>，尽管这两个方法都使用了T这个泛型符号，但是，其含义截然不同。前者的T是跟随泛型类的T来确定的，而后者是根据具体方法来确定的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Gen&lt;Father&gt; gen = <span class="keyword">new</span> Gen&lt;&gt;(<span class="keyword">new</span> Father());</span><br><span class="line">    <span class="comment">// 泛型类中的方法</span></span><br><span class="line">    gen.f(<span class="keyword">new</span> Father());</span><br><span class="line">    <span class="comment">// 泛型方法</span></span><br><span class="line">    gen.g(<span class="keyword">new</span> MrWang());</span><br><span class="line">    <span class="comment">// 互不相关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="关于-lt-gt-的一二"><a href="#关于-lt-gt-的一二" class="headerlink" title="关于 &lt;?&gt; 的一二"></a>关于 &lt;?&gt; 的一二</h3><p>\&lt;?&gt;其实和\<T>非常的类似，都表示一种不确定性，都是告诉编译器，我现在有一个泛型，但是这个东西的具体类型我不确定到底是什么。但是，它们还是有一定的区别的。首先说一个最基础的，\&lt;?&gt;无界通配符是不能用做声明泛型类的或者是泛型方法的；而\<T>可以，不再赘述。<strong>在理解&lt;?&gt;的时候，请暂时不要和\<T>联系起来，这二者的使用没有必然的联系</strong>! 它们之外的差别这里使用一个情景：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">(List&lt;T&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object o : lists) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        Object o = lists.size() &gt; <span class="number">0</span> ? lists.get(<span class="number">0</span>) : <span class="keyword">null</span>;</span><br><span class="line">        lists.add((T) <span class="keyword">new</span> Object());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;?&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object o : lists) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        Object o = lists.size() &gt; <span class="number">0</span> ? lists.get(<span class="number">0</span>) : <span class="keyword">null</span>;</span><br><span class="line">        lists.add(<span class="keyword">new</span> Object()); <span class="comment">// 编译出错！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先上面的f0方法接收List<T>对象，而f1方法接收List&lt;?&gt;对象。首先我们来看共同点，我们看到两个方法均可以遍历其List中的对象并且上转型为Object类型，当然，这是完全没有问题的，无论你的list中存放的是什么对象，你再不确定，但你始终可以将其上转型为Object类型，因为一切类都继承自Object这个类。</p>
<p>上面来两个方法的不同点在于，最后一句向lists中添加一个Object对象。首先看f0，这里将Object对象往lists中添加的时候，需要我们转型为T，这里没有问题，因为既然我们定义的这个方法已经告诉了编译器，我们传入的是一个某种类型T的List，自然，往里面的添加的对象必须要上转型为T，否则如果不进行转型，那么任何的类都往里面的添加岂不是违背了类型安全。也许你有些疑问：不是说在运行时候会擦出到边界（这里就是Object），那为什么我添加Object对象都需要类型转换呢？其实不管你添加什么类型的对象，都需要类型转换，其理由在我看来是这样：在使用的泛型<strong>定义</strong>的某些类功能，尤其是添加或获取容器类中的元素，如果在一开始往里面添加的时候类型转换就失败了，肯定可以确定一点，你往里面添加的类是不正确的！是不符合我到时候（真正在使用确定了泛型类型的容器的时候）想要添加的类型的。所以这里强制需要你进行转型，以在添加的时候就保证其类型的安全。</p>
<p>看完f0，在看f1。f1中最后一句add一个Object对象的时候始终编译不通过，其原因就是&lt;?&gt;无界通配符只告诉编译器，我这里要使用一个带有泛型的List，但是其具体类型我不知道，也不想知道！所以为了保证你到时候使用的时候的多样性（你有可能会传入List\<String>，也有可能会传入List\<Integer>），这里我就不支持转型操作了，请你进行一些与类型无关的操作。</p>
<h4 id="关于-lt-extends-SomeClass-gt-与-lt-super-SomeClass-gt-的一二"><a href="#关于-lt-extends-SomeClass-gt-与-lt-super-SomeClass-gt-的一二" class="headerlink" title="关于 &lt;? extends SomeClass&gt; 与 &lt;? super SomeClass&gt; 的一二"></a>关于 &lt;? extends SomeClass&gt; 与 &lt;? super SomeClass&gt; 的一二</h4><p>在上面实例中我们使用了&lt;?&gt;这样的无界通配符，但是它太宽泛了，甚至可以说它与List无差别。于是，我们需要一种限定方式，来限定我们的容器类的类型有一定的边界。我们首先定义是那个类从上到下依次继承：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Top</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> <span class="keyword">extends</span> <span class="title">Mid</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>接下来我们定义带有有界通配符的相关参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;? extends Mid&gt; ls)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(List&lt;? <span class="keyword">super</span> Mid&gt; ls)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>这里解读一下：对于方法f来说，他接受一个List，但是这个List需要满足泛型？必须是extends于Mid，即定义了目标List的泛型的上界是Mid，就是说我们传入的泛型List的其类型必须是Mid的子类；而对于g方法来说，则是必须满足泛型？必须是super于Mid，即定义了其List的泛型的下界是Mid，即我们传入的List的泛型必须是Mid的超类，所有也就有了下面的编译中的细节：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Top&gt; topList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Mid&gt; midList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Bottom&gt; bottomList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">f(list); <span class="comment">// 1、编译出错</span></span><br><span class="line">f(topList); <span class="comment">// 2、编译出错</span></span><br><span class="line">f(midList); <span class="comment">// 3、编译通过</span></span><br><span class="line">f(bottomList); <span class="comment">// 4、编译通过</span></span><br><span class="line">g(list); <span class="comment">// 5、编译通过</span></span><br><span class="line">g(topList); <span class="comment">// 6、编译通过</span></span><br><span class="line">g(midList); <span class="comment">// 7、编译通过</span></span><br><span class="line">g(bottomList); <span class="comment">// 8、编译出错</span></span><br></pre></td></tr></table></figure><br>1与2编译出错的原因很显然就是因为分别不满足 Object extends Mid 和 Top extends Mid；3与4通过编译的原因也就显而易见了（Mid本身是本身的子类）；5、6和7同样满足其对应的类型是Mid的超类（Mid本身也可以是本身的超类），故通过编译，而8中的Bottom不是Mid的超类，故不通过编译。</p>
<h4 id="进阶-lt-extends-T-gt-与-lt-super-T-gt"><a href="#进阶-lt-extends-T-gt-与-lt-super-T-gt" class="headerlink" title="进阶 &lt;? extends T&gt; 与 &lt;? super T&gt;"></a>进阶 &lt;? extends T&gt; 与 &lt;? super T&gt;</h4><p>在上面的讨论中，我们都是用一个特定的类来限定了？的边界（上面就是Mid类），但是泛型同样适用于此，就像下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">genF</span><span class="params">(List&lt;? extends T&gt; ls)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">genG</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; ls)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>当我们指定了泛型的类型为特定的类型的时候，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericTest.&lt;Mid&gt;genF(midList);</span><br></pre></td></tr></table></figure><br>他其实等同于上面的3中的方法，因为就是直接将对应的泛型替换为具体的类。那么genF方法与genG方法究竟有什么区别呢？答案就是PECS原则。</p>
<h4 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h4><p>什么是PECS？PECS指“Producer Extends，Consumer Super”。换句话说，如果参数化类型表示一个生产者，就使用&lt;? extends T&gt;；如果它表示一个消费者，就使用&lt;? super T&gt;。</p>
<p>这里一定要明确一点，我们在使用这两种的时候，通常是在使用容器（绝大多数）；其次，生产者和消费者的概念是针对容器的。怎么理解呢？先用一段代码来表达这个场景：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">genF</span><span class="params">(List&lt;? extends T&gt; ls)</span> </span>&#123;</span><br><span class="line">    T o = ls.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们先看PE（Producer Extends）部分，这里我们通过方法，可以知道，我们定义了一个genF方法，接收一个泛型List，其具体类型我们还不知道，但至少可以确定的是，它的上界是T，也就是说，我传入的List中的存放的对象一定是T的子类，由于如此，我可以在这个方法中，定义T类型的对象，然后从List中取得对象，由于上面的描述，我们一定可以确定，无论你传入的List去具体的类型到底是什么，但一定可以上转型为T，这里List是一个生产者（Producer），它生产出来的（get(0)）的对象（某个类型，但一定是T的子类），一定可以传给T的引用（上转型）。这就是PE部分。</p>
<p>而CS（Consumer Super）也很好理解，下面的代码不够严谨，但是可以让我们清楚其中的意义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">genG</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; ls)</span> </span>&#123;</span><br><span class="line">    ls.add((T)<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的方法接收一个List&lt;? super T&gt;参数，意味着，ls虽然我不知道到底会有什么样的类型的List传入，但是我一定知道，这个类型一定是T类型的超类，也就是说，ls.add方法能够存放的对象，是某个类型，而这个类型是T的超类（或本身），那么，T类型的对象我一定能够放进去（通过上转型到“？”，而这个“？”到底是什么我不知道，只知道是T的超类，T当然能够上转型到T的某个超类）。这里的List就是一个消费者，它消费（add）T类型，凭什么能够add，因为ls本身的类型是T的超类。</p>
<h5 id="最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除"><a href="#最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除" class="headerlink" title="最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除"></a>最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除</h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/04/24/2018-04-24-Scala%20trait%E7%89%B9%E8%B4%A8%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/24/2018-04-24-Scala%20trait%E7%89%B9%E8%B4%A8%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">Scala trait特质 深入理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-24 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-24T00:00:00+08:00">2018-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="初探Scala-特质trait"><a href="#初探Scala-特质trait" class="headerlink" title="初探Scala 特质trait"></a>初探Scala 特质trait</h3><p>在Scala中，trait（特质）关键字有着举足轻重的作用。就像在Java中一样，我们只能在Scala中通过extends进行单一继承，但trait可以让我们从语义上实现了多重继承。通过对继承的类混入（mixin）多个特质，来达到多重继承的目的。乍一看，trait和Java中的interface接口很像，但是，细节上它们又有着大不同。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义超类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">定义特质</span></span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">Trait</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">定义子类，将特质使用with关键字混入</span> <span class="title">Super</span> <span class="title">类，并继承之</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> <span class="keyword">with</span> <span class="title">Trait</span></span></span><br></pre></td></tr></table></figure><br>请务必体会上面的最后一条注释，早期学习的时候，我们往往容易将特质理解为Java中的接口，同时将with理解为Java中的implements，于是我们编写出如下的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">with</span> <span class="title">T</span> // 错误✖️</span></span><br></pre></td></tr></table></figure><br>这样想是因为我们没有正确理解特质，特质是对我们要<strong>被继承</strong>的类的补充，是要混入我们要继承的类的，不是我们本身类！即我们要明确，对于混入特质的子类定义，其实整体分为两个部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ class A ] extends [ S with T1 with T2 ...] </span><br></pre></td></tr></table></figure><br>中括号的表示两个部分才是正确的结构！</p>
<p>此外，与Java中的接口相比，我们还能够在特质中直接实现完整的方法，就像如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TrMid1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span> = println(<span class="string">&quot;In TrMid 1&#x27;s f.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在Java8以前我们无法在接口中定义并实现完整的方法，而在Java8及以后我们可以通过default关键字来后面接完整的方法来实现。</p>
<p>现在，我们定义两个如下的特质：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TrMid1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span> = println(<span class="string">&quot;In TrMid 1&#x27;s f.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TrMid2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span> = println(<span class="string">&quot;In TrMid 2&#x27;s f.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>之后，我们定义一个名为Bottom的类，继承Scala中的Any类，同时混入上面定义的特质<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">TrMid1</span> <span class="keyword">with</span> <span class="title">TrMid2</span></span></span><br><span class="line"><span class="class"><span class="title">/*</span> </span></span><br><span class="line"><span class="class"><span class="title">这里的Any是scala中的特殊对象</span></span></span><br><span class="line"><span class="class"><span class="title">这里使用Any会报错</span></span></span><br><span class="line"><span class="class"><span class="title">Error</span></span>:(<span class="number">16</span>, <span class="number">31</span>) illegal inheritance; superclass <span class="type">Any</span></span><br><span class="line"> is not a subclass of the superclass <span class="type">Object</span></span><br><span class="line"> of the mixin <span class="class"><span class="keyword">trait</span> <span class="title">TrMid2</span></span></span><br><span class="line"><span class="class">...</span></span><br><span class="line"><span class="class"><span class="title">*/</span></span></span><br></pre></td></tr></table></figure><br>“超类Any不是混入特质TrMid2的超类Object的子类”，即我们extends的类需要是Object的子类才行。面对上面的错误，我们可以将Any修改为AnyRef，这个类是scala内建类，本质上对应Java中的java.lang.Object类。修改之后，编译还是会报错：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> <span class="keyword">extends</span> <span class="title">AnyRef</span> <span class="keyword">with</span> <span class="title">TrMid1</span> <span class="keyword">with</span> <span class="title">TrMid2</span></span></span><br><span class="line"><span class="class">...</span></span><br><span class="line"><span class="class"><span class="title">/*</span></span></span><br><span class="line"><span class="class"><span class="title">Error</span></span>:(<span class="number">16</span>, <span class="number">7</span>) <span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> <span class="title">inherits</span> <span class="title">conflicting</span> <span class="title">members</span></span>:</span><br><span class="line">  method f in <span class="class"><span class="keyword">trait</span> <span class="title">TrMid2</span> <span class="title">of</span> <span class="title">type</span> <span class="title">=&gt;</span> <span class="title">Unit</span>  <span class="title">and</span></span></span><br><span class="line"><span class="class">  <span class="title">method</span> <span class="title">f</span> <span class="title">in</span> <span class="title">trait</span> <span class="title">TrMid1</span> <span class="title">of</span> <span class="title">type</span> <span class="title">=&gt;</span> <span class="title">Unit</span></span></span><br><span class="line"><span class="class">(<span class="params"><span class="type">Note</span>: this can be resolved by declaring an override in class <span class="type">Bottom</span>.</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Bottom</span> <span class="keyword">extends</span> <span class="title">AnyRef</span> <span class="keyword">with</span> <span class="title">TrMid2</span> <span class="keyword">with</span> <span class="title">TrMid1</span> </span>&#123;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><br>这个错误提示我们在上面的两个特质中，均定义了相同签名的方法f，这里编译不通过，建议我们在Bottom类中实现f方法。换言之，当混入的多个特质中，分别定义了同名的方法，那么Scala会编译报错。在Java中也有类似的错误情形，下面就是关于Java，当然你可以跳过这一部分</p>
<hr>
<h4 id="Java接口中的同名方法"><a href="#Java接口中的同名方法" class="headerlink" title="Java接口中的同名方法"></a>Java接口中的同名方法</h4><p>以上的讨论，务必与Java中区分开来，这里需要补充一下。在Java中，首先由于我们无法进行多重继承，我们只能编写形如这样的class AA extends BB implements CC, DD这样的代码，想要建立像上面的测试情形，我们还只能使用JDK8之后的能够在接口中使用default关键字来定义具有具体实现的方法，最终我们的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [abstract] 为可选</span></span><br><span class="line">[<span class="keyword">abstract</span>] <span class="class"><span class="keyword">class</span> <span class="title">BB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;In BB&#x27;s f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CC</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK8及以后的default关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;In CC&#x27;s f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">BB</span> <span class="keyword">implements</span> <span class="title">CC</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比验证类，保证我们接口中的方法没问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZZ</span> <span class="keyword">implements</span> <span class="title">CC</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AA().f();</span><br><span class="line">        <span class="comment">// In BB&#x27;s f()</span></span><br><span class="line">        <span class="keyword">new</span> ZZ().f();</span><br><span class="line">        <span class="comment">// In CC&#x27;s f()，接口方法是没有问题的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>根据上面的区别，我们首先确定是类似这样的class AA extends BB implements CC，同时BB，CC有同名的方法，Java中首先（只会？）找类中的实现。可能你有疑惑了，为什么不能够让多个接口都创建同名的默认方法，让一个类来实现它们，调用同名方法，就想这样：class AA implements CC, DD，遗憾的是（高兴的是？），当你这样做的时候，Java编译期就给你报错了啦！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;In CC&#x27;s f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;In DD&#x27;s f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">implements</span> <span class="title">CC</span>, <span class="title">DD</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 编译就会报错</span></span><br><span class="line"><span class="comment">// Error:(25, 1) java: 类 AA从类型 CC 和 DD 中继承了f() 的不相关默认值</span></span><br></pre></td></tr></table></figure><br>要解决这个错误，要么，让其中一个接口中的同名方法改名，要么，实现类重写这个方法。</p>
<hr>
<h4 id="继续Scala特质的讨论"><a href="#继续Scala特质的讨论" class="headerlink" title="继续Scala特质的讨论"></a>继续Scala特质的讨论</h4><p>上面的关于同名方法的报错曾提示我们，在底层类重写实现Bottom中的f方法。这是办法之一。但是，我们还有另一种方式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先我们定义一个顶层的抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbTop</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让TrMid1、TrMid2均继承AbTop这个顶层抽象类，同时均重写抽象类中的方法</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TrMid1</span> <span class="keyword">extends</span> <span class="title">AbTop</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span> = println(<span class="string">&quot;In TrMid 1&#x27;s f.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TrMid2</span> <span class="keyword">extends</span> <span class="title">AbTop</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span> = println(<span class="string">&quot;In TrMid 2&#x27;s f.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bottom类继承AbTop类并混入上面定义的两个特质</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> <span class="keyword">extends</span> <span class="title">AbTop</span> <span class="keyword">with</span> <span class="title">TrMid1</span> <span class="keyword">with</span> <span class="title">TrMid2</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 进行测试</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TraitTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> top: <span class="type">Bottom</span> = <span class="keyword">new</span> <span class="type">Bottom</span></span><br><span class="line">    top.f</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们编译运行这段程序，得到了如下的结果：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">In</span> <span class="type">TrMid</span> <span class="number">2</span><span class="symbol">&#x27;s</span> f.</span><br></pre></td></tr></table></figure><br>首先我们可以确定，我们按照上面的类层级结构混入了两个带有同名方法f的特质，并没有像上面那样出现二义性错误；为什么会这样？让我们再次理解这一段话“特质是对我们要<strong>被继承</strong>的类的补充，是要混入我们要继承的类的，不是我们本身类”。也就是说，报错的那个二义性，是由于我们想要将两个同名的f方法混入AnyRef这个类中，然而，我们没有override关键字（也无法加上），那么混入过程只是单纯的向AnyRef类中添加两个签名一样的方法f，而语法上我们无法向同一个类中添加连个签名完全一样的方法，故报错；解决方法就是在我们的子类中override这个f方法，重写覆盖它，消除二选一。</p>
<p>而后者，我们能够编译运行还是像上面这样理解，由于我们是要向AbTop这个类中去混入特质，而我们每一个特质都是继承了AbTop类的，故我们应当重写覆盖顶层抽象类中的f方法，所以，在混入的过程中，从左到右每混入一次，他就加上一层外壳，所以这就是为什么，输出的结果是打印的第二个特质中f方法的输出，因为逐渐混入加壳的过程是从左到右的，先对AbTop加了壳，混入TrMid1特质，然后又对这一个结构加壳过程，混入TrMid2特质，就像下图：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/wrap.png" alt="wrap"><br>这样一来，不难理解混入特质的过程（加壳的过程）本身就像一个一层一层继承的过程。还是上面那段带有AbTop的代码中，这一次我们添加一个新的抽象类AbNewTop，但是其中包含一个抽象方法其名称依然为f，然我们修改Bottom的定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbNewTop</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> <span class="keyword">extends</span> <span class="title">AbNewTop</span> <span class="keyword">with</span> <span class="title">TrMid2</span> <span class="keyword">with</span> <span class="title">TrMid1</span> </span>&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>注意我们让Bottom不再继承AbTop，而是继承新定义的AbNewTop，其他诸如TrMid1依然继承的是AbTop不变。让我们运行代码，报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error:(19, 36) illegal inheritance; superclass AbNewTop</span><br><span class="line"> is not a subclass of the superclass AbTop</span><br><span class="line"> of the mixin trait TrMid2</span><br><span class="line">class Bottom extends AbNewTop with TrMid2 with TrMid1 &#123;</span><br></pre></td></tr></table></figure><br>英语有点绕口，我们这里翻译并分割一下：“非法的继承；<em>超类AbNewTop</em> 不是 混入特质的TrMid2的 <em>超类AbTop</em> 的子类”。再次对应这个结构：[ class A ] extends [ S with T1 with T2 …] 那么错误就在与后面的 S 与 T1、T2 对应不上了，及要实现正确的混入，S必须是T1、T2的超类的子类，当然，隐含的，本身也可以。转化为类图应该要满足如下的情形：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/class_map.png" alt="class_map"><br>可能有些人有疑惑，为什么特质不继承自任何其他的类的时候，依然可以被混入到其他的类中，就像如下的形式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">T1</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">with</span> <span class="title">T1</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>因为在Scala任何的非值类（或特质）有默认的继承了scala.AnyRef类！这里的类图是如下的情形：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/animal_class.png" alt="animal_class"></p>
<h3 id="使用特质来做可堆叠的改动——过滤"><a href="#使用特质来做可堆叠的改动——过滤" class="headerlink" title="使用特质来做可堆叠的改动——过滤"></a>使用特质来做可堆叠的改动——过滤</h3><p>试想一种情形：现在有一个客户需要我们编写一种整形数字容器，这个容器的类似于Java中的List，我们可以往里面去添加数据，但是添加数据的过程是可过滤的，或者说可按条件进行预处理的。首先我们定义一个Container类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> list: util.<span class="type">ArrayList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> util.<span class="type">ArrayList</span>[<span class="type">Int</span>]()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(n: <span class="type">Int</span>): <span class="type">Unit</span> = list.add(n)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(idx: <span class="type">Int</span>): <span class="type">Int</span> = list.get(idx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>目前为止，这个类似乎没什么特殊之处，甚至可以说是多此一举 —— 定义Container类的结构还不如直接使用一个util.ArrayList来的快。但是，试想一个场景，我现在要在添加之前 想要 首先检查这个是是否是偶数，如果不是，直接丢弃；如果是，则除以2再加入到容器中。如果仅仅使用现在的版本，你可能会直接在Container.add方法中去进行筛选，就像如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(n: <span class="type">Int</span>): <span class="type">Unit</span> = <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) list.add(n / <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>诚然，这段简单的代码的确能工作的很好。但是每一次的我改变规则，你难道就要在这个add代码中进行修改吗？亦或者假设这个类的源码根本就无法修改。你又如何操作？于是，使用特质来堆叠能够发挥作用：<br>首先我们还原add代码为最初始的状态，然后，我们定义如下的两个特质，并且定义我们的MyContainer类继承Container类并混入这两个特质：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Even</span> <span class="keyword">extends</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>): <span class="type">Unit</span> = <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">super</span>.add(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Divide</span> <span class="keyword">extends</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>): <span class="type">Unit</span> = <span class="keyword">super</span>.add(x / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContainer</span> <span class="keyword">extends</span> <span class="title">Container</span> <span class="keyword">with</span> <span class="title">Divide</span> <span class="keyword">with</span> <span class="title">Even</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">测试这段代码</span></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> myContainer = <span class="keyword">new</span> <span class="type">MyContainer</span></span><br><span class="line">    myContainer.add(<span class="number">1</span>)</span><br><span class="line">    myContainer.add(<span class="number">6</span>)</span><br><span class="line">    println(myContainer.get(<span class="number">0</span>)) <span class="comment">// 输出3</span></span><br><span class="line">    <span class="comment">// println(myContainer.get(1)) // 超出边界</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在前面的讨论中我们知道，如果是一个类混入了多个特质，这多个特质含有同名的方法，会从左到右包装出来，即最终调用的是靠近右侧的实现了的方法。首先要实现筛选偶数，再除以2，最终添加到容器中。所以最先发挥作用的Even特质放在了最右侧。为什么这里，不仅能够筛选出偶数，同时还能除以2呢？答案就在super这个关键点。super.add即调用超类的add方法。这里再次用图来说明：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/evendivide.png" alt="evendivide"><br>我想这个图足以说明了吧。调用过程就是先调用最右侧的Even.add方法，进行偶数筛选；然后调用超类super.add(x)；超类即从右到左开始Even左侧是Divide，Divide.add(x)，Divide.add内部对x除以2，传入super.add()方法，即再次向左侧，是Container.add()，此时接收到的数已经是除以2的数了：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/flow.png" alt="flow"><br>还有一种情况是更为复杂的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span> = println(<span class="string">&quot;In A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;In B&quot;</span>)</span><br><span class="line">    <span class="keyword">super</span>.f</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;In C&quot;</span>)</span><br><span class="line">    <span class="keyword">super</span>.f</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">with</span> <span class="title">C</span></span></span><br></pre></td></tr></table></figure><br>关系图对应如下：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/classrelation.png" alt="classrelation"><br>输出：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> t: <span class="type">T</span> = <span class="keyword">new</span> <span class="type">T</span></span><br><span class="line">    t.f</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="type">In</span> <span class="type">C</span></span><br><span class="line"><span class="type">In</span> <span class="type">B</span></span><br><span class="line"><span class="type">In</span> <span class="type">A</span></span><br></pre></td></tr></table></figure><br>看到输出，再根据前面的内容，我们也很容易理解，当某一个特质本生继承了其他的类的时候，super一定是其对应的超类，而不是class AA extends BB with TT中的BB这个类！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/04/18/2018-04-18-Linux%E4%B8%8Biptables%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/18/2018-04-18-Linux%E4%B8%8Biptables%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Linux下iptables学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-18T00:00:00+08:00">2018-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Centos7版本之后，防火墙应用已经由从前的iptables转变为firewall这款应用了。但是，当今绝大多数的Linux版本（特别是企业中）还是使用的6.x以下的Centos版本，所以对iptables的了解还是很有必要的。此外，需要说明的是iptables自身并不具备防火墙的功能，它需要通过内核netfilter（网络过滤器）来实现，与firewalld一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结构以及使用方法不一样，他们都只是一个外壳应用罢了。打个比方，就好像有一本书，同样的内容，一种是纸质的，另一种是电子的，我们翻阅它的方式不同，给它做笔记的方式不同，但是内容（内核）一样。</p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p><strong>iptables概念</strong></p>
<p>iptables中的规则（rule）。在我看来，规则是iptables中进行数据包检查的基本单元。每一条规则都定义了对于数据包的条件验证，譬如网络地址的验证、端口验证、协议验证等。</p>
<p>iptables中的链（chain）。链是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。就像这里，我们有一个INPUT链（INPUT概念之后再作解释），数据包来到这条链时，就会根据该链中的规则进行检查，譬如源、目的地址是否符合规则；源、目的端口是否符合规则等等。当一个数据包到达一个<strong>链</strong>时，iptables就会从INPUT链中规则1开始检查，看该数据包是否满足规则所定义的条件——如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则2，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/inputchain.png" alt="inputchain"></p>
<p>iptables中的表（table）。表是一组链的集合，在iptables中默认定义了四张表：filter、nat、mangle和raw，分别用于实现包过滤（最常用去配置的表），网络地址转换、包重构(修改)和数据跟踪处理。如下图：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/alltables.png" alt="alltables"><br>当然，上图只是一个大致示意，并不意味着每个表中的例如想PREROUTING这样的链是独自在各个表中的，实际上表与链之间是一种交叉的关系，为什么这么说呢？这需要我们理解在iptables中传输数据包的流程（请结合下图慢慢阅读）。<br>（1）当一个数据包进入网卡时，它首先进入PREROUTING链，根据该链中的规则判定数据包的处理方式（ACCEPT？DROP？REJECT？），一旦通过规则检测，Linux内核根据数据包的IP地址决定是将数据包留下传入进入内部，还是转发出去。<br>1）如果数据包就是进入本机的（IP地址表明），它就会到达INPUT链。数据包到了INPUT链后，便开始根据INPUT链中的规则来检查数据包是否满足一系列的条件，满足之后，完全进入主机，任何进程都会收到它。同时，主机中的任何程序都可以发送数据包，发送出来的数据包会走到OUTPUT链，再根据里面的规则判定处理，最后到POSTROUTING链，再判定处理。<br>2）如果数据包是准备转发的，他就会到达FORWARD链，再根据FORWARD链中的规则进行检查判定决定接下来的处理。如果通过了FORWARD链，说明内核允许该数据包转发，那么数据包就会到POSTROUTING链进行最后的判断。<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/flow.png" alt="flow"><br>同时我们可以看到，这里的角度并不是以table来看的，而是以chain来看的，这就是为什么我在上面提到的，尽管table是chain的集合，但并不意味着当我们定义防火墙的时候是按照table角度来定义，而是要根据chain角度来定义。我们要根据上图来决定我们要在何处怎样处理进入的数据包。这个flow在我看来必须要非常熟悉，对之后的命令行配置也有很大的帮助，因为iptables的命令行配置十分复杂。</p>
<h4 id="iptables命令行配置"><a href="#iptables命令行配置" class="headerlink" title="iptables命令行配置"></a>iptables命令行配置</h4><p>iptables的命令格式如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables [-t table] COMMAND chain rules [-j action]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> table 表名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chain 链名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rules 规则</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> action 动作</span></span><br></pre></td></tr></table></figure><br><strong>table</strong> </p>
<p>表选项用于指定命令要作用于哪一个表（raw、mangle、nat、filter）</p>
<p><strong>COMMAND</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1、对某一条的整条链进行管理的命令</span><br><span class="line">-P或–policy &lt;链名&gt; 定义默认策略</span><br><span class="line">  设置默认策略的（设定默认门是关着的还是开着的）</span><br><span class="line">  默认策略一般只有两种（DROP 关闭 | ACCEPT 打开 ）</span><br><span class="line">  比如：</span><br><span class="line">  iptables -P INPUT DROP </span><br><span class="line">  这条命令就是我们将INPUT链默认的策略设置为关闭，即所有的想要进入我们主机的连接全部被拒绝。</span><br><span class="line">-F或-flush &lt;链名&gt; 清空某个表中的某条链中的所有规则</span><br><span class="line">  比如：</span><br><span class="line">  iptables -t filter -F INPUT # 清空filter表中的INPUT链中的所有规则</span><br><span class="line">  iptables -t filter -F # 清空filter表中的所有链的所有规则</span><br><span class="line">-Z或–zero &lt;链名&gt; 将表中数据包计数器和流量计数器归零</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2、对某一条链的具体规则进行相关的定义</span><br><span class="line">-A或—append &lt;链名&gt; 追加，在当前链的最后新增一个规则</span><br><span class="line">-I或–insert num &lt;链名&gt; 在指定的num位置插入1条规则</span><br><span class="line">-D或–delete num &lt;链名&gt; 从规则列表中删除第num条规则</span><br><span class="line">-R或–replace num &lt;链名&gt; 替换规则列表中的第num条规则</span><br><span class="line"></span><br><span class="line">3、查看管理命令 “-L”</span><br><span class="line">-L或–list &lt;链名&gt; 查看iptables规则列表</span><br><span class="line">附加命令</span><br><span class="line">  -n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名。</span><br><span class="line">  -v：显示详细信息</span><br><span class="line">  -vv</span><br><span class="line">  -vvv :越多越详细</span><br><span class="line">  -x：在计数器上显示精确值，不做单位换算</span><br><span class="line">  --line-numbers : 显示规则的行号</span><br><span class="line">  -t nat：显示所有的关卡的信息</span><br></pre></td></tr></table></figure><br><strong>rules</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-i或–in-interface &lt;网络接口名&gt; 指定数据包从哪个网络接口进入，如ppp0、eth0和eth1等</span><br><span class="line">-o或–out-interface &lt;网络接口名&gt; 指定数据包从哪块网络接口输出，如ppp0、eth0和eth1等</span><br><span class="line">-p或—proto协议类型 &lt;协议类型&gt; 指定数据包匹配的协议，如TCP、UDP和ICMP等</span><br><span class="line">-s或–source &lt;源地址或子网&gt; 指定数据包匹配的源地址</span><br><span class="line">–sport &lt;源端口号&gt; 指定数据包匹配的源端口号，可以使用“起始端口号:结束端口号”的格式指定一个范围的端口</span><br><span class="line">-d或–destination &lt;目标地址或子网&gt; 指定数据包匹配的目标地址</span><br><span class="line">–dport目标端口号 指定数据包匹配的目标端口号，可以使用“起始端口号:结束端口号”的格式指定一个范围的端口</span><br></pre></td></tr></table></figure><br><strong>action</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 主要的action有如下的几个</span><br><span class="line">ACCEPT 接受数据包</span><br><span class="line">DROP 丢弃数据包（只丢弃，不作回应，与下面的REJECT不一样）</span><br><span class="line">REJECT 明确的拒绝，还向发送者返回错误信息。</span><br><span class="line">SNAT 源地址转换，即改变数据包的源地址</span><br><span class="line">DNAT 目标地址转换，即改变数据包的目的地址</span><br><span class="line">REDIRECT：重定向，主要用于实现端口重定向</span><br><span class="line">MASQUERADE IP伪装，即是常说的NAT技术</span><br><span class="line">LOG 日志功能，将符合规则的数据包的相关信息记录在日志中，以便管理员的分析和排错</span><br></pre></td></tr></table></figure><br>这里大致整理一下iptables命令的格式：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/fullformat.png" alt="fullformat"></p>
<p>接下来详细的讲解一下实际使用命令的要点：</p>
<p><strong>1、定义默认策略</strong></p>
<p>什么叫默认策略？可以试想这样的场景，首先结合上面的当一个数据包到达链的时候，会根据链中定义的规则进行处理，但是很显然，我们没法对任何一种数据包的处理方式都定义在规则中，当我们的数据包进入链的时候，如果不满足所有规则的进入条件，那么我们起码要有一种默认的策略方式来处理这个数据包。这个定义默认策略就是这个作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t表名] &lt;-P&gt; &lt;链名&gt; &lt;动作&gt; </span><br><span class="line">参数说明如下。</span><br><span class="line">[-t表名]：指默认策略将应用于哪个表，可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认使用filter表。</span><br><span class="line">&lt;-P&gt;：定义默认策略。</span><br><span class="line">&lt;链名&gt;：指默认策略将应用于哪个链，可以使用INPUT、OUTPUT、FORWARD、PREROUTING、OUTPUT和POSTROUTING。</span><br><span class="line">&lt;动作&gt;：处理数据包的动作，可以使用ACCEPT（接受数据包）和DROP（丢弃数据包）。</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/defaultPolicy.png" alt="defaultPolicy"><br><strong>2、增加、插入、删除和替换规则</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">相关规则定义的格式为：</span><br><span class="line">iptables [-t表名] &lt;-A | I | R | D&gt; 链名 [规则编号] [-i | o 网卡名称] [-p 协议类型] [-s 源IP地址 | 源子网] [--sport 源端口号] [-d 目标IP地址 | 目标子网] [--dport目标端口号] &lt;-j动作&gt;</span><br><span class="line">参数说明如下。</span><br><span class="line">[-t表名]：定义默认策略将应用于哪个表，可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认使用filter表。</span><br><span class="line">-A：新增加一条规则，该规则将会增加到规则列表的最后一行，该参数不能使用规则编号。</span><br><span class="line">-I：插入一条规则，原本该位置上的规则将会往后顺序移动，如果没有指定规则编号，则在第一条规则前插入。</span><br><span class="line">-R：替换某条规则，规则被替换并不会改变顺序，必须要指定替换的规则编号。</span><br><span class="line">-D：从规则列表中删除一条规则，可以输入完整规则，或直接指定规则编号加以删除。</span><br><span class="line">&lt;链名&gt;：指定查看指定表中哪个链的规则列表，可以使用INPUT、OUTPUT、FORWARD、PREROUTING、OUTPUT和POSTROUTING。</span><br><span class="line">[规则编号]：规则编号用于插入、删除和替换规则时用，编号是按照规则列表的顺序排列，规则列表中第一条规则的编号为1。</span><br><span class="line">[-i | o 网卡名称]：i是指定数据包从哪块网卡进入，o是指定数据包从哪块网卡输出。网卡名称可以使用ppp0、eth0和eth1等(注意CentOS6.x与7.x网卡命名区别)。</span><br><span class="line">[-p 协议类型]：可以指定规则应用的协议，包含TCP、UDP和ICMP等。</span><br><span class="line">[-s 源IP地址 | 源子网]：源主机的IP地址或子网地址。</span><br><span class="line">[--sport 源端口号]：数据包的IP的源端口号。</span><br><span class="line">[-d目标IP地址 | 目标子网]：目标主机的IP地址或子网地址。</span><br><span class="line">[--dport目标端口号]：数据包的IP的目标端口号。</span><br><span class="line">&lt;-j动作&gt;：处理数据包的动作，各个动作的详细说明可以参考前面的说明。</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/modifyRule.png" alt="modifyRule"></p>
<p><strong>3、查看iptables规则</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看iptables规则的命令格式为：</span><br><span class="line">iptables [-t表名] &lt;-L&gt; [链名]</span><br><span class="line">参数说明如下。</span><br><span class="line">[-t表名]：指查看哪个表的规则列表，表名用可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认查看filter表的规则列表。</span><br><span class="line">&lt;-L&gt;：查看指定表和指定链的规则列表。</span><br><span class="line">[链名]：指查看指定表中哪个链的规则列表，可以使用INPUT、OUTPUT、FORWARD、PREROUTING、OUTPUT和POSTROUTING，如果不指明哪个链，则将查看某个表中所有链的规则列表。</span><br></pre></td></tr></table></figure><br>由于这个命令比较简单，就不贴图了。</p>
<p><strong>4、清除规则和计数器</strong></p>
<p>在新建规则时，往往需要清除原有的、旧的规则，以免它们影响新设定的规则。如果规则比较多，一条条删除就会十分麻烦，这时可以使用iptables提供的清除规则参数达到快速删除所有的规则的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义参数的格式为：</span><br><span class="line">iptables [-t表名] &lt;-F | Z&gt;</span><br><span class="line">参数说明如下。</span><br><span class="line">[-t表名]：指定默认策略将应用于哪个表，可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认使用filter表。</span><br><span class="line">-F：删除指定表中所有规则。</span><br><span class="line">-Z：将指定表中的数据包计数器和流量计数器归零。</span><br></pre></td></tr></table></figure><br>同上，由于这个命令比较简单，就不贴图了。</p>
<p>当然，我们只看命令格式是枯燥的，这里我们使用一些实例来结合命令，使我们更加直观的理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">禁止客户机访问某个网站或者某个IP地址</span><br><span class="line">【例1】添加iptables规则禁止用户访问域名为www.xxx.com的网站。</span><br><span class="line">iptables &lt;-A | I&gt; FORWARD -d www.xxx.com -j DROP</span><br><span class="line">【例2】添加iptables规则禁止用户访问IP地址为xxx.xxx.xxx.xxx的网站。</span><br><span class="line">iptables &lt;-A | I&gt; FORWARD -d xxx.xxx.xxx.xxx -j DROP</span><br></pre></td></tr></table></figure>
<p>解析：首先我们可以确定是需要添加或者是插入一条我们的规则，所以使用&lt;-A | I&gt;；由于这里的拓扑是客户机连接我们的Linux服务器，客户机访问某一个网站，数据包到我们这里并不进入我们主机内部，而是经过转发FORWARD，所以我们要给FORWARD链插入或添加规则；由于指定了目标IP或域名，所以使用 -d 参数，又因为是禁止访问，所以 -j 之后的操作我们使用DROP。</p>
<p>总结：这条命令告诉防火墙，我们现在添加了一条规则在默认的filter表中的FORWARD链，其规则为如果数据包到我们目前这个Linux服务器时，是要准备转发访问IP或域名为XXX的目标（-d），那么我们禁止它访问（DROP）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">禁止某些客户机上网</span><br><span class="line">【例1】添加iptables规则禁止IP地址为192.168.1.X的客户机上网。</span><br><span class="line">iptables &lt;-A | I&gt; FORWARD -s 192.168.1.X -j DROP</span><br><span class="line">【例2】添加iptables规则禁止192.168.1.0子网里所有的客户机上网。</span><br><span class="line">iptables &lt;-A | I&gt; FORWARD -s 192.168.1.0&#x2F;24 -j DROP</span><br></pre></td></tr></table></figure>
<p>解析：同上的拓扑一样，客户机连接我们的Linux服务器，我们的Linux服务器是要准备做转发服务器，替我们的客户机去访问资源。所以还是对FORWARD链添加或者插入规则；但是这一次我们是要准备禁止某个IP地址的客户机上网，或者是某一子网下所有的客户机上网，也就是说，只要数据包的源IP地址或者是源子网下的我们都要禁止，所以这里采用 -s 参数。后面 -j 接DROP代表我们要丢弃来自这些源地址的数据包</p>
<p>总结：这条命令告诉防火墙，我们现在添加了一条规则在默认的filter表中的FORWARD链，其规则为如果客户机的数据包到我们的服务器了，如果其源地址是xxx或者是某个子网下的地址，那么我们禁止转发他。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">禁止客户机访问某些服务</span><br><span class="line">【例1】禁止192.168.1.0子网里所有的客户机使用FTP协议下载。</span><br><span class="line">iptables -I FORWARD -s 192.168.1.0&#x2F;24 -p tcp –dport 21 -j DROP</span><br><span class="line">【例2】禁止192.168.1.0子网里所有的客户机使用Telnet协议连接远程计算机。</span><br><span class="line">iptables -I FORWARD -s 192.168.1.0&#x2F;24 -p tcp –dport 23 -j DROP</span><br></pre></td></tr></table></figure>
<p>解析：以例1为例，首先我们要知道FTP协议使用的是TCP下默认21号端口。禁止192.168.1.0子网里所有的客户机使用FTP协议下载，首先还是转发的地方进行限定所以要在FORWARD链添加规则，源地址为192.168.1.0/24这个子网下的所有客户机，协议使用的是TCP，目的端口为21号。后面 -j 接DROP代表我我们要丢弃满足上述规则的数据包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">强制访问指定的站点</span><br><span class="line">【例】强制所有的客户机访问192.168.1.x这台Web服务器。</span><br><span class="line">iptables -t nat -I PREROUTING -i eth0 -p tcp –dport 80 -j DNAT –to-destination 192.168.1.x:80</span><br><span class="line"></span><br><span class="line">禁止使用ICMP协议</span><br><span class="line">【例】禁止Internet上的计算机通过ICMP协议ping到NAT服务器的ppp0接口，但允许内网的客户机通过ICMP协议ping的计算机。</span><br><span class="line">iptables -I INPUT -i ppp0 -p icmp -j DROP</span><br></pre></td></tr></table></figure></p>
<h3 id="补充学习-NAT类型"><a href="#补充学习-NAT类型" class="headerlink" title="[补充学习]NAT类型"></a>[补充学习]NAT类型</h3><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。</p>
<p>这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。</p>
<p>另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。</p>
<p>静态NAT(Static NAT)<br>静态NAT设置起来最为简单和最容易实现的一种，内部网络中的每个主机都被永久映射成外部网络中的某个合法的地址。</p>
<p>动态地址NAT(Pooled NAT)<br>动态地址NAT是在外部网络中定义了一系列的合法地址，采用动态分配的方法映射到内部网络。<br>动态地址NAT只是转换IP地址，它为每一个内部的IP地址分配一个临时的外部IP地址，主要应用于拨号，对于频繁的远程联接也可以采用动态NAT。</p>
<p>网络地址端口转换NAPT（Port－Level NAT）<br>NAPT是把内部地址映射到外部网络的一个IP地址的不同端口上。<br>最熟悉的一种转换方式。NAPT普遍应用于接入设备中，它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的TCP端口号。</p>
<h3 id="了解-在Centos7-x上卸载firewalld，安装iptables"><a href="#了解-在Centos7-x上卸载firewalld，安装iptables" class="headerlink" title="[了解]在Centos7.x上卸载firewalld，安装iptables"></a>[了解]在Centos7.x上卸载firewalld，安装iptables</h3><p>由于CentOS7.x开始，防火墙应用已经不实用iptables，而是使用firewalld了。其应用的管理理念与iptables有着很大的区别。鉴于你确实可能不想用firewalld而是习惯使用iptables，这里提供相关的操作方式来卸载firewalld安装iptables。</p>
<h4 id="安装iptables、iptables-service"><a href="#安装iptables、iptables-service" class="headerlink" title="安装iptables、iptables-service"></a>安装iptables、iptables-service</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先检查是否安装了iptables</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status iptables.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装iptables</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install -y iptables</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级iptables（安装的最新版本则不需要）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum update iptables </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装iptables-services</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install iptables-services <span class="comment"># service!s!</span></span></span><br></pre></td></tr></table></figure>
<h4 id="禁用-停止自带的firewalld服务"><a href="#禁用-停止自带的firewalld服务" class="headerlink" title="禁用/停止自带的firewalld服务"></a>禁用/停止自带的firewalld服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">停止firewalld服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl stop firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash">禁用firewalld服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl mask firewalld</span></span><br></pre></td></tr></table></figure>
<h4 id="设置现有的规则"><a href="#设置现有的规则" class="headerlink" title="设置现有的规则"></a>设置现有的规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看iptables现有规则</span><br><span class="line">$ iptables -L -n</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/iptables-L-n.png" alt="iptables-L-n"><br>可以看到显示的INPUT、FORWARD、OUTPUT上没有任何规则配置且默认策略均为ACCEPT<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 务必先配置INPUT链的默认规则为ACCEPT，这样一来，避免误配置导致我们无法进入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -P INPUT ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash">清空所有默认规则</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -F</span></span><br><span class="line"><span class="meta">#</span><span class="bash">清空所有自定义规则</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -X</span></span><br><span class="line"><span class="meta">#</span><span class="bash">所有计数器归0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -Z</span></span><br><span class="line"><span class="meta">#</span><span class="bash">允许来自于lo接口的数据包(本地访问)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -i lo -j ACCEPT</span></span><br></pre></td></tr></table></figure><br>接下来定义特别的入站规则<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开放22端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放21端口(FTP)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放80端口(HTTP)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放443端口(HTTPS)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许ping</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许接受本机请求之后的返回数据 RELATED,是为FTP设置的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -m state --state  RELATED,ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure><br>在上面的入站规则配置好以后，接下来我们可以将INPUT默认策略转为DROP（拒绝）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其他入站一律丢弃</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -P INPUT DROP</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有出站一律允许</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -P OUTPUT ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有转发一律丢弃</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -P FORWARD DROP</span></span><br></pre></td></tr></table></figure><br>最终我们可以看到我们目前定义的配置表：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/finalConfig.png" alt="finalConfig"></p>
<h4 id="保存规则设定、开启iptables服务"><a href="#保存规则设定、开启iptables服务" class="headerlink" title="保存规则设定、开启iptables服务"></a>保存规则设定、开启iptables服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存上述规则</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service iptables save</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注册iptables服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相当于以前的chkconfig iptables on</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> iptables.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl start iptables.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status iptables.service</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/enableAndStart.png" alt="enableAndStart"><br>防火墙配置完成！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/04/12/2018-04-12-%E6%A0%91%E8%8E%93%E6%B4%BE3B%E6%90%AD%E5%BB%BANODE-RED%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/12/2018-04-12-%E6%A0%91%E8%8E%93%E6%B4%BE3B%E6%90%AD%E5%BB%BANODE-RED%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/" class="post-title-link" itemprop="url">树莓派3B搭建NODE-RED运行环境并构建数据流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-12T00:00:00+08:00">2018-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>树莓派搭建Node-RED环境</strong></p>
<p>树莓派自2015年开始是默认就带NODE-RED的，但是如今已是2018年：）自带的版本已经很老了，可通过下面的命令进行自动升级NODE.JS和NODE-RED<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -sL https://raw.githubusercontent.com/node-red/raspbian-deb-package/master/resources/update-nodejs-and-nodered)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果出现失败请多尝试几次</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后进入如下界面，展示更新进度</span></span><br><span class="line">  Stop Node-RED                       ✔</span><br><span class="line">  Remove old version of Node-RED      ✔</span><br><span class="line">  Remove old version of Node.js</span><br><span class="line">  Install Node.js</span><br><span class="line">  Clean npm cache</span><br><span class="line">  Install Node-RED core</span><br><span class="line">  Move global nodes to local</span><br><span class="line">  Install extra Pi nodes</span><br><span class="line">  Npm rebuild existing nodes</span><br><span class="line">  Add menu shortcut</span><br><span class="line">  Update systemd script</span><br><span class="line">  Update update script</span><br><span class="line"></span><br><span class="line">Any errors will be logged to   /var/log/nodered-install.log</span><br></pre></td></tr></table></figure><br>一段时间过后，升级完毕：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">All done.</span><br><span class="line">  You can now start Node-RED with the command  node-red-start</span><br><span class="line">  or using the icon under   Menu / Programming / Node-RED</span><br><span class="line">  Then point your browser to localhost:1880 or http://&#123;your_pi_ip-address&#125;:1880</span><br></pre></td></tr></table></figure><br>根据提示我么可以知道，通过如下的命令启用NODE-RED服务，并且访问树莓派地址并加上1880端口访问WEB下的NODE-RED：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node-red-start</span></span><br><span class="line">Start Node-RED</span><br><span class="line"></span><br><span class="line">Once Node-RED has started, point a browser at http://192.168.2.7:1880 # 这里是树莓派分配到IP地址</span><br><span class="line">On Pi Node-RED works better with the Firefox or Chrome browser</span><br><span class="line"></span><br><span class="line">Use   node-red-stop                          to stop Node-RED</span><br><span class="line">Use   node-red-start                         to start Node-RED again</span><br><span class="line">Use   node-red-log                           to view the recent log output</span><br><span class="line">Use   sudo systemctl enable nodered.service  to autostart Node-RED at every boot</span><br><span class="line">Use   sudo systemctl disable nodered.service to disable autostart on boot</span><br><span class="line"></span><br><span class="line">To find more nodes and example flows - go to http://flows.nodered.org</span><br><span class="line"></span><br><span class="line">Starting as a systemd service.</span><br><span class="line">Started Node-RED graphical event wiring tool..</span><br><span class="line">12 Apr 04:33:27 - [info]</span><br><span class="line">Welcome to Node-RED</span><br></pre></td></tr></table></figure><br>然后我们打开浏览器访问web网页，能够看到如下的界面：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/node-red-web.png" alt="node-red-web"><br>Node-RED  UI——显示节点选择板（左）、流的编辑界面（中心）和输出窗格（右）</p>
<p>左侧里面全是node-red包含的节点，而节点就是node-red的基本单位，它包含了生成数据的节点、处理数据的节点以及最终输出的节点。</p>
<p>中间是我们的工作区，在该区域内，我们按照正确的形式构建节点，来形成一套数据流生成、处理过程。</p>
<p>右侧是输出窗格可以切换信息和调试选项卡等。选择信息后，将显示所选节点的文档。当调试被选中时，它将显示调试节点的信息、错误和警告。</p>
<p>作为Node-red最基本的单位：节点。在Node-red中主要分为3类：</p>
<p>1、输入节点（例如inject）<br>2、处理节点（例如function）<br>3、输出节点（例如debug）</p>
<p>输入节点</p>
<p>输入节点允许数据输入到整个流工作空间中。它们至少有一个输出（端点由右边的小灰色方块表示）。同时也可以将其他服务数据连接到输入节点，例如TCP、WebSockets、UDP等节点，或利用手动输入数据到一个流之中。</p>
<p>处理节点</p>
<p>处理节点主要功能是处理数据。它们有一个输入端点和一个或多个输出端点。我们通常使用function节点来处理收到的数据。当然它页可以转换数据类型（例如：JSON、CSV、XML）节点。</p>
<p>输出节点</p>
<p>输出节点允许在Node-RED的流之外发送数据。它们的左侧有一个输入端点。使用输出节点将数据发送到其他服务，TCP等或者使用调试节点输出到调试窗进行观察。</p>
<p>而对于各种数据来说，其本质的最简单的数据结构如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg=&#123;</span><br><span class="line">  payload:”负载数据”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>即每一条数据都会有其本身的负载数据。</p>
<p>讲完了基础的知识，我们来通过动手实践来更加直观的了解node-red</p>
<p><strong>构建时间戳流</strong></p>
<p>这个例子十分简单，我们不需要任何的处理节点，只需要一个输入和一个输出就可以了：</p>
<p>我们首先从左侧拉取一个inject输入节点，放置到工作空间中，它会自动变为默认的时间戳节点，单击这个时间戳节点，查看右侧信息栏，我们能看到这个节点的描述：这个时间戳节点能够生成自1970年1月1号以来的所过的毫秒数<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/inject-timestamp.png" alt="inject-timestamp"><br>通过双击该节点我们还可以看到更加具体的细节：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/inject-detail.png" alt="inject-detail"></p>
<p>接下来我们拉取一个debug节点到工作空间中，它会自动转变为msg.payload节点，这个节点就是会将数据直接输出：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/debug-node-info.png" alt="debug-node-info"><br>接下来我们连接两个节点，同时可以看到每个节点上面都有一个小蓝点，意味着我们的节点只放置到了工作空间中，但是并没有部署：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/node-linked.png" alt="node-linked"><br>点击右上角的部署之后，我们发现小蓝点消失了。接下来我们让时间戳节点产生时间数据并输出查看。首先点击右侧的调试窗口，然后点击时间戳节点左侧的蓝色矩形按钮：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/clickit.png" alt="clickit"><br>点击过程中我们可以看到提示我们注入成功，并且在右侧的还能看到输出的数据：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/successinject.png" alt="successinject"><br>此外，当我们双击debug节点，然后在输出那一栏选择“完整消息”，我们发现输出节点变成了“msg”即整个msg消息体，同时再次部署并点击时间戳产生数据，我们发现输出的信息变得更加完整：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/completeinfo.png" alt="completeinfo"></p>
<p>最后，让我们产生编程界的经典输出：Hello, World!</p>
<p>首先双击“注入节点”，我们不选时间戳类型了，而是替换为文字列：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/change2String.png" alt="change2String"><br>再次部署并点击消息注入按钮（就是蓝色矩形）<br>得到如下的结果：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/injecthw.png" alt="injecthw"></p>
<p>至此，我们成功的使用Node-RED构建了我们的第一条简单的流。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/04/12/2018-04-12-%E6%A0%91%E8%8E%93%E6%B4%BE3B%E4%B8%8A%E6%89%8B%E4%B8%80%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/12/2018-04-12-%E6%A0%91%E8%8E%93%E6%B4%BE3B%E4%B8%8A%E6%89%8B%E4%B8%80%E4%BA%8C/" class="post-title-link" itemprop="url">树莓派3B上手一二</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-12T00:00:00+08:00">2018-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>早些时间心血来潮买过一个树莓派，但是当时只是玩一玩，买来按照网上的教程摆弄了一下就闲置了。最近毕业设计，做时序数据分析的相关的工作，刚好想起能够用到树莓派+Node-RED来生成模拟的时序数据。于是开始搭建相关的环境。特此记录一下。</p>
<p><strong>系统镜像下载</strong></p>
<p>树莓派如今已是一个状态的生态圈。其本身有Linux定制的发行版树莓派系统。首先<a target="_blank" rel="noopener" href="https://www.raspberrypi.org/downloads/raspbian/">官网</a>去下载系统系统镜像：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/officialwebsite.png" alt="officialwebsite"><br>上面有两个版本左边是带有图形界面的，右边是没有图形界面的。个人推荐不带图形界面的，既然是玩树莓派的，我想大多数还是有一定Linux基础的，真没有必要装图形界面。</p>
<p>下载好以后我们能够看到压缩包中存在一个.img后缀的文件，这个就是系统镜像。</p>
<p><strong>系统烧录</strong></p>
<p>由于本人使用的macOS，所以接下来实际操作的都是在macOS环境下进行的，在windows下进行系统烧录，可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012313335/article/details/53405734">这篇文章</a>。</p>
<p>1）格式化SD卡</p>
<p>这里我使用SD官方的SD格式化工具SD Card Formatter，<a target="_blank" rel="noopener" href="https://www.sdcard.org/chs/downloads/formatter_4/index.html">下载地址</a></p>
<p>下载好以后，安装并打开该工具，然后插入SD卡，SD Card Formatter会自动识别插入的Sd卡，我们直接点击format进行格式化。<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/sdformat.png" alt="sdformat"><br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/formatsuccess.png" alt="formatsuccess"></p>
<p>2）烧录系统镜像</p>
<p>在mac下烧录系统是很容易的，因为Linux/UNIX本身有相关的命令操作。</p>
<p>首先在命令行我们使用命令df -h来显示目前的挂载情况<br>这里稍微补充一下Linux/UNIX下的磁盘的命名规则：<br>本人的mac只有一块磁盘就像下面的disk1，而后面的s1、s4则代表这块磁盘上的分区<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df -h  <span class="comment"># 我只粘贴了有代表性的输出</span></span></span><br><span class="line">Filesystem                        Size   Used  Avail Capacity iused               ifree %iused  Mounted on</span><br><span class="line">/dev/disk1s1                     234Gi   99Gi  132Gi    43% 1230474 9223372036853545333    0%   /</span><br><span class="line">/dev/disk1s4                     234Gi  2.0Gi  132Gi     2%       2 9223372036854775805    0%   /private/var/vm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重点是下面这一个条</span></span><br><span class="line">/dev/disk3s1                      15Gi  2.4Mi   15Gi     1%       0                   0  100%   /Volumes/BOOT</span><br></pre></td></tr></table></figure><br>上面的disk3则是我们的SD的磁盘，并且，只有一个分区s1，我们还可以看到容量为15Gi就是我们预期的格式化好了之后的容量。当然，既然这里能够显示则说明，这些磁盘我们已经挂载好了。接下来首先需要取消挂载：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 千万注意一定要取消挂载正确的磁盘！不要把你的mac磁盘给取消挂载了：）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 另外，请记住disk3s1这个名称，后面要用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> diskutil unmount /dev/disk3s1</span></span><br><span class="line">Volume BOOT on disk3s1 unmounted</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候再df发现我们的SD已经不再显示里面了，说明卸载成功</span></span><br></pre></td></tr></table></figure><br>接下来进行正式的烧录，使用dd命令将系统镜像写入，需要特别特别注意disk后的数字，不能搞错！/dev/disk3s1是分区，/dev/disk3是块设备，/dev/rdisk3是原始字符设备<br>我们接下来就是要吧镜像烧录到原始字符设备<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面dd用于将系统镜像写入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bs代表了文件系统的页大小这里设置为4m</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span>=后面接上镜像文件的对应路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of=后面接上原始字符设备的路径，因为上面是我们卸载之前是disk3s1，所以这里就是rdisk3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dd bs=4m <span class="keyword">if</span>=(镜像存放路径)/XXX.img of=/dev/rdisk3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不放心可以在命令行末尾双击tab会出现类似下面的输出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rdisk3    rdisk3s1</span></span><br></pre></td></tr></table></figure><br>回车开始烧录，这个过程按机器的差异时间会有所不同。烧录完成以后会出现下面的输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">443+0 records in</span><br><span class="line">443+0 records out</span><br><span class="line">1858076672 bytes transferred in 237.453302 secs (7825019 bytes/sec)</span><br></pre></td></tr></table></figure><br>至此，树莓派系统的烧录工作就完成了。<strong>补充</strong>：为了方便以后的SSH连接树莓派，完成树莓派的系统烧录之后，先别着急推出SD，打开SD卡（通常在桌面），我们在系统目录下创建一个名为SSH（大写，没有文件后缀）的文件，以供树莓派开启SSH。</p>
<p>命令行下如何进入SD卡？所有挂载的外部设备都会在/Volumes下查创建对应的文件夹：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /Volumes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">lrwxr-xr-x  1 root  wheel     1  4  8 10:59 Macintosh HD -&gt; /</span><br><span class="line">drwxr-xr-x+ 3 root  wheel    96 11 11 15:22 Preboot</span><br><span class="line">drwxrwxrwx@ 1 zhen  staff  2560  4 12 10:30 boot # 这个boot名称的设备就是SD卡</span><br></pre></td></tr></table></figure>
<p>至此，系统初始化工作完全搞定。</p>
<p><strong>登陆系统</strong></p>
<p>以下的操作我们都是在没有显示器的情况下进入树莓派系统，如果你本身有外接显示器，自然不需要这么麻烦，连接然后开机就行了：）</p>
<p>树莓派3B本身带有wifi模块，但是，如果要开启首先你需要进入系统进行配置：），所以最开始你需要有线连接树莓派</p>
<p>理论上，mac在有以太网转雷电或者是转USB情况下，我们可以通过网线直连树莓派和mac，但是本身尝试了多次发现就是发现不了同一网段的树莓派（树莓派都给mac分配了IP地址了），猜测macOS High Serria安全性增强了？这个坑以后在研究一下，填了。</p>
<p>另外一种是路由器组网方式<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/topology.png" alt="topology"><br>按照这样的连接，你的mac和树莓派都在同一网段中，同时你还可以登陆路由器的管理界面去查看树莓派分配到的IP地址，然后通过ssh连接树莓派。</p>
<p>组网完成以后，登陆网关，找到设备管理（不同品牌的路由器界面不同，道理上类似）<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/alldevice.png" alt="alldevice"><br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/netgate.png" alt="netgate"><br>可以看到我们的树莓派已经分配到了IP，然后我们直接通过命令行登陆：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh pi@192.168.1.100</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意默认的用户名和密码分别为pi和raspberry</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将树莓派加入到已识别的主机中</span></span><br><span class="line">The authenticity of host &#x27;192.168.1.100 (192.168.1.100)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:p1UPTb5aXIOUiiqdpdaP/e2MV+vbkZJVey0wCYOUEJE.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入密码，看到一堆信息之后，我们成功进入系统</span></span><br><span class="line">pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure><br>注意：由于我们使用的lite版的树莓派系统，vi使用过程中会出现上下左右方向键成为ABCD等字符，同时mac上的delete（windows上是backspace）都会失效，我们要进行如下的操作：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、编辑/etc/vim/vimrc.tiny</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/vim/vimrc.tiny</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 <span class="built_in">set</span> compatible 改为 <span class="built_in">set</span> nocompatible 这里解决方向键ABCD问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、依旧在该文件中添加 <span class="built_in">set</span> backspace=2 解决删除问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> :wq保存</span></span><br></pre></td></tr></table></figure><br><strong>打开wifi模块</strong></p>
<p>首先我们扫描当前环境中能够找到的wifi<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo iwlist wlan0 scan <span class="comment"># 此步骤非必须，如果你本来就知道wifi名称就可以不用扫描</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果当前环境中有很多会出现类似下面的格式的信息：</span></span><br><span class="line">Cell 10 - Address: 94:D9:B3:15:7F:28</span><br><span class="line">                    Channel:6</span><br><span class="line">                    Frequency:2.437 GHz (Channel 6)</span><br><span class="line">                    Quality=70/70  Signal level=-16 dBm</span><br><span class="line">                    Encryption key:on</span><br><span class="line">                    ESSID:&quot;210&quot;</span><br><span class="line">                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s</span><br><span class="line">                              9 Mb/s; 12 Mb/s; 18 Mb/s</span><br><span class="line">                    Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s</span><br><span class="line">                    Mode:Master</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 我删除很多不重要的输出信息，这里重点看ESSID，这个就是wifi名称。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来我们需要在下面的文件中开启它：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/wpa_supplicant/wpa_supplicant.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加如下的信息</span></span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=&quot;你的Wi-Fi名称&quot;</span><br><span class="line">        psk=&quot;Wi-Fi密码&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果有多个wifi，你可以创建多个network</span></span><br></pre></td></tr></table></figure><br>最后一步，首先请重启（$ sudo reboot）树莓派，然后拔掉网线，通过mac登陆网关，你会发现树莓派已经通过wifi连接到了。下面两款设备都是wifi连接的。<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/twowifi.png" alt="twowifi"><br>此外，由于lite版本，树莓派不具备vim，所以需要我们手动下载：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先移除掉旧的vi</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove -y vim-common</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后安装vim</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install -y vim</span></span><br></pre></td></tr></table></figure><br>接下来在用户目录下打开（没有就创建）.vimrc，并添加如下的vim配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.vimrc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加：</span></span><br><span class="line">set nocompatible &quot;不兼容vi</span><br><span class="line">set nu &quot;显示行号</span><br><span class="line">set nowrap &quot;不自动折行</span><br><span class="line">set scrolloff=3 &quot;距离顶部底部3行</span><br><span class="line">hi MatchParen ctermbg=DarkRed guibg=lightblue</span><br><span class="line">set encoding=utf-8 &quot;编码方式</span><br><span class="line">set fenc=utf-8 &quot;存储时候的编码方式</span><br><span class="line">set hlsearch &quot;搜索高亮</span><br><span class="line">syntax on &quot;语法高亮</span><br><span class="line">set ts=4 &quot;一个tab长度为4</span><br><span class="line">set expandtab &quot;tab替换为空格（配合上面即一个tab四个空格）</span><br><span class="line">set autoindent &quot;自动缩进</span><br></pre></td></tr></table></figure><br>至此，树莓派的初始环境已经OK！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://compilemind.com/2018/04/08/2018-04-08-Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8Einode%E3%80%81Block%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="w4ngzhen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CompileMind">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/08/2018-04-08-Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8Einode%E3%80%81Block%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Linux文件系统与inode、Block笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-08 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-08T00:00:00+08:00">2018-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 15:20:30" itemprop="dateModified" datetime="2020-10-13T15:20:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Linux下一切都是文件，无论是设备还是接口，亦或是网卡等均被抽象成了文件，并且有相关的内核代码进行调度。然而，在一切都是文件的前提下，最需要进行探讨的则是文件存储的根源：文件系统。文件系统的好坏能够更加完美的解决在一个操作系统中对于文件的管理。</p>
<p>Linux下的文件系统是按照inode + block模式来进行了的。通俗一点讲，类似于指针一样的形式存在。即inode作为“指针”记录并指向了真正的”数据块“block。 </p>
<p><strong>环境</strong></p>
<p>为了方便后面的实际操作，我们按照如下进行环境的搭建<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先在<span class="built_in">test</span>目录下创建一个名为temp的文件夹与一个普通的文件test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/root/test</span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir temp &amp;&amp; touch test.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件结构如下</span></span><br><span class="line">test</span><br><span class="line">├── temp</span><br><span class="line">└── test.txt</span><br><span class="line">1 directory, 1 file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 向test.txt写入一句话</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;Its&#x27;s a test.txt&quot;</span> &gt;&gt; test.txt</span></span><br></pre></td></tr></table></figure></p>
<p><strong>inode</strong></p>
<p>在Linux中，每一份文件都对应了独一无二的inode编号，通过使用命令ls加参数-i，则可以在显示的文件前显示inode编号。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -i</span></span><br><span class="line">33933113 temp 17414066 test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 前面的数字就是inode且独一无二</span></span><br></pre></td></tr></table></figure><br>除此之外，inode中还存储更加关键的文件元信息：权限、属性等。例如当我们使用ls -l显示文件的相关属性时，这里面的信息就存储在inode：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x. 2 root root  6 Apr  8 13:05 temp</span><br><span class="line">-rw-r--r--. 1 root root 16 Apr  8 13:08 test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件夹、文件名前面的诸如读、写、执行权限，修改时间等均存储在inode中</span></span><br></pre></td></tr></table></figure><br>当然，对于inode来说，既然它本身能够记录这些信息，所以自身是有大小的，每个inode 大小均固定为128 bytes，虽然不大，但是记录元信息完全足够了。同时，它本身还记录此文件数据所在的block数据块的编号。inode记录一个block编号需要花掉4bytes</p>
<p><strong>block</strong></p>
<p>既然inode是记录文件的元信息的，那么一般文件本身的数据记录在何处呢？答案则是block数据块。在Linux中，block文件快大小通常选择4KB，当然我们还可以选择1KB、2KB等。这是不定的，但是如果选择的太小，那么inode需要记录block编号就要增多，如果太大，容易造成存储碎片。如何理解？其实我们可以把block看作是文件的基本单位，例如，我们现在有一个22KB大小的文件，一个简单的计算，倘若我们使用4KB的block需要6块才能完全装下，不过会有2KB是浪费了的。如果我们采用2KB的block则刚好11块可以装下。这里虽然是选择2KB是最合适的，但是在一般Linux系统中是4KB，为什么？请自行查阅相关的资料，不再赘述。</p>
<p><strong>综合inode与block进行探讨</strong></p>
<p>上面的inode与block只是大致介绍了相关的，下面才是更加实在的内容。</p>
<p>inode具体包含了哪些东西？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、文件的字节数</span><br><span class="line">2、文件拥有者的User ID</span><br><span class="line">3、文件的Group ID</span><br><span class="line">4、文件的读、写、执行权限</span><br><span class="line">5、文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class="line">6、链接数，即有多少文件名指向这个inode</span><br><span class="line">7、文件数据block的位置</span><br></pre></td></tr></table></figure><br>1-5点不难理解，第6点在后面的软硬连接再叙，第七点这里要提一下。上面说过inode本身128 Bytes，还是能记录很多信息的，这里1-6点不至于花光128 Bytes，而对于第7点，inode本身能够记录12个block，如果采用4KB block显然，我们只能存储12 <em> 4KB大小的文件，这显然是不现实的。为了解决这个问题，inode中在第12个记录block编号之后，还能动态的增加二级、甚至三级间接指向，这里我们使用如下的图更为形象的说明：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-08-inode-block/inode-block.png" alt="inode-block"><br>在上图的情况下，我们可以知道假设我们使用4KB大小的block，并且刚好使用满二次间接，能够存储的数据大小为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12*4KB + 1024*4KB + 1024*1024*4KB</span><br><span class="line">&#x3D; 48KB + 4MB + 4GB</span><br><span class="line">≈ 4GB</span><br></pre></td></tr></table></figure><br><em>*关于文件夹的inode、block</em></em></p>
<p>上面讨论inode与block我们都是以一个普通文件的角度来看待的。然而，文件夹inode与block与普通文件是有一定的差别的。对于一个文件夹来说，inode与普通文件类似，包含了关于文件夹的属性、读写执行权限、时间戳等。然而，文件夹inode中的直接block通常不会超过12个直接的。为什么呢？因为文件夹所指向的block只会存储这个文件夹拥有的文件的inode编号，并不会存储实际的文件内容。</p>
<p>例如，当我们拥有一个文件夹dir，这个文件夹下面只有一份文件大小为4GB的inode为1234的文件，那么实际上，文件夹inode中存储的block中只会存储类似inode=1234这样的信息。下图能够更加形象的展示：<br><img src="https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-08-inode-block/dir-inode-block.png" alt="dir-inode-block"><br>总结一下，文件夹的block只会存储对应文件夹下面的文件的inode。所以当我们访问某一个文件的时候，譬如我问需要查看/root/test.txt的时候，流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首先检查根目录下的权限“&#x2F;”，符合权限</span><br><span class="line">通过之后，检查根目录的block是否存储有“root&#x2F;”目录以及对应inode</span><br><span class="line"></span><br><span class="line">查找成功，找到&#x2F;root&#x2F;目录的inode，检查权限等信息，符合权限</span><br><span class="line">通过之后，检查&#x2F;root&#x2F;inode下的block中是否存在test.txt以及inode</span><br><span class="line"></span><br><span class="line">查找成功，找到&#x2F;root&#x2F;test.txt的inode检查权限等信息，符合</span><br><span class="line">查询inode中的直接或间接block将数据读出</span><br></pre></td></tr></table></figure><br>那么，通过以上的分析，我们也很容易的能够理解，如果我们没有对文件夹有写的权限，是不能够删除文件夹下面的文件或者是创建文件的。因为当我们删除一个文件的时候，是对<strong>文件夹</strong>inode对应的block中存储的文件信息进行删除或添加。由于root用户的特殊性，我们使用一个普通用户zhen，并在zhen用户的home目录下创建一个temp文件夹<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">drwxrwxr-x. 2 zhen zhen  6 Apr  8 13:05 temp</span><br><span class="line"><span class="meta">#</span><span class="bash"> temp文件夹对于zhen用户有读写以及执行的权限，所以我们（zhen）可以自由的在里面添加删除文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ./temp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">test</span><br><span class="line"><span class="meta">$</span><span class="bash"> rm <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建删除都没有问题</span></span><br></pre></td></tr></table></figure><br>接下来我们首先在temp文件夹中创建一个test2文件，再回到上一目录，将temp的写权限移除<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建test2文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch test2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">test2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到上一目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将temp对于zhen的写权限移除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 500 ./temp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 4</span><br><span class="line">dr-x------. 2 zhen zhen  6 Apr  8 14:52 temp</span><br></pre></td></tr></table></figure><br>然后，我们再次进入temp文件夹，试图创建文件，发现失败：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ./temp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch test3</span></span><br><span class="line">touch: cannot touch ‘test3’: Permission denied</span><br><span class="line"><span class="meta">$</span><span class="bash"> rm test2</span></span><br><span class="line">rm: cannot rm ‘test3’: Permission denied</span><br></pre></td></tr></table></figure><br>操作发现，无论是在该文件夹下创建还是删除文件，都是失败的。那么，我们还能不能编辑该文件夹该文件夹下面的文件呢？譬如想test2文件插入一句“Hello”？理论上来讲，是可以的，因为我们修改test2文件内容，并不会影响temp文件夹的block内容，而事实上也是如此：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span> &gt; test2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat test2</span></span><br><span class="line">Hello</span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有问题</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="w4ngzhen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">w4ngzhen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/w4ngzhen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;w4ngzhen" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">w4ngzhen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
