[{"title":"node-gyp项目命名BUG","url":"http://compilemind.com/2021/06/25/2021-06-25-node-gyp项目命名BUG/","content":"<p>当我们编写node原生模块的时候，免不了对node-gyp项目进行命名，在node-gyp进行build的时候，会跟binding.gyp配置文件中的target_name生成对应的原生模块。但是，如果target_name填写不规范，会触发编译问题。</p>\n<a id=\"more\"></a>\n<h1 id=\"问题与解决\"><a href=\"#问题与解决\" class=\"headerlink\" title=\"问题与解决\"></a>问题与解决</h1><p>本人发现，当target_name使用了短中线的时候（”-“），会导致编译过程中触发编译问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error C2143: 语法错误: 缺少“;”(在“-”的前面) </span><br></pre></td></tr></table></figure>\n<p>使用下划线命名以及各种驼峰命名不会出现此问题。出现问题的点为文件最后使用宏的时候：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br></pre></td></tr></table></figure>\n<p>解决方案，target_name名称不使用中横线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_name: &quot;the-demo&quot; &#x3D;&gt; target_name: &quot;theDemo&quot;</span><br><span class=\"line\">或</span><br><span class=\"line\">target_name: &quot;the-demo&quot; &#x3D;&gt; target_name: &quot;the_demo&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><p>接下来的问题分析，需要一定的C/C++知识。</p>\n<h2 id=\"编写样例\"><a href=\"#编写样例\" class=\"headerlink\" title=\"编写样例\"></a>编写样例</h2><p>这里不再赘述样例，直接使用这篇文章建立一个demo：<a href=\"https://zhuanlan.zhihu.com/p/383948462\">使用node-gyp编写简单的node原生模块 - 知乎 (zhihu.com)</a>，或是<a href=\"https://www.cnblogs.com/w4ngzhen/p/14931367.html\">使用node-gyp编写简单的node原生模块 - w4ngzhen - 博客园 (cnblogs.com)</a>。</p>\n<p>Demo编写完成后，我们修改其中的target_name，使其带有中横线（”-“）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;hello-world&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello_world.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改为该target_name后，我们进行<code>node-gyp configure &amp;&amp; node-gyp build</code>，会发现编译器报错：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/compile-error.jpg\" alt=\"\"></p>\n<h2 id=\"使用IDE分析\"><a href=\"#使用IDE分析\" class=\"headerlink\" title=\"使用IDE分析\"></a>使用IDE分析</h2><p>我们曾经讲过，node-gyp实际上只是构建工具，他会根据各个操作平台，生成对应平台的项目。在Windows上，它最终会帮你生成一个解决方案。查看项目目录下，我们就能看到一个build文件夹，这个文件夹下面会有解决方案：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/node-gyp-build-sln.jpg\" alt=\"\"></p>\n<p>我们使用VS打开，开始进行分析：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/demo-sln-in-vs.jpg\" alt=\"\"></p>\n<p>通过IDE的智能提示，我们看到在下面的宏使用报错了：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/compile-err-in-vs.jpg\" alt=\"\"></p>\n<p>通常，对于宏报错，我们需要的第一步是进行宏展开，查看到底是什么导致了编译错误的。在VS中，我们进行进行如下的配置，让编译器首先生成宏展开的源码：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/gen-i-file.jpg\" alt=\"\"></p>\n<p>然后，我们重新进行编译，可以看到在对应的生成目录下，产生了一个<code>.i</code>后缀的文件。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/i-file-generated.jpg\" alt=\"\"></p>\n<p>这个宏展开后的源码文件，可以更见方便的便于我们分析。我们直接定位到这个文件的最下方，可以看到我们已经经过宏展开的代码：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/i-file-content.jpg\" alt=\"\"></p>\n<p>我们67404这行宏展开的代码拷贝到VS对应宏使用的地方，通过IDE来更加智能的检查这段有何问题：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/replace-macro-to-code.jpg\" alt=\"\"></p>\n<p>因为改行很长，这里我进行一下格式化代码的操作：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/macro-unfold-error-point.jpg\" alt=\"\"></p>\n<p>可以看到，宏展开里面模块名为”hello-world”，在上图指出的部分，被分割为了”hello - world”，而分割开来后，导致了语法错误。如果target_name使用的”hello_world”，则不会有这个问题：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/macro-unfold-with-underline.jpg\" alt=\"\"></p>\n<p>实际上被<code>&quot;-&quot;</code>分割，是因为在宏展开的时候，作为了函数名的一部分，而函数名标识符是不能有<code>&quot;-&quot;</code>的。这里举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NAME hello-world</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TEST_MACRO(fn) static void fn(void);</span></span><br><span class=\"line\"></span><br><span class=\"line\">TEST_MACRO(NAME) <span class=\"comment\">// 报错，因为最终展开后：static void hello-world(void);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>C语言规定，标识符只能由字母（A~Z, a~z）、数字（0~9）和下划线（_）组成，并且第一个字符必须是字母或下划线，不能是数字。</p>\n</blockquote>\n<p>所以这就是为什么target_name使用有中横线的名称会报错了。</p>\n","categories":[],"tags":["node-gyp","C/C++"]},{"title":"使用node-gyp编写简单的node原生模块","url":"http://compilemind.com/2021/06/25/2021-06-25-编写一个简单的node原生模块/","content":"<p>通过样例，让我们了解如何编写一个node的原生模块。当然，这篇文章还有一个目的，是为了方便以后编写关于node-gyp的文章，搭建初始环境。</p>\n<a id=\"more\"></a>\n<h1 id=\"基于node-addon-api\"><a href=\"#基于node-addon-api\" class=\"headerlink\" title=\"基于node-addon-api\"></a>基于node-addon-api</h1><p>基于node-addon-api的nodejs插件，使用的是node的头文件：<code>#include &lt;node.h&gt;</code>。</p>\n<p><strong>hello_world.cc</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;node.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Method</span><span class=\"params\">(<span class=\"keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class=\"line\">  v8::Isolate* isolate = args.GetIsolate();</span><br><span class=\"line\">  args.GetReturnValue().Set(v8::String::NewFromUtf8(</span><br><span class=\"line\">      isolate, <span class=\"string\">&quot;world&quot;</span>).ToLocalChecked());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Initialize</span><span class=\"params\">(v8::Local&lt;v8::Object&gt; exports)</span> </span>&#123;</span><br><span class=\"line\">  NODE_SET_METHOD(exports, <span class=\"string\">&quot;hello&quot;</span>, Method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br></pre></td></tr></table></figure>\n<p><strong>binding.gyp</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;hello_world&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello_world.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>index.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binding = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./build/Release/hello_world&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binding.hello());</span><br></pre></td></tr></table></figure>\n<p><strong>package.json</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...  </span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build&quot;: &quot;node-gyp configure &amp;&amp; node-gyp build&quot;,</span><br><span class=\"line\">    &quot;run:demo&quot;: &quot;node index.js&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><strong>整体结构</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-simple-node-gyp-demo/node-addon-simple-demo-proj-arch.jpg\" alt=\"\"></p>\n<p>按照如下命令依次运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run build</span></span><br><span class=\"line\">// 使用node-gyp配置并构建</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run run:demo</span></span><br><span class=\"line\">// 运行Demo</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\Projects\\node-addon-demo&gt;npm run run:demo</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; node-addon-demo@1.0.0 run:demo</span><br><span class=\"line\">&gt; node index.js</span><br><span class=\"line\"></span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n<p>附上GitHub地址：<a href=\"https://github.com/w4ngzhen/node-addon-demo\">w4ngzhen/node-addon-demo (github.com)</a>，方便以后快速完成环境搭建。</p>\n","categories":[],"tags":["node-gyp"]},{"title":"从源码分析node-gyp指定node库文件下载地址","url":"http://compilemind.com/2021/05/12/2021-05-12-从源码分析node-gyp指定node库文件下载地址/","content":"<p>当我们安装node的C/C++原生模块时，涉及到使用node-gyp对C/C++原生模块的编译工作（configure、build）。这个过程，需要nodejs的<strong>头文件</strong>以及<strong>静态库</strong>参与（后续称库文件）对C/C++项目编译和链接。库文件从哪里下载，会有一定逻辑进行处理，本文将从源码入手进行分析。</p>\n<a id=\"more\"></a>\n<h1 id=\"编写简单的原生模块\"><a href=\"#编写简单的原生模块\" class=\"headerlink\" title=\"编写简单的原生模块\"></a>编写简单的原生模块</h1><p>为了方便进行分析，我们首先创建一个原生模块（关于如何编写原生模块的细节不再本文讨论）。</p>\n<p><strong>hello_world.cc</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;node.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Method</span><span class=\"params\">(<span class=\"keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class=\"line\">  v8::Isolate* isolate = args.GetIsolate();</span><br><span class=\"line\">  args.GetReturnValue().Set(v8::String::NewFromUtf8(</span><br><span class=\"line\">      isolate, <span class=\"string\">&quot;world&quot;</span>).ToLocalChecked());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Initialize</span><span class=\"params\">(v8::Local&lt;v8::Object&gt; exports)</span> </span>&#123;</span><br><span class=\"line\">  NODE_SET_METHOD(exports, <span class=\"string\">&quot;hello&quot;</span>, Method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br></pre></td></tr></table></figure>\n<p><strong>binding.gyp</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;hello_world&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello_world.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>index.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binding = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./build/Release/hello_world&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binding.hello());</span><br></pre></td></tr></table></figure>\n<p><strong>package.json</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...  </span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build&quot;: &quot;node-gyp configure &amp;&amp; node-gyp build&quot;,</span><br><span class=\"line\">    &quot;run:demo&quot;: &quot;node index.js&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><strong>整体结构</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/node-addon-simple-demo-proj-arch.jpg\" alt=\"\"></p>\n<p>按照如下命令依次运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run build</span></span><br><span class=\"line\">// 使用node-gyp配置并构建</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run run:demo</span></span><br><span class=\"line\">// 运行Demo</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\Projects\\node-addon-demo&gt;npm run run:demo</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; node-addon-demo@1.0.0 run:demo</span><br><span class=\"line\">&gt; node index.js</span><br><span class=\"line\"></span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n<h1 id=\"从源码分析node-gyp下载库文件的路径\"><a href=\"#从源码分析node-gyp下载库文件的路径\" class=\"headerlink\" title=\"从源码分析node-gyp下载库文件的路径\"></a>从源码分析node-gyp下载库文件的路径</h1><p>首先要直接给出一个结论，库文件并不是每次都要从网络上下载，库文件下载后会缓存在本地一个目录，在Windows上为<code>C:\\Users\\用户\\AppData\\Local\\node-gyp\\Cache</code>中，并按照nodejs的版本进行存储：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/node-headers-cache-dir.jpg\" alt=\"\"></p>\n<p><em>本人电脑安装的node版本为14.15.0，且曾经已经缓存了对应的库文件。</em></p>\n<p>为了便于分析，我们首先删除该缓存文件，并且在原有的npm命令加上<code>--verbose</code>，输出更加详细的日志：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run build --verbose</span><br></pre></td></tr></table></figure>\n<p>于是，我们可以从众多的输出中，看到一个关键信息：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/show-official-dist-url.jpg\" alt=\"\"></p>\n<p>从日志中可以看出，node-gyp在构建过程中，会创建缓存目录，然后从指定URL下载指定版本的headers文件。</p>\n<p>我们利用GrepWin（一款Windows下超好用的文本内容搜索工具，<a href=\"https://tools.stefankueng.com/grepWin.html\">官网</a>），在node-gyp目录中搜索<code>created nodedir</code>这个关键词，因为可以看到<code>gyp http GET</code>上面出现了这个关键词。那么现在有一个新的问题，node-gyp目录在哪儿？其实，从上面的日志往上查看，能够找到：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/where-is-node-gyp.jpg\" alt=\"\"></p>\n<p>这里是调用的我们全局安装的npm依赖的node-gyp，于是我们定位到node-gyp所在目录进行搜索：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/search-create-nodedir.jpg\" alt=\"\"></p>\n<p>进入该文件，我们找到：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/create-nodedir-and-download.jpg\" alt=\"\"></p>\n<p>找到关键词搜索后，继续往后续代码查阅，能够看到一个<code>download</code>函数的调用，入参最后一位是url，此时已经是成型的url，所以接下来我们需要确定，<code>release.tarballUrl</code>这个值，究竟是什么时候确定的。</p>\n<h2 id=\"tarballUrl如何得到\"><a href=\"#tarballUrl如何得到\" class=\"headerlink\" title=\"tarballUrl如何得到\"></a>tarballUrl如何得到</h2><p>继续向上翻阅代码，能够在入口处看到这个release是如何生成的：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/get-the-release.jpg\" alt=\"\"></p>\n<p>进入代码后，能够找到一段核心的构建：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/distUrl-make-flow.jpg\" alt=\"\"></p>\n<p>通过上述代码流程，我们总结出来，tarballUrl的baseUrl取决于是否存在overrideDistUrl，若存在，则直接使用；否则使用默认URL：<code>https://nodejs.org/dist</code>。</p>\n<p>再查看<code>overrideDistUrl</code>的传入点：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/overrideDistUrl.jpg\" alt=\"\"></p>\n<p>也就是说，gyp对象的opts属性存在<code>dist-url</code>或<code>disturl</code>时，就会使用该值作为库文件下载的baseUrl。</p>\n<h2 id=\"如何构建gyp-opts\"><a href=\"#如何构建gyp-opts\" class=\"headerlink\" title=\"如何构建gyp.opts\"></a>如何构建gyp.opts</h2><p>首先检查该函数的调用点：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/where-use-processRelease.jpg\" alt=\"\"></p>\n<p>发现configure和install.js都使用了该函数，且都是入口处进行的调用的：</p>\n<p><strong>configure.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configure</span> (<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> python</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buildDir = path.resolve(<span class=\"string\">&#x27;build&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> configNames = [<span class=\"string\">&#x27;config.gypi&#x27;</span>, <span class=\"string\">&#x27;common.gypi&#x27;</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> configs = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nodeDir</span><br><span class=\"line\">  <span class=\"keyword\">var</span> release = processRelease(argv, gyp, process.version, process.release)</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = configure</span><br></pre></td></tr></table></figure>\n<p><strong>install.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">fs, gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> release = processRelease(argv, gyp, process.version, process.release)</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> install(fs, gyp, argv, callback)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到confiigure.js和install.js都作为函数形式导出，也就是说，gyp这个对象是在这两个模块在被导入并以函数形式调用时被传入的。那么接下来我们需要看这两个模块在何处使用的。</p>\n<p>在上文我们查看当前执行的node-gyp目录的时候，我们就看到过：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gyp verb cli [</span><br><span class=\"line\">gyp verb cli   &#39;D:\\\\Programs\\\\nodejs\\\\node.exe&#39;,</span><br><span class=\"line\">gyp verb cli   &#39;D:\\\\Programs\\\\nodejs\\\\global_modules\\\\node_modules\\\\npm\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js&#39;,</span><br><span class=\"line\">gyp verb cli   &#39;configure&#39;</span><br><span class=\"line\">gyp verb cli ]</span><br></pre></td></tr></table></figure>\n<p>入口函数是：<code>node-gyp根目录/bin/node-gyp.js</code>。所以，我们将node-gyp以项目的形式添加到IDEA中，尝试以相同的形式调用这些命令，通过开启DEBUG模式，来一探究竟。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/debug-node-gyp-portal.jpg\" alt=\"\"></p>\n<p>在<code>bin/node-gyp.js</code>中的最下方进行了一个名为<code>run</code>的函数调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bin/node-gyp.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// 还有很多省略的代码......</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// start running the given commands!</span></span><br><span class=\"line\">run()</span><br></pre></td></tr></table></figure>\n<p>根据注释可以，<code>run()</code>执行所提供的命令。翻阅该函数：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/the-run-func.jpg\" alt=\"\"></p>\n<p>总体分为两步：</p>\n<ol>\n<li>从对象prog的todo这个数组中取出首个command命令对象，不存在判定为所有命令执行完成。</li>\n<li>从对象prog的命令数组（commands）中找到对应命令名称（command.name），通过代码可知，该命令实际上对应一个函数。传入参数（command.args）完成该函数的调用。</li>\n</ol>\n<p>那么这个prog是什么呢？通过向上阅读代码，可以知道来自于上层目录提供的模块：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/what-is-gyp.jpg\" alt=\"\"></p>\n<p>而上层所指代的模块是通过package.json的<code>main</code>字段可知是<code>lib/node-gyp.js</code>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根目录下的package.json</span></span><br><span class=\"line\">&quot;main&quot;: &quot;./lib/node-gyp.js&quot;,</span><br></pre></td></tr></table></figure>\n<p>进入该文件的gyp函数，返回的是类Gyp的实例，而Gyp实例的构造过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/Gyp-constructor-and-commands.jpg\" alt=\"\"></p>\n<ol>\n<li>使用self变量指代Gyp实例，并创建devDir和commands字段。</li>\n<li>遍历上方的commands字符串数组，给self（也就是Gyp实例）的commands属性中，逐步添加对应命令名称的函数，函数的实现是：require和command同名的js模块，这些模块又本身是以函数形式导出的，最终是调用对应模块函数。举例说明：当遍历到command为<code>configure</code>的时候，就是如下的形式：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.commands[<span class=\"string\">&#x27;configure&#x27;</span>] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  log.verbose(<span class=\"string\">&#x27;command&#x27;</span>, <span class=\"string\">&#x27;configure&#x27;</span>, argv)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./configure&#x27;</span>)(self, argv, callback)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在进行<code>node-gyp configure</code>时的调用栈就如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行node-gyp configure:</span><br><span class=\"line\">=&gt; run()</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">=&gt; gyp.commands[<span class=\"string\">&#x27;configure&#x27;</span>](argv, cb);</span><br><span class=\"line\">=&gt; <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./configure&#x27;</span>)(self, argv, cb); <span class=\"comment\">// self就是Gyp实例</span></span><br></pre></td></tr></table></figure>\n<p>前文我们已经知道了configure.js这个模块导出的就是一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// configure.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configure</span> (<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> python</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buildDir = path.resolve(<span class=\"string\">&#x27;build&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> configNames = [<span class=\"string\">&#x27;config.gypi&#x27;</span>, <span class=\"string\">&#x27;common.gypi&#x27;</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> configs = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nodeDir</span><br><span class=\"line\">  <span class=\"comment\">// 这个gyp，就是入参gyp，也就是上面的gyp实例</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> release = processRelease(argv, gyp, process.version, process.release)</span><br><span class=\"line\">  ... ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">... ...</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = configure</span><br></pre></td></tr></table></figure>\n<p>所以，我们终于知道<code>processRelease</code>的入参的gyp，就是上面的gyp实例。那么gyp实例中的opts属性，是哪儿来的呢？使用IDEA的Debug进行断点调式，调试<code>bin/node-gyp.js</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/before-handle-opts.jpg\" alt=\"\"></p>\n<p>可以看到，在执行<code>parseArgv</code>这个函数前，gyp实例里面还不存在opts属性，而执行后，又在使用opts属性的devdir。也就是说，<code>parseArgv</code>这个函数一定构建了opts，接下来我们重点分析这个函数。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/parseArgv-portal.jpg\" alt=\"\"></p>\n<p>入口的argv就是我们的运行时入参：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dev&quot;: &quot;node .&#x2F;bin&#x2F;node-gyp.js configure&quot;</span><br></pre></td></tr></table></figure>\n<p>首先会经过<code>nopt</code>函数，看样子，是对命令行参数以及短命令的处理：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/opts-build-1.jpg\" alt=\"\"></p>\n<p>然后是该函数其他的部分：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/opts-build-2-handle-argv-and-env.jpg\" alt=\"\"></p>\n<p>主要分为两个部分：</p>\n<ol>\n<li>对argv的解析</li>\n<li>对环境变量的解析</li>\n</ol>\n<p>对argv的解析不涉及设置opts属性，我们重点看对环境变量的解析：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// support for inheriting config env variables from npm</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> npmConfigPrefix = <span class=\"string\">&#x27;npm_config_&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(process.env).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name.indexOf(npmConfigPrefix) !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> val = process.env[name]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name === npmConfigPrefix + <span class=\"string\">&#x27;loglevel&#x27;</span>) &#123;</span><br><span class=\"line\">    log.level = val</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add the user-defined options to the config</span></span><br><span class=\"line\">    name = name.substring(npmConfigPrefix.length)</span><br><span class=\"line\">    <span class=\"comment\">// gyp@741b7f1 enters an infinite loop when it encounters</span></span><br><span class=\"line\">    <span class=\"comment\">// zero-length options so ensure those don&#x27;t get through.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.opts[name] = val</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"built_in\">this</span>)</span><br></pre></td></tr></table></figure>\n<p>处理流程为：</p>\n<ol>\n<li>判断环境变量的名称（name），如果<strong>不是</strong>以<code>npm_config_</code>开头，则跳过该次处理，否则进入下一步。</li>\n<li>如果变量名是<code>npm_config_loglevel</code>（npm的日志等级变量），则使用该日志等级作为node-gyp在使用npm时候的日志变量（这是对日志等级的特殊处理）。</li>\n<li>否则（一般处理），截断该变量的名，例如<code>name = &#39;npm_config_my_key&#39;</code>，则得到<code>my_key</code>，设置到opts中：<code>opts[&#39;my_key&#39;] = 变量值</code>。</li>\n</ol>\n<p>至此，我们已经知道了，opts属性的值来源于上述的解析。</p>\n<p>那么，回到我们一开始的目的，我们知道了要实现从指定的地方下载node的库文件，只要opts里面存在<code>dist-url</code>或是<code>disturl</code>即可。有些读者可能会说，那这样就行了呀：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/custom-url-by-set-dist-url.jpg\" alt=\"\"></p>\n<p>实际上，并不行：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/just-has-dist_url.jpg\" alt=\"\"></p>\n<p>解析结束后，会发现，gyp.opts中是不存在<code>dist-url</code>字段的，只有<code>dist_url</code>。这一切的缘由，都是因为，npm在处理环境变量的时候，会将<code>-</code>替换为下划线<code>_</code>（<a href=\"https://docs.npmjs.com/cli/v7/using-npm/config#environment-variables\">config | npm Docs (npmjs.com)</a>）。</p>\n<p>好在，node-gyp还能够处理opts中的<code>disturl</code>字段。所以我们只需要在使用npm来使用node-gyp的时候，加入参数<code>--disturl</code>。现在，让我们回到我们一开始的node-addon-demo，添加设置变量的参数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;build&quot;: &quot;node-gyp configure &amp;&amp; node-gyp build&quot;,</span><br><span class=\"line\">  &quot;build:custom&quot;: &quot;npm run build --verbose --disturl=this_is_my_custom_url&quot;,</span><br><span class=\"line\">  &quot;run:demo&quot;: &quot;node index.js&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>上述<code>build:custom</code>就是我们新加的配置，通过运行，果然，加载的是我们制定的url：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gyp verb created nodedir C:\\Users\\w4ngzhen\\AppData\\Local\\node-gyp\\Cache\\14.15.0</span><br><span class=\"line\">&#x2F;&#x2F; 这里报错忽略，因为使用的是一个无效的url: &#39;this_is_my_custom_url&#39;</span><br><span class=\"line\">&#x2F;&#x2F; 主要是为了验证确实是改变了</span><br><span class=\"line\">gyp http GET this_is_my_custom_url&#x2F;v14.15.0&#x2F;node-v14.15.0-headers.tar.gz</span><br><span class=\"line\">gyp WARN install got an error, rolling back install</span><br><span class=\"line\">gyp verb command remove [ &#39;14.15.0&#39; ]</span><br></pre></td></tr></table></figure>\n<h2 id=\"node-gyp的直接使用和npm使用的区别\"><a href=\"#node-gyp的直接使用和npm使用的区别\" class=\"headerlink\" title=\"node-gyp的直接使用和npm使用的区别\"></a>node-gyp的直接使用和npm使用的区别</h2><p>那么，有的细心的读者可能会说，明明这里通过npm使用的时候会转为下划线，那在node-gyp的官方github，说是可以使用<code>dist-url</code>这个参数呢？。</p>\n<p><a href=\"https://github.com/nodejs/node-gyp\">nodejs/node-gyp: Node.js native addon build tool (github.com)</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/official-dist-url.jpg\" alt=\"\"></p>\n<p>实际上，官方文档给出的参数，需要你直接使用node-gyp方式进行设置，也就是说，—dist-url这个参数必须紧跟node-gyp的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node-gyp configure --dist-url&#x3D;xxx</span><br></pre></td></tr></table></figure>\n<p>像是上面的<code>npm run $&#123;使用node-gyp的脚本名&#125; --dist-url=xxx</code>，这个dist-url是作为npm的参数来被识别，而非node-gyp。所以，对于demo，我们还可以如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;build&quot;: &quot;node-gyp configure --dist-url=this_is_my_custom_url &amp;&amp; node-gyp build --dist-url=this_is_my_custom_url&quot;,</span><br><span class=\"line\">  &quot;build:custom&quot;: &quot;npm run build --verbose&quot;,</span><br><span class=\"line\">  &quot;run:demo&quot;: &quot;node index.js&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>注意，这一次，我把<code>--dist-url</code>是放在和node-gyp命令的参数的。但是，我们知道有些npm包，内部就直接使用node-gyp进行配置编译的操作，这个过程没法通过<code>--dist-url</code>紧跟<code>node-gyp</code>命令方式，所以只能在例如<code>.npmrc</code>文件中配置兼容的不会被下划线处理的<code>disturl</code>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>要想让node-gyp下载node库文件的时候，能够走指定的镜像，可以通过配置<code>--dist-url</code>或是<code>--disturl</code>的方式，但配置<code>dist-url</code>形式参数只能是参数紧跟<code>node-gyp</code>的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node-gyp configure --dist-url&#x3D;xxx</span><br></pre></td></tr></table></figure>\n<p>而<strong>不能</strong>是如下的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 你的package.json scripts字段</span><br><span class=\"line\">&quot;build&quot;: &quot;node-gyp configure&quot;</span><br><span class=\"line\">&#x2F;&#x2F; 然后在命令行调用</span><br><span class=\"line\">npm run build --dist-url&#x3D;xxx &#x2F;&#x2F; </span><br></pre></td></tr></table></figure>\n<p>因为此时<code>--dist-url</code>参数是npm的参数，且会被处理为<code>npm_config_dist_url</code>下划线形式，进而在gyp.opts只有dist_url属性。</p>\n<p>所以，最安全的方式是使用disturl参数：</p>\n<p>情况1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node-gyp configure --disturl&#x3D;xxx</span><br></pre></td></tr></table></figure>\n<p>情况2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 你的package.json scripts字段</span><br><span class=\"line\">&quot;build&quot;: &quot;node-gyp configure&quot;</span><br><span class=\"line\">&#x2F;&#x2F; 然后在命令行调用</span><br><span class=\"line\">npm run build --disturl&#x3D;xxx</span><br></pre></td></tr></table></figure>\n<p>情况1下，disturl是作为node-gyp的参数进行解析，能够被设置到opts中。</p>\n<p>情况2，disturl是作为npm的参数被加入到npm环境变量：<code>npm_config_disturl</code>，此时，node-gyp解析process.env的时候，也能解析到<code>disturl</code>进而设置到opts。</p>\n","categories":[],"tags":["node-gyp"]},{"title":"electron-builder进行DEBUG输出的正确方式","url":"http://compilemind.com/2021/04/18/2021-04-18-electron-builder进行DEBUG输出的正确方式/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>使用Electron进行打包通常会用到electron-builder或者electron-packager两种工具。在使用electron-builder的时候，由于对机制的不熟悉，我们在打包过程中常常遇到很多环境错误，但最终只是一些简单的错误信息，难以排查问题。本文将介绍electron-builder进行DEBUG输出的正确方式来帮助排查打包过程中的各种问题。</p>\n<a id=\"more\"></a>\n<h1 id=\"本地node与electron内部的node\"><a href=\"#本地node与electron内部的node\" class=\"headerlink\" title=\"本地node与electron内部的node\"></a>本地node与electron内部的node</h1><p>在对Electron进行打包的时候，需要对当前Electron项目中使用到的node原生C/C++模块进行额外的平台编译，这个过程被称为<code>rebuild</code>。有这样的一个步骤，是因为electron在运行主进程脚本的时候，是跑在了electron内部的一个nodejs环境的，electron内部的nodejs与开发机器上的nodejs并不一定是相同的。为了验证这一论点，我们进行如下的一个测试，来分别打印本地机器安装的node的版本和electon内部的node版本：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/test-show-version1.png\" alt=\"\"></p>\n<p>接下来是electron主进程脚本的node版本显示（main.js）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/test-show-version2.png\" alt=\"\"></p>\n<p>接下来是分别运行<code>npm run show-local-node-version</code>和<code>npm run start</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/show-local-and-inner-version.png\" alt=\"\"></p>\n<p>可以看到输出确实和我们的理解是一致的，版本为11.2.0的electron内部的node版本呢是12，而我们本地机器上的node是14。这也侧面说明了为什么一般的electron应用程序会很大，因为一份electron应用程序，就有一个node的运行时。</p>\n<h1 id=\"electron-builder调试输出正确方式\"><a href=\"#electron-builder调试输出正确方式\" class=\"headerlink\" title=\"electron-builder调试输出正确方式\"></a>electron-builder调试输出正确方式</h1><p>electron-builder进行打包的时候，会建议你在此之前使用<code>electron-builder install-app-deps</code>的命令。该命令的作用就是针对即将打包的electron程序对应的node版本进行原生模块的编译工作，以达到模块运行时匹配。实际上，<code>install-app-deps</code>内部依然使用了<code>node-gyp</code>相关知识，关于这一块的知识，读者可以翻阅我之前的文章《node-pre-gyp以及node-gyp的源码简单解析（以安装sqlite3为例）》来了解，这里不再赘述。本文着重介绍electron-builder如何进行debug打印，好知道打包的过程中发生了什么。</p>\n<ol>\n<li>首先我们准备在项目中，安装一个需要根据平台原生编译的npm包：<code>images</code>。</li>\n<li>然后在package.json中的scripts中添加一段脚本：<code>&quot;installappdeps&quot;: &quot;electron-builder install-app-deps&quot;</code></li>\n<li>最后调用命令<code>npm rum installappdeps</code>执行该脚本</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/images-install-and-run-install-app-deps.png\" alt=\"\"></p>\n<h2 id=\"DEBUG环境变量\"><a href=\"#DEBUG环境变量\" class=\"headerlink\" title=\"DEBUG环境变量\"></a>DEBUG环境变量</h2><p>在<a href=\"https://www.electron.build/#debug\">官方文档</a>中指出了，你可以设置环境变量的方式来方便输出：</p>\n<p>Set the <code>DEBUG</code> environment variable to debug what electron-builder is doing:</p>\n<p>设置<code>DEBUG</code>环境变量值为字符串<code>electron-builder</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEBUG=electron-builder</span><br></pre></td></tr></table></figure>\n<p><code>FPM_DEBUG</code> 环境变量，将会显示更多关于构建Linux平台程序的细节（除了snap和appimage）。</p>\n<ul>\n<li><strong>cmd（Windows CMD）</strong></li>\n</ul>\n<p>On <a href=\"https://github.com/visionmedia/debug#windows-command-prompt-notes\">Windows</a> the environment variable is set using the set command：</p>\n<p>在Windows CMD设置环境变量可以使用如下命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> DEBUG=electron-builder</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>PowerShell</strong></li>\n</ul>\n<p>PowerShell uses different syntax to set environment variables：</p>\n<p>PowerShell使用不同的语法来设置环境变量：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$env:DEBUG</span>=electron<span class=\"literal\">-builder</span></span><br></pre></td></tr></table></figure>\n<p>在我们的机器上，我们同样设置该环境变量，然后执行：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/install-app-deps-with-DEBUG.png\" alt=\"\"></p>\n<p>发现输出了大量的关于electron-builder的DEBUG打印，为我们了解<code>electron-builder install-app-deps</code>提供了更多的信息。</p>\n<h2 id=\"verbose参数\"><a href=\"#verbose参数\" class=\"headerlink\" title=\"verbose参数\"></a>verbose参数</h2><p>然而，有的时候光是设置上述<code>DEBUG</code>环境变量还不够，因为electron-builder内部在进行rebuild操作的时候，还会以子进程方式调用<code>node-gyp</code>等工具，这些工具可不会查看上面的环境变量来输出调试信息的。我们需要在electron-builder调用node-gyp的时候，还能够打印这些工具的调试信息。熟悉node的读者可能会说，那我使用<code>electron-builder</code>的时候，传入<code>--verbose</code>怎么样？就像如下的方式：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;installappdeps&quot;: &quot;electron-builder install-app-deps --verbose&quot;</span><br></pre></td></tr></table></figure>\n<p>不幸的是，虽然<code>--verbose</code>能被node-gyp识别，无法被electron-builder识别，。当你直接这么调用的时候，会出错：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/electron-cannot-recognise-verbose.png\" alt=\"\"></p>\n<p>那么要如何解决这个问题呢？正确的做法是编写两个<code>scripts</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;scripts&quot;: &#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">   &quot;installappdeps&quot;: &quot;electron-builder install-app-deps&quot;,</span><br><span class=\"line\">   &quot;installappdeps-with-verbose&quot;: &quot;npm run installappdeps --verbose&quot;</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure>\n<p>然后在想要进行verbose打印的时候，执行<code>npm rum installappdeps-with-verbose</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/after-use-two-scripts-output.png\" alt=\"\"></p>\n<p>可以看到，在install-app-deps的DEBUG打印前，我们还看到node给出的一些额外信息。</p>\n","categories":[],"tags":["electron","electron-builder"]},{"title":"使用CEF（3）— 从CEF官方Demo源码入手解析CEF架构与CefApp、CefClient对象","url":"http://compilemind.com/2021/03/31/2021-03-31-使用CEF（3）— 从CEF官方Demo源码入手解析CEF架构与CefApp、CefClient对象/","content":"<p>在上文《使用CEF（2）— 基于VS2019编写一个简单CEF样例》中，我们介绍了如何编写一个CEF的样例，在文章中提供了一些代码清单，在这些代码清单中提到了一些CEF的定义的类，例如<code>CefApp</code>、<code>CefClient</code>等等。它们具体有什么作用，和CEF的进程架构有什么关系呢？本文将逐一进行介绍。</p>\n<a id=\"more\"></a>\n<h1 id=\"CEF的进程架构\"><a href=\"#CEF的进程架构\" class=\"headerlink\" title=\"CEF的进程架构\"></a>CEF的进程架构</h1><blockquote>\n<p>CEF3 runs using multiple processes. The main process which handles window creation, painting and network access is called the “browser” process. This is generally the same process as the host application and the majority of the application logic will run in the browser process. Blink rendering and JavaScript execution occur in a separate “render” process. Some application logic, such as JavaScript bindings and DOM access, will also run in the render process. The default <a href=\"http://www.chromium.org/developers/design-documents/process-models\">process model</a> will spawn a new render process for each unique origin (scheme + domain). Other processes will be spawned as needed, such as “plugin” processes to handle <a href=\"http://www.chromium.org/developers/design-documents/plugin-architecture\">plugins</a> like Flash and “gpu” processes to handle <a href=\"http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome\">accelerated compositing</a>.</p>\n</blockquote>\n<p>CEF3使用多个进程运行。处理窗口创建、绘制和网络访问的主要进程称为<strong>浏览器进程</strong>。这通常与宿主应用程序的进程相同，大多数应用程序的逻辑将在浏览器进程中运行。使用Blink引擎渲染HTML和JavaScript执行在单独的<strong>渲染进程</strong>中发生。一些应用程序逻辑（如JavaScript绑定和DOM访问）也将在渲染进程中运行。默认进程模型将为每个唯一源地址（scheme+domain）运行一个新的渲染进程。其他进程将根据需要生成，例如处理Flash等插件的<strong>插件进程</strong>和处理加速合成的<strong>GPU进程</strong>。综合上述文档，我们整理一下：</p>\n<p>浏览器进程（Browser Process）：</p>\n<ul>\n<li>窗口创建、绘制</li>\n<li>网络访问</li>\n<li>……</li>\n</ul>\n<p>渲染进程（Renderer Process）：</p>\n<ul>\n<li><p>通过Blink引擎渲染HTML</p>\n</li>\n<li><p>JavaScript执行（V8引擎）</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<p>需要注意的是，<strong>浏览器进程</strong>中会进行窗口绘制，并不是指绘制HTML内容，而是承载网页内容的那个窗体壳，同样<strong>渲染进程</strong>也不是用来创建窗体的进程。接下来，本人将以官方CefSimple Demo源码入手，逐步介绍Cef的概念。</p>\n<p>本来本人想要使用上一文中的编写的simple-cef进行源码解析，但是为了让本文相对的独立，所以还是决定使用官方的Demo：cefsimple进行源码解析。尽管和simple-cef项目的内容差别不大。需要注意的是一下的源码在解析的时候，会进行适当的删改，读者最好对照源码进行阅读更佳。<strong>PS：源码中显示<code>......</code>表明示例代码有所删除。</strong></p>\n<h2 id=\"cefsimple-win-cc\"><a href=\"#cefsimple-win-cc\" class=\"headerlink\" title=\"cefsimple_win.cc\"></a>cefsimple_win.cc</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// Entry point function for all processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> APIENTRY <span class=\"title\">wWinMain</span><span class=\"params\">(HINSTANCE hInstance,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      HINSTANCE hPrevInstance,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      LPTSTR lpCmdLine,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">int</span> nCmdShow)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// CEF applications have multiple sub-processes (render, plugin, GPU, etc)</span></span><br><span class=\"line\">  <span class=\"comment\">// that share the same executable. This function checks the command-line and,</span></span><br><span class=\"line\">  <span class=\"comment\">// if this is a sub-process, executes the appropriate logic.</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> exit_code = CefExecuteProcess(main_args, <span class=\"literal\">nullptr</span>, sandbox_info);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exit_code &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// The sub-process has completed so return here.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> exit_code;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// SimpleApp implements application-level callbacks for the browser process.</span></span><br><span class=\"line\">  <span class=\"comment\">// It will create the first browser instance in OnContextInitialized() after</span></span><br><span class=\"line\">  <span class=\"comment\">// CEF has initialized.</span></span><br><span class=\"line\">  <span class=\"function\">CefRefPtr&lt;SimpleApp&gt; <span class=\"title\">app</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleApp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Initialize CEF.</span></span><br><span class=\"line\">  CefInitialize(main_args, settings, app.<span class=\"built_in\">get</span>(), sandbox_info);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Run the CEF message loop. This will block until CefQuitMessageLoop() is</span></span><br><span class=\"line\">  <span class=\"comment\">// called.</span></span><br><span class=\"line\">  CefRunMessageLoop();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Shut down CEF.</span></span><br><span class=\"line\">  CefShutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>首先第一个重要点是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">// CEF applications have multiple sub-processes (render, plugin, GPU, etc)</span></span><br><span class=\"line\">   <span class=\"comment\">// that share the same executable. This function checks the command-line and,</span></span><br><span class=\"line\">   <span class=\"comment\">// if this is a sub-process, executes the appropriate logic.    </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> exit_code = CefExecuteProcess(main_args, <span class=\"literal\">nullptr</span>, sandbox_info);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (exit_code &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// The sub-process has completed so return here.</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> exit_code;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码看起来有点奇怪，对于英文的翻译如下：</p>\n<blockquote>\n<p>CEF应用程序会创建多个子进程（渲染render，插件plugin，GPU处理，等等）但是会共用一个可执行程序。以下的函数会检查命令行并且，如果确认是一个子进程，那么会执行相关的逻辑。</p>\n</blockquote>\n<p>然后，我们查看该函数：<code>CefExecuteProcess</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// This function should be called from the application entry point function to</span></span><br><span class=\"line\"><span class=\"comment\">// execute a secondary process. It can be used to run secondary processes from</span></span><br><span class=\"line\"><span class=\"comment\">// the browser client executable (default behavior) or from a separate</span></span><br><span class=\"line\"><span class=\"comment\">// executable specified by the CefSettings.browser_subprocess_path value. If</span></span><br><span class=\"line\"><span class=\"comment\">// called for the browser process (identified by no &quot;type&quot; command-line value)</span></span><br><span class=\"line\"><span class=\"comment\">// it will return immediately with a value of -1. If called for a recognized</span></span><br><span class=\"line\"><span class=\"comment\">// secondary process it will block until the process should exit and then return</span></span><br><span class=\"line\"><span class=\"comment\">// the process exit code. The |application| parameter may be empty. The</span></span><br><span class=\"line\"><span class=\"comment\">// |windows_sandbox_info| parameter is only used on Windows and may be NULL (see</span></span><br><span class=\"line\"><span class=\"comment\">// cef_sandbox_win.h for details).</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/*--cef(api_hash_check,optional_param=application,</span></span><br><span class=\"line\"><span class=\"comment\">        optional_param=windows_sandbox_info)--*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CefExecuteProcess</span><span class=\"params\">(<span class=\"keyword\">const</span> CefMainArgs&amp; args,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      CefRefPtr&lt;CefApp&gt; application,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">void</span>* windows_sandbox_info)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>翻译：</p>\n<blockquote>\n<p>该函数应当在应用程序的入口函数处被调用，用以执行一个子进程。它可以用于执行一个可执行程序来启动一个子进程，该可执行程序可以是当前的浏览器客户端可执行程序（默认行为）或是通过设置CefSettings.browser_subprocess_path指定路径的可执行程序。如果被调用用于浏览器进程（在启动命令行中没有”type”参数），该函数会立刻返回<code>-1</code>。如果被调用时识别为子进程，该函数将会阻塞直到子进程退出并且返回子进程退出的返回码。<code>application</code>参数可以为空（null）。<code>windows_sandbox_info</code>参数只能在Windows上使用或设置为NULL（详见cef_sandbox_win.h）</p>\n</blockquote>\n<p>从这段话我们不难推断出，CEF在以多进程架构下启动的时候，会多次启动自身可执行程序。启动的时候，会通过命令行参数传入某些标识，由<code>CefExecuteProcess</code>内部进行判断。如果是主进程，则该函数立刻返回-1，程序会继续执行下去，那么后续继续运行的代码全部都运行在主进程中；如果是子进程（渲染进程等），那么该函数会阻塞住，直到子进程结束后，该函数会返回一个大于等于0的值，并在main函数直接返回，进而退出。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/CefExecuteProcess-flow.jpg\" alt=\"\"></p>\n<p>对CefExecuteProcess分析就到这里，细节可以阅读<a href=\"https://bitbucket.org/chromiumembedded/cef/wiki/GeneralUsage.md#markdown-header-entry-point-function\">官方文档</a>，我们继续后续的代码分析：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SimpleApp implements application-level callbacks for the browser process.</span></span><br><span class=\"line\"><span class=\"comment\">// It will create the first browser instance in OnContextInitialized() after</span></span><br><span class=\"line\"><span class=\"comment\">// CEF has initialized.</span></span><br><span class=\"line\"><span class=\"function\">CefRefPtr&lt;SimpleApp&gt; <span class=\"title\">app</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleApp)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>注释翻译如下</p>\n<blockquote>\n<p>SimpleApp实现了对于浏览器进程在应用级别的回调。该实例CEF初始化后（initialized），在OnContextInitialized中会创建第一个browser实例</p>\n</blockquote>\n<p>查看SimpleApp的声明，发现该类继承了CefApp：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SimpleApp : public CefApp, public CefBrowserProcessHandler &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">  SimpleApp();</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是，我们迎来了第一个重要的类：CefApp。</p>\n<h2 id=\"CefApp\"><a href=\"#CefApp\" class=\"headerlink\" title=\"CefApp\"></a>CefApp</h2><p>CefApp在官方文档中，就写了一句话介绍：</p>\n<blockquote>\n<p>The <a href=\"http://magpcss.org/ceforum/apidocs3/projects/(default\">CefApp</a>/CefApp.html) interface provides access to process-specific callbacks.</p>\n<p>CefApp接口提供了指定进程的回调访问。</p>\n</blockquote>\n<p>本人一开始看到CefApp时，想到上面提到的CEF的多进程架构，结合后文还会提到的CefClient，以为所谓CefApp就是指浏览器进程，CefClient就对应其他的进程（一个App对应多个Client，多么的自然的理解），<strong>然而这样错误的理解</strong>，让本人在阅读代码的时候走了很大的弯路。</p>\n<p>首先，我们看一下CefApp的头文件声明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CefApp</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> CefBaseRefCounted &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnBeforeCommandLineProcessing</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">const</span> CefString&amp; process_type,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CefRefPtr&lt;CefCommandLine&gt; command_line)</span> </span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnRegisterCustomSchemes</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CefRawPtr&lt;CefSchemeRegistrar&gt; registrar)</span> </span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefResourceBundleHandler&gt; <span class=\"title\">GetResourceBundleHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefBrowserProcessHandler&gt; <span class=\"title\">GetBrowserProcessHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefRenderProcessHandler&gt; <span class=\"title\">GetRenderProcessHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>先看其中有两个本文讨论的重点方法：<code>GetBrowserProcessHandler</code>、<code>GetRenderProcessHandler</code>。它们的文档注释如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// Return the handler for functionality specific to the browser process. This</span></span><br><span class=\"line\"><span class=\"comment\">// method is called on multiple threads in the browser process.</span></span><br><span class=\"line\"><span class=\"comment\">// 返回浏览器进程特定功能的处理程序。在浏览器进程中的多个线程上调用此方法。</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefBrowserProcessHandler&gt; <span class=\"title\">GetBrowserProcessHandler</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">///</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// Return the handler for functionality specific to the render process. This</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// method is called on the render process main thread.</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 返回渲染进程特定功能的处理程序。在渲染进程中的主线程上调用此方法。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">///</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefRenderProcessHandler&gt; <span class=\"title\">GetRenderProcessHandler</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>读者看到这些注释可能会疑问：为什么注释中一会儿说在浏览器进程中一会儿又说在渲染进程中？难道这个类的实例还会在多个进程中使用吗？对也不对。这个类的实例确实会在浏览器进程和渲染进程中使用，但是我们又知道，两个进程之间的资源是不共享的，包括类实例，所以在浏览器进程运行的过程中，会使用到CefApp的某个实例化对象，而在渲染进程的运行过程中，又会使用到CefApp另一个实例化对象，它们都是CefApp子类的实例，但一定不是同一个实例对象。</p>\n<p>我们可以这样理解：一个CefApp对应了一个进程，而一个进程可以是浏览器进程（Browser Process），可以是渲染进程（Renderer Process）。因此，CefApp提供了GetBrowserProcessHandler和GetRendererProcessHandler来分别在相关进程中获取对应的handler。</p>\n<p>这两个方法的实现由我们来决定，即我们可以通过编程方式来返回handler，<strong>但这两个方法不会由我们客户端代码进行调用</strong>，而是CEF在运行过程中，由CEF在某个时刻来回调这两个方法。所以，这里虽然写了两个GetXXXProcessHandler，但在<strong>浏览器进程</strong>和<strong>渲染进程</strong>中只会<strong>分别</strong>调用GetBrowserProcessHandler和GetRendererProcessHandler。</p>\n<p>按照程序运行的角度讲，当浏览器进程运行的时候，CEF框架就会在某个时候调用CefApp::GetBrowserProcessHandler获得由我们定义的BrowserProcessHandler实例，这个实例会在适当的时候调用它提供的一些方法（后文介绍有哪些方法）；当渲染进程运行的时候，CEF框架就会在某个时候调用CefApp::GetRendererProcessHandler得到我们定义的RendererProcessHandler实例，然后在适当的时候调用RenererProcessHandler中的一些方法（后文介绍有哪些方法）。</p>\n<p>在cefsimple的示例代码中只有一个SimpleApp是继承的CefApp，这个类还继承了CefBrowserHandler，表明自身是同时也是CefBrowserHandler，这样实现的<code>GetBrowserProcessHandler</code>就返回自身。那么CEF是如何将我们的CefApp实例关联到CEF运行中的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SimpleApp implements application-level callbacks for the browser process.</span></span><br><span class=\"line\"><span class=\"comment\">// It will create the first browser instance in OnContextInitialized() after</span></span><br><span class=\"line\"><span class=\"comment\">// CEF has initialized.</span></span><br><span class=\"line\"><span class=\"function\">CefRefPtr&lt;SimpleApp&gt; <span class=\"title\">app</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleApp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initialize CEF.</span></span><br><span class=\"line\">CefInitialize(main_args, settings, app.<span class=\"built_in\">get</span>(), sandbox_info);</span><br></pre></td></tr></table></figure>\n<p>注意CefInitialize中的<code>app.get()</code>参数，就是将我们的CefApp关联到CEF的运行中的。那么，有些读者会有疑问，在示例代码中，只看到我们创建的SimpleApp类继承了CefApp，并通过<code>GetBrowserProcessHandler</code>返回自身来表明是一个浏览器进程的回调实例，并没有看到体现渲染进程的代码呢？确实，cefsimple作为helloworld级别的代码，没有体现这一点。在cefclient示例代码中（更高阶的CEF示例，也更复杂），你会看到：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cefclient-app-browser.jpg\" alt=\"\"></p>\n<p>上图是浏览器进程CefApp子类ClientAppBrowser（这里的”Client“是cefclient示例代码的“client”，请勿和下文的CefClient类混淆）。</p>\n<p>同时你还能找到一个CefApp子类ClientAppRenderer：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cefclient-app-renderer.jpg\" alt=\"\"></p>\n<p>你甚至还能找到一个名为ClientAppOther的CefApp子类：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cefclient-app-other.jpg\" alt=\"\"></p>\n<p>那么它们在哪儿被使用到呢？</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/where-use-CefApp.jpg\" alt=\"\"></p>\n<p>看到这里，我相信绝大多数的读者应该能够理解我所说的CefApp代表的是一个进程的抽象了。这块的大体流程是，通过一个工具函数<code>GetProcessType</code>从命令行中解析<code>--type=xxx</code>（浏览器进程没有这个命令参数）来判断进程的类型，然后实例化对应的CefApp子类，最后通过<code>CefExecuteProcess</code>来运行进程。</p>\n<p>在介绍了CefApp的基本概念以后，我们可以继续分析<code>SimpleApp</code>。</p>\n<p>通过上文，我们知道SimpleApp是CefApp子类，并且通过只会在浏览器进程中，会使用到该类的实例，因为实现了接口<code>CefBrowserProcessHandler</code>，并且有如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CefApp methods:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefBrowserProcessHandler&gt; <span class=\"title\">GetBrowserProcessHandler</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    OVERRIDE </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在CEF中，作为<code>CefBrowserProcessHandler</code>，有哪些回调可以供我们定制呢？下面是头文件声明，并且我也写了下概要注释：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CefBrowserProcessHandler</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> CefBaseRefCounted &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Cookie处理定制化</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetCookieableSchemes</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;CefString&gt;&amp; schemes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    <span class=\"keyword\">bool</span>&amp; include_defaults)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在CEF上下文初始化后，在浏览器进程UI线程中进行调用。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnContextInitialized</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可定制化处理子进程启动时的命令行参数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnBeforeChildProcessLaunch</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CefRefPtr&lt;CefCommandLine&gt; command_line)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 打印处理</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefPrintHandler&gt; <span class=\"title\">GetPrintHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义消息循环的时候，消息循环的频率</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnScheduleMessagePumpWork</span><span class=\"params\">(int64 delay_ms)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取默认的CefClient</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefClient&gt; <span class=\"title\">GetDefaultClient</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过阅读该Handler的头文件以及每个函数的调用说明，我们继续阅读在<code>SimpleApp::OnContextInitialized</code>这个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleApp::OnContextInitialized</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">  CefRefPtr&lt;CefCommandLine&gt; command_line =</span><br><span class=\"line\">      CefCommandLine::GetGlobalCommandLine();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> enable_chrome_runtime =</span><br><span class=\"line\">      command_line-&gt;HasSwitch(<span class=\"string\">&quot;enable-chrome-runtime&quot;</span>); <span class=\"comment\">// 是否启用chrome运行时</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(OS_WIN) || defined(OS_LINUX)</span></span><br><span class=\"line\">    <span class=\"comment\">// Create the browser using the Views framework if &quot;--use-views&quot; is specified</span></span><br><span class=\"line\">    <span class=\"comment\">// via the command-line. Otherwise, create the browser using the native</span></span><br><span class=\"line\">    <span class=\"comment\">// platform framework. The Views framework is currently only supported on</span></span><br><span class=\"line\">    <span class=\"comment\">// Windows and Linux.</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果命令行中指定了&quot;--use-views&quot;，那么使用CEF自己的视图框架（Views framework）</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则使用操作系统原生API。视图框架目前只支持Windows和Linux。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views = command_line-&gt;HasSwitch(<span class=\"string\">&quot;use-views&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// SimpleHandler implements browser-level callbacks.</span></span><br><span class=\"line\">  <span class=\"function\">CefRefPtr&lt;SimpleHandler&gt; <span class=\"title\">handler</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleHandler(use_views))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Specify CEF browser settings here.</span></span><br><span class=\"line\">  CefBrowserSettings browser_settings;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> url;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Check if a &quot;--url=&quot; value was provided via the command-line. If so, use</span></span><br><span class=\"line\">  <span class=\"comment\">// that instead of the default URL.</span></span><br><span class=\"line\">  url = command_line-&gt;GetSwitchValue(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (url.empty())</span><br><span class=\"line\">    url = <span class=\"string\">&quot;http://www.google.com&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (use_views &amp;&amp; !enable_chrome_runtime) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the BrowserView.</span></span><br><span class=\"line\">    CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(</span><br><span class=\"line\">        handler, url, browser_settings, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> SimpleBrowserViewDelegate());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Create the Window. It will show itself after creation.</span></span><br><span class=\"line\">    CefWindow::CreateTopLevelWindow(<span class=\"keyword\">new</span> SimpleWindowDelegate(browser_view));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Information used when creating the native window.</span></span><br><span class=\"line\">    CefWindowInfo window_info;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(OS_WIN)</span></span><br><span class=\"line\">    <span class=\"comment\">// On Windows we need to specify certain flags that will be passed to</span></span><br><span class=\"line\">    <span class=\"comment\">// CreateWindowEx().</span></span><br><span class=\"line\">    window_info.SetAsPopup(<span class=\"literal\">NULL</span>, <span class=\"string\">&quot;cefsimple&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Create the first browser window.</span></span><br><span class=\"line\">    CefBrowserHost::CreateBrowser(window_info, handler, url, browser_settings,</span><br><span class=\"line\">                                  <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这段代码，我整理了如下流程，方便读者对照阅读：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cef-SimpleApp-OnContextInitialized.jpg\" alt=\"\"></p>\n<p>在这个流程中，最关键的3个部分被我用红色标记出来：</p>\n<ol>\n<li>SimpleHandler（CefClient子类）；</li>\n<li>使用CEF的窗体视图框架创建CefBrowserView和CefWindow；</li>\n<li>使用操作系统原生API构建窗体。</li>\n</ol>\n<p>整个过程中会创建CefClient的子类实例，然后通过CEF提供的API来将CefClient和窗体结合在一起。</p>\n<p><strong>对于使用CEF自己的视图框架，有如下的步骤：</strong></p>\n<ol>\n<li>首先是调用CefBrowserView::CreateBrowserView得到CefBrowserView实例，这个过程会把CefClient实例和View对象通过API绑定。</li>\n<li>调用CefWindow::CreateTopLevelWindow，传入CefBrowserView实例来创建窗体。</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cef-use-CEF-Views.jpg\" alt=\"\"></p>\n<p><strong>对于使用操作系统原生API创建浏览器窗体，主要是如下步骤：</strong></p>\n<ol>\n<li>使用CefWindowInfo设置窗体句柄</li>\n<li>调用CefBrowserHost::CreateBrowser将对应窗体句柄的窗体和CefClient绑定起来</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cef-use-OS-native-Views.jpg\" alt=\"\"></p>\n<p>当然，上述两个窗体的创建过程涉及到CEF的窗体模块，我们不在这里细说，但是两个流程都离不开一个重要的类：CefClient，它具体是什么呢？接下来，我们将对CefClient进行介绍，并对SimpleHandler这个类（CefClient子类）进行一定的源码分析。</p>\n<h2 id=\"CefClient\"><a href=\"#CefClient\" class=\"headerlink\" title=\"CefClient\"></a>CefClient</h2><p>在官方的文档，描述了CefClien的概念：</p>\n<blockquote>\n<p>The <a href=\"http://magpcss.org/ceforum/apidocs3/projects/(default\">CefClient</a>/CefClient.html) interface provides access to browser-instance-specific callbacks. A single CefClient instance can be shared among any number of browsers. Important callbacks include:</p>\n<p>CefClient接口提供对特定于浏览器实例的回调的访问。一个CefClient实例可以在任意数量的浏览器之间共享。重要的回调包括：</p>\n<ul>\n<li>Handlers for things like browser life span, context menus, dialogs, display notifications, drag events, focus events, keyboard events and more. The majority of handlers are optional. See the documentation in cef_client.h for the side effects, if any, of not implementing a specific handler.</li>\n<li>所有的Handler，例如浏览器的生命周期，上下文菜单，对话框，显示通知，拖动事件，焦点事件，键盘事件等。大多数处理程序是可选的。请参阅cef_client.h中的文档，以了解不实施特定处理程序的副作用（如果有）。</li>\n<li><strong>OnProcessMessageReceived</strong> which is called when an IPC message is received from the render process. See the “Inter-Process Communication” section for more information.</li>\n<li>从渲染过程中接收到IPC消息时调用的OnProcessMessageReceived。有关更多信息，请参见“进程间通信”部分。</li>\n</ul>\n</blockquote>\n<p>首先需要解释一下什么什么是特定浏览器实例，实际上，指的是以下过程产生的浏览器实例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(</span><br><span class=\"line\">        handler, url, browser_settings, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> SimpleBrowserViewDelegate());</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">    CefBrowserHost::CreateBrowser(window_info, handler, url, browser_settings,</span><br><span class=\"line\">                                  <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br></pre></td></tr></table></figure>\n<p>通过上述两种方式创建的浏览器实例，是一个概念上的实例，并不是指你能看得到的浏览器的窗口，窗口只是浏览器实例的宿主而已。而浏览器中发生的事件，例如：生命周期的变化，对话框等，都只会通过CefClient中返回的各种类型Handler以及这些Handler接口实例提供的方法回调。</p>\n<p>下面时CefClient的声明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CefClient</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> CefBaseRefCounted &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefAudioHandler&gt; <span class=\"title\">GetAudioHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefContextMenuHandler&gt; <span class=\"title\">GetContextMenuHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDialogHandler&gt; <span class=\"title\">GetDialogHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDisplayHandler&gt; <span class=\"title\">GetDisplayHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDownloadHandler&gt; <span class=\"title\">GetDownloadHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDragHandler&gt; <span class=\"title\">GetDragHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...... 还有很多的Handler</span></span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个CefClient提供了很多<code>GetXXXHandler</code>方法，这些方法会在合适的时候，被CEF调用以得到对应的Handler，然后再调用返回的Handler中的方法。例如，HTML页面中的Title发生变化的时候，就会调用<code>CefClient::CefDisplayHandler()</code>得到一个CefDisplayHandler实例，然后再调用其中的<code>CefDisplayHandler::OnTitleChange</code>，而这些过程不是我们调用的，而是CEF框架完成的。只是具体的实现有我们客户端代码编写。</p>\n<p>那么现在思考一下，为什么会有这个CefClient呢？在本人看来主要是如下的理由：</p>\n<p>在CefClient中各种回调的事件，本质上发生的地方是渲染进程。因为每当一个浏览器实例（不是浏览器进程）创建的时候，会有一个对应的渲染进程创建（也可能由于配置，而共用一个，这里先认为默认多个一对一）。渲染进程中发生的各种V8事件、下载事件，显示事件等触发后，会通过<strong>进程间通讯</strong>给到浏览器进程，然后在浏览器进程中找到与之相关的CefClient，然后从CefClient中找到对应的Handler，回调Handler对应的方法。</p>\n<p>也就是说，将在渲染进程发生的事件，用在浏览器进程中的CefClient一定的抽象映射，而不是直接在浏览器进程处理器中进行，因为一个浏览器进程可能会创建多个渲染进程，让CefClient作为中间层避免耦合。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/CefClientAndRenderer.jpg\" alt=\"\"></p>\n<p>当然，文档也为我们指出，CefClient实例与浏览器实例可以不是一一对应的，多个浏览器实例可以共享一个CefClient，如此一来我们也可以总结关于CefClient的一点：<strong>非必要情况，不要编写具有状态的CefClient</strong>。</p>\n<p>至此，我们通过对Demo源码入手，对CefApp和CefClient已经有了一个整体的认识，读者可以阅读官方文档来更加深入的了解：<a href=\"https://bitbucket.org/chromiumembedded/cef/wiki/GeneralUsage.md#markdown-header-application-structure\">官方文档</a>。</p>\n","categories":[],"tags":["CEF"]},{"title":"Windows下node-gyp查找VS安装路径简单解析","url":"http://compilemind.com/2021/03/27/2021-03-27-Windows下node-gyp查找VS安装路径简单解析/","content":"<p>node-gyp的作用我已经不想赘述了，这里给一个我之前文章的链接：<a href=\"https://www.cnblogs.com/w4ngzhen/p/14086497.html\">cnblogs看这里</a>，<a href=\"https://zhuanlan.zhihu.com/p/330468774\">知乎看这里</a>。本文主要从源码入手，介绍node-gyp查找VisualStudio的过程</p>\n<a id=\"more\"></a>\n<p>为了方便我们研究node-gyp的源码，我们随意创建一个node项目，然后我们npm install node-gyp，安装node-gyp这个包来开始我们源码探索之路吧。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E:\\Projects\\node<span class=\"literal\">-gyp</span><span class=\"literal\">-demo</span>&gt; npm init</span><br><span class=\"line\">...</span><br><span class=\"line\">package name: (gyp<span class=\"literal\">-demo</span>)</span><br><span class=\"line\">version: (<span class=\"number\">1.0</span>.<span class=\"number\">0</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install node-gyp@latest // 安装最新的node-gyp</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在项目/node_modules/node-gyp中，已经有了我们需要的node-gyp的js脚本代码：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/gyp-lib-dir-position.jpg\" alt=\"\"></p>\n<p>那么，我们应该怎么入手呢？这里需要再次提到node-gyp的处理过程，主要分为两个步骤：</p>\n<ol>\n<li>configure</li>\n</ol>\n<p>gyp首先根据C/C++源码目录下的binding.gyp文件+操作系统（Windows、macOS以及Linux）+编译构建工具（Windows下的VS，macOS以及Linux下的make）来决定生成什么样的项目结构（Windows下的sln以及vcxproj、macOS以及Linux下的make项目）这一步是<em>configure</em>配置过程，不会进行源码的编译，仅仅是生成能够作为对应平台下对应编译工具输入的项目结构。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/node-gyp-configure-flow.jpg\" alt=\"\"></p>\n<ol>\n<li>build</li>\n</ol>\n<p>生成项目结构以后，执行build过程调用对应的编译工具完成编译任务。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/node-gyp-build-flow.jpg\" alt=\"\"></p>\n<p>所以，我们首先查看lib/configure.js文件，试着从源码中探索一下。进入configure.js，一下就可以看到我们期望的东西（图片顶部显示了js代码位置）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/gyp-configure-portal-code.jpg\" alt=\"\"></p>\n<p>如果当前进程平台是<code>win32</code>（Windows操作系统标识），则会引入模块<code>find-visualstudio</code>。暂时停止阅读configure.js的代码，直接上我们的主角：<code>find-visualstudio.js</code></p>\n<h2 id=\"find-visualstudio-js\"><a href=\"#find-visualstudio-js\" class=\"headerlink\" title=\"find-visualstudio.js\"></a>find-visualstudio.js</h2><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/visualStudioFinder-class-def.jpg\" alt=\"\"></p>\n<p>在该文件中定义了一个名为<code>VisualStudioFinder</code>的类，查找的过程就是执行创建该类的一个实例，并调用实例的一个名为<code>findVisualStudio</code>的方法。该方法被定义在该类的原型里：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/method-the-findVisualStudio.png\" alt=\"\"></p>\n<p>对于该函数来说，主要分为了三个步骤：</p>\n<ol>\n<li>对于参数msvs_version的处理</li>\n<li>对于环境变量VSINSTALLDIR的处理</li>\n<li>查找各个版本的VS</li>\n</ol>\n<p>对于步骤1和2，我们暂时不进行解析，主要解析步骤3。因为绝大多数开发者就卡在这个步骤，导致安装需要原生编译的node模块失败。对于步骤3来说，我们不难看出处理的过程是优先查找本地的vs2017以及更高的版本，然后是vs2015，最后是vs2013，所以开发者Windows机器上没有安装VS或者是不在源码中支持的范围都一定会报错，提示VS找不到。我们首先解析<code>findVisualStudio2017OrNewer</code>这个函数，然后解析<code>findVisualStudio2015</code>和<code>findVisualStudio2013</code>，对于后两个，实际上最终都是相同的逻辑，后面会提到。</p>\n<h3 id=\"findVisualStudio2017OrNewer\"><a href=\"#findVisualStudio2017OrNewer\" class=\"headerlink\" title=\"findVisualStudio2017OrNewer\"></a>findVisualStudio2017OrNewer</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/func-findVisualStudio2017OrNewer.png\" alt=\"\"></p>\n<p>该函数的签名表示，这个函数是通过调用PowerShell脚本来获取关于VS2017或是更高版本VS的安装信息。</p>\n<p>那么这段代码的运行情况到底如何呢？我们将该段代码单独拿出来，并将<code>Find-VisualStudio.cs</code>拷贝到运行目录下来Debug它。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/mock-findVisualStudio2017OrNewer.png\" alt=\"\"></p>\n<p>上图中，我模拟了node-gyp中查询VS2017以上版本的函数，通过Debug方式断点调试：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/use-powershell.jpg\" alt=\"\"></p>\n<p><code>ps</code>变量值为：<code>C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe</code>，即为Windows下对应的最初版本的PowerShell。cs文件不再赘述，我们也不对CSharp代码解读了。代码的最后就是执行弄得的chile_process模块中的<code>execFile</code>函数，通过传入可执行程序的完整路径已经执行参数，完成外部程序调用。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/execFile-stdout.jpg\" alt=\"\"></p>\n<p>而在这一步当中，如果执行出现了异常就会导致node-gyp的执行过程出现异常，进而导致需要原生编译的模块无法完成安装等。为了方便开发人员进行在Windows上查找VS2017以及以上版本，我把这段代码和CSharp代码提取出来，放在了<a href=\"https://github.com/w4ngzhen/node-gyp-find-vs-check\">github仓库（w4ngzhen/node-gyp-find-vs-check）</a>，读者如果出现了问题，可以直接下载脚本和CSharp代码进行环境的确认。</p>\n<p>当然，有些读者的机器还是VS2015或者VS2013等版本，我们继续分析。</p>\n<h3 id=\"findVisualStudio2015-2013\"><a href=\"#findVisualStudio2015-2013\" class=\"headerlink\" title=\"findVisualStudio2015/2013\"></a>findVisualStudio2015/2013</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/method-findVs2015Or2013.jpg\" alt=\"\"></p>\n<p>通过源码可以知道，最终都调用了方法：<code>findOldVS</code>，并且还知道，nodejs的主版本大于等于9时，根本不会查找VS了。接下来我们查看方法<code>findOldVs</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/method-findOldVS.jpg\" alt=\"\"></p>\n<p>对于该段代码，其实一点也不难理解，就是根据注册表上对应的键去查找的VS的安装路径（PS：好像又学习到了VS的安装路径可以从注册表里面查看呢！）对于该段代码，本人不提供demo代码帮助查询了。有兴趣的读者可以自己提取代码，模拟调用。</p>\n","categories":[],"tags":["node-gyp"]},{"title":"Windows下的程序及热键监视神器——Spy++","url":"http://compilemind.com/2021/03/09/2021-03-09-Windows下的程序及热键监视神器——Spy++/","content":"<h1 id=\"Windows下的程序及热键监视神器——Spy\"><a href=\"#Windows下的程序及热键监视神器——Spy\" class=\"headerlink\" title=\"Windows下的程序及热键监视神器——Spy++\"></a>Windows下的程序及热键监视神器——Spy++</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在使用Windows的时候，偶尔会发现某些应用程序的热键不生效了；又或是桌面弹出了弹框却并不知道这个弹框来自何处。例如，本人最近使用Vim的时候，发现创建分屏后，无法使用<code>ctrl+w</code>快捷键完成切屏操作，一开始以为是Vim配置出现了问题，后来发现就连Edge浏览器的<code>ctrl+w</code>关闭页面都无法完成，仔细一想才觉得是热键被占用了，这时候就要祭出Windows下一款简单的神器Spy++。</p>\n<a id=\"more\"></a>\n<h2 id=\"如何获取Spy\"><a href=\"#如何获取Spy\" class=\"headerlink\" title=\"如何获取Spy++\"></a>如何获取Spy++</h2><h3 id=\"Visual-Studio\"><a href=\"#Visual-Studio\" class=\"headerlink\" title=\"Visual Studio\"></a>Visual Studio</h3><p>如果你下载过VS2019（其他版本应该同理），那么你可以在<code>VS的安装目录/Common7/Tools/</code>中找到一个名叫<code>spyxx.exe</code>以及<code>spyxx_amd64.exe</code>，如果你的机器是64位版本最好使用后者（PS：spyxx中的xx即为倒着的加号++）。</p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/visualstudio/debugger/spy-increment-help?view=vs-2019\">Spy++ 帮助 - Visual Studio | Microsoft Docs</a></p>\n<h3 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h3><p>当然，如果你没有安装VS或是其他版本的VS没有spy++，已经有热心开发者把不同版本的spy++上传到了仓库。</p>\n<p><a href=\"https://github.com/westoncampbell/SpyPlusPlus\">GitHub - westoncampbell/SpyPlusPlus: Microsoft Spy++</a></p>\n<p>你只需要clone仓库下载即可。</p>\n<h3 id=\"本人提供度盘\"><a href=\"#本人提供度盘\" class=\"headerlink\" title=\"本人提供度盘\"></a>本人提供度盘</h3><p>如果你是一位普通的Windows使用者，对上面的方式都不怎么会，本人已经将VS2019中的spy++传到了度盘，下载即可使用。</p>\n<p>链接：<a href=\"https://pan.baidu.com/s/1CwLPltBelCJVtbyFQObA0w\">https://pan.baidu.com/s/1CwLPltBelCJVtbyFQObA0w</a><br>提取码：cdn7 </p>\n<h2 id=\"如何使用Spy\"><a href=\"#如何使用Spy\" class=\"headerlink\" title=\"如何使用Spy++\"></a>如何使用Spy++</h2><h3 id=\"热键占用检测\"><a href=\"#热键占用检测\" class=\"headerlink\" title=\"热键占用检测\"></a>热键占用检测</h3><p>Spy++能够对当前的热键占用进行检测并给出占用该热键的应用程序。具体做法如下：</p>\n<p>1、打开Spy++，选择<strong>日志消息（log message）</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/log-message.jpg\" alt=\"\"></p>\n<p>2、选择<strong>All Windows in System</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/set-all-windows-in-system.jpg\" alt=\"\"></p>\n<p>这一步的目的是保证拦截到当前Windows系统中的所有窗体的有关消息</p>\n<p>3、进入message页签，筛选热键消息</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/filter-message.jpg\" alt=\"\"></p>\n<p>4、保存配置后，会看到界面有一个空白窗口，然后按下快捷键，会发现窗口中会出现对应的热键消息</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/message.gif\" alt=\"\"></p>\n<p>本例中，本人使用了<code>alt+space</code>快捷键呼出了uTools（另一款本人特别喜欢的工具）。通过Spy++监听到了快捷键的按下。我们可以右键该条消息，查看Properties检查该热键是由哪个程序捕获的：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/prop1.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/prop2.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/prop3.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/prop4.jpg\" alt=\"\"></p>\n<h3 id=\"窗体所属程序检测\"><a href=\"#窗体所属程序检测\" class=\"headerlink\" title=\"窗体所属程序检测\"></a>窗体所属程序检测</h3><p>除了上述Spy++能够监听Windows下的事件消息外，它还能获取Windows下任意窗口的句柄信息，进而获取到该窗口所属的应用程序。</p>\n<p>1、Spy菜单中选择<code>Find Window</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/find-window.jpg\" alt=\"\"></p>\n<p>2、拖动FinderTool到你想要识别的窗口上，松开它。剩下的请看下面的gif。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/how-to-find-window.gif\" alt=\"\"></p>\n","categories":[],"tags":["Windows"]},{"title":"iframe、SameSite与CEF","url":"http://compilemind.com/2021/03/08/2021-03-08-iframe、SameSite与CEF/","content":"<h1 id=\"iframe、SameSite与CEF\"><a href=\"#iframe、SameSite与CEF\" class=\"headerlink\" title=\"iframe、SameSite与CEF\"></a>iframe、SameSite与CEF</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>本人使用CEF（或是Chrome）来加载开发的前端页面，其中使用iframe嵌入了第三方页面，在第三方页面中需要发送cookie到后端，然而加载会报错，第三方页面后端无法接受到Cookie。</p>\n<a id=\"more\"></a>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>由于CEF（Chrome内核）的安全策略，在51版本以前、80版本以后，绝大多数情况下是禁止嵌入的iframe提交Cookie的（下文会列出哪些禁止），所以需要浏览器配置策略来允许iframe提交Cookie，这个策略就是SameSite。</p>\n<p>SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。<br>SameSite 可以有下面三种值：</p>\n<ul>\n<li><strong>Strict</strong>（严格的）。仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</li>\n<li><strong>Lax</strong>（松懈的）。允许部分第三方请求携带 Cookie。</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">请求类型</th>\n<th style=\"text-align:center\">示例</th>\n<th style=\"text-align:right\">正常情况</th>\n<th style=\"text-align:left\">Lax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">链接</td>\n<td style=\"text-align:center\"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">发送 Cookie</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">预加载</td>\n<td style=\"text-align:center\"><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">发送 Cookie</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GET 表单</td>\n<td style=\"text-align:center\"><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">发送 Cookie</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">POST 表单</td>\n<td style=\"text-align:center\"><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">不发送</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iframe</td>\n<td style=\"text-align:center\"><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">不发送</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AJAX</td>\n<td style=\"text-align:center\"><code>$.get(&quot;...&quot;)</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">不发送</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Image</td>\n<td style=\"text-align:center\"><code>&lt;img src=&quot;...&quot;&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">不发送</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><strong>None</strong>（无）。无论是否跨站都会发送 Cookie。</li>\n</ul>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"Chrome（或是基于Chromium的Edge）\"><a href=\"#Chrome（或是基于Chromium的Edge）\" class=\"headerlink\" title=\"Chrome（或是基于Chromium的Edge）\"></a>Chrome（或是基于Chromium的Edge）</h3><p>在基于Chrome中，可以进入如下的页面进行配置：</p>\n<ul>\n<li>地址栏输入：<code>chrome://flags/</code>（Edge中会自动转为<code>edge://</code>）</li>\n<li>找到<code>SameSite by default cookies</code>和<code>Cookies without SameSite must be secure</code></li>\n<li>将上面两项设置为 <code>Disable</code></li>\n</ul>\n<h3 id=\"CEF\"><a href=\"#CEF\" class=\"headerlink\" title=\"CEF\"></a>CEF</h3><p>上面的方法很通用，不过，对于CEF项目来说，并没有这个页面供我们配置。我们可以通过命令行形式传入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cef-app.exe（你的cef应用程序） --disable-features&#x3D;SameSiteByDefaultCookies</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html\">http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>\n","categories":[],"tags":["CEF"]},{"title":"Linux下Electron loadURL报错 ERR_FAILED Not allowed to load local resource","url":"http://compilemind.com/2021/02/24/2021-02-24-Linux下Electron loadURL报错 ERR_FAILED Not allowed to load local resource/","content":"<h1 id=\"Linux下Electron-loadURL报错-ERR-FAILED-2-Not-allowed-to-load-local-resource\"><a href=\"#Linux下Electron-loadURL报错-ERR-FAILED-2-Not-allowed-to-load-local-resource\" class=\"headerlink\" title=\"Linux下Electron loadURL报错 ERR_FAILED(-2) Not allowed to load local resource\"></a>Linux下Electron loadURL报错 ERR_FAILED(-2) Not allowed to load local resource</h1><p>Linux Electron打包后页面无法加载，报错：Not allowed to load local resource</p>\n<a id=\"more\"></a>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>使用electron-vue的时候，窗体创建后加载页面使用的是<code>loadURL</code>函数，并且传入的参数形如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`file://<span class=\"subst\">$&#123;__dirname&#125;</span>/index.html`</span></span><br></pre></td></tr></table></figure>\n<p>PS：在<strong>electron-vue</strong>中，编译打包后的<code>__dirname</code>是<code>asar所在绝对地址/dist/electron/</code>。</p>\n<p>编译打包后的Electron程序启动时候，发现在调用loadURL的时候会出现：ERR_FAILED(-2) 。</p>\n<p>遂临时启动DevTool窗口查看控制台输出，发现类似如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Not allowed to load local resource: file:&#x2F;&#x2F;XXXXXX&#x2F;app.asar&#x2F;dir1&#x2F;dir2&#x2F;index.html</span><br></pre></td></tr></table></figure>\n<h2 id=\"原因及方案\"><a href=\"#原因及方案\" class=\"headerlink\" title=\"原因及方案\"></a>原因及方案</h2><h3 id=\"1、文件并不存在于你的asar包中\"><a href=\"#1、文件并不存在于你的asar包中\" class=\"headerlink\" title=\"1、文件并不存在于你的asar包中\"></a>1、文件并不存在于你的asar包中</h3><p>处理方式：</p>\n<ol>\n<li>全局安装<code>npm install -g asar</code></li>\n<li>通过asar解压app.asar包，检查上述提到的file路径中是否存在你的index.html。</li>\n</ol>\n<h3 id=\"2、尝试禁用窗体参数中的webSercurity\"><a href=\"#2、尝试禁用窗体参数中的webSercurity\" class=\"headerlink\" title=\"2、尝试禁用窗体参数中的webSercurity\"></a>2、尝试禁用窗体参数中的<code>webSercurity</code></h3><p>处理方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  webPreferences: &#123;</span><br><span class=\"line\">    webSecurity: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、检查webpack配置中的-dirname，防止webpack处理’mock’\"><a href=\"#3、检查webpack配置中的-dirname，防止webpack处理’mock’\" class=\"headerlink\" title=\"3、检查webpack配置中的__dirname，防止webpack处理’mock’\"></a>3、检查webpack配置中的__dirname，防止webpack处理’mock’</h3><p>这一点主要是当上述<code>Not alloed to load local resource</code>提到的路径明显不正确时候，可以检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; webpack配置文件中的node节点，当打包的时候需要防止webpack处理</span><br><span class=\"line\">node: &#123;</span><br><span class=\"line\">  __dirname: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>webpack配置文件中的node节点，当打包的时候需要防止webpack处理<code>__dirname</code>，如果你使用了electron-vue脚手架应该不需要关心，因为你会看到如下的内容，已经帮你处理了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node: &#123;</span><br><span class=\"line\">  __dirname: process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;,</span><br><span class=\"line\">  __filename: process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、使用loadFile而不是loadURL\"><a href=\"#4、使用loadFile而不是loadURL\" class=\"headerlink\" title=\"4、使用loadFile而不是loadURL\"></a>4、使用loadFile而不是loadURL</h3><p>使用loadFile接口来加载本地的路径，loadFile(‘path/to/index.html’)，这个路径是以app.asar根路径为base的。例如，loadFile(‘dir_path1/dir_path2/index.html’)，那么你的index.html在app.asar是如下的结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.asar</span><br><span class=\"line\">|-dir_path1</span><br><span class=\"line\">  |-dir_path2</span><br><span class=\"line\">    |-index.html</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["electron"]},{"title":"从源码解析Electron的安装为什么这么慢","url":"http://compilemind.com/2021/02/01/2021-02-01-从源码解析Electron的安装为什么这么慢/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Electron作为一款跨平台的桌面应用端解决方案已经风靡全球。作为开发者，我们几乎不用关心与操作系统的交互，直接通过Web前端技术与Electron提供的API就可以完成桌面应用端的开发。</p>\n<p>然而，为什么国内使用Electron的踩坑文章数不胜数，主要原因是Electron为了支持跨平台，为不同的操作系统平台进行了适配，将chromium内核与node集成到了一起，屏蔽了底层操作系统的细节，所以在不同的平台上有着不同的二进制基座。在开发的过程中，我们必须要下载对应的平台的基座，才能正常开发。也就是说，我们<code>npm install electron -D</code>的时候，一定是下载了Electron的二进制基座的。那么这个下载的过程在哪里？为什么速度这么慢呢？本文将通过Electron的安装源码一一说明。</p>\n<a id=\"more\"></a>\n<h1 id=\"安装Electron\"><a href=\"#安装Electron\" class=\"headerlink\" title=\"安装Electron\"></a>安装Electron</h1><p>在安装之前，我们先模拟一下没有配置任何关于Electron二进制镜像的npm配置文件，在<code>~/.npmrc</code>里面，只有一些默认的配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ~&#x2F;.npmrc文件</span><br><span class=\"line\">registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class=\"line\">prefix&#x3D;D:\\Programs\\nodejs\\global_modules</span><br><span class=\"line\">cache&#x3D;D:\\Programs\\nodejs\\cache_modules</span><br><span class=\"line\">python&#x3D;D:\\Programs\\Python39\\python.exe</span><br></pre></td></tr></table></figure>\n<p>然后，创建一个名为<code>electron-install-example</code>的文件夹作为本此测试的Demo项目目录，并在<strong>进入</strong>该目录后执行<code>npm init</code>初始化node项目。</p>\n<p>最后，使用命令行安装Electron：<code>npm install electron -D</code>。在短暂的npm包安装后，我们会发现会卡在一个地方：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/electron-postinstall.jpg\" alt=\"\"></p>\n<p>这时候，很多开发者就会开始在网络上搜索：’安装Electron卡住’，并且也很容易得到解决方案：</p>\n<blockquote>\n<p>在<code>~/.npmrc</code>文件中，单独设置Electron的镜像<code>electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot;</code></p>\n</blockquote>\n<p>于是我们按照搜来的解决方案重新配置我们的<code>.npmrc</code>文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ~&#x2F;.npmrc文件</span><br><span class=\"line\">registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class=\"line\">prefix&#x3D;D:\\Programs\\nodejs\\global_modules</span><br><span class=\"line\">cache&#x3D;D:\\Programs\\nodejs\\cache_modules</span><br><span class=\"line\">python&#x3D;D:\\Programs\\Python39\\python.exe</span><br><span class=\"line\"># 单独设置Electron的镜像</span><br><span class=\"line\">electron_mirror&#x3D;&quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;electron&#x2F;&quot; </span><br></pre></td></tr></table></figure>\n<p>设置完成后，重新进行<code>npm install</code>，发现能够很快完成下载并继续开发。通过本文，我们深入细节，看看为什么Electron设置了单独的镜像后，就能够正常且快速完成下载安装。</p>\n<h1 id=\"深入下载细节\"><a href=\"#深入下载细节\" class=\"headerlink\" title=\"深入下载细节\"></a>深入下载细节</h1><p>进入<code>项目根目录下/node_modules/electron/</code>（后续除特殊情况外，提到的目录路径都是统一相对于项目根目录）目录中，查看package.json文件中的<strong>scripts</strong>脚本节点：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/electron-pkgjson.jpg\" alt=\"\"></p>\n<p>了解npm的朋友们知道，<code>postinstall</code>中的脚本会在npm包完成安装后执行。</p>\n<p>也就是说，<code>npm install -D electron</code>完成以后，会在<code>node_modules/electron</code>目录中立刻执行<code>node install.js</code>。所以，我们进一步查看install.js文件，看看它到底执行了什么。核心代码如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/download-electron-code.jpg\" alt=\"\"></p>\n<p>代码特别容易理解：在没有缓存文件的时候，会使用<code>@electron/get</code>提供的<code>downloadArtifact</code>函数，进行Electron二进制制品的下载。</p>\n<p>于是，我们又将目标转移到<code>@electron/get</code>。这是个什么东西呢？查询官方仓库：<a href=\"https://github.com/electron/get\">官方仓库</a>，就能够大概知道该工具的功能了：提供一定的参数来向远端下载文件。</p>\n<p>找到<code>@electron/get</code>的模块入口<code>node_modules/@electron/get/dist/cjs/index.js</code>，也很容易从中找到<code>downloadArtifact</code>的函数定义：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/where-is-downloadArtifact.jpg\" alt=\"\"></p>\n<p>该函数的文档：下载Electron发行制品，并且返回下载后的制品的绝对路径。而函数内部主要流程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/func-flow.jpg\" alt=\"\"></p>\n<ul>\n<li><p>解析要下载的制品对应的操作系统和平台。例如是Windows还是Linux，架构是x86还是AMD64。</p>\n</li>\n<li><p>解析要下载的制品的版本。</p>\n</li>\n<li><p>解析要下载的制品的具体文件名。例如要下载Windows下的64位的Electron制品，那么默认文件名称是：<code>electron-v11.0.2-win32-x64.zip</code></p>\n</li>\n<li><p>解析要下载的制品所在的远端URL是多少（与本文相关的重点）。</p>\n</li>\n<li>处理本地缓存。</li>\n</ul>\n<p>本文主要解析下载以及从本地缓存制品两个环节。</p>\n<h2 id=\"远端下载的URL\"><a href=\"#远端下载的URL\" class=\"headerlink\" title=\"远端下载的URL\"></a>远端下载的URL</h2><p>从上面的源码图中，我们会看到远端的URL来自于<code>artifact_utils_1.getArtifactRemoteURL(artifactDetails)</code>这个的返回，而该函数在<code>@electron/get/dist/cjs/artifact-utils.js</code>中进行定义：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/getArtifactRemoteURL.jpg\" alt=\"\"></p>\n<p>该函数的定义也不难，主要流程如下：解析得到<code>base</code>变量，解析得到<code>path</code>变量，解析得到<code>file</code>变量，组合为<code>$&#123;base&#125;$&#123;path&#125;/$&#123;file&#125;</code>。当然，你也可以在<code>mirrorOptions</code>中定义<code>resolveAssetURL</code>函数来返回自定义的地址。</p>\n<p>在上面的处理流程中，能够看到一个频繁出现的函数：<code>mirroVar</code>。该函数也在该文件中定义，其函数定义如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mirrorVar</span>(<span class=\"params\">name, options, defaultValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Convert camelCase to camel_case for env var reading</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> lowerName = name.replace(<span class=\"regexp\">/([a-z])([A-Z])/g</span>, <span class=\"function\">(<span class=\"params\">_, a, b</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;a&#125;</span>_<span class=\"subst\">$&#123;b&#125;</span>`</span>).toLowerCase();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (process.env[<span class=\"string\">`NPM_CONFIG_ELECTRON_<span class=\"subst\">$&#123;lowerName.toUpperCase()&#125;</span>`</span>] ||</span><br><span class=\"line\">        process.env[<span class=\"string\">`npm_config_electron_<span class=\"subst\">$&#123;lowerName&#125;</span>`</span>] ||</span><br><span class=\"line\">        process.env[<span class=\"string\">`npm_package_config_electron_<span class=\"subst\">$&#123;lowerName&#125;</span>`</span>] ||</span><br><span class=\"line\">        process.env[<span class=\"string\">`ELECTRON_<span class=\"subst\">$&#123;lowerName.toUpperCase()&#125;</span>`</span>] ||</span><br><span class=\"line\">        options[name] ||</span><br><span class=\"line\">        defaultValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数主要返回参数<code>name</code>相关的变量值，以<code>name = &#39;mirror&#39;</code>为例，获取过程为：</p>\n<p><code>customDir</code>进行下划线分割转换，得到<code>const lowerName = &#39;mirror&#39;</code>（name为’customDir’则转换为’custom_dir’）。</p>\n<p>依次检查如下环境变量值：</p>\n<ol>\n<li>NPM_CONFIG_ELECTRON_MIRROR</li>\n<li>npm_config_electron_mirror</li>\n<li>npm_package_config_electron_mirror</li>\n<li>ELECTRON_MIRROR</li>\n<li>options[‘mirror’]</li>\n</ol>\n<p>上述任意变量存在值则直接使用，否则，使用默认值<code>defaultValue</code>。</p>\n<p>读到这里，也许有读者疑惑了，我明明是在<code>.npmrc</code>文件中配置的<code>ELECTRON_MIRROR</code>变量，而这里读取的明明是环境变量里面的值，怎么会有呢？如果直接使用node作为入口，那么确实不会有这些变量，但是通过npm运行就不一样了。这里用一个小例子来说明。</p>\n<p>首先在一个node项目中编写一个脚本env-test.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(process.env);</span><br></pre></td></tr></table></figure>\n<p>我们通过使用node运行该js脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node env-test.js</span><br></pre></td></tr></table></figure>\n<p>看到命令行的输出，只会有当前机器的环境变量：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/just-env.jpg\" alt=\"\"></p>\n<p>但是一旦通过npm进行运行，又会不一样：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/run-with-npm.jpg\" alt=\"\"></p>\n<p>运行命令<code>npm run dev</code>，会得到如下的结果，这里本人使用IDEA的断掉调试，会更加清晰的看到env的值：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/npm-env.jpg\" alt=\"\"></p>\n<p>通过<code>npm run</code>的方式，我们发现我们在<code>~/.npmrc</code>文件中配置的一些参数，都能在这里得到，并且是以<code>npm_config_</code>作为开头的。可能还有读者有疑惑，上面读取的变量，都是同意大小写的，这里是<code>npm_config_ELECTRON_MIRROR</code>，能读取到吗？事实上，env的读取是忽略大小写的：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/proc-env-ignore-case.jpg\" alt=\"\"></p>\n<p>综合目前的研究，相信读者已经清楚了为什么通过配置ELECTRON_MIRROR在<code>.npmrc</code>能够达到加快Electron二进制基座的下载速度的目的了，至于一些其他的配置变量，可以阅读附录的官方文档翻译。</p>\n<h2 id=\"本地缓存机制\"><a href=\"#本地缓存机制\" class=\"headerlink\" title=\"本地缓存机制\"></a>本地缓存机制</h2><p>有的读者看了上述的远端下载可能会说，我的机器就在内网环境，内网也没有镜像让我来写，我该怎么下载呢？实际上，<code>@electron/get</code>也不会完全从远端下载制品。它在下载的过程，会优先进行本地缓存文件的查找，如果已经存在了缓存好的制品，自然也就不会从远端下载了。那么这个查找缓存的过程是怎样的呢？或者说，<code>@electron/get</code>会从本地哪个目录去查找呢？让我们回到<code>@electron/get/dist/cjs/index.js</code>脚本的<code>downloadArtifact</code>函数中，看该部分：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/get-cache-path.jpg\" alt=\"\"></p>\n<p>在<code>url</code>变量获取的下一行，构建了一个Cache缓存对象，继续往下，通过判断不进行强制从远端下载的标志，会进入<code>getPathForFileInCache</code>函数返回一个本地的缓存文件路径，如果路径不为空则使用它。所以，我们只需要让这个函数能够返回一个合法的缓存文件路径就能让<code>@electron/get</code>不进行远端下载，而是使用本地的缓存文件。所以我们跟到该函数中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/getCachePath.jpg\" alt=\"\"></p>\n<p>函数最终会使用上一节中的<code>url</code>变量形成一个本地的缓存路径，至于代码中的<code>url.format</code>以及<code>filenamify</code>的效果，读者可以自行编写Demo验证。</p>\n<p>最后，路径还使用到了<code>this.cacheRoot</code>，查看Cache的构造函数，发现如果没有传递<code>cacheRoot</code>，则使用<code>defaultCacheRoot</code>，该值在该脚本文件上面有定义：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/default-cache-root-def.jpg\" alt=\"\"></p>\n<p>通过一段脚本输出该路径：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> env_paths_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;env-paths&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultCacheRoot = env_paths_1.default(<span class=\"string\">&#x27;electron&#x27;</span>, &#123;</span><br><span class=\"line\">  suffix: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">&#125;).cache;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(defaultCacheRoot);</span><br><span class=\"line\"><span class=\"comment\">// 在本人的机器上输出：</span></span><br><span class=\"line\"><span class=\"comment\">// C:\\Users\\w4ngzhen\\AppData\\Local\\electron\\Cache</span></span><br></pre></td></tr></table></figure>\n<p>所以在Windows机器下，默认的缓存目录在<code>~/AppData/Local/electron/Cache/</code>，在本人的机器上，已经缓存的文件如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/cache-file-list.jpg\" alt=\"\"></p>\n<p>源码个人认为也不用继续解析了，读者结合文件夹名称应该能够很容易分析。</p>\n<h1 id=\"附录：-electron-get-官方Wiki翻译\"><a href=\"#附录：-electron-get-官方Wiki翻译\" class=\"headerlink\" title=\"附录：@electron/get 官方Wiki翻译\"></a>附录：@electron/get 官方Wiki翻译</h1><blockquote>\n<p>下载Electron发行版制品</p>\n</blockquote>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"基础方式：下载一个Electron二进制ZIP\"><a href=\"#基础方式：下载一个Electron二进制ZIP\" class=\"headerlink\" title=\"基础方式：下载一个Electron二进制ZIP\"></a>基础方式：下载一个Electron二进制ZIP</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; download &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@electron/get&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NB: Use this syntax within an async function, Node does not have support for</span></span><br><span class=\"line\"><span class=\"comment\">//     top-level await as of Node 12.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> zipFilePath = <span class=\"keyword\">await</span> download(<span class=\"string\">&#x27;4.0.4&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶：下载macOS下带有调试符号的Electron文件\"><a href=\"#进阶：下载macOS下带有调试符号的Electron文件\" class=\"headerlink\" title=\"进阶：下载macOS下带有调试符号的Electron文件\"></a>进阶：下载macOS下带有调试符号的Electron文件</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; downloadArtifact &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@electron/get&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NB: Use this syntax within an async function, Node does not have support for</span></span><br><span class=\"line\"><span class=\"comment\">//     top-level await as of Node 12.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> zipFilePath = <span class=\"keyword\">await</span> downloadArtifact(&#123;</span><br><span class=\"line\">  version: <span class=\"string\">&#x27;4.0.4&#x27;</span>,</span><br><span class=\"line\">  platform: <span class=\"string\">&#x27;darwin&#x27;</span>,</span><br><span class=\"line\">  artifactName: <span class=\"string\">&#x27;electron&#x27;</span>,</span><br><span class=\"line\">  artifactSuffix: <span class=\"string\">&#x27;symbols&#x27;</span>,</span><br><span class=\"line\">  arch: <span class=\"string\">&#x27;x64&#x27;</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"指定镜像\"><a href=\"#指定镜像\" class=\"headerlink\" title=\"指定镜像\"></a>指定镜像</h3><p>下列选项可以用来指定从其他的地方下载Electron资源：</p>\n<ul>\n<li><code>mirrorOptions</code> Object（JavaScript对象）<ul>\n<li><code>mirror</code> String (可选) - 下载资源的镜像地址的基础URL。</li>\n<li><code>nightlyMirror</code> String (可选) - Electron nightly-specific版本的镜像URL。</li>\n<li><code>customDir</code> String (可选) - 下载资源的目录名称，通常由版本号来设定。</li>\n<li><code>customFilename</code> String (可选) - 将要下载的资源的文件名称。</li>\n<li><code>resolveAssetURL</code> Function (可选) - 允许通过编程方式来进行资源下载的函数回调。</li>\n</ul>\n</li>\n</ul>\n<p>下载资源的URL进行如下的分解，每一项都来可以映射到<code>mirrorOptions</code>:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/url-resolve.jpg\" alt=\"\"></p>\n<p>Example:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; download &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@electron/get&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> zipFilePath = <span class=\"keyword\">await</span> download(<span class=\"string\">&#x27;4.0.4&#x27;</span>, &#123;</span><br><span class=\"line\">  mirrorOptions: &#123;</span><br><span class=\"line\">    mirror: <span class=\"string\">&#x27;https://mirror.example.com/electron/&#x27;</span>,</span><br><span class=\"line\">    customDir: <span class=\"string\">&#x27;custom&#x27;</span>,</span><br><span class=\"line\">    customFilename: <span class=\"string\">&#x27;unofficial-electron-linux.zip&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 上述将会从如下URL下载：</span></span><br><span class=\"line\"><span class=\"comment\">// https://mirror.example.com/electron/custom/unofficial-electron-linux.zip</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> nightlyZipFilePath = <span class=\"keyword\">await</span> download(<span class=\"string\">&#x27;8.0.0-nightly.20190901&#x27;</span>, &#123;</span><br><span class=\"line\">  mirrorOptions: &#123;</span><br><span class=\"line\">    nightlyMirror: <span class=\"string\">&#x27;https://nightly.example.com/&#x27;</span>,</span><br><span class=\"line\">    customDir: <span class=\"string\">&#x27;nightlies&#x27;</span>,</span><br><span class=\"line\">    customFilename: <span class=\"string\">&#x27;nightly-linux.zip&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 上述将会从如下URL下载：</span></span><br><span class=\"line\"><span class=\"comment\">// https://nightly.example.com/nightlies/nightly-linux.zip</span></span><br></pre></td></tr></table></figure>\n<p><code>customDir</code>参数可以使用<code>&#123;&#123; version &#125;&#125;</code>占位符来设置版本（务必注意：<code>&#123;&#125;</code>括号之间一定要有空格，否则会解析失败，即，<code>&#123;&#123;[空格]version&#123;空格&#125;&#125;&#125;</code>），这个占位符将会由所下载的资源的版本（没有首字符<code>v</code>）来动态替换。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> zipFilePath = <span class=\"keyword\">await</span> download(<span class=\"string\">&#x27;4.0.4&#x27;</span>, &#123;</span><br><span class=\"line\">  mirrorOptions: &#123;</span><br><span class=\"line\">    mirror: <span class=\"string\">&#x27;https://mirror.example.com/electron/&#x27;</span>,</span><br><span class=\"line\">    customDir: <span class=\"string\">&#x27;version-&#123;&#123; version &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    platform: <span class=\"string\">&#x27;linux&#x27;</span>,</span><br><span class=\"line\">    arch: <span class=\"string\">&#x27;x64&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 将会从如下的URL下载：</span></span><br><span class=\"line\"><span class=\"comment\">// https://mirror.example.com/electron/version-4.0.4/electron-v4.0.4-linux-x64.zip</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用环境变量来指定镜像选项\"><a href=\"#使用环境变量来指定镜像选项\" class=\"headerlink\" title=\"使用环境变量来指定镜像选项\"></a>使用环境变量来指定镜像选项</h4><p>镜像配置选项也可以通过如下的环境变量来指定：</p>\n<ul>\n<li><code>ELECTRON_CUSTOM_DIR</code> - 指定资源下载的自定义目录。</li>\n<li><code>ELECTRON_CUSTOM_FILENAME</code> - 指定资源下载的自定义文件名。</li>\n<li><code>ELECTRON_MIRROR</code> - 指定如果版本没有使用nightly的时候，服务器的下载URL。</li>\n<li><code>ELECTRON_NIGHTLY_MIRROR</code> - 指定如果版本使用nightly的时候，服务器的下载URL。</li>\n</ul>\n<h3 id=\"重写下载的资源版本\"><a href=\"#重写下载的资源版本\" class=\"headerlink\" title=\"重写下载的资源版本\"></a>重写下载的资源版本</h3><p>所下载的资源的版本可以通过设置<code>`ELECTRON_CUSTOM_VERSION</code> 环境变量来进行覆盖。设置该版本将会覆盖传入<code>download</code>或是<code>downloadArtifact</code>函数的version参数。</p>\n<h2 id=\"它是如何运行的\"><a href=\"#它是如何运行的\" class=\"headerlink\" title=\"它是如何运行的\"></a>它是如何运行的</h2><p>下载Electron资源到操作系统中已知的位置，并且缓存该资源的模块，用于便于在将来请求同一个资源的时候能够立刻完成并返回。缓存路径如下：</p>\n<ul>\n<li>Linux: <code>$XDG_CACHE_HOME</code> or <code>~/.cache/electron/</code></li>\n<li>MacOS: <code>~/Library/Caches/electron/</code></li>\n<li>Windows: <code>%LOCALAPPDATA%/electron/Cache</code> or <code>~/AppData/Local/electron/Cache/</code></li>\n</ul>\n<p>默认情况下，该模块使用 <a href=\"https://github.com/sindresorhus/got\"><code>got</code></a>作为下载器。因此，您可以通过<code>downloadOptions</code>使用与<code>get</code>相同的选项（<a href=\"https://github.com/sindresorhus/got#options\">options</a>）来进行下载。</p>\n<h3 id=\"进度条\"><a href=\"#进度条\" class=\"headerlink\" title=\"进度条\"></a>进度条</h3><p>默认情况下，下载工件超过30秒时会显示进度条。若要禁用，请将<code>ELECTRON_GET_NO_PROGRESS</code> 环境变量设置为任何非空值，或设置<code>downloadOptions</code>中的<code>quiet</code>为<code>true</code>。如果您需要通过API自己监视进度，请设置<code>downloadOptions</code>中的<code>getProgressCallback</code> 回调，其函数签名与<code>got</code>的<a href=\"https://github.com/sindresorhus/got#ondownloadprogress-progress\"><code>downloadProgress</code> event callback</a>相同。</p>\n<h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><p>下游软件包应利用 <code>initializeProxy</code>功能来添加HTTP(S)代理支持。如果设置了环境变量<code>ELECTRON_GET_USE_PROXY</code>，则会自动调用它。根据使用的Node版本，使用不同的代理模块.因此，设置代理环境变量的方式略有不同。对于Node 10及更高版本，使用<a href=\"https://github.com/gajus/global-agent#environment-variables\"><code>global-agent</code></a>。否则，将使用<a href=\"https://github.com/np-maintain/global-tunnel#auto-config\"><code>global-tunnel-ng</code></a>。请参阅相应的链接模块以确定如何配置代理支持。</p>\n","categories":[],"tags":["electron"]},{"title":"使用CEF（2）— 基于VS2019编写一个简单CEF样例","url":"http://compilemind.com/2021/01/15/2021-01-15-使用CEF（2）— 基于VS2019编写一个简单CEF样例/","content":"<h1 id=\"使用CEF（2）—-基于VS2019编写一个简单CEF样例\"><a href=\"#使用CEF（2）—-基于VS2019编写一个简单CEF样例\" class=\"headerlink\" title=\"使用CEF（2）— 基于VS2019编写一个简单CEF样例\"></a>使用CEF（2）— 基于VS2019编写一个简单CEF样例</h1><p>在这一节中，本人将会在Windows下使用VS2019创建一个空白的C++<strong>Windows Desktop Application</strong>项目，逐步进行修改配置和代码编写，并在这个过程中介绍vs使用过程中和C++项目的结合。源码见文章末尾Github链接。</p>\n<a id=\"more\"></a>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>你已经阅读过《使用CEF（1）— 起步》，你可以在这些地方读到：<a href=\"https://zhuanlan.zhihu.com/p/344306287\">知乎链接</a>、<a href=\"https://www.cnblogs.com/w4ngzhen/p/14278187.html\">cnblogs</a>。或，你知道如何获得libcef的库以及libcef_dll_wrapper静态库。</p>\n<h2 id=\"文件准备\"><a href=\"#文件准备\" class=\"headerlink\" title=\"文件准备\"></a>文件准备</h2><p>接下来，本人将以Debug的模式下完成代码的开发工作。在Release下是同样的步骤，但是需要注意的是你所选择的目标是Debug或是Release都需要和libcef库以及libcef_dll_wrapper完全一致。</p>\n<ul>\n<li>现在，你需要libcef库文件相关文件，它来自于：</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/libcef-lib-list.jpg\" alt=\"\"></p>\n<ul>\n<li>你需要使用libcef_dll_wrapper静态库文件，它来自于你编译出来的静态库：</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/libcef-dll-lib-list.jpg\" alt=\"\"></p>\n<ul>\n<li>你需要libcef与wrapper的include文件，它来自于：</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/include-files.jpg\" alt=\"\"></p>\n<p>接下来我们创建一个名为cef的文件夹，并且把上述提到的文件夹和文件放到该目录下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cef</span><br><span class=\"line\">│  libcef_dll_wrapper.lib</span><br><span class=\"line\">│  libcef_dll_wrapper.pdb</span><br><span class=\"line\">│</span><br><span class=\"line\">├─Debug</span><br><span class=\"line\">│  │  ......</span><br><span class=\"line\">│  │  libcef.dll</span><br><span class=\"line\">│  │  libcef.lib</span><br><span class=\"line\">│  │  libEGL.dll</span><br><span class=\"line\">│  │  libGLESv2.dll</span><br><span class=\"line\">│  │  ......</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─swiftshader</span><br><span class=\"line\">│          libEGL.dll</span><br><span class=\"line\">│          libGLESv2.dll</span><br><span class=\"line\">│</span><br><span class=\"line\">└─include</span><br><span class=\"line\">    │  cef_accessibility_handler.h</span><br><span class=\"line\">    │  cef_api_hash.h</span><br><span class=\"line\">    │  cef_app.h</span><br><span class=\"line\">    │  cef_audio_handler.h</span><br><span class=\"line\">    |  .....</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/files-dir.jpg\" alt=\"\"></p>\n<p>基础文件创建完成后，我们开始编写一个简单的基于CEF的程序吧！</p>\n<h2 id=\"项目创建\"><a href=\"#项目创建\" class=\"headerlink\" title=\"项目创建\"></a>项目创建</h2><p>创建一个Windows桌面应用程序</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/create-sln.jpg\" alt=\"\"></p>\n<p>创建一个名为simple-cef的项目</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/create-proj.jpg\" alt=\"\"></p>\n<p>创建完成后，我们删除所有模板生成的代码，得到一个完全空白的应用程序项目：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/delete-all-files.jpg\" alt=\"\"></p>\n<h2 id=\"依赖添加\"><a href=\"#依赖添加\" class=\"headerlink\" title=\"依赖添加\"></a>依赖添加</h2><h3 id=\"头文件添加\"><a href=\"#头文件添加\" class=\"headerlink\" title=\"头文件添加\"></a>头文件添加</h3><p>众所周知，C/C++头文件作为声明定义，对于编译过程有着举足轻重的位置。当我们引入CEF编译我们的项目时候，首先需要include正确位置的头文件，才能实现编译（狭义的编译，不包括链接）。我们首先把上述做好的cef文件夹放到<strong>项目</strong>所在目录下，也就是说我们把cef的inlucde头文件以及静态库文件全都加到了项目中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/20210122161019.png\" alt=\"\"></p>\n<p>然后，在VS中，我们通过如下的方式为我们的项目引入CEF的头文件：</p>\n<p><strong>右键项目</strong> — <strong>properties</strong> — <strong>C/C++</strong> — <strong>General</strong> — <strong>Additional Include Directories</strong></p>\n<p>PS：如果你发现没有C/C++分类，是因为你没有创建任何的源代码文件，<a href=\"https://developercommunity.visualstudio.com/content/problem/87843/property-pages-cc-category-missing.html\">官方FAQ</a>。所以我们在Source Files目录下先创建一个main.cpp，然后继续上述的配置。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/additional-include-dir.jpg\" alt=\"\"></p>\n<p>PS：这里本人使用了<code>$(ProjectDir)</code>，它是一个VS宏变量，返回项目所在目录（即，vcxproj所在目录），且目录末尾带反斜杠<code>\\</code>。从上面的Evaluated value里面展示的经过实际计算得到的值，可以验证我们配置是否正确。这里正确的返回了我们<strong>放在项目目录下的cef文件夹</strong>。</p>\n<p>这里只需要添加到<strong>cef文件夹</strong>这一层级，是因为<strong>cef/include</strong>里面的头文件在include的时候，采用了对应的”include/xxx.h”，即需要从<strong>引入目录</strong>中找到include文件夹，里面查找xxx.h头文件。当我们指定到了cef层级后，就能够使得编译器正确处理cef头文件中include的位置。</p>\n<p>这里以<strong>$(ProjectDir)cef/include/cef_broweser.h</strong>这个头文件举例：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/20210122162053.png\" alt=\"\"></p>\n<p>当编译器发现里面的#include预编译命令后，会从头文件目录中去查找，即希望从上述配置的<strong>$(ProjectDir)cef/</strong>以及默认目录下查找，默认的项目目录应该是找不到了，但是可以在<strong>$(ProjectDir)cef/</strong>目录下找到<strong>include/cef_base.h</strong>等文件，因为<strong>$(ProjectDir)cef/include/cef_base.h</strong>确实是正确的文件路径。因此，上述额外的include文件夹只需要指定到cef层级即可。</p>\n<h3 id=\"库文件添加\"><a href=\"#库文件添加\" class=\"headerlink\" title=\"库文件添加\"></a>库文件添加</h3><p>完成头文件的添加后，我们还需要添加链接目标，即cef的静态库。添加方式为：</p>\n<p><strong>properties</strong> — <strong>Linker</strong> — <strong>Input</strong>— <strong>Additional Dependencies</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/add-the-additional-dependencies.jpg\" alt=\"\"></p>\n<p>同样使用宏变量来指定对应的lib静态库：libcef_dll_wrapper.lib、libcef.lib、cef_sandbox.lib。</p>\n<p>通过上述的库文件添加，我们就完成了<strong>编译（狭义，头文件查找）——链接（库文件链接）</strong>这两个步骤的配置了，接下来就是进一步，开始我们的代码编写之路。</p>\n<h2 id=\"代码编写与说明\"><a href=\"#代码编写与说明\" class=\"headerlink\" title=\"代码编写与说明\"></a>代码编写与说明</h2><p>CEF的整体架构以及CefApp以及CefClient的概念可以参考<a href=\"https://github.com/fanfeilong/cefutil\">该仓库里面的文档</a>，或者是<a href=\"https://bitbucket.org/chromiumembedded/cef/wiki/GeneralUsage.md\">阅读官方文档</a>。接下来将使用cefsimple代码进行解释说明，并适当增加一些小的细节。</p>\n<h3 id=\"simple-app\"><a href=\"#simple-app\" class=\"headerlink\" title=\"simple_app\"></a>simple_app</h3><h4 id=\"simple-app-h\"><a href=\"#simple-app-h\" class=\"headerlink\" title=\"simple_app.h\"></a>simple_app.h</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> SIMPLE_APP_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIMPLE_APP_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_app.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implement application-level callbacks for the browser process.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleApp</span> :</span> <span class=\"keyword\">public</span> CefApp, <span class=\"keyword\">public</span> CefBrowserProcessHandler &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    SimpleApp();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CefApp methods:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefBrowserProcessHandler&gt; <span class=\"title\">GetBrowserProcessHandler</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        OVERRIDE </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CefBrowserProcessHandler methods:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnContextInitialized</span><span class=\"params\">()</span> OVERRIDE</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Include the default reference counting implementation.</span></span><br><span class=\"line\">    IMPLEMENT_REFCOUNTING(SimpleApp);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>这里引入的时候，如果发现VS提示，<code>#include &quot;include/cef_app.h&quot;</code>无效，首先检查上述的对项目的配置是否正确！上述项目Properties中配置的平台是x64，VS中也请选择一致的平台。而且在本Demo是无法使用32位的，因为我们下载的静态库是x64位的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/same-config.jpg\" alt=\"\"></p>\n<h4 id=\"simple-app-cpp\"><a href=\"#simple-app-cpp\" class=\"headerlink\" title=\"simple_app.cpp\"></a>simple_app.cpp</h4><p>在simple_app的实现中，主要需要提供3个部分的代码实现：</p>\n<ul>\n<li>CefWindowDelegate</li>\n<li>CefBrowserViewDelegate</li>\n<li>SimpleApp</li>\n</ul>\n<h5 id=\"CefWindowDelegate与CefBrowserViewDelegate\"><a href=\"#CefWindowDelegate与CefBrowserViewDelegate\" class=\"headerlink\" title=\"CefWindowDelegate与CefBrowserViewDelegate\"></a>CefWindowDelegate与CefBrowserViewDelegate</h5><p>Cef窗体代理以及Cef浏览器视图代理，他们是CEF提供的一套图形视图框架。这一套图形接口目前在Windows和Linux上支持了，所以在Windows和Linux我们完全可以不用选择原生的窗体框架（例如在Windows上的WinForm和Linux上的QT之类的），而是直接使用CEF提供的图形视图框架。而CEF的图形视图框架的内部实现原理我们暂时不需要知道，可以把它们想象成一些窗体和控件对象，它们需要在SimpleApp中的实现用到，所以也写在了simple_app.cpp中。相关代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SimpleBrowserViewDelegate</span></span><br><span class=\"line\"><span class=\"comment\">// 继承CefBrowserViewDelegate，即CEF浏览器视图代理。</span></span><br><span class=\"line\"><span class=\"comment\">// 该代理由CEF屏蔽细节，只暴露出视图控件指定的接口回调供我们实现即可</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleBrowserViewDelegate</span> :</span> <span class=\"keyword\">public</span> CefBrowserViewDelegate </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">    SimpleBrowserViewDelegate()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">OnPopupBrowserViewCreated</span><span class=\"params\">(CefRefPtr&lt;CefBrowserView&gt; browser_view,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   CefRefPtr&lt;CefBrowserView&gt; popup_browser_view,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">bool</span> is_devtools)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a new top-level Window for the popup. It will show itself after</span></span><br><span class=\"line\">        <span class=\"comment\">// creation.</span></span><br><span class=\"line\">        CefWindow::CreateTopLevelWindow(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SimpleWindowDelegate(popup_browser_view));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We created the Window.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    IMPLEMENT_REFCOUNTING(SimpleBrowserViewDelegate);</span><br><span class=\"line\">    DISALLOW_COPY_AND_ASSIGN(SimpleBrowserViewDelegate);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SimpleWindowDelegate</span></span><br><span class=\"line\"><span class=\"comment\">// 继承CefWindowDelegate，即CEF窗口代理。</span></span><br><span class=\"line\"><span class=\"comment\">// 该代理由CEF屏蔽细节，只暴露窗口一些接口回调供我们实现即可。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleWindowDelegate</span> :</span> <span class=\"keyword\">public</span> CefWindowDelegate</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">SimpleWindowDelegate</span><span class=\"params\">(CefRefPtr&lt;CefBrowserView&gt; browser_view)</span></span></span><br><span class=\"line\"><span class=\"function\">        : <span class=\"title\">browser_view_</span><span class=\"params\">(browser_view)</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 窗体创建时</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnWindowCreated</span><span class=\"params\">(CefRefPtr&lt;CefWindow&gt; window)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Add the browser view and show the window.</span></span><br><span class=\"line\">        window-&gt;AddChildView(browser_view_);</span><br><span class=\"line\">        window-&gt;Show();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Give keyboard focus to the browser view.</span></span><br><span class=\"line\">        browser_view_-&gt;RequestFocus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 窗体销毁时</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnWindowDestroyed</span><span class=\"params\">(CefRefPtr&lt;CefWindow&gt; window)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        browser_view_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 窗体是否可以关闭</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CanClose</span><span class=\"params\">(CefRefPtr&lt;CefWindow&gt; window)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Allow the window to close if the browser says it&#x27;s OK.</span></span><br><span class=\"line\">        CefRefPtr&lt;CefBrowser&gt; browser = browser_view_-&gt;GetBrowser();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (browser)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> browser-&gt;GetHost()-&gt;TryCloseBrowser();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取窗体展示的最佳尺寸</span></span><br><span class=\"line\">    <span class=\"function\">CefSize <span class=\"title\">GetPreferredSize</span><span class=\"params\">(CefRefPtr&lt;CefView&gt; view)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CefSize(<span class=\"number\">800</span>, <span class=\"number\">600</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    CefRefPtr&lt;CefBrowserView&gt; browser_view_;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMPLEMENT_REFCOUNTING(SimpleWindowDelegate);</span><br><span class=\"line\">    DISALLOW_COPY_AND_ASSIGN(SimpleWindowDelegate);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"SimpleApp\"><a href=\"#SimpleApp\" class=\"headerlink\" title=\"SimpleApp\"></a>SimpleApp</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SimpleApp::SimpleApp()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleApp::OnContextInitialized</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    CefRefPtr&lt;CefCommandLine&gt; command_line =</span><br><span class=\"line\">        CefCommandLine::GetGlobalCommandLine();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> enable_chrome_runtime =</span><br><span class=\"line\">        command_line-&gt;HasSwitch(<span class=\"string\">&quot;enable-chrome-runtime&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(OS_WIN) || defined(OS_LINUX)</span></span><br><span class=\"line\">    <span class=\"comment\">// Create the browser using the Views framework if &quot;--use-views&quot; is specified</span></span><br><span class=\"line\">    <span class=\"comment\">// via the command-line. Otherwise, create the browser using the native</span></span><br><span class=\"line\">    <span class=\"comment\">// platform framework. The Views framework is currently only supported on</span></span><br><span class=\"line\">    <span class=\"comment\">// Windows and Linux.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views = command_line-&gt;HasSwitch(<span class=\"string\">&quot;use-views&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// SimpleHandler implements browser-level callbacks.</span></span><br><span class=\"line\">    <span class=\"function\">CefRefPtr&lt;SimpleClient&gt; <span class=\"title\">handler</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleClient(use_views))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Specify CEF browser settings here.</span></span><br><span class=\"line\">    CefBrowserSettings browser_settings;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> url;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if a &quot;--url=&quot; value was provided via the command-line. If so, use</span></span><br><span class=\"line\">    <span class=\"comment\">// that instead of the default URL.</span></span><br><span class=\"line\">    url = command_line-&gt;GetSwitchValue(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url.empty())</span><br><span class=\"line\">        url = <span class=\"string\">&quot;https://www.cnblogs.com/w4ngzhen/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (use_views &amp;&amp; !enable_chrome_runtime)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create the BrowserView.</span></span><br><span class=\"line\">        CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(</span><br><span class=\"line\">            handler, url, browser_settings, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SimpleBrowserViewDelegate());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create the Window. It will show itself after creation.</span></span><br><span class=\"line\">        CefWindow::CreateTopLevelWindow(<span class=\"keyword\">new</span> SimpleWindowDelegate(browser_view));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Information used when creating the native window.</span></span><br><span class=\"line\">        CefWindowInfo window_info;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(OS_WIN)</span></span><br><span class=\"line\">        <span class=\"comment\">// On Windows we need to specify certain flags that will be passed to</span></span><br><span class=\"line\">        <span class=\"comment\">// CreateWindowEx().</span></span><br><span class=\"line\">        window_info.SetAsPopup(<span class=\"literal\">NULL</span>, <span class=\"string\">&quot;simple-cef by w4ngzhen&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create the first browser window.</span></span><br><span class=\"line\">        CefBrowserHost::CreateBrowser(window_info, handler, url, browser_settings,</span><br><span class=\"line\">                                      <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"simple-client\"><a href=\"#simple-client\" class=\"headerlink\" title=\"simple_client\"></a>simple_client</h3><h5 id=\"simple-client-h\"><a href=\"#simple-client-h\" class=\"headerlink\" title=\"simple_client.h\"></a>simple_client.h</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> SIMPLE_CLIENT_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIMPLE_CLIENT_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_client.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleClient</span> :</span> <span class=\"keyword\">public</span> CefClient,</span><br><span class=\"line\">                     <span class=\"keyword\">public</span> CefDisplayHandler,</span><br><span class=\"line\">                     <span class=\"keyword\">public</span> CefLifeSpanHandler,</span><br><span class=\"line\">                     <span class=\"keyword\">public</span> CefLoadHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">SimpleClient</span><span class=\"params\">(<span class=\"keyword\">bool</span> use_views)</span></span>;</span><br><span class=\"line\">\t~SimpleClient();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> SimpleClient* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDisplayHandler&gt; <span class=\"title\">GetDisplayHandler</span><span class=\"params\">()</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefLifeSpanHandler&gt; <span class=\"title\">GetLifeSpanHandler</span><span class=\"params\">()</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefLoadHandler&gt; <span class=\"title\">GetLoadHandler</span><span class=\"params\">()</span> OVERRIDE </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// CefDisplayHandler的实现声明:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnTitleChange</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                           <span class=\"keyword\">const</span> CefString&amp; title)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// CefLifeSpanHandler的实现声明:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnAfterCreated</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">DoClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnBeforeClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// CefLoadHandler的实现声明:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnLoadError</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         CefRefPtr&lt;CefFrame&gt; frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         ErrorCode errorCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         <span class=\"keyword\">const</span> CefString&amp; errorText,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         <span class=\"keyword\">const</span> CefString&amp; failedUrl)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CloseAllBrowsers</span><span class=\"params\">(<span class=\"keyword\">bool</span> force_close)</span></span>; <span class=\"comment\">// 请求将所有的已经存在的浏览器窗体进行关闭</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsClosing</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> is_closing_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 平台特定的标题修改</span></span><br><span class=\"line\">    <span class=\"comment\">// 当我们没有CEF的GUI视图框架的时候，就需要特定平台的标题修改实现</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如，Windows中需要我们获取窗体句柄，调用Windows的API完成对该窗体的标题修改</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PlatformTitleChange</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         <span class=\"keyword\">const</span> CefString&amp; title)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views_; <span class=\"comment\">// 是否使用了CEF的GUI视图框架</span></span><br><span class=\"line\">\t<span class=\"comment\">// List of existing browser windows. Only accessed on the CEF UI thread.</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;CefRefPtr&lt;CefBrowser&gt;&gt; BrowserList;</span><br><span class=\"line\">\tBrowserList browser_list_;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> is_closing_;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Include the default reference counting implementation.</span></span><br><span class=\"line\">IMPLEMENT_REFCOUNTING(SimpleClient);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"simple-client-cpp以及simple-client-os-win-cpp\"><a href=\"#simple-client-cpp以及simple-client-os-win-cpp\" class=\"headerlink\" title=\"simple_client.cpp以及simple_client_os_win.cpp\"></a>simple_client.cpp以及simple_client_os_win.cpp</h5><p>这里我们提供了两份源代码，第一份是所有平台的通用实现，而第二份源码从名称可以看出跟特定的操作系统平台有关，这里就是Windows，为什么会有两份源码我们下文会逐步了解。</p>\n<p>首先看simple_client.cpp的源代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_client.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/base/cef_bind.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_app.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_parser.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/views/cef_browser_view.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/views/cef_window.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/wrapper/cef_closure_task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/wrapper/cef_helpers.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SimpleClient* g_instance = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns a data: URI with the specified contents.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">GetDataURI</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; data, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; mime_type)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;data:&quot;</span> + mime_type + <span class=\"string\">&quot;;base64,&quot;</span> +</span><br><span class=\"line\">            CefURIEncode(CefBase64Encode(data.data(), data.<span class=\"built_in\">size</span>()), <span class=\"literal\">false</span>)</span><br><span class=\"line\">            .ToString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace</span></span><br><span class=\"line\"></span><br><span class=\"line\">SimpleClient::SimpleClient(<span class=\"keyword\">bool</span> use_views)</span><br><span class=\"line\">    : use_views_(use_views), is_closing_(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DCHECK(!g_instance);</span><br><span class=\"line\">    g_instance = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SimpleClient::~SimpleClient()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    g_instance = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// static</span></span><br><span class=\"line\"><span class=\"function\">SimpleClient* <span class=\"title\">SimpleClient::GetInstance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g_instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::OnTitleChange</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 <span class=\"keyword\">const</span> CefString&amp; title)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (use_views_)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果使用CEF的GUI视图框架，那么修改窗体的标题通过调用该视图框架的API完成</span></span><br><span class=\"line\">        CefRefPtr&lt;CefBrowserView&gt; browser_view =</span><br><span class=\"line\">            CefBrowserView::GetForBrowser(browser);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (browser_view)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CefRefPtr&lt;CefWindow&gt; window = browser_view-&gt;GetWindow();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (window)</span><br><span class=\"line\">                window-&gt;SetTitle(title);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则使用特定平台窗体标题修改API</span></span><br><span class=\"line\">        <span class=\"comment\">// 详情见simple_client_os_win.cpp</span></span><br><span class=\"line\">        PlatformTitleChange(browser, title);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::OnAfterCreated</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Add to the list of existing browsers.</span></span><br><span class=\"line\">    browser_list_.push_back(browser);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SimpleClient::DoClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Closing the main window requires special handling. See the DoClose()</span></span><br><span class=\"line\">    <span class=\"comment\">// documentation in the CEF header for a detailed destription of this</span></span><br><span class=\"line\">    <span class=\"comment\">// process.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (browser_list_.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set a flag to indicate that the window close should be allowed.</span></span><br><span class=\"line\">        is_closing_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allow the close. For windowed browsers this will result in the OS close</span></span><br><span class=\"line\">    <span class=\"comment\">// event being sent.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::OnBeforeClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Remove from the list of existing browsers.</span></span><br><span class=\"line\">    BrowserList::iterator <span class=\"built_in\">bit</span> = browser_list_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; <span class=\"built_in\">bit</span> != browser_list_.<span class=\"built_in\">end</span>(); ++<span class=\"built_in\">bit</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((*<span class=\"built_in\">bit</span>)-&gt;IsSame(browser))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            browser_list_.erase(<span class=\"built_in\">bit</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (browser_list_.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// All browser windows have closed. Quit the application message loop.</span></span><br><span class=\"line\">        CefQuitMessageLoop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::OnLoadError</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               CefRefPtr&lt;CefFrame&gt; frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               ErrorCode errorCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">const</span> CefString&amp; errorText,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">const</span> CefString&amp; failedUrl)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t display an error for downloaded files.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (errorCode == ERR_ABORTED)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Display a load error message using a data: URI.</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">    ss &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;&lt;body bgcolor=\\&quot;white\\&quot;&gt;&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&lt;h2&gt;Failed to load URL &quot;</span></span><br><span class=\"line\">        &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>(failedUrl) &lt;&lt; <span class=\"string\">&quot; with error &quot;</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>(errorText)</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot; (&quot;</span> &lt;&lt; errorCode &lt;&lt; <span class=\"string\">&quot;).&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    frame-&gt;LoadURL(GetDataURI(ss.str(), <span class=\"string\">&quot;text/html&quot;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::CloseAllBrowsers</span><span class=\"params\">(<span class=\"keyword\">bool</span> force_close)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!CefCurrentlyOn(TID_UI))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Execute on the UI thread.</span></span><br><span class=\"line\">        CefPostTask(TID_UI, base::Bind(&amp;SimpleClient::CloseAllBrowsers, <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                                       force_close));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (browser_list_.empty())</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    BrowserList::const_iterator it = browser_list_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; it != browser_list_.<span class=\"built_in\">end</span>(); ++it)</span><br><span class=\"line\">        (*it)-&gt;GetHost()-&gt;CloseBrowser(force_close);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码有重要部分为函数<code>SimpleClient::OnTitleChange</code>的实现。在该实现代码中，通过判断变量<code>use_views_</code>来决定是否使用CEF提供的视图框架，也就有了下面两种情况：</p>\n<ul>\n<li>使用了CEF提供的视图框架：在这种情况下，窗体的标题改变直接使用CEF视图框架提供的API完成修改；</li>\n<li><strong>未</strong>使用CEF提供的视图框架：在这种情况下，我们一定用了原生的窗体框架或者是第三方的（QT或者GTK+），那么就需要调用相关原生窗体的API或者第三方的API来完成窗体标题的修改。</li>\n</ul>\n<p>由于存在上面的情况2，才有了下面的simple_client_os_win.cpp的代码。（PS：上面的代码并没有实现头文件里面的PlatformTitleChange声明哟，只是调用了而已）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// simple_client_os_win.cpp代码</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_client.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_browser.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::PlatformTitleChange</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> CefString&amp; title)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过GetHost()来获取CEF浏览器对象的宿主对象（这里就是Windows原生窗体）</span></span><br><span class=\"line\">    <span class=\"comment\">// 再获取对应的窗体句柄</span></span><br><span class=\"line\">    <span class=\"comment\">// 通过#include &lt;windows.h&gt;得到的WindowsAPI完成标题修改</span></span><br><span class=\"line\">    CefWindowHandle hwnd = browser-&gt;GetHost()-&gt;GetWindowHandle();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hwnd)</span><br><span class=\"line\">        SetWindowText(hwnd, <span class=\"built_in\">std</span>::<span class=\"built_in\">wstring</span>(title).c_str());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码实际上跟特定的平台有关，这里就是Windows平台。</p>\n<ol>\n<li>通过GetHost()来获取CEF浏览器对象的宿主对象（这里就是Windows原生窗体）；</li>\n<li>再获取对应的窗体句柄；</li>\n<li>通过#include <windows.h>得到的WindowsAPI完成标题修改。</li>\n</ol>\n<h3 id=\"入口代码main-cpp\"><a href=\"#入口代码main-cpp\" class=\"headerlink\" title=\"入口代码main.cpp\"></a>入口代码main.cpp</h3><p>编写完成上述的CEF应用模块后，我们最后编写入口代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights</span></span><br><span class=\"line\"><span class=\"comment\">// reserved. Use of this source code is governed by a BSD-style license that</span></span><br><span class=\"line\"><span class=\"comment\">// can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_command_line.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_sandbox_win.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_app.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// When generating projects with CMake the CEF_USE_SANDBOX value will be defined</span></span><br><span class=\"line\"><span class=\"comment\">// automatically if using the required compiler version. Pass -DUSE_SANDBOX=OFF</span></span><br><span class=\"line\"><span class=\"comment\">// to the CMake command-line to disable use of the sandbox.</span></span><br><span class=\"line\"><span class=\"comment\">// Uncomment this line to manually enable sandbox support.</span></span><br><span class=\"line\"><span class=\"comment\">// #define CEF_USE_SANDBOX 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(CEF_USE_SANDBOX)</span></span><br><span class=\"line\"><span class=\"comment\">// The cef_sandbox.lib static library may not link successfully with all VS</span></span><br><span class=\"line\"><span class=\"comment\">// versions.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> comment(lib, <span class=\"meta-string\">&quot;cef_sandbox.lib&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Entry point function for all processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> APIENTRY <span class=\"title\">wWinMain</span><span class=\"params\">(HINSTANCE hInstance,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    HINSTANCE hPrevInstance,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    LPTSTR lpCmdLine,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">int</span> nCmdShow)</span> </span>&#123;</span><br><span class=\"line\">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class=\"line\">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Enable High-DPI support on Windows 7 or newer.</span></span><br><span class=\"line\">    CefEnableHighDPISupport();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>* sandbox_info = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(CEF_USE_SANDBOX)</span></span><br><span class=\"line\">    <span class=\"comment\">// Manage the life span of the sandbox information object. This is necessary</span></span><br><span class=\"line\">    <span class=\"comment\">// for sandbox support on Windows. See cef_sandbox_win.h for complete details.</span></span><br><span class=\"line\">    CefScopedSandboxInfo scoped_sandbox;</span><br><span class=\"line\">    sandbox_info = scoped_sandbox.sandbox_info();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Provide CEF with command-line arguments.</span></span><br><span class=\"line\">    <span class=\"function\">CefMainArgs <span class=\"title\">main_args</span><span class=\"params\">(hInstance)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CEF applications have multiple sub-processes (render, plugin, GPU, etc)</span></span><br><span class=\"line\">    <span class=\"comment\">// that share the same executable. This function checks the command-line and,</span></span><br><span class=\"line\">    <span class=\"comment\">// if this is a sub-process, executes the appropriate logic.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> exit_code = CefExecuteProcess(main_args, <span class=\"literal\">nullptr</span>, sandbox_info);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exit_code &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The sub-process has completed so return here.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> exit_code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Parse command-line arguments for use in this method.</span></span><br><span class=\"line\">    CefRefPtr&lt;CefCommandLine&gt; command_line = CefCommandLine::CreateCommandLine();</span><br><span class=\"line\">    command_line-&gt;InitFromString(::GetCommandLineW());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Specify CEF global settings here.</span></span><br><span class=\"line\">    CefSettings settings;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command_line-&gt;HasSwitch(<span class=\"string\">&quot;enable-chrome-runtime&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Enable experimental Chrome runtime. See issue #2969 for details.</span></span><br><span class=\"line\">        settings.chrome_runtime = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(CEF_USE_SANDBOX)</span></span><br><span class=\"line\">    settings.no_sandbox = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// SimpleApp implements application-level callbacks for the browser process.</span></span><br><span class=\"line\">    <span class=\"comment\">// It will create the first browser instance in OnContextInitialized() after</span></span><br><span class=\"line\">    <span class=\"comment\">// CEF has initialized.</span></span><br><span class=\"line\">    <span class=\"function\">CefRefPtr&lt;SimpleApp&gt; <span class=\"title\">app</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleApp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize CEF.</span></span><br><span class=\"line\">    CefInitialize(main_args, settings, app.<span class=\"built_in\">get</span>(), sandbox_info);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run the CEF message loop. This will block until CefQuitMessageLoop() is</span></span><br><span class=\"line\">    <span class=\"comment\">// called.</span></span><br><span class=\"line\">    CefRunMessageLoop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Shut down CEF.</span></span><br><span class=\"line\">    CefShutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"编译与运行\"><a href=\"#编译与运行\" class=\"headerlink\" title=\"编译与运行\"></a>编译与运行</h2><p>上述代码完成后，我们的代码结构如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/files-arch.jpg\" alt=\"\"></p>\n<p>我们右键项目使用build指令进行尝试编译，如果不出意外会看到这些内容：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/compile-error.jpg\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;: value &#39;MTd_StaticDebug&#39; doesn&#39;t match value &#39;MDd_DynamicDebug&#39;</span><br></pre></td></tr></table></figure>\n<p>译为中文大意为：未检测到运行时库：<code>MTd_StaticDebug</code>无法匹配<code>MDd_DynamicDebug</code>，MTd是什么？MDd又是什么？关键字：MD、MDd、MT以及MTd。读者可以参考这篇文章深入了解：<a href=\"https://www.cnblogs.com/xzabg/p/5875296.html\">VS运行时 /MD、/MDd 和 /MT、/MTd之间的区别</a>。简单一点讲，我们编译出来的libcef_dll_wrapper.lib库的某个标志与我们当前编译的程序的某个标志不一致：一个是MTd一个是MDd。那么这个标志在哪儿设置呢？我们可以右键项目工程——properties——C/C++——Code Generation（代码生成）——Runtime Library中看到。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/proj-runtime-lib.jpg\" alt=\"\"></p>\n<p>在我们的simple项目中，VS在创建项目的时候默认使用了MDd，那么libcef_dll_wrapper.lib又是使用的什么呢？在《使用CEF（1）— 起步》文章中编译libcef_dll_wrapper.lib的项目目录下使用的是MTd。下图是再回看当时的项目使用的运行库类型：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/wrapper-runtime-lib.jpg\" alt=\"\"></p>\n<p>当然，具体情况也要具体判断。例如Debug与Release的不同，又或者是当时确实是使用MD(d)进行编译的，总之需要一一对应起来。这里我们修改我们的simple项目的RuntimeLibrary为对应的MTd，再次进行编译。不出意外，你会看到如下的编译成功的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rebuild started...</span><br><span class=\"line\">1&gt;------ Rebuild All started: Project: simple-cef, Configuration: Debug x64 ------</span><br><span class=\"line\">1&gt;main.cpp</span><br><span class=\"line\">1&gt;simple_app.cpp</span><br><span class=\"line\">1&gt;simple_client.cpp</span><br><span class=\"line\">1&gt;simple_client_os_win.cpp</span><br><span class=\"line\">1&gt;Generating Code...</span><br><span class=\"line\">1&gt;simple-cef.vcxproj -&gt; D:\\Projects\\cef-projects\\simple-cef\\x64\\Debug\\simple-cef.exe</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Rebuild All: 1 succeeded, 0 failed, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<p>于是，我们运行生成出来的exe，不出意外会有弹框报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------------------------</span><br><span class=\"line\">simple-cef.exe - 系统错误</span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">由于找不到 libcef.dll，无法继续执行代码。重新安装程序可能会解决此问题。 </span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">确定   </span><br><span class=\"line\">---------------------------</span><br></pre></td></tr></table></figure>\n<p>检查目录下发现，确实只有个孤单的可执行程序，并没有那些依赖库。此时我们需要将所有的依赖文件全部复制到运行目录下，主要有以下几个部分需要拷贝：</p>\n<ul>\n<li>Resources</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/cef-resources.jpg\" alt=\"\"></p>\n<p>把<strong>Resources</strong>文件夹里面的所有文件和子文件夹复制到运行目录下。</p>\n<ul>\n<li>CEF依赖库文件</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/cef-runtime-dep-lib.jpg\" alt=\"\"></p>\n<p>将上图中<strong>除了两个lib库文件之外</strong>的组件拷贝到运行目录下。</p>\n<p>此时，我们的编译出来的运行目录如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/app-files-list.png\" alt=\"\"></p>\n<p>我们再次尝试运行该simple-cef，终于能够成功打开，然而<strong>再次</strong>不出意外的话，会看到一个白屏的浏览器窗口。<strong>首先会看到标题，然后转为对应的空白</strong>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/title-change-and-white-screen.gif\" alt=\"\"></p>\n<h3 id=\"运行问题：Check-failed-fallback-available-base-win-GetVersion-gt-base-win-Version-WIN8-1-vs-0\"><a href=\"#运行问题：Check-failed-fallback-available-base-win-GetVersion-gt-base-win-Version-WIN8-1-vs-0\" class=\"headerlink\" title=\"运行问题：Check failed: fallback_available == base::win::GetVersion() &gt; base::win::Version::WIN8 (1 vs. 0)\"></a>运行问题：Check failed: fallback_available == base::win::GetVersion() &gt; base::win::Version::WIN8 (1 vs. 0)</h3><p>上述白屏后，还会在运行目录下会看到一个名为<code>debug.log</code>的文件，打开检查内容。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/debug-log-error.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; debug.log</span><br><span class=\"line\">[0124&#x2F;113454.346:INFO:content_main_runner_impl.cc(976)] Chrome is running in full browser mode.</span><br><span class=\"line\">[0124&#x2F;113454.488:FATAL:dwrite_font_proxy_init_impl_win.cc(91)] Check failed: fallback_available &#x3D;&#x3D; base::win::GetVersion() &gt; base::win::Version::WIN8 (1 vs. 0)</span><br><span class=\"line\">[0124&#x2F;113454.545:FATAL:dwrite_font_proxy_init_impl_win.cc(91)] Check failed: fallback_available &#x3D;&#x3D; base::win::GetVersion() &gt; base::win::Version::WIN8 (1 vs. 0)</span><br></pre></td></tr></table></figure>\n<p>该错误的关键字：CEF base::win::GetVersion() &gt; base::win::Version::WIN8。这里能够得到一个CEF官方论坛的解答：<a href=\"https://magpcss.org/ceforum/viewtopic.php?t=14721&amp;start=10\">CEF Forum  Check failed: fallback_available (magpcss.org)</a>。简单来说，浏览器程序无法加载manifest文件从而无法处理操作系统的版本问题。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ol>\n<li>创建manifest文件放在项目根目录下</li>\n</ol>\n<p>在<strong>项目根目录下</strong>创建一个manifest文件：<strong>simple-cef.manifest</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;assembly xmlns&#x3D;&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion&#x3D;&quot;1.0&quot;&gt;  </span><br><span class=\"line\">  &lt;compatibility xmlns&#x3D;&quot;urn:schemas-microsoft-com:compatibility.v1&quot;&gt;  </span><br><span class=\"line\">    &lt;application&gt; </span><br><span class=\"line\">      &lt;!--The ID below indicates application support for Windows 8.1 --&gt;  </span><br><span class=\"line\">      &lt;supportedOS Id&#x3D;&quot;&#123;1f676c76-80e1-4239-95bb-83d0f6d0da78&#125;&quot;&#x2F;&gt;  </span><br><span class=\"line\">      &lt;!-- 10.0 --&gt;  </span><br><span class=\"line\">      &lt;supportedOS Id&#x3D;&quot;&#123;8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a&#125;&quot;&#x2F;&gt; </span><br><span class=\"line\">    &lt;&#x2F;application&gt; </span><br><span class=\"line\">  &lt;&#x2F;compatibility&gt; </span><br><span class=\"line\">&lt;&#x2F;assembly&gt;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>为项目添加上述manifest</li>\n</ol>\n<p>打开项目的属性，找到<strong>Manifest Tool —— Input and Output —— Additional Manifest Files</strong>，选择项目根目录下的<strong>simple-cef.manifest</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/add-my-manifest.png\" alt=\"\"></p>\n<p>保存后，我们再次构建项目并运行我们的simple-cef.exe，终于看到了期待已久的页面：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/simple-cef-demo-show.gif\" alt=\"\"></p>\n<h2 id=\"写在结尾\"><a href=\"#写在结尾\" class=\"headerlink\" title=\"写在结尾\"></a>写在结尾</h2><p>在不断的踩坑下，我们终于得到了一个网络页面，不过这并不意味着我们的使用CEF之旅就结束了，恰恰相反，通过这个Demo，我们接触到了更多的东西，有CefApp、CefClient类，有CefBrowserProcessHandler等等，这些类是干什么的？CefWindowDelegate、CefBrowserViewDelegate这里些CEF框架提供的窗体GUI代理又是怎样的概念？CEF跨平台的实现策略又是怎样的呢？问题只增不减，本人也会就着这些问题继续探索并给出总结。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><p><a href=\"https://github.com/w4ngzhen/simple-cef\">w4ngzhen/simple-cef (github.com)</a></p>\n<p>PS：在改源码中，没有将上述的cef相关库以及include文件放在源码库中，因为静态库超过了大小。请读者自行编译并按照指定的方式添加。</p>\n","categories":[],"tags":["cef"]},{"title":"使用CEF（1）— 起步","url":"http://compilemind.com/2021/01/12/2021-01-12-使用CEF（1）— 起步/","content":"<h1 id=\"使用CEF（1）—-起步\"><a href=\"#使用CEF（1）—-起步\" class=\"headerlink\" title=\"使用CEF（1）— 起步\"></a>使用CEF（1）— 起步</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Chromium Embedded Framework (CEF)是个基于Google Chromium项目的开源Web browser控件，支持Windows, Linux, Mac平台。除了提供C/C++接口外，也有其他语言的移植版。</p>\n<p>因为基于Chromium，所以CEF支持<a href=\"https://baike.baidu.com/item/Webkit\">Webkit</a> &amp; Chrome中实现的<a href=\"https://baike.baidu.com/item/HTML5\">HTML5</a>的特性，并且在性能上面，也比较接近Chrome。</p>\n<a id=\"more\"></a>\n<h2 id=\"CEF架构\"><a href=\"#CEF架构\" class=\"headerlink\" title=\"CEF架构\"></a>CEF架构</h2><p><a href=\"http://dev.chromium.org/developers/design-documents/multi-process-architecture\">Chromium架构文档</a></p>\n<h2 id=\"libcef-dll-wrapper\"><a href=\"#libcef-dll-wrapper\" class=\"headerlink\" title=\"libcef_dll_wrapper\"></a>libcef_dll_wrapper</h2><p>在网上，大多数所谓编译CEF的教程，实际上只是编译针对CEF源码的C++包装库：<strong>libcef_dll_wrapper</strong>，并不是真正的编译CEF。libcef动态链接库导出 C API 使得使用者不用关心CEF运行库和基础代码。libcef_dll_wrapper 工程把 C API 封装成 C++ API同时包含在客户端应用程序工程中。C/C++ API的转换层代码是由转换工具自动生成。实际上，想要编译CEF源码是一件非常麻烦的事情，你需要梯子、良好的网速以及不错的电脑。回归正题，我们开始编译libcef_dll_wrapper。</p>\n<h3 id=\"编译前准备\"><a href=\"#编译前准备\" class=\"headerlink\" title=\"编译前准备\"></a>编译前准备</h3><p>cmake：<a href=\"https://cmake.org/download/\">https://cmake.org/download/</a></p>\n<p>vs2019：<a href=\"https://visualstudio.microsoft.com/zh-hans/vs/\">https://visualstudio.microsoft.com/zh-hans/vs/</a></p>\n<p>CEF以及Wrapper源码：<a href=\"https://cef-builds.spotifycdn.com/index.html\">https://cef-builds.spotifycdn.com/index.html</a></p>\n<h3 id=\"下载libcef以及wrapper\"><a href=\"#下载libcef以及wrapper\" class=\"headerlink\" title=\"下载libcef以及wrapper\"></a>下载libcef以及wrapper</h3><p>我们首先从CDN上下载ceflib静态库以及wrapper源码：Windows64bit，标准分发（Standard Distribution）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/download-cef.jpg\" alt=\"\"></p>\n<p>下载完成后，我们解压到工作目录下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/cef-decompression-dir.jpg\" alt=\"\"></p>\n<p>在这个目录下，会看到很多的文件夹和目录。其中主要的几个文件夹：</p>\n<ul>\n<li><p><strong>cmake</strong>：该目录下存放了配置和构建以Windows作为编译环境的cmake配置文件，具体内容可以自行查看。</p>\n</li>\n<li><p><strong>Debug和Release</strong>：这两个文件夹中，打开会看到已经编译好的CEF核心库文件：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/libcef-files.jpg\" alt=\"\"></p>\n<ul>\n<li><strong>include</strong>：libcef本身提供的头文件以及wrapper会使用到的头文件。</li>\n<li><p><strong>libcef_dll</strong>：存放了<strong>libcef_dll_wrapper</strong>源码。</p>\n</li>\n<li><p><strong>Resources</strong>：CEF作为内核的浏览器运行时需要用到的资源文件。</p>\n</li>\n<li><strong>tests</strong>：存放了利用libcef、以及wrapper作为库来编写的浏览器Demo。其中，cefsimple编译出来的是一个简单的浏览器，而cefclient编译出来的是一个展示了cef许多API功能的exe。</li>\n</ul>\n<h3 id=\"使用cmake进行配置构建\"><a href=\"#使用cmake进行配置构建\" class=\"headerlink\" title=\"使用cmake进行配置构建\"></a>使用cmake进行配置构建</h3><p>打开cmake-gui.exe程序，在<code>Where is the source code</code>栏中选择源码所在目录，在下方的<code>Where to build the binaries</code>栏目中我们可以自定义任意位置，但是为了方便管理，我们选择在源码所在目录下增加一个build文件夹，所以综合来看，当前cmake-gui的配置为：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/cmakegui-config.jpg\" alt=\"\"></p>\n<p>接下来我们直接点击下方的<code>Configure</code>按钮，cmake-gui会弹框提示没有build文件夹，会帮助你ui创建一个build文件夹，以及让你选择构建工具：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/create-build-dir.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/select-vs.jpg\" alt=\"\"></p>\n<p>完成配置后，我们进行cmake的生成操作（Generate），并打开该解决方案：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/generate-and-open.jpg\" alt=\"\"></p>\n<h3 id=\"编译libcef-dll-wrapper\"><a href=\"#编译libcef-dll-wrapper\" class=\"headerlink\" title=\"编译libcef_dll_wrapper\"></a>编译libcef_dll_wrapper</h3><p>上述使用cmake配置构建后，在Windows下，我们得到了一个解决方案：cef.sln。使用vs2019打开后，我们会看到解决方案中已经存在了几个工程：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/projects-in-sln.jpg\" alt=\"\"></p>\n<ul>\n<li><strong>ALL_BUILD与ZERO_CHECK</strong>：是cmake自动生成的辅助工程。</li>\n<li><strong>cef_gtest与ceftests</strong>：都是测试模块,这里不关心。</li>\n<li><strong>cefclient</strong>：一个包含CEF各种API演示的浏览器程序Demo。</li>\n<li><strong>cefsimple</strong>：一个简单的CEF浏览器程序Demo。</li>\n<li><strong>libcef_dll_wrapper</strong>：对libcef库的C++代码封装。上述cefclient与cefsimple都会用它。</li>\n</ul>\n<p>我们首先完成libcef_dll_wrapper的编译，然后对cefclient以及cefsimple完成编译。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2&gt;libcef_dll_wrapper.vcxproj -&gt; D:\\Projects\\cef\\cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64\\build\\libcef_dll_wrapper\\Debug\\libcef_dll_wrapper.lib</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Build: 2 succeeded, 0 failed, 0 up-to-date, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt;   Creating library D:&#x2F;Projects&#x2F;cef&#x2F;cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64&#x2F;build&#x2F;tests&#x2F;cefsimple&#x2F;Debug&#x2F;cefsimple.lib and object D:&#x2F;Projects&#x2F;cef&#x2F;cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64&#x2F;build&#x2F;tests&#x2F;cefsimple&#x2F;Debug&#x2F;cefsimple.exp</span><br><span class=\"line\">1&gt;cefsimple.vcxproj -&gt; D:\\Projects\\cef\\cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64\\build\\tests\\cefsimple\\Debug\\cefsimple.exe</span><br><span class=\"line\">1&gt;Adding manifest...</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Build: 1 succeeded, 0 failed, 2 up-to-date, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt;   Creating library D:&#x2F;Projects&#x2F;cef&#x2F;cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64&#x2F;build&#x2F;tests&#x2F;cefclient&#x2F;Debug&#x2F;cefclient.lib and object D:&#x2F;Projects&#x2F;cef&#x2F;cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64&#x2F;build&#x2F;tests&#x2F;cefclient&#x2F;Debug&#x2F;cefclient.exp</span><br><span class=\"line\">1&gt;cefclient.vcxproj -&gt; D:\\Projects\\cef\\cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64\\build\\tests\\cefclient\\Debug\\cefclient.exe</span><br><span class=\"line\">1&gt;Adding manifest...</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Build: 1 succeeded, 0 failed, 2 up-to-date, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<p>完成了编译以后，我们可以直接进入cefclient或者是cefsimple里面的输出中运行对应的浏览器程序：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/demo-show.jpg\" alt=\"\"></p>\n<p>注意，cefsimple.exe打开白屏是因为demo代码中默认访问的Google，cefclient.exe其实默认也访问的Google，但是因为可以输入任意的地址，所以这里不太容易发现。</p>\n<p>cefsimple中的默认访问地址修改为国内即可（cefclient中的自行搜索）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/change-init-url.jpg\" alt=\"\"></p>\n<p>下一节，将从零开始，使用cef来编写一个简单Demo。</p>\n","categories":[],"tags":["cef"]},{"title":"node-pre-gyp以及node-gyp的源码简单解析（以安装sqlite3为例）","url":"http://compilemind.com/2020/11/27/2020-11-27-node-pre-gyp以及node-gyp的源码简单解析（以安装sqlite3为例）/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>简单来说，node是跨平台的，那么对于任何的node模块理论也是应该是跨平台的。然而，有些node模块直接或间接使用原生C/C++代码，这些东西要跨平台，就需要使用源码根据实际的操作平台环境进行原生模块编译。SQLite3就是一个经典的原生模块，让我们以安装该模块为例，探索一下安装原生模块的流程。</p>\n<a id=\"more\"></a>\n<h1 id=\"项目建立\"><a href=\"#项目建立\" class=\"headerlink\" title=\"项目建立\"></a>项目建立</h1><p>建立一个简单的node项目，我们开始安装<code>SQLite3</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir sqlite3-install-demo </span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> sqlite3-install-demo</span><br><span class=\"line\">$ npm init</span><br><span class=\"line\"><span class=\"comment\"># 初始化项目</span></span><br><span class=\"line\">Press ^C at any time to quit.</span><br><span class=\"line\">package name: (projects) sqlite3-install-demo</span><br><span class=\"line\">version: (1.0.0)</span><br><span class=\"line\">description:</span><br><span class=\"line\">entry point: (index.js)</span><br><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"built_in\">command</span>:</span><br><span class=\"line\">git repository:</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author:</span><br><span class=\"line\">license: (ISC) MIT</span><br><span class=\"line\">About to write to D:\\Projects\\package.json:</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;sqlite3-install-demo&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;version&quot;</span>: <span class=\"string\">&quot;1.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;description&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;main&quot;</span>: <span class=\"string\">&quot;index.js&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;test&quot;</span>: <span class=\"string\">&quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;author&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;license&quot;</span>: <span class=\"string\">&quot;MIT&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装SQLite3\"><a href=\"#安装SQLite3\" class=\"headerlink\" title=\"安装SQLite3\"></a>安装<code>SQLite3</code></h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -S sqlite3</span><br></pre></td></tr></table></figure>\n<p>完成命令执行后，你会看到命令行界面出现了如下的几行<strong>重要</strong>的输出：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&gt; sqlite3@5.0.0 install D:\\Projects\\sqlite3-install-demo\\node_modules\\sqlite3</span><br><span class=\"line\">&gt; node-pre-gyp install --fallback-to-build</span><br><span class=\"line\"></span><br><span class=\"line\">node-pre-gyp WARN Using request <span class=\"keyword\">for</span> node-pre-gyp https download</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>啪一下，很快啊！我们就迎来了第一个东西<code>node-pre-gyp</code>，但是提到了<code>node-pre-gyp</code>，我们不得不提及<code>node-gyp</code>，然后又不得不提及<code>gyp</code>。</p>\n<h1 id=\"gyp与node-gyp与node-pre-gyp\"><a href=\"#gyp与node-gyp与node-pre-gyp\" class=\"headerlink\" title=\"gyp与node-gyp与node-pre-gyp\"></a>gyp与node-gyp与node-pre-gyp</h1><h2 id=\"什么是gyp？\"><a href=\"#什么是gyp？\" class=\"headerlink\" title=\"什么是gyp？\"></a>什么是gyp？</h2><p>gyp全称<code>Generate Your Projects</code>（构建你的项目）。wiki的解释如下，自行翻译：</p>\n<blockquote>\n<p>GYP (generate your projects) is a build automation tool. GYP was created by Google to generate native IDE project files (such as Visual Studio Code and Xcode) for building the Chromium web browser and is licensed as open source software using the BSD software license.</p>\n</blockquote>\n<p>重点在于，它是一套用于生成原生IDE项目文件的自动化构建工具，处理C/C++项目，同类型的有CMake、ninja等自动构建工具。</p>\n<h2 id=\"什么是node-gyp？\"><a href=\"#什么是node-gyp？\" class=\"headerlink\" title=\"什么是node-gyp？\"></a>什么是node-gyp？</h2><p>直接给出<code>stackoverflow</code>高票回答：</p>\n<blockquote>\n<p><code>node-gyp</code> is a tool which compiles Node.js Addons. Node.js Addons are native Node.js Modules, written in C or C++, which therefore need to be compiled on your machine. After they are compiled with tools like node-gyp, their functionality can be accessed via <code>require()</code>, just as any other Node.js Module.</p>\n</blockquote>\n<p>简单来说，node是跨平台的，那么对于任何的node模块理论也是应该是跨平台的。然而，有些node模块直接或间接使用原生C/C++代码，这些东西要跨平台，就需要使用源码根据实际的操作平台环境进行原生模块编译。那么我们需要下载源码文件，通过node-gyp生成一定结构的代码项目让我们能够<code>require</code>引入（譬如，Windows下会生成<code>vcxproj</code>，再调用<code>MSBuild</code>进行编译，以生成Windows下的动态链接库，最后打包为一个原生node模块）。这个知乎回答的每一条可以看看：<a href=\"https://www.zhihu.com/question/36291768\">传送门</a>。</p>\n<h2 id=\"什么是node-pre-gyp？\"><a href=\"#什么是node-pre-gyp？\" class=\"headerlink\" title=\"什么是node-pre-gyp？\"></a>什么是node-pre-gyp？</h2><p>上面<code>node-gyp</code>固然相当方便了，但是每一次安装node原生模块的时候，都需要根据平台（Windows、Linux、macOS以及对应的x86、x64、arm64等等）进行源码编译，这样做费时费力。为什么不一开始就针对这些平台编译好了做成二进制制品发布呢？反正一般来说主流的平台架构就那么一些（Windows、Linux、macOS）。所以<code>node-pre--gyp</code>就帮我们做了这件事。原生模块开发者将代码编译生成各个平台架构的二进制包直接发布到<code>node-pre-gyp</code>上，当我们的node项目安装原生模块时候。处理流程就是首先去<code>node-pre-gyp</code>上找有没有当前平台的组件包，有的话直接拉取使用，如果没有则进行原生编译。</p>\n<p><code>node-pre-gyp</code>一些<strong>重要参数</strong>（不全）：</p>\n<ul>\n<li><code>-C/--directory</code>: run the command in this directory</li>\n<li><code>--build-from-source</code>: build from source instead of using pre-built binary</li>\n<li><code>--fallback-to-build</code>: fallback to building from source if pre-built binary is not available</li>\n<li><code>--target=0.4.0</code>: Pass the target node or node-webkit version to compile against</li>\n<li><code>--target_arch=ia32</code>: Pass the target arch and override the host <code>arch</code>. Valid values are ‘ia32’,’x64’, or <code>arm</code>.</li>\n<li><code>--target_platform=win32</code>: Pass the target platform and override the host <code>platform</code>. Valid values are <code>linux</code>, <code>darwin</code>, <code>win32</code>, <code>sunos</code>, <code>freebsd</code>, <code>openbsd</code>, and <code>aix</code>.</li>\n</ul>\n<p>对于<code>--fallback-to-build</code>这个参数：如果二进制不可获取则直接从源码编译，即从<code>node-pre-gyp</code>又回到<code>node-gyp</code>。所以你才会在上文看到安装sqlite3的时候，会有<code>--fallback-to-build</code>。</p>\n<p>于是乎，当我们进行node原生模块安装的时候，一般会有如下的流程：</p>\n<ol>\n<li>针对当前平台架构优先考虑<code>node-pre-gyp</code>方式进行安装，但是为了防止无法获取针对对应平台编译好的二进制包（网络原因、暂时没有对应平台的二进制包），进入第2步；</li>\n<li>下载原生模块源码，然后使用<code>node-gyp</code>进行项目构建，得到与平台相关的源码项目文件（Windows则生成<code>vcxproj</code>项目，Linux下是<code>Makefile</code>）；在这个过程，<code>node-gyp</code>会使用<code>Python</code>进行自动化构建操作，这也是为什么有些朋友安装node原生模块的时候，会报错找不到<code>Python</code>。</li>\n<li>调用平台对应的编译工具进行编译。在Windows的环境下，<code>node-gyp</code>会查找本地的<code>MSBuild/CL</code>等编译工具，而这些编译工具又一般在<code>Visual Studio</code>安装的时候，也一并安装在了机器上。这就是为什么有些朋友没有安装<code>Visual Studio</code>的时候，会报错。</li>\n</ol>\n<h1 id=\"探索SQLite3的安装流程\"><a href=\"#探索SQLite3的安装流程\" class=\"headerlink\" title=\"探索SQLite3的安装流程\"></a>探索SQLite3的安装流程</h1><h2 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a><code>npm install</code></h2><p>为什么我们安装<code>sqlite3</code>的时候，会调用<code>node-pre-gyp</code>命令呢？进入<code>项目目录/node_modules/sqlite3/</code>文件夹，让我们查看一下<code>package.json</code>中的<code>scripts</code>部分：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">    &quot;url&quot;: &quot;git://github.com/mapbox/node-sqlite3.git&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;install&quot;: &quot;node-pre-gyp install --fallback-to-build&quot;, // install</span><br><span class=\"line\">    &quot;pack&quot;: &quot;node-pre-gyp package&quot;,</span><br><span class=\"line\">    &quot;pretest&quot;: &quot;node test/support/createdb.js&quot;,</span><br><span class=\"line\">    &quot;test&quot;: &quot;mocha -R spec --timeout 480000&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;5.0.0&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案显而易见了，<code>install</code>脚本中执行了<code>node-pre-gyp install --fallback-to-build</code>命令。</p>\n<p>这就不得不提到<code>npm</code>的安装流程是。当我们进行<code>npm install xxx</code>的时候，<code>npm</code>首先下载<code>xxx</code>的包。下载完成后，若<code>package.json</code>中的scripts中存在<code>install</code>属性，则会立刻调用。至于<code>scripts</code>中的其他固定脚本：<code>test</code>、<code>preinstall</code>、<code>postinstall</code>等等作用以及<code>scripts</code>的高级用法，请直接查阅<a href=\"https://docs.npmjs.com/cli/v6/using-npm/scripts\">scripts | npm Docs (npmjs.com)</a>。</p>\n<p>所以本此<code>sqlite3</code><strong>前期</strong>安装的过程为：</p>\n<ol>\n<li><code>npm</code>下载在仓库中的<code>sqlite3</code>npm包；</li>\n<li>执行<code>$&#123;your_projects&#125;/node_modules/sqlite3/package.json</code>中的<code>install</code>脚本，即<code>node-pre-gyp install --fallback-to-build</code></li>\n</ol>\n<p>于是乎，安装进入到了一个新的环节：<code>node-pre-gyp install</code>。当然，若你没有全局安装<code>node-pre-gyp</code>，它会由<code>npm</code>帮你安装到<code>$&#123;your_projects&#125;/node_modules/</code>中，并且通过<code>node-pre-gyp/package.json</code>中的<code>bin</code>元素，建立软连接到<code>$&#123;your_projects&#125;/node_modules/.bin</code>中。这样，<code>node\\npm</code>环境中就有了<code>node-pre-gyp</code>命令可以使用。至于<code>package.json#bin</code>的作用，详细参考官方文档<a href=\"https://docs.npmjs.com/cli/v6/configuring-npm/package-json#bin\">package.json | npm Docs (npmjs.com)</a>。</p>\n<h2 id=\"node-pre-gyp-install\"><a href=\"#node-pre-gyp-install\" class=\"headerlink\" title=\"node-pre-gyp install\"></a><code>node-pre-gyp install</code></h2><p><code>node-pre-gyp</code>在上述的安装流程中，已经能够被我们在CLI中所使用。查看<code>node_modules/node-pre-gyp/bin/node-pre-gyp</code>文件（下文都将省略<code>$&#123;your_projects&#125;/</code>），用文本的形式打开。就是<code>node-pre-gyp</code>CLI的执行过程，脚本中的主要内容为最后一行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// start running the given commands!</span><br><span class=\"line\">run();</span><br></pre></td></tr></table></figure>\n<p>检查该函数的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> command = prog.todo.shift();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!command) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// done!</span></span><br><span class=\"line\">    completed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    log.info(<span class=\"string\">&#x27;ok&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  prog.commands[command.name](command.args, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      log.error(command.name + <span class=\"string\">&#x27; error&#x27;</span>);</span><br><span class=\"line\">      log.error(<span class=\"string\">&#x27;stack&#x27;</span>, err.stack);</span><br><span class=\"line\">      errorMessage();</span><br><span class=\"line\">      log.error(<span class=\"string\">&#x27;not ok&#x27;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err.message);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> process.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args_array = [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args_array.length) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, args_array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// now run the next command in the queue</span></span><br><span class=\"line\">    process.nextTick(run);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>prog</code>是什么？该文件往上查看定义，原来是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node_pre_gyp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../&#x27;</span>); <span class=\"comment\">// 上一个目录作为模块引入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> log = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;npmlog&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Process and execute the selected commands.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> prog = <span class=\"keyword\">new</span> node_pre_gyp.Run(); <span class=\"comment\">// 来自于node_pre_gyp中的Run，而node_pre_gyp在上方</span></span><br></pre></td></tr></table></figure>\n<p>继续检查上一个目录，发现并没又<code>indes.js</code>文件，熟悉<code>npm</code>的朋友应该知道要去看<code>package.json</code>中的<code>main</code>元素了：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">\t&quot;license&quot;: &quot;BSD-3-Clause&quot;,</span><br><span class=\"line\">\t&quot;main&quot;: &quot;./lib/node-pre-gyp.js&quot;, // 模块是这个文件</span><br><span class=\"line\">\t&quot;name&quot;: &quot;node-pre-gyp&quot;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>查阅<code>lib/node-pre-gyp.js</code>代码中的Run：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.commands = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  commands.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">command</span>) </span>&#123;</span><br><span class=\"line\">    self.commands[command] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argv, callback</span>) </span>&#123;</span><br><span class=\"line\">      log.verbose(<span class=\"string\">&#x27;command&#x27;</span>, command, argv);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./&#x27;</span> + command)(self, argv, callback); <span class=\"comment\">// 这里是核心</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>核心功能就是引入当前所在目录下的模块进行执行。例如，本次调用的是<code>node-pre-gyp install</code>，则会<code>require(./install)</code>，检查一下<code>node-pre-gyp.js</code>目录下，果然存在该<code>js</code>文件。继续阅读<code>install.js</code>源码。里面有几个函数的定义。咱们先不看内容，把函数名列举出来，猜测一下作用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 去下载平台编译好的二进制？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">download</span>(<span class=\"params\">uri,opts,callback</span>) </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">// 把下载好的二进制放到对应目录？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">place_binary</span>(<span class=\"params\">from,to,opts,callback</span>) </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">// 进行构建。难道是没有下载，就调用node-gyp源码编译？</span></span><br><span class=\"line\"><span class=\"comment\">// 还有，node-pre-gyp又--fallback-to-build参数，也会调用这个？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do_build</span>(<span class=\"params\">gyp,argv,callback</span>) </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">// 打印回退出现的异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print_fallback_error</span>(<span class=\"params\">err,opts,package_json</span>) </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">// 安装，核心没跑了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span>(<span class=\"params\">gyp, argv, callback</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>首先看<code>download</code>的调用点是在<code>place_binary</code>中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">place_binary</span>(<span class=\"params\">from,to,opts,callback</span>) </span>&#123; <span class=\"comment\">// place_binary函数</span></span><br><span class=\"line\">    download(<span class=\"keyword\">from</span>,opts,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,req</span>) </span>&#123; <span class=\"comment\">// 调用了download</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!req) <span class=\"keyword\">return</span> callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;empty req&quot;</span>));</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看<code>place_binary</code>调用点是在<code>install</code>中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span>(<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 省略部分...</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> should_do_source_build = source_build === package_json.name || (source_build === <span class=\"literal\">true</span> || source_build === <span class=\"string\">&#x27;true&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (should_do_source_build) &#123; <span class=\"comment\">// 源码编译</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&#x27;build&#x27;</span>,<span class=\"string\">&#x27;requesting source compile&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> do_build(gyp,argv,callback);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 省略部分...</span></span><br><span class=\"line\">        mkdirp(to,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">\t\t\t\tafter_place(err);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tplace_binary(<span class=\"keyword\">from</span>,to,opts,after_place); <span class=\"comment\">// 调用点</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 省略部分...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 省略部分...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述分析，整个大的处理流程如下：</p>\n<ol>\n<li>进入<code>install</code>函数</li>\n<li>检查是否需要<code>build-from-source</code>。是则进，入<code>do_build</code>分支，进行源码编译；否则进入步骤3。</li>\n<li>检查是否启用<code>--fallback-to-build</code>参数，设定是否启用标志位。</li>\n<li>解析编译好的二进制文件的选项配置，譬如二进制文件存放地址，也就是通过请求下载对应二进制包的地址，以及各种各样参数。所以说，为什么下载很慢，我们后文会重点关注下载地址。</li>\n</ol>\n<h3 id=\"下载二进制包\"><a href=\"#下载二进制包\" class=\"headerlink\" title=\"下载二进制包\"></a>下载二进制包</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/hosted_tarball_download.png\" alt=\"\"></p>\n<p>根据流程，接下来我们进一步检查<code>versioning.js</code>文件，找到其中的<code>evaluate</code>函数，分析最后的<code>hosted_tarball</code>路径：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/analysis_hosted_path.png\" alt=\"\"></p>\n<p><code>hosted_tarball</code>路径主要分为两个部分：1、<code>hosted_path</code>；2、<code>package_name</code>。</p>\n<h4 id=\"hosted-path\"><a href=\"#hosted-path\" class=\"headerlink\" title=\"hosted_path\"></a>hosted_path</h4><p>经过源码分析来源路径为：</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/opts.hosted_path-analysis.png\" alt=\"\"></p>\n<p>我们自底向上分析。</p>\n<p><code>host</code>变量取决于从环境变量中检查名称为<code>&#39;npm_config_&#39; + opts.module_name + &#39;_binary_host_mirror&#39;</code>的环境变量。如果不存在，则使用<code>package_json.binary.host</code>。正常使用的时候，我们并不会设定环境变量，所以这里就进入<code>package_json.binary</code>进行获取。这个<code>package_json</code>是<code>evaluate</code>函数被调用时候传入的，在<code>node-pre-gyp/install.js</code>中能够看到：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/import-gyp.png\" alt=\"\"></p>\n<p>一开始分析的时候，看到这里，本人以为<code>package_json</code>就是<code>node-pre-gyp/package.json</code>，于是本人去检查该<code>json</code>发现很奇怪，并没有binary属性，更别提host了。一番思考才明白，<code>node-pre-gyp install</code>的运行时调用者是谁呀？不是应该是<code>sqlite3</code>吗？所以这个地方的<code>require(&#39;./package.json&#39;)</code>实际上是指代的是<code>sqlite3/package.json</code>。查看<code>sqlite3/package.json</code>，果然发现了对应的元素：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/sqlite3-binary.png\" alt=\"\"></p>\n<p>在<code>binary</code>属性中，我们还能看到<code>remote_path</code>也在其中。</p>\n<p>至此，<code>hosted_path</code>我们完成了简单的分析，我们可以得出一个结论：</p>\n<p><strong><code>node-pre-gyp</code>下载二进制文件的路径，优先来源于对应模块的镜像地址，该镜像地址通过配置<code>&#39;npm_config_&#39; + 模块名 + &#39;_binary_host_mirror&#39;</code>来实现自定义；在没有定义镜像地址的情况下，读取模块<code>package.json</code>中的binary属性信息。</strong></p>\n<p>当然，读者可以根据具体情况再进一步分析源码。</p>\n<h4 id=\"package-name\"><a href=\"#package-name\" class=\"headerlink\" title=\"package_name\"></a>package_name</h4><p>其实，对于<code>hosted_path</code>的分析，我们也容易分析<code>package_name</code>了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/opts.package_name-analysis.png\" alt=\"\"></p>\n<p>自底向上分析，来自于<code>sqlite3/package.json</code>中<code>binary</code>属性中的<code>package_name</code>，内容见上图分析<code>host</code>。</p>\n<h4 id=\"失败处理\"><a href=\"#失败处理\" class=\"headerlink\" title=\"失败处理\"></a>失败处理</h4><p><code>--fallback-to-build</code>参数表明了是否进行失败后下载源码进行编译，源码不再分析。</p>\n<h3 id=\"从源码构建\"><a href=\"#从源码构建\" class=\"headerlink\" title=\"从源码构建\"></a>从源码构建</h3><h4 id=\"build-js\"><a href=\"#build-js\" class=\"headerlink\" title=\"build.js\"></a>build.js</h4><p>当我们提供了参数<code>--build-from-source</code>或是在下载编译好的二进制到本地出错的时提供了参数<code>--fallback-to-build</code>。node-pre-gyp将进入<code>do_build</code>模块，进行源码编译。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function do_build(gyp,argv,callback) &#123;</span><br><span class=\"line\">  var args &#x3D; [&#39;rebuild&#39;].concat(argv);</span><br><span class=\"line\">  gyp.todo.push( &#123; name: &#39;build&#39;, args: args &#125; );</span><br><span class=\"line\">  process.nextTick(callback);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码中，<code>gyp</code>由调用install的时候，传入：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/gyp-from-install.png\" alt=\"\"></p>\n<p>那么我们又将回到调用install的地方。实际上，gyp就是node-pre-gyp.js导出的模块：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/node-pre-gyp-export.png\" alt=\"\"></p>\n<p>也就是说在<code>do_build</code>中进行操作就是，放置了一个<code>build</code>任务在队列中。所以我们按照先前的分析，直接去看<code>build.js</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/build-buildjs.png\" alt=\"\"></p>\n<p>看源码调用了当前模块中的<code>do_build</code>，且其中最核心的就是<code>compile</code>模块：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/do_build-buildjs.png\" alt=\"\"></p>\n<h4 id=\"util-compile-js\"><a href=\"#util-compile-js\" class=\"headerlink\" title=\"util/compile.js\"></a>util/compile.js</h4><p>进入compile模块，直接找到对应的<code>run_gyp</code>函数，代码很短，不难看出进行构建调用了<code>node-gyp</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/run-gyp.png\" alt=\"\"></p>\n<p>上述代码，会先考略<code>node-webkit</code>构建。但是我们核心的还是使用<code>node-gyp</code>，所以else中，会进行<code>node-gyp</code>的工具的检查工作。最后调用命令行执行<code>node-gyp</code>。于是，node原生模块的安装工作，进入了新的阶段：<code>node-gyp</code>。</p>\n<h2 id=\"node-gyp-build\"><a href=\"#node-gyp-build\" class=\"headerlink\" title=\"node-gyp build\"></a><code>node-gyp build</code></h2><p>上文提到我们已经进入了<code>node-gyp</code>的范畴，会调用<code>node-gyp build</code>操作。当然，这个命令同样是在安装<code>node-gyp</code>依赖的时候已经完成了安装，并且进行<code>node_modules/.bin/</code>软连接操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"string\">&quot;bin&quot;</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;node-gyp&quot;</span>: <span class=\"string\">&quot;bin/node-gyp.js&quot;</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>我们进入该<code>js</code>进行分析</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/node-gyp-GYP.png\" alt=\"\"></p>\n<p>实际上，<code>node-gyp</code>这段的命令行代码，和<code>node-pre-gyp</code>非常相似！所以我们也不去深入分析调用命令行了。直接在lib文件夹下面的<code>build.js</code>。在该<code>js</code>中，核心的方法为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build</span> (<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在该方法中，还编写了几个<strong>内部函数</strong>，作为了功能的划分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// function build (gyp, argv, callback) 内部函数</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Load the &quot;config.gypi&quot; file that was generated during &quot;configure&quot;.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadConfigGypi</span> (<span class=\"params\"></span>) </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * On Windows, find the first build/*.sln file.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findSolutionFile</span> (<span class=\"params\"></span>) </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Uses node-which to locate the msbuild / make executable.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doWhich</span> (<span class=\"params\"></span>) </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Search for the location of &quot;msbuild.exe&quot; file on Windows.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMsbuild</span> (<span class=\"params\"></span>) </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Actually spawn the process and compile the module.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doBuild</span> (<span class=\"params\"></span>) </span>&#123;...&#125;  </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Invoked after the make/msbuild command exits.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onExit</span> (<span class=\"params\">code, signal</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>不得不说，<code>build</code>写的真心不错，看起来很舒服。这里为了方便读者快速阅读，我整理这些函数的调用图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/node-gyp-build-flow.png\" alt=\"\"></p>\n<p>整个调用流程图个人认为足够进行安装的时候的一场分析了。至于每个内部函数的功能，有空继续更新本文吧。</p>\n","categories":[],"tags":["node","native","sqlite3"]},{"title":"再议Windows消息与WinForm事件","url":"http://compilemind.com/2020/10/13/2020-10-13-再议Windows消息与WinForm事件/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在2月份的时候，我之前曾经写过一篇关于Windows消息与C# WinForm事件机制的文章，名为《WinForm事件与消息》。在那篇文章中，我简单探讨了一下事件和消息。然而如今看来，当时的文章中的案例在运行上存在一定的问题，并且内容也有所缺陷，于是本文将重新优化文章的内容。</p>\n<a id=\"more\"></a>\n<h1 id=\"消息概述\"><a href=\"#消息概述\" class=\"headerlink\" title=\"消息概述\"></a>消息概述</h1><p>Windows下窗体应用程序的执行是通过消息驱动的。所有的外部事件，如键盘输入、鼠标移动、按动鼠标都由用户所触发；然后OS接收到对应的“消息”；然后送入消息队列中；接下来，启动的应用程序的工作引擎通过轮询等方式遍历获取，然后按照消息的类型逐个分发（Dispatch）到对应的组件（例如窗体、按钮等），最后才调用对应组件所注册的事件进行处理。</p>\n<h1 id=\"处理消息\"><a href=\"#处理消息\" class=\"headerlink\" title=\"处理消息\"></a>处理消息</h1><p>一般来说，使用WinForm技术进行开发，绝大部分的情况下，我们都在做上述流程的最后一件事情：给各种控件注册事件。毕竟，WinForm真的为我们封装了绝大部分的事件了。而通常的WinForm开发，我们都离不开一个东西：System.Windows.Forms.Application。</p>\n<h2 id=\"System-Windows-Forms-Application\"><a href=\"#System-Windows-Forms-Application\" class=\"headerlink\" title=\"System.Windows.Forms.Application\"></a>System.Windows.Forms.Application</h2><p>Application具有用于启动和停止应用程序和线程以及处理Windows消息的方法。例如，调用Run以启动当前线程上的应用程序消息循环，并可以选择使其窗体可见；调用Exit或ExitThread来停止消息循环。所以我们经常使用vs初始化一个基本的WinForm程序，显示的下列模板代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 应用程序的主入口点。</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">[<span class=\"meta\">STAThread</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Application.EnableVisualStyles();</span><br><span class=\"line\">    Application.SetCompatibleTextRenderingDefault(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    Application.Run(<span class=\"keyword\">new</span> Form1()); <span class=\"comment\">// 调用Run以启动当前线程上的应用程序消息循环</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为Application是在单线程中运行的，所以在Application.Run开始后，Application本身不断轮询检查消息队列，然后根据消息类型进行数据分发。例如，当我们为这个Form1增加一个鼠标的点击事件后，我们运行该打开Form1：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Form1 form1 = <span class=\"keyword\">new</span> Form1();</span><br><span class=\"line\">form1.MouseClick += </span><br><span class=\"line\">                (sender, e) =&gt; MessageBox.Show(<span class=\"string\">@&quot;MouseClick 1&quot;</span>);</span><br><span class=\"line\">form1.MouseClick += </span><br><span class=\"line\">                (sender, e) =&gt; MessageBox.Show(<span class=\"string\">@&quot;MouseClick 2&quot;</span>);</span><br><span class=\"line\">Application.Run(form1);</span><br></pre></td></tr></table></figure>\n<p>运行后点击Form，可以看到首先出现一个MessageBox，展示“MouseClick 1”，我们点击确定后，又会出现MessageBox，展示“MouseClick 2”。实际上整个过程应该如下：</p>\n<p>当我们按下鼠标左键后，消息形成并送往应用程序消息队列中，然后被Application类从应用程序消息队列中取出，然后分发到相应的窗体。窗体使用MouseClick事件中的函数指针调用已经添加的响应函数。所以C#中的事件字段实质上是一个函数指针列表，用来维护一些消息到达时的响应函数的地址。</p>\n<p>到目前为止我们可以看到，消息其实在我们进行事件调用的时候，已经被提取加工了，它已经由Application进行了预处理，形成了所谓的“事件调用”。那么，我们还能更加自定义的干预消息吗？答案是可以的。</p>\n<h2 id=\"WndProc\"><a href=\"#WndProc\" class=\"headerlink\" title=\"WndProc\"></a>WndProc</h2><p>在.NET框架类库中的System.Windows.Forms命名空间中微软采用面对对象的方式重新定义了Message。该消息主要有一下的几个公共属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.Windows.Forms.Message</span><br><span class=\"line\">HWnd     获取或设定消息的处理函数</span><br><span class=\"line\">Msg      获取或设定消息的ID号</span><br><span class=\"line\">Lparam   指定消息的LParam字段</span><br><span class=\"line\">Wparam   指定消息的WParam字段</span><br><span class=\"line\">Result   指定为响应消息处理函数而向OS系统返回的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"WndProc-1\"><a href=\"#WndProc-1\" class=\"headerlink\" title=\"WndProc\"></a>WndProc</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\"> &#x2F;&#x2F; 摘要:</span><br><span class=\"line\">&#x2F;&#x2F;     处理 Windows 消息。</span><br><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\">&#x2F;&#x2F; 参数:</span><br><span class=\"line\">&#x2F;&#x2F;   m:</span><br><span class=\"line\">&#x2F;&#x2F;     要处理的 Windows System.Windows.Forms.Message。</span><br><span class=\"line\">protected override void WndProc(ref System.Windows.Forms.Message e);</span><br></pre></td></tr></table></figure>\n<p>对于每个Form来说，我们都可以重写该方法，该方法的参数就是上面提到的Message类的实例，所有的消息在被获取后，正常情况下都会被封装为Message对象，然后由Application工作引擎调用对用的Form.WndProc传入该Messsage，由于Form子类重写了该方法，所以如果希望底层能处理相关的消息，需要通过base.WndProc传递到父类继续调用。下面就是一个代码示例来展示控制如果当前的消息是鼠标左键点击，则弹出MessageBox展示“WndProc MouseClick”：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">WndProc</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Message m</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> WM_LBUTTONDOWN = <span class=\"number\">0x0201</span>;<span class=\"comment\">// 鼠标左键点击</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.Msg == WM_LBUTTONDOWN)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBox.Show(<span class=\"string\">&quot;WndProc MouseClick&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">base</span>.WndProc(<span class=\"keyword\">ref</span> m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"IMessageFilter\"><a href=\"#IMessageFilter\" class=\"headerlink\" title=\"IMessageFilter\"></a>IMessageFilter</h3><p>除了上述的WndProc之外，其实更加便于处理应该的实现IMessageFilter接口，然后让Application将实现该接口的消息过滤器添加到Application中：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MyMessageFilter</span> : <span class=\"title\">IMessageFilter</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">PreFilterMessage</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Message m</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>     &#123;</span><br><span class=\"line\">         <span class=\"comment\">//返回值为true， 表示消息已被处理，不要再往后传递，因此消息被截获</span></span><br><span class=\"line\">         <span class=\"comment\">//返回值为false，表示消息未被处理，需要再往后传递，因此消息未被截获</span></span><br><span class=\"line\">         <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> WM_LBUTTONDOWN = <span class=\"number\">0x0201</span>;<span class=\"comment\">// 鼠标左键点击</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (m.Msg == WM_LBUTTONDOWN)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             MessageBox.Show(<span class=\"string\">&quot;MyMessageFilter MouseClick&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>编写完成后，在应用程序初始化的过程中，添加该过滤器：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application.AddMessageFilter(<span class=\"keyword\">new</span> MyMessageFilter());</span><br></pre></td></tr></table></figure>\n<p>同样的，我们启动应用程序并点击实验，可以看到正常的MessageBox输出。</p>\n","categories":[],"tags":["WinForm"]},{"title":"VirtualBox上安装Debian10","url":"http://compilemind.com/2020/09/29/2020-09-29-VirtualBox上安装Debian10/","content":"<p>本文将介绍如何使用VBox进行Debian10的安装<br><a id=\"more\"></a></p>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><h2 id=\"VirtualBox\"><a href=\"#VirtualBox\" class=\"headerlink\" title=\"VirtualBox\"></a>VirtualBox</h2><p>下载链接：<a href=\"https://www.virtualbox.org/wiki/Downloads\">Downloads – Oracle VM VirtualBox</a>，下载完成后安装即可。</p>\n<h2 id=\"Debian\"><a href=\"#Debian\" class=\"headerlink\" title=\"Debian\"></a>Debian</h2><p>下载链接：<a href=\"https://www.debian.org/CD/http-ftp/#stable\">通过 HTTP/FTP 下载 Debian CD/DVD 映像</a></p>\n<p>下载说明：</p>\n<p>从下载页面可以看到有两个介质的下载，如果你希望最大限度的离线安装的话，可以选择DVD版本</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/download-debian.png\" alt=\"\"></p>\n<p>这里本人选择CD介质中的amd64，进入后会看到下方有一系列的ISO，到底该下载哪个呢？其实在DVD介质页面里面已经给了说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">There are lots of files here! Do I need all of them?</span><br><span class=\"line\">In most cases it is not necessary to download and use all of these images to be able to install Debian on your computer. Debian comes with a massive set of software packages, hence why it takes so many disks for a complete set. Most typical users only need a small subset of those software packages.</span><br><span class=\"line\"></span><br><span class=\"line\">Initially, you will only need to download and use the first image of a set (labelled as debian-something-1 to be able to start the Debian installer and set up Debian on your computer. If there are more images available here (labelled debian-something-2, debian-something-3, etc.), they contain the extra packages that can be installed on a Debian system (as mentioned previously). They will not be bootable and are entirely optional. If you have a fast Internet connection, you&#39;re most likely better off installing any desired extra packages directly from the Debian mirrors on the Internet instead of by using these extra images.</span><br></pre></td></tr></table></figure>\n<p>简而言之，下载Debian-XXX-1.iso的即可，其他的都是可选包，可以通过网络下载。</p>\n<h1 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h1><h2 id=\"VirtualBox-1\"><a href=\"#VirtualBox-1\" class=\"headerlink\" title=\"VirtualBox\"></a>VirtualBox</h2><p>VirtualBox的安装没有什么特殊的处理，Python的支持可以去掉，然后安装路径按需放置。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/install-vbox.png\" alt=\"\"></p>\n<p>安装完成后，进入VirtualBox创建一个新的虚拟机：<strong>Machine -&gt; New</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/new-vm.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/new-vm-disk.png\" alt=\"\"></p>\n<p>接下来的进行<code>Create</code>，等待VirtualBox进行虚拟机的磁盘存储等初始化操作。这个过程的处理时间取决于工作电脑的处理器和磁盘类型。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/create-over.png\" alt=\"\"></p>\n<h2 id=\"Debian-1\"><a href=\"#Debian-1\" class=\"headerlink\" title=\"Debian\"></a>Debian</h2><h3 id=\"启动并选择镜像\"><a href=\"#启动并选择镜像\" class=\"headerlink\" title=\"启动并选择镜像\"></a>启动并选择镜像</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/pre-choose-image.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/choose-image.png\" alt=\"\"></p>\n<h3 id=\"一系列的安装过程\"><a href=\"#一系列的安装过程\" class=\"headerlink\" title=\"一系列的安装过程\"></a>一系列的安装过程</h3><p>由于步骤很多，详情可以参考这篇很有用的知乎文章：<a href=\"https://zhuanlan.zhihu.com/p/73122221\">图解 Debian 10（Buster）安装步骤 - 知乎 (zhihu.com)</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/install-debian-step01.png\" alt=\"\"></p>\n<h1 id=\"环境初始化\"><a href=\"#环境初始化\" class=\"headerlink\" title=\"环境初始化\"></a>环境初始化</h1><h2 id=\"添加用户到sudoers\"><a href=\"#添加用户到sudoers\" class=\"headerlink\" title=\"添加用户到sudoers\"></a>添加用户到sudoers</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.切换到root用户</span></span><br><span class=\"line\">$ su</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.编辑sudoer文件</span></span><br><span class=\"line\">$ vi /etc/sudoers</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.在User privilege specification一行复制root对应的内容，添加一行当前用户的记录，内容为</span></span><br><span class=\"line\">w4ngzhen(你的用户名，本人使用的w4ngzhen) ALL=(ALL:ALL) ALL</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.强制保存</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5.退出root用户</span></span><br><span class=\"line\">$ <span class=\"built_in\">exit</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"sudo方式修改apt源\"><a href=\"#sudo方式修改apt源\" class=\"headerlink\" title=\"sudo方式修改apt源\"></a>sudo方式修改apt源</h2><p>实际上该步骤可以在上述安装Debian的时候就可以选择镜像完成配置，这里写出来主要是为了方便以后查阅修改镜像。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.编辑apt源配置文件</span></span><br><span class=\"line\">$ sudo vi /etc/apt/sources.list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.添加国内能快速访问的镜像源，这里选择腾讯。修改完成后，保存退出到命令行</span></span><br><span class=\"line\">deb http://mirrors.cloud.tencent.com/debian/ buster main non-free contrib</span><br><span class=\"line\">deb http://mirrors.cloud.tencent.com/debian-security buster/updates main</span><br><span class=\"line\">deb http://mirrors.cloud.tencent.com/debian/ buster-updates main non-free contrib</span><br><span class=\"line\">deb http://mirrors.cloud.tencent.com/debian/ buster-backports main non-free contrib</span><br><span class=\"line\">deb-src http://mirrors.cloud.tencent.com/debian-security buster/updates main</span><br><span class=\"line\">deb-src http://mirrors.cloud.tencent.com/debian/ buster main non-free contrib</span><br><span class=\"line\">deb-src http://mirrors.cloud.tencent.com/debian/ buster-updates main non-free contrib</span><br><span class=\"line\">deb-src http://mirrors.cloud.tencent.com/debian/ buster-backports main non-free contrib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.更新apt源</span></span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.更新apt已安装包</span></span><br><span class=\"line\">$ sudo apt-get upgrade</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装linux-headers\"><a href=\"#安装linux-headers\" class=\"headerlink\" title=\"安装linux-headers\"></a>安装linux-headers</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># linux-headers的版本需要与当前内核发行版一致，查看内核发行版本命令如下：</span></span><br><span class=\"line\">$ uname -r</span><br><span class=\"line\"><span class=\"comment\"># 本人机器输出：4.19.0-9-amd64</span></span><br><span class=\"line\"><span class=\"comment\"># 所以需要安装的linux-headers为：linux-headers-4.19.0-9-amd64，这里使用shell命令便捷操作</span></span><br><span class=\"line\">$ sudo apt-get install -y linux-headers-$(uname -r) </span><br></pre></td></tr></table></figure>\n<h2 id=\"安装gcc、make、perl等\"><a href=\"#安装gcc、make、perl等\" class=\"headerlink\" title=\"安装gcc、make、perl等\"></a>安装gcc、make、perl等</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install -y gcc make perl</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题及解决\"><a href=\"#问题及解决\" class=\"headerlink\" title=\"问题及解决\"></a>问题及解决</h1><h2 id=\"VBox启动Debian-Xfce图形界面黑屏\"><a href=\"#VBox启动Debian-Xfce图形界面黑屏\" class=\"headerlink\" title=\"VBox启动Debian/Xfce图形界面黑屏\"></a>VBox启动Debian/Xfce图形界面黑屏</h2><ul>\n<li>原因1：VBox虚拟机【设置】-【显示】中启用了3D加速</li>\n<li>解决方式：关闭3D加速</li>\n</ul>\n","categories":[],"tags":["Linux","Debian"]},{"title":"S_型文法到q_型文法再到LL(1)型文法演进笔记","url":"http://compilemind.com/2020/08/23/2020-08-29-S_型文法到q_型文法再到LL(1)型文法演进笔记/","content":"<h1 id=\"S型文法到q型文法再到LL-1-型文法演进笔记\"><a href=\"#S型文法到q型文法再到LL-1-型文法演进笔记\" class=\"headerlink\" title=\"S型文法到q型文法再到LL(1)型文法演进笔记\"></a>S<em>型文法到q</em>型文法再到LL(1)型文法演进笔记</h1><a id=\"more\"></a>\n<h2 id=\"S-型文法（简单的确定性文法）\"><a href=\"#S-型文法（简单的确定性文法）\" class=\"headerlink\" title=\"S_型文法（简单的确定性文法）\"></a>S_型文法（简单的确定性文法）</h2><ul>\n<li><p>每个产生式的右部都以<strong>终结符</strong>开始</p>\n</li>\n<li><p>同一非终结符的各个候选式的<strong>首终结符</strong>都不同</p>\n</li>\n</ul>\n<p>针对第一条的理解是，只要右部都是终结符开始，那么对于串当前的读入字符，我们可以很容易的直接根据右部开头的终结符来进行判断匹配，而无需进行产生式的推导；针对第二条的理解是，因为首终结符都不一样，所以根据当前串读入的字符，我们只会匹配到一个确定的产生式。</p>\n<p>举例，现有文法如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&1. \\quad S \\rightarrow aBC\\\\\n&2. \\quad B \\rightarrow b\\\\  \n&3. \\quad C \\rightarrow c\\\\  \n\\end{aligned}</script><p>现有字符串$abc$，我们从左部第一个字符开始输入，因为字符$a$能够被产生式1匹配，因此我们首先选择产生式$1. \\quad S \\rightarrow aBC$；接下来输入第二个字符$b$，于是我们从产生式1到3种进行匹配判断，找到左部非终结符为$B$（找$B$的原因是上一步我们已经匹配到了产生式1，产生式1的右部现在已经匹配上了$a$字符，我们接下来需要推导$B$，所以要找左部为非终结符$B$的产生式)，右部首终结符为$b$的产生式，于是找到产生式2。以此类推，我们最后能够如下的推导：</p>\n<script type=\"math/tex; mode=display\">\nS \\rightarrow aBC \\rightarrow abC \\rightarrow abc</script><p>个人理解觉得，针对S_型文法的特征是：<strong>我们总是能够根据读入的字符，直接匹配找到一个确定的产生式</strong>。</p>\n<p>然而，该文法的局限性非常的大，最基本的一点就是该文法<strong>不包含$\\varepsilon$的产生式</strong>。例如，现有下列文法：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&1. \\quad S \\rightarrow aBC \\\\\n&2. \\quad B \\rightarrow bC \\\\\n&3. \\quad B \\rightarrow dB \\\\\n&4. \\quad B \\rightarrow \\varepsilon \\\\\n&5. \\quad C \\rightarrow c \\\\\n&6. \\quad C \\rightarrow a \\\\\n&7. \\quad D \\rightarrow e \\\\\n\\end{aligned}</script><p>对于字符串$ade$，首先还是产生式1没得说；接下来，我们需要寻找的是左部为$B$，右部首终结符为$d$的产生式，于是我们选择产生式3，此时产生式推到得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n& 1. \\Rightarrow a，选择产生式1，得到 aBC \\\\\n& 2. \\Rightarrow d，选择产生式3，得到 adBC \\\\\n& 3. \\Rightarrow e，因为产生式2、3的首位非终结符不是e，这里选择\\varepsilon，即选择产生式4，得到 adC \\\\\n\\end{aligned}</script><p>因为此时输入字符为$e$，且当前推导的式子中还存在非终结符$C$，于是我们继续应用上述规则进行匹配选择（即，我们结束第3轮，进入第4轮准备开始查找），然而我们无法找到形如$C \\rightarrow e…$的产生式，此时报错。</p>\n<p>尽管最终报错了，但是当前的文法存在这样一个问题：因为$\\varepsilon$产生式的存在，本该在第3轮中就该发现的再无匹配的问题，在第4轮的检查过程中才被发现。为什么说第3轮就该发现呢？我们回到第3轮的检查中，上面说“因为产生式2、3的首位非终结符不是$e$，我们选择$B \\rightarrow \\varepsilon$，但是选择这个产生式真的正确吗？事实上，当产生式右部是$\\varepsilon$的时候，我们应该要考虑空串之后紧跟着的非终结符是什么，如果我们知道紧跟着的非终结符也和当前的输入符号不匹配的话，我们立刻就能知道选择了空串后的下一步必然是无法匹配的。这里$\\varepsilon$后面紧跟的等价于$B$紧跟的，那么通过产生式1我们知道$B$后面紧跟的是$C$，而$C$能够推导出$c$和$a$，故在第3轮中，我们首先知道已经无法选择产生式2和3了，接下来我们判断产生式4是否满足，因为当前的输入$e$依然无法和$c$、$a$匹配，所以在第3轮我们已经无法继续进行下去，就应该报错了。</p>\n<p>而我们上面所说的“紧跟着的…”也就是接下来要引入的一个概念：$FOLLOW$集。</p>\n<h3 id=\"FOLLOW-集-（后继符号集）\"><a href=\"#FOLLOW-集-（后继符号集）\" class=\"headerlink\" title=\"$FOLLOW 集$（后继符号集）\"></a>$FOLLOW 集$（后继符号集）</h3><blockquote>\n<p>非终结符$A$的后继符号集<br>可能在某个句型中紧跟在$A$后边的终结符$a$的集合，记为$FOLLOW(A)$</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\nFOLLOW(A)=\\{a|S \\Rightarrow^* \\alpha Aa\\beta, \\quad a \\in V_T, \\quad \\alpha, \\beta \\in (V_T \\cup V_N)^*\\}</script><p>有了$FOLLOW集$这个东西之后，再回头看待$\\varepsilon$产生式就变得很明朗了。</p>\n<p>如果当前某非终结符$A$的产生式右部的首字符与输入$a$不匹配的时候，若存在$A \\rightarrow \\varepsilon$，则我们检查$a$是否存在于$A$的后继符号集$FOLLOW(A)$中，若在其中，则匹配继续，否则程序报错。</p>\n<p>于是，对于上面的判断流程的第3步中，$FOLLOW(B) = {a, c}$，而当前我们遇到的符号是$e$，不在对应的集中，于是该步骤已经结束。</p>\n<h3 id=\"SELECT-集-（产生式可选集）\"><a href=\"#SELECT-集-（产生式可选集）\" class=\"headerlink\" title=\"$SELECT 集$（产生式可选集）\"></a>$SELECT 集$（产生式可选集）</h3><p>我们综合上述的对于非$\\varepsilon$产生式和$\\varepsilon$产生式，可以定义产生式的可选集这一概念。</p>\n<p>产生式$A \\rightarrow \\beta$的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为$SELECT(A \\rightarrow \\beta)$。例如：</p>\n<p>$SELECT(A \\rightarrow \\alpha\\beta) = {\\alpha}$</p>\n<p>$SELECT(A \\rightarrow \\varepsilon) = FOLLOW(A)$</p>\n<h2 id=\"q-文法\"><a href=\"#q-文法\" class=\"headerlink\" title=\"q_文法\"></a>q_文法</h2><blockquote>\n<p>每个产生式的右部或为$\\varepsilon$或以终结符开始</p>\n<p>具有相同左部的产生式有不可相交的可选集</p>\n</blockquote>\n<p>我们称这样的文法为q<em>型文法。为什么引入q</em>型文法，因为前面的$FOLLOW集$概念的引入，解决$\\varepsilon$产生式的问题，而这一点可以很好的地对照在q<em>型文法的第一条定义。尽管它对于S</em>型文法限制有了略微的放宽，支持了$\\varepsilon$的产生式，可是还是有一定的限制：q_文法不含右部以<code>非终结符</code>打头的产生式。</p>\n<p>在前文中，我们总是在限制产生式的右部，要么首字符是一个终结符，要么是$\\varepsilon$空串，之所以这样是因为我们总是希望在进行输入的时候右部具有确定的信息（这里就是一个首终结字符）。然而，当右部打头的是非终结符的时候，我们就无从下手了（至少目前是），因为非终结符是不确定的（至少一下子无法知道），它最终能够推导成什么样子的串，似乎变数太多，要是我们事先有一个集合，已经存放好了产生式右部的串(无论它是$\\varepsilon$，还是终结符，还是非终结符打头）的首非终结符，每次进行输入匹配的时候，看一下是不是在这里面，问题就迎刃而解了。于是，我们引入概念：串首终结符集。</p>\n<h3 id=\"串首终结符集\"><a href=\"#串首终结符集\" class=\"headerlink\" title=\"串首终结符集\"></a>串首终结符集</h3><p>给定一个文法符号串$\\alpha$，$\\alpha$的串首终结符集$FIRST(\\alpha)$被定义为：可以从$\\alpha$推导出的所有串首终结符的集合。此外，如果$\\alpha \\Rightarrow^* \\varepsilon$，那么$\\varepsilon \\in FIRST(\\alpha)$。即：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n& 对于 \\forall \\alpha \\in (V_T, V_N)^+，FIRST(\\alpha) = \\{ a | a\\beta, \\quad a \\in V_T, \\quad \\beta \\in (V_T \\cup V_N)^* \\} \\\\\n& 如果\\alpha \\Rightarrow^* \\varepsilon，那么\\varepsilon \\in FIRST(\\alpha) \\\\\n\\end{aligned}</script><p>至于这个串首终结符集如何生成，我们在后文再议。</p>\n<p>有了串首终结符集的定义后，我们再次回头看一下产生式$A \\rightarrow \\alpha$的可选集$SELECT(A \\rightarrow \\alpha)$。我们先给出定义：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation*}\nSELECT(A \\rightarrow \\alpha) = \\begin{cases}\nFIRST(\\alpha), & \\text{if} \\quad \\varepsilon \\notin FIRST(\\alpha) \\\\\n(FIRST(\\alpha) - \\{\\varepsilon\\}) \\cup FOLLOW(A), & \\text{if} \\quad \\varepsilon \\in FIRST(\\alpha)\n\\end{cases}\n\\end{equation*}</script><p>我们首先解读这个定义，先看第一种情况，因为$\\varepsilon \\notin FIRST(\\alpha)$，即$\\alpha$无法通过任意步骤推导得到空串，即产生式$A \\rightarrow \\alpha$的左部$A$是无法推导得到空串，那么该产生式的可选集是$FIRST(\\alpha)$确实是合理的，试想，现在我有个输入字符c，因为我知道$\\varepsilon \\notin FIRST(\\alpha)$，那么我检查字符c是不是在$FIRST(\\alpha)$中就可以做出判断报错还是继续，而无需担心因为左部$A$可以产生空串进而还要考虑$A$的后继符号集；</p>\n<p>对于第二种情况，其实就是把空串的情况也考虑了：不仅仅要判断输入字符是不是在右部的串首终结符集中，还因为左部$A$能够推导出空串，而判断是不是在左部的后记符号集中。当然这里排除串首终结符中的空串的含义也是显而易见的，正式因为$A \\rightarrow \\alpha \\Rightarrow^* \\varepsilon$，我们才要判断是否在$FOLLOW(A)$中，这里自然要排除空串了。</p>\n<h2 id=\"LL-1-型文法\"><a href=\"#LL-1-型文法\" class=\"headerlink\" title=\"LL(1)型文法\"></a>LL(1)型文法</h2><p>在上述理论基础上，我们现在将产生式的右部已经扩展到了任意形式了。于是，我们引入LL(1)型文法。它的定义如下：</p>\n<p>文法G是LL(1)的，当且仅当G的任意两个具有相同左部的产生式$A \\rightarrow \\alpha|\\beta$满足如下的条件：</p>\n<ol>\n<li>如果$\\alpha$和$\\beta$均不能推导出$\\varepsilon$，则$FIRST(\\alpha) \\cap FIRST(\\beta) = \\emptyset$。</li>\n<li>$\\alpha$和$\\beta$至多有一个能推导出$\\varepsilon$。如果$\\beta \\Rightarrow^<em> \\varepsilon$，则$FIRST(\\alpha) \\cap FOLLOW(A) = \\emptyset$；如果$\\alpha \\Rightarrow^</em> \\varepsilon$，则$FIRST(\\beta) \\cap FOLLOW(A) = \\emptyset$。</li>\n</ol>\n<p>对于情况1，对于$\\alpha$和$\\beta$都无法推导出空集的时候，假设两者的串首终结符集的交集不为空，那么对于某个输入字符c，我到底该选择右部为$\\alpha$的产生式还是$\\beta$的呢？很显然出现了二义性，所以我们有了交集为空集的条件；</p>\n<p>对于情况2，首先解释为什么至多有一个能推到出$\\varepsilon$。假设都能推导出空集，根据前面产生式的可选集对于右部推导有空集的情况，可选集会包含左部的后记符号集，在这里也就是说，$SELECT(A \\rightarrow \\alpha)$和$SELECT(A \\rightarrow \\beta)$都有$FOLLOW(A)$，当输入字符c属于$FOLLOW(A)$的时候，我们应该选择哪一个产生式呢？于是又出现了二义性。所以我们限定只能至多一个能够推导出$\\varepsilon$。再进一步，当其中一个右部（这里以$\\beta$为例）能够推导出$\\varepsilon$，那么$SELECT(A \\rightarrow \\beta) = {FIRST(\\beta) - {\\varepsilon}} \\cup FOLLOW(A)$，而$\\alpha$无法推导出$\\varepsilon$，所以$SELECT(A \\rightarrow \\alpha) = FIRST(\\alpha)$，为了保证不会出现二义性，我们需要$SELECT(A \\rightarrow \\beta) \\cap SELECT(A \\rightarrow \\alpha) = \\emptyset$，这里$FIRST(\\alpha)$和$FIRST(\\beta)$的交集不为空是一个隐藏的条件，因为是情况1的情形；于是，我们还需要保证$FIRST(\\alpha) \\cap FOLLOW(A) = \\emptyset$。</p>\n","categories":[],"tags":[]},{"title":"CefSharp请求资源拦截及自定义处理","url":"http://compilemind.com/2020/08/23/2020-08-23-CefSharp资源拦截处理/","content":"<h1 id=\"CefSharp请求资源拦截及自定义处理\"><a href=\"#CefSharp请求资源拦截及自定义处理\" class=\"headerlink\" title=\"CefSharp请求资源拦截及自定义处理\"></a>CefSharp请求资源拦截及自定义处理</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在CefSharp中，我们不仅可以使用Chromium浏览器内核，还可以通过Cef暴露出来的各种Handler来实现我们自己的资源请求处理。</p>\n<p>什么是资源请求呢？简单来说，就是前端页面在加载的过程中，请求的各种文本（js、css以及html）。在以Chromium内核的浏览器上，我们可以使用浏览器为我们提供的开发者工具来检查每一次页面加载发生的请求。</p>\n<a id=\"more\"></a>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>鉴于本文的重心是了解CefSharp的资源拦截处理，所以我们不讨论前端的开发以及客户端嵌入CefSharp组件的细节。我们首先完成一个基本的嵌入CefSharp的WinForm程序：该程序界面如下，拥有一个地址输入栏和一个显示网页的Panel：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/webbrowser.png\" alt=\"\"></p>\n<p>并且编写一个<strong>极其简单</strong>的页面，该页面会请求1个js资源和1个css资源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo:</span><br><span class=\"line\">    - index.html</span><br><span class=\"line\">    - test1.js</span><br><span class=\"line\">    - test1.css</span><br></pre></td></tr></table></figure>\n<p>这几个文件的代码都十分简单：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: aqua</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;test1 js file&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 如下记载js、css资源 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;test1.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;test1.css&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Resource Intercept Example<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;result&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 调用test1.js中的myFunc</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;result&#x27;</span>).innerHTML = myFunc();</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>代码很简单，效果也很容易知道，页面加载后，页面背景色为aqua，页面上会显示文本“test1 js file”。同时，当我们使用开发工具，刷新页面，能够看到对应的资源加载：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/src-web-page.png\" alt=\"\"></p>\n<h2 id=\"CefSharp资源拦截及自定义处理\"><a href=\"#CefSharp资源拦截及自定义处理\" class=\"headerlink\" title=\"CefSharp资源拦截及自定义处理\"></a>CefSharp资源拦截及自定义处理</h2><p>完成上述准备后，我们进入正文：资源拦截及自定义处理。首先我们需要对目标的理解达成一致，资源拦截是指我们能够检测到上图中的html、js还有css的资源请求事件，在接下来的Example中，因为我们是使用的客户端程序，所以会在请求的过程中弹出提示；自定义处理是指，在完成拦截提示后，我们还能够替换这些资源，这里我们设定完成拦截后，可以把js和css换为我们想要另外的文件：test2.js和test2.css：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;test2 js file&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: beige</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>即我们希望拦截并替换后，页面上的文字不再是之前的，而是“test2 js file”，页面的背景色是beige。</p>\n<h3 id=\"IRequestHandler\"><a href=\"#IRequestHandler\" class=\"headerlink\" title=\"IRequestHandler\"></a>IRequestHandler</h3><p>在CefSharp中，要想对请求进行拦截处理，最为核心的Handler就是IRequestHandler这个接口，查看官方的源码，会发现里面有数个方法的定义，通过阅读官方的summary，我们可以聚焦到如下的两个定义（注释本人进行了删减）：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Called before browser navigation.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 译：在浏览器导航前调用</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> If the navigation is allowed <span class=\"doctag\">&lt;see cref=&quot;E:CefSharp.IWebBrowser.FrameLoadStart&quot; /&gt;</span> and <span class=\"doctag\">&lt;see cref=&quot;E:CefSharp.IWebBrowser.FrameLoadEnd&quot; /&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> will be called. If the navigation is canceled <span class=\"doctag\">&lt;see cref=&quot;E:CefSharp.IWebBrowser.LoadError&quot; /&gt;</span> will be called with an ErrorCode</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> value of <span class=\"doctag\">&lt;see cref=&quot;F:CefSharp.CefErrorCode.Aborted&quot; /&gt;</span>.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">OnBeforeBrowse</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IWebBrowser chromiumWebBrowser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IBrowser browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IFrame frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IRequest request,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">bool</span> userGesture,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">bool</span> isRedirect</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Called on the CEF IO thread before a resource request is initiated.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 在一个资源请求初始化前在CEF IO线程上调用</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">IResourceRequestHandler <span class=\"title\">GetResourceRequestHandler</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IWebBrowser chromiumWebBrowser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IBrowser browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IFrame frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IRequest request,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">bool</span> isNavigation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">bool</span> isDownload,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">string</span> requestInitiator,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">ref</span> <span class=\"keyword\">bool</span> disableDefaultHandling</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>于是，我们继承一个默认的名为RequestHandler的类（请区分DefaultRequestHandler），只重写上述的两个方法。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MyRequestHandler</span> : <span class=\"title\">RequestHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">bool</span> <span class=\"title\">OnBeforeBrowse</span>(<span class=\"params\">IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, <span class=\"keyword\">bool</span> userGesture,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">bool</span> isRedirect</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用基类的实现，断点调试</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">base</span>.OnBeforeBrowse(chromiumWebBrowser, browser, frame, request, userGesture, isRedirect);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> IResourceRequestHandler <span class=\"title\">GetResourceRequestHandler</span>(<span class=\"params\">IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IRequest request, <span class=\"keyword\">bool</span> isNavigation, <span class=\"keyword\">bool</span> isDownload, <span class=\"keyword\">string</span> requestInitiator, <span class=\"keyword\">ref</span> <span class=\"keyword\">bool</span> disableDefaultHandling</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用基类的实现，断点调试</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">base</span>.GetResourceRequestHandler(</span><br><span class=\"line\">            chromiumWebBrowser, browser, frame, request, isNavigation, </span><br><span class=\"line\">            isDownload, requestInitiator, <span class=\"keyword\">ref</span> disableDefaultHandling);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<p>然后完成对该Handler的注册：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">this</span>._webBrowser = <span class=\"keyword\">new</span> ChromiumWebBrowser(<span class=\"keyword\">string</span>.Empty)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RequestHandler = <span class=\"keyword\">new</span> MyRequestHandler()</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>打上断点，开始访问我们的Example：index.html。这里会发现，OnBeforeBrowse调用了一次，而GetResourceRequestHandler会调用3次。检查OnBeforeBrowse中的request参数内容，是一次主页的请求，而GetResourceRequestHandler中的3次分别是：主页html资源、test1.js和test1.css。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/OnBeforeBrowse.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/GetResourceRequestHandler.png\" alt=\"\"></p>\n<p>结合官方注释和调试的结果，我们可以得出结论：要进行导航的拦截，我们可以重写OnBeforeBrowse方法，要想进行资源的拦截，我们需要实现自己的ResourceRequestHandler。</p>\n<h3 id=\"IResourceRequestHandler\"><a href=\"#IResourceRequestHandler\" class=\"headerlink\" title=\"IResourceRequestHandler\"></a>IResourceRequestHandler</h3><p>查看IResourceRequestHandler的定义，我们再次聚焦一个函数定义：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Called on the CEF IO thread before a resource is loaded. To specify a handler for the resource return a <span class=\"doctag\">&lt;see cref=&quot;T:CefSharp.IResourceHandler&quot; /&gt;</span> object</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span>To allow the resource to load using the default network loader return null otherwise return an instance of <span class=\"doctag\">&lt;see cref=&quot;T:CefSharp.IResourceHandler&quot; /&gt;</span> with a valid stream<span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">IResourceHandler <span class=\"title\">GetResourceHandler</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IWebBrowser chromiumWebBrowser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IBrowser browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IFrame frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IRequest request</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>该定义从注释可以看出，如果实现返回null，那么Cef会使用默认的网络加载器来发起请求，或者我们可以返回一个自定义的资源处理器ResourceHandler来处理一个合法的数据流（Stream）。也就是说，对于资源的处理，要想实现自定义的处理（不是拦截，拦截到目前为止我们可以在上述的两个Handler中进行处理）我们还需要实现一个IResourceHandler接口的实例，并在GetResourceHandler处进行返回，Cef才会在进行处理的时候使用我们的Handler。所以在<code>GetResourceHandler</code>中，我们进行资源的判断，如果是想要替换的资源，我们就使用WinForm提供的OpenFileDialog来选择本地的js或是css文件，并传给我们自定义的ResourceHandler，如果不是想要拦截的资源或是用户未选择任何的文件就走默认的：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MyResourceRequestHandler</span> : <span class=\"title\">ResourceRequestHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> IResourceHandler <span class=\"title\">GetResourceHandler</span>(<span class=\"params\">IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.Url.EndsWith(<span class=\"string\">&quot;test1.js&quot;</span>) || request.Url.EndsWith(<span class=\"string\">&quot;test1.css&quot;</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            MessageBox.Show(<span class=\"string\">$@&quot;资源拦截：<span class=\"subst\">&#123;request.Url&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">string</span> type = request.Url.EndsWith(<span class=\"string\">&quot;.js&quot;</span>) ? <span class=\"string\">&quot;js&quot;</span> : <span class=\"string\">&quot;css&quot;</span>; <span class=\"comment\">// 这里简单判断js还是css，不过多编写</span></span><br><span class=\"line\">            <span class=\"keyword\">string</span> fileName = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">using</span> (OpenFileDialog openFileDialog = <span class=\"keyword\">new</span> OpenFileDialog())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                openFileDialog.Filter = <span class=\"string\">$@&quot;<span class=\"subst\">&#123;type&#125;</span>文件|*.<span class=\"subst\">&#123;type&#125;</span>&quot;</span>; <span class=\"comment\">// 过滤</span></span><br><span class=\"line\">                openFileDialog.Multiselect = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (openFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    fileName = openFileDialog.FileName;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">string</span>.IsNullOrWhiteSpace(fileName))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有选择文件，还是走默认的Handler</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">base</span>.GetResourceHandler(chromiumWebBrowser, browser, frame, request);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 否则使用选择的资源返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyResourceHandler(fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">base</span>.GetResourceHandler(chromiumWebBrowser, browser, frame, request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"IResourceHandler\"><a href=\"#IResourceHandler\" class=\"headerlink\" title=\"IResourceHandler\"></a>IResourceHandler</h3><p>根据上文，我们进一步探究IResourceHandler，对该Handler，官方有一个默认的实现：RequestHandler，该Handler通过阅读源码可以知道是网络加载的Handler，这里为了实现我们自定义拦截策略，我们最好单独实现自己的IResourceHandler。对于该接口，有如下的注释：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Class used to implement a custom resource handler. The methods of this class will always be called on the CEF IO thread.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Blocking the CEF IO thread will adversely affect browser performance. We suggest you execute your code in a Task (or similar).</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> To implement async handling, spawn a new Task (or similar), keep a reference to the callback. When you have a</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> fully populated stream, execute the callback. Once the callback Executes, GetResponseHeaders will be called where you</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> can modify the response including headers, or even redirect to a new Url. Set your responseLength and headers</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Populate the dataOut stream in ReadResponse. For those looking for a sample implementation or upgrading from</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> a previous version <span class=\"doctag\">&lt;see cref=&quot;T:CefSharp.ResourceHandler&quot; /&gt;</span>. For those upgrading, inherit from ResourceHandler instead of IResourceHandler</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> add the override keywoard to existing methods e.g. ProcessRequestAsync.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IResourceHandler</span> : <span class=\"title\">IDisposable</span></span><br><span class=\"line\">&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<p>该类的注释意思大致为：我们可以通过实现该接口来实现自定义资源的处理类。该类中的方法总是在CEF的IO线程中调用。然而，阻塞CEF IO线程将会不利于浏览器的性能。所以官方建议开发者通过把自己的处理代码放在Task（或是类似的异步编程框架）中异步执行，然后在完成或取消（失败）时，在异步中调用callback对应的操作函数（continue、cancel等方法）。当你拥有一个完全填充（fully populated）好了的Stream的时候，再执行callback（这一步对应Open方法）。一旦callback执行了，GetResponseHeaders这个方法将会调用，于是你可以在这个方法里面对Reponse的内容包括headers进行修改，或者甚至是重定向到一个新的Url。设置你自己的reponseLength和headers。接下来，通过在ReadResponse（实际上即将作废，而是Read）函数中，实现并填充dataOut这个Stream。最终CEF会对该Stream进行读取数据，获得资源数据。</p>\n<p>事实上，该Handler的实现可以有很多花样，这里我们实现一个最简单的。</p>\n<h4 id=\"Dispose\"><a href=\"#Dispose\" class=\"headerlink\" title=\"Dispose\"></a>Dispose</h4><p>对于通常进行资源释放的Dispose，因为我们这里只是一个Demo，所以暂时留空。</p>\n<h4 id=\"Open（ProcessRequest）\"><a href=\"#Open（ProcessRequest）\" class=\"headerlink\" title=\"Open（ProcessRequest）\"></a>Open（ProcessRequest）</h4><p>官方注释指出，ProcessRequest将会在不久的将来弃用，改为Open。所以ProcessRequest我们直接返回true。对于Open方法，其注释告诉我们：</p>\n<ul>\n<li>要想要立刻进行资源处理（同步），请设置handleRequest参数为true，并返回true</li>\n<li>决定稍后再进行资源的处理（异步），设置handleRequest为false，并调用callback对应的continue和cancel方法来让请求处理继续还是取消，并且当前Open返回false。</li>\n<li>要立刻取消资源的处理，设置handleRequest为true，并返回false。</li>\n</ul>\n<p>也就是说，handleRequest的true或false决定是同步还是异步处理。若同步，则Cef会立刻通过Open的返回值true或false来决定后续继续进行还是取消。若为异步，则Cef会通过异步的方式来检查callback的调用情况（这里的callback实际上是要我们创建Task回调触发的）。这里我们选择同步的方式（选择异步也没有问题）编写如下的代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">Open</span>(<span class=\"params\">IRequest request, <span class=\"keyword\">out</span> <span class=\"keyword\">bool</span> handleRequest, ICallback callback</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    handleRequest = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"GetResponseHeaders\"><a href=\"#GetResponseHeaders\" class=\"headerlink\" title=\"GetResponseHeaders\"></a>GetResponseHeaders</h4><p>在上小节中我们已经完成了对资源数据的入口（Open）的分析。既然我们已经告诉了Cef我们准备开始进行资源请求的处理了，那么接下来我们显然需要着手进行资源的处理。根据前面的概要注释，我们需要实现GetResponseHeaders方法，因为这是资源处理的第二步。该方法的注释如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Retrieve response header information. If the response length is not known</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> set <span class=\"doctag\">&lt;paramref name=&quot;responseLength&quot; /&gt;</span> to -1 and ReadResponse() will be called until it</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> returns false. If the response length is known set <span class=\"doctag\">&lt;paramref name=&quot;responseLength&quot; /&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> to a positive value and ReadResponse() will be called until it returns</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> false or the specified number of bytes have been read.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> </span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> It is also possible to set <span class=\"doctag\">&lt;paramref name=&quot;response&quot; /&gt;</span> to a redirect http status code</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> and pass the new URL via a Location header. Likewise with <span class=\"doctag\">&lt;paramref name=&quot;redirectUrl&quot; /&gt;</span> it</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> is valid to set a relative or fully qualified URL as the Location header</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> value. If an error occured while setting up the request you can call</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;see cref=&quot;P:CefSharp.IResponse.ErrorCode&quot; /&gt;</span> on <span class=\"doctag\">&lt;paramref name=&quot;response&quot; /&gt;</span> to indicate the error condition.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetResponseHeaders</span>(<span class=\"params\">IResponse response, <span class=\"keyword\">out</span> <span class=\"keyword\">long</span> responseLength, <span class=\"keyword\">out</span> <span class=\"keyword\">string</span> redirectUrl</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>Summary翻译解释如下：获取响应头信息。如果响应的数据长度未知，则设置<code>responseLength</code>为<code>-1</code>，然后CEF会一直调用<code>ReadResponse</code>（即将废除，实际上是<code>Read</code>方法）直到该Read方法返回<code>false</code>。如果响应数据的长度是已知的，可以直接设置<code>responseLength</code>长度为一个正数，然后<code>ReadResponse</code>（<code>Read</code>）将会一直调用，直到该Read方法返回false或者在已经读取的数据的字节长度达到了设置的responseLength的值。当然你也可以通过设置response.StatusCode值为重定向的值（30x）以及redirectUrl为对应的重定向Url来实现资源重定向。</p>\n<p>在本文中，我们采取简单的方式：直接返回资源的长度，然后交给下一步的<code>Read</code>方法来进行真正的资源处理。在该步骤中，我们编写获取本地文件字节数据来实现js和css文件的本地加载，并且将该数据保存在该ResourceHanlder实例私有变量中。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">GetResponseHeaders</span>(<span class=\"params\">IResponse response, <span class=\"keyword\">out</span> <span class=\"keyword\">long</span> responseLength, <span class=\"keyword\">out</span> <span class=\"keyword\">string</span> redirectUrl</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> (FileStream fileStream = <span class=\"keyword\">new</span> FileStream(<span class=\"keyword\">this</span>._localResourceFileName, FileMode.Open, FileAccess.Read))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">using</span> (BinaryReader binaryReader = <span class=\"keyword\">new</span> BinaryReader(fileStream))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> length = fileStream.Length;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._localResourceData = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[length];</span><br><span class=\"line\">            <span class=\"comment\">// 读取文件中的内容并保存到私有变量字节数组中</span></span><br><span class=\"line\">            binaryReader.Read(<span class=\"keyword\">this</span>._localResourceData, <span class=\"number\">0</span>, <span class=\"keyword\">this</span>._localResourceData.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    responseLength = <span class=\"keyword\">this</span>._localResourceData.LongLength;</span><br><span class=\"line\">    redirectUrl = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Read\"><a href=\"#Read\" class=\"headerlink\" title=\"Read\"></a>Read</h4><p>该方法的定义和注释如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Read response data. If data is available immediately copy up to</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> dataOut.Length bytes into dataOut, set bytesRead to the number of</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> bytes copied, and return true. To read the data at a later time keep a</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> pointer to dataOut, set bytesRead to 0, return true and execute</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> callback when the data is available (dataOut will remain valid until</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> the callback is executed). To indicate response completion set bytesRead</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> to 0 and return false. To indicate failure set bytesRead to &amp;lt; 0 (e.g. -2</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> for ERR_FAILED) and return false. This method will be called in sequence</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> but not from a dedicated thread.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> </span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> For backwards compatibility set bytesRead to -1 and return false and the ReadResponse method will be called.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Read</span>(<span class=\"params\">Stream dataOut, <span class=\"keyword\">out</span> <span class=\"keyword\">int</span> bytesRead, IResourceReadCallback callback</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>Summary的翻译大致为：读取响应数据。如果数据是可以立即获得的，那么可以直接将<code>dataOut.Length</code>长度的字节数据拷贝到dataOut这个流中，然后设置bytesRead的值为拷贝的数据字节长度值，最后再返回<code>true</code>。如果开发者希望继续持有dataOut的引用（注释是pointer指针，但是个人觉得这里写为指向该dataOut的引用更好）然后在稍后填充该数据流，那么可以设置<code>bytesRead</code>为<code>0</code>，通过异步方式在数据准备好的时候执行callback的操作函数，然后立刻返回<code>true</code>。（dataOut这个流会一直保持不被释放直到callback被调用为止）。为了让CEF知道当前的响应数据已经填充完毕，需要设置<code>bytesRead</code>为<code>0</code>然后返回<code>false</code>。要想让CEF知道响应失败，需要设置<code>bytesRead</code>为一个小于零的数（例如ERR_FAILED: -2），然后返回<code>false</code>。这个方法将会依次调用但不是在一个专有线程。</p>\n<p>根据上述的注释，总结如下：</p>\n<ul>\n<li>bytesRead &gt; 0，return true：填充了数据，但Read还会被调用</li>\n<li>bytesRead = 0，return false：数据填充完毕，当前为最后一次调用</li>\n<li>bytesRead &lt; 0，return false：出错，当前为最后一次调用</li>\n<li>bytesRead = 0，return true：CEF不会释放dataOut流，在异步调用中准备好数据后调用callback</li>\n</ul>\n<p>针对本例，我们增加一个该类的私有变量<code>_dataReadCount</code>用于标识已读的资源数据字节量并在构造函数中初始化为0。</p>\n<p>每次在Read中进行读取的时候，首先检查剩余待读取字节数<code>this._localResourceData.LongLength - this._dataReadCount</code>，如果该值为零，则表明已经将所有的数据通过dataOut拷贝给了外围，此时设置bytesRead为0，直接返回false；若剩余值大于0，则需要继续进行拷贝操作，但需要注意的是dataOut并不是一个无限大的流，而是一个类似于缓存的流，它的Length值为<code>2^16 = 65536</code>，所以我们需要设置bytesRead来让外围知道我们实际在这个流中放了多少字节的数据。同时在使用<code>Stream.Write</code>API的时候，需要设置正确的offset和count。</p>\n<p>最终，<code>Read</code>的实现如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">Read</span>(<span class=\"params\">Stream dataOut, <span class=\"keyword\">out</span> <span class=\"keyword\">int</span> bytesRead, IResourceReadCallback callback</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftToRead = <span class=\"keyword\">this</span>._localResourceData.Length - <span class=\"keyword\">this</span>._dataReadCount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leftToRead == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> needRead = Math.Min((<span class=\"keyword\">int</span>)dataOut.Length, leftToRead); <span class=\"comment\">// 最大为dataOut.Lenght</span></span><br><span class=\"line\">    dataOut.Write(<span class=\"keyword\">this</span>._localResourceData, <span class=\"keyword\">this</span>._dataReadCount, needRead);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._dataReadCount += needRead;</span><br><span class=\"line\">    bytesRead = needRead;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他的几个方法\"><a href=\"#其他的几个方法\" class=\"headerlink\" title=\"其他的几个方法\"></a>其他的几个方法</h4><p>对于Cancel和Skip方法，在本例不会调用，所以这里使用默认实现，不进行讨论，感兴趣的伙伴可以自己去研究。</p>\n<h2 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h2><p>通过上文的代码设计和编写，我们最终完成了一个简单的资源拦截及自定义处理的Example。首先我们在不进行资源拦截的情况下，加载我们的web页面：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/load-without-intercept.png\" alt=\"\"></p>\n<p>可以看到界面中呈现“test1 js file”的字样以及背景色为海蓝色。接下来我们开启资源拦截，再次加载页面，在加载过程中会有对应资源的拦截时的弹窗以及我们需要选择我们自定义的资源文件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/js-intercept.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/js-select.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/css-intercept.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/css-select.png\" alt=\"\"></p>\n<p>完成处理后，得到如下的显示页面：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/load-with-intercept.png\" alt=\"\"></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p>本Example的源码已经开源在Github上，整个Demo较为简单，主要是对本文的验证</p>\n<p><a href=\"https://github.com/w4ngzhen/CefSharpResourceInterceptExample\">链接</a></p>\n","categories":[],"tags":[]},{"title":"Electron+Vue+ElementUI开发环境搭建","url":"http://compilemind.com/2020/08/08/2020-08-08-Electron+Vue+ElementUI开发环境搭建/","content":"<p>本文将从零开始，进行Electron+Vue+ElementUI的开发环境搭建</p>\n<a id=\"more\"></a>\n<h2 id=\"Node环境搭建\"><a href=\"#Node环境搭建\" class=\"headerlink\" title=\"Node环境搭建\"></a>Node环境搭建</h2><p>本文假定你完成了nodejs的环境基础搭建：<br>镜像配置（暂时只配置node包镜像源，部分包的二进制镜像源后续讨论）、全局以及缓存路径配置，全局路径加入到了环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"> $</span><span class=\"bash\"> node -v</span></span><br><span class=\"line\"> v12.18.1</span><br><span class=\"line\"><span class=\"meta\"> $</span><span class=\"bash\"> npm -v</span></span><br><span class=\"line\"> 6.14.5</span><br><span class=\"line\"><span class=\"meta\"> $</span><span class=\"bash\"> yarn -v</span></span><br><span class=\"line\"> 1.22.4</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\"> $</span><span class=\"bash\"> npm list -g --depth 0</span></span><br><span class=\"line\"> +-- hexo@4.2.1 // 忽略Hexo，本人写博用的</span><br><span class=\"line\">`-- yarn@1.22.4</span><br></pre></td></tr></table></figure>\n<h2 id=\"vue脚手架安装\"><a href=\"#vue脚手架安装\" class=\"headerlink\" title=\"vue脚手架安装\"></a>vue脚手架安装</h2><p>为了更加便捷的创建一个vue项目，我们安装脚手架@vue/cli和@vue/init（vue-cli已经deprecated了）。之所以要安装@vue/init，是因为@vue/cli是3的版本，创建项目使用命令<strong>vue create app-name</strong>，且无法暂时无法使用模板，但是下文要用electron-vue模板进行创建，还是需要vue2的init命令来通过指定模板创建项目，为了兼容vue2的init特性，官方提供@vue/init作为桥接方式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install -g @vue/cli</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install -g @vue/cli-init</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm list -g --depth 0</span></span><br><span class=\"line\">+-- @vue/cli@4.4.6</span><br><span class=\"line\">+-- @vue/cli-init@4.4.6</span><br><span class=\"line\">+-- hexo@4.2.1</span><br><span class=\"line\">`-- yarn@1.22.4</span><br><span class=\"line\"></span><br><span class=\"line\">关于init说明：</span><br><span class=\"line\">vue init [options] &lt;template&gt; &lt;app-name&gt;       generate a project from a remote template (legacy API, requires @vue/cli-init)</span><br></pre></td></tr></table></figure>\n<p>至此，你可以使用如下的形式，利用vue脚手架结合模板（template）来初始化你的vue项目（app-name）结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init [options] &lt;template&gt; &lt;app-name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化Electron项目结构\"><a href=\"#初始化Electron项目结构\" class=\"headerlink\" title=\"初始化Electron项目结构\"></a>初始化Electron项目结构</h2><p>在指定的目录下，我们使用如下的命令进行electron-vue的项目初始化：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">  vue init simulatedgreg/electron-vue electron-vue-demo</span></span><br></pre></td></tr></table></figure>\n<p>然而，这个过程很慢，甚至卡住不动。原因是指定模板进行创建时，会拉取github上的仓库进行模板初始化。幸运的是vue提供模板离线初始化的功能。</p>\n<p>下载模板源码</p>\n<p><a href=\"https://github.com/SimulatedGREG/electron-vue\">https://github.com/SimulatedGREG/electron-vue</a></p>\n<p>下载后解压存放在 <strong>用户目录/.vue-templates/</strong> 下（没有就创建，注意复数s），形成如下的结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;home目录&#125;&#x2F;</span><br><span class=\"line\">  .vue-templates&#x2F;</span><br><span class=\"line\">     electron-vue-master&#x2F;（目录名随便，但是在待会儿init指定的时候需要一致）</span><br><span class=\"line\">       .github&#x2F;</span><br><span class=\"line\">       template&#x2F;</span><br><span class=\"line\">       ....</span><br></pre></td></tr></table></figure>\n<p>之后就可以使用离线（offline）模式创建：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init --offline electron-vue-master electron-vue-demo # 名称和上述文件夹名称一致即可</span><br></pre></td></tr></table></figure>\n<p>之后就是按照向导进行创建工作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vue init --offline electron-vue-master electron-vue-demo</span><br><span class=\"line\">&gt; Use cached template at ~\\.vue-templates\\electron-vue-master</span><br><span class=\"line\"></span><br><span class=\"line\">? Application Name electron-vue-demo（项目名）</span><br><span class=\"line\">? Application Id com.compilemind（Id，这里本人使用了自己的域名）</span><br><span class=\"line\">? Application Version 0.0.1（版本）</span><br><span class=\"line\">? Project description electron vue demo（描述）</span><br><span class=\"line\">? Use Sass / Scss? No（是否使用Sass/Scss编译器）</span><br><span class=\"line\">? Select <span class=\"built_in\">which</span> Vue plugins to install (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class=\"line\">axios, vue-el, ectron, vue-router, vuex, vuex-electron（插件包）</span><br><span class=\"line\">? Use linting with ESLint? Yes（启用ESlint）</span><br><span class=\"line\">? Which ESLint config would you like to use? Standard（ESLint配置）</span><br><span class=\"line\">? Set up unit testing with Karma + Mocha? No（测试模块）</span><br><span class=\"line\">? Set up end-to-end testing with Spectron + Mocha? No（测试模块）</span><br><span class=\"line\">? What build tool would you like to use? builder <span class=\"comment\"># 这里我们使用electron-builder构建可执行程序</span></span><br><span class=\"line\">? author w4ngzhen &lt;w4ngzhen@hotmail.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   vue-cli · Generated <span class=\"string\">&quot;electron-vue-demo&quot;</span>.</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行Electron-Vue示例\"><a href=\"#运行Electron-Vue示例\" class=\"headerlink\" title=\"运行Electron-Vue示例\"></a>运行Electron-Vue示例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd electron-vue-demo</span><br><span class=\"line\">$ yarn (or &#96;npm install&#96;)</span><br><span class=\"line\">$ yarn run dev (or &#96;npm run dev&#96;)</span><br></pre></td></tr></table></figure>\n<p>在install的过程中，我们会看到如下一段console输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> electron@2.0.18 postinstall D:\\Projects\\electron-vue-demo\\node_modules\\electron</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> node install.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Downloading electron-v2.0.18-win32-x64.zip</span><br><span class=\"line\">[==========================================&gt;  ] 97.0% of 50.7 MB (2.77 MB/s)</span><br></pre></td></tr></table></figure>\n<p>可以注意到electron的node包安装完成后，配置了postinstall（安装完成后调用的脚本），该脚本执行其内部install.js脚本后，开始下载electron的二进制的文件。</p>\n<p>首先为什么会有这个额外下载的过程呢？在本人看来，electron是基于Chromium内核的跨平台客户端解决方案（本人另一篇文章正好进行了CefSharp的封装工作），既然涉及到跨平台，而不同平台的底层实现必然有所差异，那么electron项目通过自己去实现跨平台，封装底层逻辑，让我们不关心底层的实现，而是专心于前端的开发，封装成果就是上述的electron-v2.0.18-win32-x64.zip内容。这里因为我们调试和构建的时候，就需要运行时，所以electron根据我们的当前的平台，去下载了对应已经完成针对平台编译封装的二进制内容。</p>\n<p>为什么要下载的问题搞明白了，接下来我们要看看如何去下载。有些朋友可能会发现，自己在进行electron二进制包下载的时候，速度慢的离谱。为什么这么慢？我会过一两天对下载的脚本一探究竟（时间有限，过两天写）</p>\n<p>现阶段我们需要在.npmrc文件中增加一行配置，让electron下载二进制文件的时候从指定的地方下载：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure>\n<p>完成后，我们在install会发现有明显的提升。完成node包的install后，我们运行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run dev</span></span><br></pre></td></tr></table></figure>\n<p>启动后会发现客户端能够运行起来（即主进程能够运行），但是渲染进程报错：</p>\n<p><strong>Webpack ReferenceError:process is not defined</strong>，官方ISSUE已经存在该条：<a href=\"https://github.com/SimulatedGREG/electron-vue/issues/871\">ISSUE</a></p>\n<p>解决方案为：移除src\\index.ejs中的该段代码，详细原因可以看ISSUE。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src\\index.ejs</span></span><br><span class=\"line\">    &lt;% <span class=\"keyword\">if</span> (!process.browser) &#123; %&gt;</span><br><span class=\"line\">      &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">&#x27;development&#x27;</span>) <span class=\"built_in\">window</span>.__static = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>).join(__dirname, <span class=\"string\">&#x27;/static&#x27;</span>).replace(<span class=\"regexp\">/\\\\/g</span>, <span class=\"string\">&#x27;\\\\\\\\&#x27;</span>)</span><br><span class=\"line\">      &lt;/script&gt;</span><br><span class=\"line\">    &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>移除后，再次运行可以看到渲染成功的界面。</p>\n<h2 id=\"引入ElementUI\"><a href=\"#引入ElementUI\" class=\"headerlink\" title=\"引入ElementUI\"></a>引入ElementUI</h2><p>引入ElementUI相关包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install element-ui -S</span><br></pre></td></tr></table></figure>\n<p>在渲染进程模块的main.js中加入ElementUI组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ElementUI <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-ui&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span> </span><br><span class=\"line\">...</span><br><span class=\"line\">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure>\n<p>完成配置以后，我们就可以按照以往的方式进行前端的开发了。</p>\n","categories":[],"tags":[]},{"title":"CefSharp基于.Net Framework 4.0 框架编译","url":"http://compilemind.com/2020/06/06/2020-06-06-CefSharp基于.Net Framework 4.0 框架编译/","content":"<p>本次源码使用的是Github上CefSharp官方的79版本源码</p>\n<a id=\"more\"></a>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><h3 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h3><p>Visual Studio 2017 Enterprise</p>\n<h3 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h3><p>Windows10 SDK</p>\n<p>VC2013 Redistributale Package x86\\x64</p>\n<h3 id=\"组件清单\"><a href=\"#组件清单\" class=\"headerlink\" title=\"组件清单\"></a>组件清单</h3><p>以下组件按照顺序进行编译最佳</p>\n<h4 id=\"基础层\"><a href=\"#基础层\" class=\"headerlink\" title=\"基础层\"></a>基础层</h4><ul>\n<li>CefSharp（C#）</li>\n<li>CefSharp.Core（C++）</li>\n<li>CefSharp.BrowserSubprocess.Core（C++）</li>\n<li>CefSharp.BrowserSubprocess（C#）</li>\n</ul>\n<h4 id=\"UI层\"><a href=\"#UI层\" class=\"headerlink\" title=\"UI层\"></a>UI层</h4><ul>\n<li>CefSharp.WinForms（C#）</li>\n</ul>\n<h4 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h4><ul>\n<li><p>CefSharp.Example</p>\n</li>\n<li><p>CefSharp.WinForms.Example</p>\n</li>\n</ul>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>建立一个名为CefSharp-DotNet4.0的空的解决方案（下文简称sln哈），咱们就开始吧！</p>\n<h3 id=\"CefSharp\"><a href=\"#CefSharp\" class=\"headerlink\" title=\"CefSharp\"></a>CefSharp</h3><p>首先把79版本的源码中的CefSharp库加入到sln中，形成如下的结构：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-06-06-build-cefsharp/1.png\" alt=\"\"></p>\n<p>先不将框架切换为4.0尝试编译一下，出现报错提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt;------ Rebuild All started: Project: CefSharp, Configuration: Debug x64 ------</span><br><span class=\"line\">1&gt;CSC : error CS7027: Error signing output with public key from file &#39;..\\CefSharp.snk&#39; -- File not found.</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Rebuild All: 0 succeeded, 1 failed, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<p>检查79版本的源码发现，需要将CefSharp.snk文件放置到sln根目录下，这里照做，然后编译通过。</p>\n<p>接着切换为4.0尝试编译，编译出现大量错误，仔细检查发现有如下几种：</p>\n<p><strong>1、CefSharp.Web.JsonString.FromObject函数的参数DataContractJsonSerializerSettings并不存在</strong></p>\n<p><strong>原因</strong>：4.0还不存在该种形式的调用</p>\n<p><strong>解决办法</strong>：移除该方法的settings参数，移除DataContractJsonSerializerSettings构造函数的settings参数</p>\n<p><strong>2、CefSharp.Internals.ConcurrentMethodRunnerQueue.Enqueue方法中，调用了PropertyInfo.GetValue方法报错</strong></p>\n<p><strong>原因</strong>：该PropertyInfo.GetValue方法在4.5及以上可以不传入第二个参数object[] index</p>\n<p><strong>解决办法</strong>：GetValue函数传入第二个参数为null即可</p>\n<p><strong>3、CefSharp.SchemeHandler.FolderSchemeHandlerFactory.ISchemeHandlerFactory.Create中WebUtility.UrlDecode报错</strong></p>\n<p><strong>原因</strong>：该方法是对一般字符串编码为Url的实现，在4.5及以上中才有</p>\n<p><strong>解决办法</strong>：实现一个相同的功能的方法替换之，因为后续还有些处理转为4.0后的兼容问题的代码，所以本人在CefSharp增加了一个ExHelper命名空间，用于存放后续的扩展处理代码的Helper，这里首先增加一个WebUtilityHelper的处理类，该类有一个静态方法UrlDecode，其实现本人直接拷贝的.NET 4.7.2的实现，代码如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">CefSharp.ExHelper</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> https://referencesource.microsoft.com/#System/net/System/Net/HttpListenerRequest.cs,80a5cbf6a66fa610</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">WebUtilityHelper</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> _bufferSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Accumulate characters in a special array</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> _numChars;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">char</span>[] _charBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Accumulate bytes for decoding into characters in a special array</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> _numBytes;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] _byteBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Encoding to convert chars to bytes</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Encoding _encoding;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"title\">WebUtilityHelper</span>(<span class=\"params\"><span class=\"keyword\">int</span> bufferSize, Encoding encoding</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            _bufferSize = bufferSize;</span><br><span class=\"line\">            _encoding = encoding;</span><br><span class=\"line\"></span><br><span class=\"line\">            _charBuffer = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[bufferSize];</span><br><span class=\"line\">            <span class=\"comment\">// byte buffer created on demand</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">string</span> <span class=\"title\">UrlDecode</span>(<span class=\"params\"><span class=\"keyword\">string</span> encodedValue</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (encodedValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> UrlDecodeInternal(encodedValue, Encoding.UTF8);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">string</span> <span class=\"title\">UrlDecodeInternal</span>(<span class=\"params\"><span class=\"keyword\">string</span> <span class=\"keyword\">value</span>, Encoding encoding</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"keyword\">value</span>.Length;</span><br><span class=\"line\">            WebUtilityHelper helper = <span class=\"keyword\">new</span> WebUtilityHelper(count, encoding);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// go through the string&#x27;s chars collapsing %XX and</span></span><br><span class=\"line\">            <span class=\"comment\">// appending each char as char, with exception of %XX constructs</span></span><br><span class=\"line\">            <span class=\"comment\">// that are appended as bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>; pos &lt; count; pos++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> ch = <span class=\"keyword\">value</span>[pos];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ch == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ch = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch == <span class=\"string\">&#x27;%&#x27;</span> &amp;&amp; pos &lt; count - <span class=\"number\">2</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> h1 = HexToInt(<span class=\"keyword\">value</span>[pos + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> h2 = HexToInt(<span class=\"keyword\">value</span>[pos + <span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (h1 &gt;= <span class=\"number\">0</span> &amp;&amp; h2 &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;     <span class=\"comment\">// valid 2 hex chars</span></span><br><span class=\"line\">                        <span class=\"keyword\">byte</span> b = (<span class=\"keyword\">byte</span>)((h1 &lt;&lt; <span class=\"number\">4</span>) | h2);</span><br><span class=\"line\">                        pos += <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// don&#x27;t add as char</span></span><br><span class=\"line\">                        helper.AddByte(b);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((ch &amp; <span class=\"number\">0xFF80</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    helper.AddByte((<span class=\"keyword\">byte</span>)ch); <span class=\"comment\">// 7 bit have to go as bytes because of Unicode</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    helper.AddChar(ch);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> helper.GetString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">HexToInt</span>(<span class=\"params\"><span class=\"keyword\">char</span> h</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (h &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; h &lt;= <span class=\"string\">&#x27;9&#x27;</span>) ? h - <span class=\"string\">&#x27;0&#x27;</span> :</span><br><span class=\"line\">            (h &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; h &lt;= <span class=\"string\">&#x27;f&#x27;</span>) ? h - <span class=\"string\">&#x27;a&#x27;</span> + <span class=\"number\">10</span> :</span><br><span class=\"line\">            (h &gt;= <span class=\"string\">&#x27;A&#x27;</span> &amp;&amp; h &lt;= <span class=\"string\">&#x27;F&#x27;</span>) ? h - <span class=\"string\">&#x27;A&#x27;</span> + <span class=\"number\">10</span> :</span><br><span class=\"line\">            <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">FlushBytes</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_numBytes &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _numChars += _encoding.GetChars(_byteBuffer, <span class=\"number\">0</span>, _numBytes, _charBuffer, _numChars);</span><br><span class=\"line\">                _numBytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"keyword\">void</span> <span class=\"title\">AddChar</span>(<span class=\"params\"><span class=\"keyword\">char</span> ch</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_numBytes &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                FlushBytes();</span><br><span class=\"line\"></span><br><span class=\"line\">            _charBuffer[_numChars++] = ch;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"keyword\">void</span> <span class=\"title\">AddByte</span>(<span class=\"params\"><span class=\"keyword\">byte</span> b</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_byteBuffer == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                _byteBuffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_bufferSize];</span><br><span class=\"line\"></span><br><span class=\"line\">            _byteBuffer[_numBytes++] = b;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">internal</span> String <span class=\"title\">GetString</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_numBytes &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                FlushBytes();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_numChars &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(_charBuffer, <span class=\"number\">0</span>, _numChars);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> String.Empty;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在报错地方进行如下调用：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> filePath = ExHelper.WebUtilityHelper.UrlDecode(Path.GetFullPath(Path.Combine(rootFolder, asbolutePath)));</span><br></pre></td></tr></table></figure>\n<p><strong>4、Type.GetTypeInfo报错</strong></p>\n<p><strong>原因</strong>：4.0中没有将Type的信息（TypeInfo）从Type中抽离，所以4.0种的Type并没有GetTypeInfo的方法</p>\n<p><strong>解决办法</strong>：4.0访问Type的BaseType、IsGenericType等属性，直接从Type对象调用即可，即如下的形式：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type type = XXX;</span><br><span class=\"line\"><span class=\"comment\">// 4.0版本</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> val = type.IsGenericType;</span><br><span class=\"line\">Type baseType = type.BaseType;</span><br><span class=\"line\"><span class=\"comment\">// 4.5以及以上版本</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> val = type.GetTypeInfo().IsGenericType;</span><br><span class=\"line\">Type baseType = type.GetTypeInfo().BaseType;</span><br></pre></td></tr></table></figure>\n<p>这里本人将代码抽离到ExHelper.ReflecionHelper中方便统一调用</p>\n<p><strong>5、Task.Run、Task.FromResult以及Task.Delay报错</strong></p>\n<p><strong>原因</strong>：在4.0中都不支持上述的几种方式进行调用</p>\n<p><strong>解决方案</strong>：通过Nuget加入Microsoft.Bcl、Microsoft.Bcl.Build以及Microsoft.Bcl.Async三个库到本项目中，然后将上述的所有地方的调用都替换为Microsoft.Threading.Tasks.TaskEx，如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4.5之后</span></span><br><span class=\"line\">Task.Run</span><br><span class=\"line\">Task.FromResult</span><br><span class=\"line\">Task.Delay</span><br><span class=\"line\"><span class=\"comment\">// 4.0，加入了Bcl之后</span></span><br><span class=\"line\">TaskEx.Run</span><br><span class=\"line\">TaskEx.FromResult</span><br><span class=\"line\">TaskEx.Delay</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里讲一下背景，微软发布了Microsoft.Bcl.Async的最终版本，参看博客<a href=\"http://blogs.msdn.com/b/bclteam/archive/2013/04/17/microsoft-bcl-async-is-now-stable.aspx\">Microsoft.Bcl.Async is Now Stable</a>。该包允许开发者在.NET 4、Silverlight 4和Windows Phone 7.5使用C# 5和VB中的异步特性。该包由三个库组成：Microsoft.Bcl、Microsoft.Bcl.Async和Microsoft.Bcl.Build。<strong>由于使用了<a href=\"http://msdn.microsoft.com/en-us/library/db7849ey.aspx\">程序集统一</a>的方式，解决方案中的所有工程都必须引用这三个库</strong>。</p>\n<p>C#发展至今，已经从最初的1.0到了5.0版本：</p>\n<ol>\n<li>1.0版本 - 基本C#语法。</li>\n<li>2.0版本 - 泛型的支持，CLR进行了升级，从根本上支持了运行时泛型。</li>\n<li>3.0版本 - LINQ，添加了<code>from</code> / <code>join</code>等类SQL关键字，添加了扩展函数，添加了编译期动态类型var关键字。</li>\n<li>4.0版本 - dynamic关键字，CLR进行升级，加入DLR，开始对动态进行友好的支持。同时加入动态参数、参数默认值、泛型协变等特性。</li>\n<li>5.0版本 - async/await关键字，将异步变得更为简单。</li>\n</ol>\n<p>async/await 将异步的编程模型统一为同步模型，简化开发复杂度，提升生产效率。微软正式发布了Microsoft.Bcl.Async的最终版本，这让.NET4里头也可以用上async/await，而不需要把项目更改为.net 4.5。</p>\n</blockquote>\n<p>这里为了统一入口，本人把这几个TaskEx的调用收口到ExHelper.TaskHelper中便于查找改动点。</p>\n<p>目前为止，我们应该解决了CefSharp库所有的问题，再次Rebuild该项目，Succeeded！</p>\n<h3 id=\"CefSharp-Core\"><a href=\"#CefSharp-Core\" class=\"headerlink\" title=\"CefSharp.Core\"></a>CefSharp.Core</h3><p>CefSharp.Core是一个C++的库，但是由于该C++库里面调用了一些C#代码，所以跟.Net Framework版本出现了相关性。这里我们同上一样，把79版本的CefSharp.Core源码加入到sln中，右键该项目，打开菜单最下面的properties：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-06-06-build-cefsharp/2.png\" alt=\"\"></p>\n<p>这里我们修改3个点：</p>\n<p>1、选择Windows SDK Version。点击Windows SDK Version右边的下拉框，选择我们安装的Windos10 SDK，如果你和我的SDK版本安装的是一样的，应该就是10.0.17763.0，但是理论上Windows8以上的SDK都应该没啥问题；</p>\n<p>2、选择Platform Toolset为我们安装的IDE的版本，这里我的就是Visual Studio 2017；</p>\n<p>3、手动填入.NET Target Framework Version 为：”v4.0”。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-06-06-build-cefsharp/3.png\" alt=\"\"></p>\n<p>完成上述修改后，我们还需要进行如下的操作：</p>\n<p>拷贝79版本源码解决方案根目录下的CefSharp.props文件到本sln根目录下</p>\n<p>这么做的原因是在CefSharp.Core的vcxproj文件中（VC++项目编译文件），有一处Import（自行搜索）：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Import</span> <span class=\"attr\">Project</span>=<span class=\"string\">&quot;..\\CefSharp.props&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后我们进行编译Rebuild，不出意外应该还是有大量的错误，乍一看出现的错误似乎让人摸不着头脑，什么” ‘AssmblyInfo’ : is not a class or namesapce name”等C#问题，可是明显在这些.NET 4.0上没有问题。本人突然想起以前在学校学习C/C++的时候，老师告诉我们处理C/C++编译处理一定要从最上面看，仔细看命令行编译最开始的地方有两处warning：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">warning MSB3268: The primary reference &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp\\bin\\x64\\Debug\\CefSharp.dll&quot; could not be resolved because it has an indirect dependency on the framework assembly &quot;System.Runtime, Version&#x3D;1.5.11.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a&quot; which could not be resolved in the currently targeted framework. &quot;.NETFramework,Version&#x3D;v4.0&quot;. To resolve this problem, either remove the reference &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp\\bin\\x64\\Debug\\CefSharp.dll&quot; or retarget your application to a framework version which contains &quot;System.Runtime, Version&#x3D;1.5.11.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">warning MSB3268: The primary reference &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp\\bin\\x64\\Debug\\CefSharp.dll&quot; could not be resolved because it has an indirect dependency on the framework assembly &quot;System.Threading.Tasks, Version&#x3D;1.5.11.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a&quot; which could not be resolved in the currently targeted framework. &quot;.NETFramework,Version&#x3D;v4.0&quot;. To resolve this problem, either remove the reference &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp\\bin\\x64\\Debug\\CefSharp.dll&quot; or retarget your application to a framework version which contains &quot;System.Threading.Tasks, Version&#x3D;1.5.11.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a&quot;.</span><br></pre></td></tr></table></figure>\n<p>这两个warning说我们的CefSharp因为Tasks相关动态库的版本不对无法编译，但是我们之前CefSharp已经完成了编译，似乎没有什么问题。实际上，我们CefSharp为了兼容使用了Bcl相关组件，上面我们提到：</p>\n<blockquote>\n<p><strong>由于使用了<a href=\"http://msdn.microsoft.com/en-us/library/db7849ey.aspx\">程序集统一</a>的方式，解决方案中的所有工程都必须引用这三个库</strong>。</p>\n</blockquote>\n<p>实际上C++的工程代码也不例外，所以我们添加Bcl库代码到工程中，由于nuget似乎无法为C++工程添加包，所以本人采用手工的方式添加：</p>\n<p>1、在vcxproj文件的适当位置添加如下的节点引入Bcl包里面的组件：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">......</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">&quot;System.ServiceModel&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">&quot;System.Runtime&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span>..\\packages\\Microsoft.Bcl.1.1.10\\lib\\net40\\System.Runtime.dll<span class=\"tag\">&lt;/<span class=\"name\">HintPath</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Reference</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">&quot;System.Threading.Tasks&quot;</span>&gt;</span>           \t       <span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span>..\\packages\\Microsoft.Bcl.1.1.10\\lib\\net40\\System.Threading.Tasks.dll<span class=\"tag\">&lt;/<span class=\"name\">HintPath</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Reference</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ClCompile</span> <span class=\"attr\">Include</span>=<span class=\"string\">&quot;AssemblyInfo.cpp&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">......</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2、让编译的时候识别到该Nuget包，vcxproj文件末尾添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">......</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">ImportGroup</span> <span class=\"attr\">Label</span>=<span class=\"string\">&quot;ExtensionTargets&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Import</span> <span class=\"attr\">Project</span>=<span class=\"string\">&quot;..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets&quot;</span> <span class=\"attr\">Condition</span>=<span class=\"string\">&quot;Exists(&#x27;..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets&#x27;)&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ImportGroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Target</span> <span class=\"attr\">Name</span>=<span class=\"string\">&quot;EnsureNuGetPackageBuildImports&quot;</span> <span class=\"attr\">BeforeTargets</span>=<span class=\"string\">&quot;PrepareForBuild&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">PropertyGroup</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">ErrorText</span>&gt;</span>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is &#123;0&#125;.<span class=\"tag\">&lt;/<span class=\"name\">ErrorText</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">PropertyGroup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Error</span> <span class=\"attr\">Condition</span>=<span class=\"string\">&quot;!Exists(&#x27;..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets&#x27;)&quot;</span> <span class=\"attr\">Text</span>=<span class=\"string\">&quot;$([System.String]::Format(&#x27;$(ErrorText)&#x27;, &#x27;..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets&#x27;))&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Target</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>3、修改packge.config文件（没有则新增）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packages</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- cef.sdk是需要的依赖包 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cef.sdk&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;79.1.36&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;native&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;Microsoft.Bcl&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.1.10&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net40&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;Microsoft.Bcl.Async&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.168&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net40&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;Microsoft.Bcl.Build&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.21&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net40&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">packages</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上述操作完成后需要进行Restore还原一下cef.sdk的NuGet包，然后再次进行编译，发现warning已经消除，但是还是编译失败，还是有很多“报错”，本人一开始找问题也找了很久以为全都是error，后来发现很多都是warning，最后发现2处关键点error（你们可以先自行搜索这两个地方，双击就可以跳转到对应的报错处）：</p>\n<p><strong>1、</strong>在CefSharp::Internals::Serialization中的SerializeV8SimpleObject有一处GetValue调用报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error C2661: &#39;System::Reflection::PropertyInfo::GetValue&#39;: no overloaded function takes 1 arguments</span><br></pre></td></tr></table></figure>\n<p><strong>2、</strong>在CefSharp::Internals::JavascriptCallbackProxy中的ExecuteWithTimeoutAsync有一处调用报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error C2039: &#39;FromResult&#39;: is not a member of &#39;System::Threading::Tasks::Task&#39;</span><br></pre></td></tr></table></figure>\n<p>这两处很明显是使用了C#的代码，且该代码是 .Net4.0不支持的，原因以及解决方法在上面的CefSharp中已经说了。这里我们修改按照C++语法改写下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、</span><br><span class=\"line\"><span class=\"keyword\">auto</span> propertyValue = properties[i]-&gt;GetValue(obj); <span class=\"comment\">// 4.5.2</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> propertyValue = properties[i]-&gt;GetValue(obj, <span class=\"literal\">nullptr</span>); <span class=\"comment\">// 4.0</span></span><br><span class=\"line\"><span class=\"number\">2</span>、</span><br><span class=\"line\"><span class=\"built_in\">Task</span>::FromResult(invalidFrameResponse); <span class=\"comment\">// 4.5.2</span></span><br><span class=\"line\">ExHelper::TaskHelper::FromResult(invalidFrameResponse); <span class=\"comment\">// 4.0 命名空间就对应的CefSharp里面的Helper</span></span><br></pre></td></tr></table></figure>\n<p>完成操作后，Rebuild sln，Succeeded！</p>\n<h3 id=\"CefSharp-BrowserSubprocess-Core\"><a href=\"#CefSharp-BrowserSubprocess-Core\" class=\"headerlink\" title=\"CefSharp.BrowserSubprocess.Core\"></a>CefSharp.BrowserSubprocess.Core</h3><p>同上操作，将4.5.2源码加入到sln中，和上述CefSharp.Core相同方式：</p>\n<p>1、修改properties；</p>\n<p><strong>2、增加Bcl包的依赖到vsxproj中。</strong></p>\n<p>完成操作后，直接进行Rebuild操作，因为该C++库并不涉及到C#的代码，所以只需要做上述增加Bcl库的相关操作，编译成功！</p>\n<h3 id=\"CefSharp-BrowserSubprocess\"><a href=\"#CefSharp-BrowserSubprocess\" class=\"headerlink\" title=\"CefSharp.BrowserSubprocess\"></a>CefSharp.BrowserSubprocess</h3><p>同上操作，将4.5.2源码加入到sln中，然后：<strong>1、切换版本为.NET 4.0；2、增加Bcl相关依赖包。</strong>因为是C#项目我们终于不用手工给csproj添加节点了，可以使用nuget添加Bcl三个包。</p>\n<p>添加完成后我们尝试编译该组件，不知道为什么，在我的机器上编译过程会出现如下的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">找不到命令的错误提示</span><br></pre></td></tr></table></figure>\n<p>但是查看编译结果还有输出目录能够看到是编译成功的，我也索性没有继续看下去了</p>\n<h3 id=\"CefSharp-WinForm\"><a href=\"#CefSharp-WinForm\" class=\"headerlink\" title=\"CefSharp.WinForm\"></a>CefSharp.WinForm</h3><p>终于到我们的UI层了，如上方式添加源码到项目里，然后：<strong>1、切换版本为.NET 4.0；2、增加Bcl相关依赖包。</strong>（如果你切换了框架后，右键该项目-Manage NuGet Packages出现报错nuget is invalid，请尝试关闭解决方案重新打开）。编译该项目，不出意外，编译成功～</p>\n<p>至此，跟.NET Framework绑定的代码已经全部编译通过，本来到此步骤，我们的编译工作已经完成了，但是官方提供了Example让我们可以调用看看样例，本人索性把Example和WinForm.Example两个工程也一并.NET 4.0化了。</p>\n<h3 id=\"CefSharp-Example\"><a href=\"#CefSharp-Example\" class=\"headerlink\" title=\"CefSharp.Example\"></a>CefSharp.Example</h3><p>该组件并非是必须组件，但是后续无论是Wpf还是WinForm的Example运行，都需要该组件，所以我们还是把它也.NET 4.0化。</p>\n<p>还是上述方式，添加到项目，然后：<strong>1、切换版本为.NET 4.0；2、增加Bcl相关依赖包。</strong>最后尝试进行编译，出现编译错误：</p>\n<p><strong>1、在CefSharp.Example.Handlers.DownloadHandler.OnBeforeDownloadFired函数中，定义的Eventhandler的泛型参数DownloadItem并不是EventArgs子类</strong></p>\n<p><strong>原因</strong>：在4.5之后，EventHandler的泛型参数可以不是EventArgs的子类，而在.Net 4.0必须是继承自EventArgs</p>\n<p><strong>解决办法</strong>：因为DownloadItem较为公共，我们不方便将其继承EventArgs，所以我们单独写一个自己的EventHandler，让其泛型参数接收任意类型：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">DownloadEventHandler</span>&lt;<span class=\"keyword\">in</span> <span class=\"title\">T</span>&gt;(<span class=\"params\"><span class=\"keyword\">object</span> sender, T args</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 改成我们的自己的下载事件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">event</span> DownloadEventHandler&lt;DownloadItem&gt; OnBeforeDownloadFired;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">event</span> DownloadEventHandler&lt;DownloadItem&gt; OnDownloadUpdatedFired;</span><br></pre></td></tr></table></figure>\n<p>再次编译，还会有一些剩下的和Task相关的编译报错问题，上文已经解释了原因和提供了解决方案，Do It！完成修改后，编译成功！</p>\n<h3 id=\"CefSharp-WinForm-Example\"><a href=\"#CefSharp-WinForm-Example\" class=\"headerlink\" title=\"CefSharp.WinForm.Example\"></a>CefSharp.WinForm.Example</h3><p>我们依然如上的方式进行工程的添加，添加的过程会弹出提示框报如下的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------------------------</span><br><span class=\"line\">Microsoft Visual Studio</span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">The imported project &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp.Native.props&quot; was not found. Confirm that the path in the &lt;Import&gt; declaration is correct, and that the file exists on disk.  E:\\Projects\\CefSharp-DotNet4.0\\CefSharp.WinForms.Example\\CefSharp.WinForms.Example.csproj</span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">确定   </span><br><span class=\"line\">---------------------------</span><br></pre></td></tr></table></figure>\n<p>上述提示表明，我们缺少CefSharp.Native.props，在官方源码中的解决方案根目录下找到对应的文件拷贝到我们的目录下。拷贝完成后，<strong>我们先不进行切换Framework和添加Bcl依赖包的操作</strong>，我们首先打开该项目的package.config文件，可以看到有如下的内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cef.redist.x64&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;79.1.36&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net462&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cef.redist.x86&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;79.1.36&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net462&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;Microsoft.Net.Compilers&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.9.0&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net462&quot;</span> <span class=\"attr\">developmentDependency</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>很明显和我们即将要切换的.NET4.0不符合，接下来我们再进行如下操作：</p>\n<p>1、先Restore这些NuGet包，然后卸载掉，最后再切换为4.0；</p>\n<p>2、<strong>只安装Bcl相关组件包，不安装上述卸载的cef.redist和Compiler</strong></p>\n<p>进行编译，不出意外会出现如下的几个编译错误：</p>\n<p><strong>1、error CS0117: ‘TaskContinuationOptions’ does not contain a definition for ‘HideScheduler’</strong></p>\n<p><strong>原因</strong>：Net4.0中没有这个定义</p>\n<p><strong>解决办法</strong>：因为是Demo，我们使用的TaskContinuationOptions.None的枚举暂时避过编译</p>\n<p><strong>2、error CS0103: The name ‘AppContext’ does not exist in the current context</strong></p>\n<p><strong>原因</strong>：Net4.0中没有这个定义</p>\n<p><strong>解决办法</strong>：这里的目的是获取CefSharp.Example\\Extensions里面的文件，我们使用System.AppDomain.CurrentDomain.BaseDirectory即可</p>\n<p>剩下的几个编译问题还是Task的问题，不在赘述。</p>\n<p>完成编译以后，我们尝试运行该WinForm.Example，提示：</p>\n<blockquote>\n<p>未能加载文件或程序集“CefSharp.Core.dll”或它的某一个依赖项。找不到指定的模块</p>\n</blockquote>\n<p>检查Bin目录下的，发现已经有了该dll，那么就是缺少了CefSharp.Core.dll需要的组件。实际上，刚才我们移除了2个NuGet依赖包：</p>\n<p>cef.redist.x64、cef.redist.x86，这里面是Cef的核心资源与类库，就包含了CefSharp.Core所需要的所有资源。</p>\n<p>重新安装这两个组件包，但需要注意的是对应版本一定要对应当前的版本（79.1.36）。安装完成后，我们检查packages里面的cef.redist组件包，可以看到CEF文件夹下面有我们需要的ceflib.dll等类库和资源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locales(dir)</span><br><span class=\"line\">swiftshader(dir)</span><br><span class=\"line\">cef.pak</span><br><span class=\"line\">cef_100_percent.pak</span><br><span class=\"line\">cef_200_percent.pak</span><br><span class=\"line\">cef_extensions.pak</span><br><span class=\"line\">chrome_elf.dll</span><br><span class=\"line\">d3dcompiler_47.dll</span><br><span class=\"line\">devtools_resources.pak</span><br><span class=\"line\">icudtl.dat</span><br><span class=\"line\">libcef.dll</span><br><span class=\"line\">libEGL.dll</span><br><span class=\"line\">libGLESv2.dll</span><br><span class=\"line\">natives_blob.bin</span><br><span class=\"line\">README.txt</span><br><span class=\"line\">snapshot_blob.bin</span><br><span class=\"line\">v8_context_snapshot.bin</span><br></pre></td></tr></table></figure>\n<p>我们再次运行，终于出现关于WinForm的Example！</p>\n<h2 id=\"制品梳理\"><a href=\"#制品梳理\" class=\"headerlink\" title=\"制品梳理\"></a>制品梳理</h2><ul>\n<li>NuGet引用Microsoft.Bcl、Microsoft.Bcl.Build以及Microsoft.Bcl.Async</li>\n</ul>\n<p>引入上述3个依赖库组件是因为我们为了将CefSharp代码使用.NET 4.0进行编译，兼容async/await等Task相关的特性而引入的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Miscrosoft.Threading.Tasks.dll</span><br><span class=\"line\">Miscrosoft.Threading.Tasks.Extensions.dll</span><br><span class=\"line\">Miscrosoft.Threading.Tasks.Extensions.Desktop.dll</span><br><span class=\"line\">System.IO.dll</span><br><span class=\"line\">System.Runtime.dll</span><br><span class=\"line\">System.Threading.Tasks.dll</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NuGet引用cef.redist. x86/x64</li>\n</ul>\n<p>该NuGet包中包含Cef原生需要的组件和资源包，包括核心的ceflib.dll，具体内容请查看packages/cef.redist. x86/x64/CEF中的所有。</p>\n<ul>\n<li>基于DotNet 4.0编译的CefSharp核心依赖库</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CefSharp（C#）</span><br><span class=\"line\">CefSharp.Core（C++）</span><br><span class=\"line\">CefSharp.BrowserSubprocess.Core（C++）</span><br><span class=\"line\">CefSharp.BrowserSubprocess（C#）</span><br><span class=\"line\">CefSharp.WinForms（C#）</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["CefSharp"]},{"title":"Git常用命令参考手册","url":"http://compilemind.com/2020/04/06/2020-04-06-Git常用命令参考手册/","content":"<h1 id=\"Git常用命令参考手册\"><a href=\"#Git常用命令参考手册\" class=\"headerlink\" title=\"Git常用命令参考手册\"></a>Git常用命令参考手册</h1><p>基本git命令</p>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#配置\">配置</a></li>\n<li><a href=\"#初始化本地仓库\">初始化本地仓库</a></li>\n<li><a href=\"#文件状态\">文件状态</a></li>\n<li><a href=\"#日志\">日志</a></li>\n<li><a href=\"#克隆\">克隆</a></li>\n<li><a href=\"#查看分支\">查看分支</a></li>\n<li><a href=\"#切换分支\">切换分支</a></li>\n<li><a href=\"#创建分支\">创建分支</a></li>\n<li><a href=\"#删除分支\">删除分支</a></li>\n<li><a href=\"#重命名分支\">重命名分支</a></li>\n<li><a href=\"#代码合并\">代码合并</a></li>\n<li><a href=\"#暂存\">暂存</a></li>\n<li><a href=\"#删除\">删除</a></li>\n<li><a href=\"#提交\">提交</a></li>\n<li><a href=\"#推送\">推送</a></li>\n<li><a href=\"#提交\">提交</a></li>\n<li><a href=\"#拉取、获取内容\">拉取、获取内容</a></li>\n<li><a href=\"#查看文件的改动\">查看文件的改动</a></li>\n<li><a href=\"#回滚版本\">回滚版本</a></li>\n<li><a href=\"#撤销\">撤销</a></li>\n<li><a href=\"#标签\">标签</a></li>\n<li><a href=\"#其他\">其他</a></li>\n</ul>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看配置列表</span></span><br><span class=\"line\">git config -l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看已设置的用户名</span></span><br><span class=\"line\">git config --global --get user.name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置用户名</span></span><br><span class=\"line\">git config --global user.name <span class=\"variable\">$&#123;username&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看已设置的邮箱</span></span><br><span class=\"line\">git config --global --get user.email</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置邮箱</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;example@example.com&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 上述配置均可在用户目录下的.gitconfig文件中进行查看配置</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化本地仓库\"><a href=\"#初始化本地仓库\" class=\"headerlink\" title=\"初始化本地仓库\"></a>初始化本地仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 会在当前目录生成.git</span></span><br><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件状态\"><a href=\"#文件状态\" class=\"headerlink\" title=\"文件状态\"></a>文件状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<h3 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看完整历史提交记录</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看前2次提交记录 commit message</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看前2次提交记录，包括diff</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -p -2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索关键词</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -S 你好</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出提交者贡献数量</span></span><br><span class=\"line\">git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 单行简要显示内容</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --oneline</span><br></pre></td></tr></table></figure>\n<h3 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># https 协议</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/<span class=\"variable\">$&#123;username&#125;</span>/<span class=\"variable\">$&#123;git-repo&#125;</span>.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># SSH协议</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:<span class=\"variable\">$&#123;username&#125;</span>/<span class=\"variable\">$&#123;git-repo&#125;</span>.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 克隆某个分支， -b 后面分支名字</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> -b <span class=\"variable\">$&#123;branch-name&#125;</span> https://github.com/<span class=\"variable\">$&#123;username&#125;</span>/<span class=\"variable\">$&#123;git-repo&#125;</span>.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 递归克隆，适用于项目中包含子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive <span class=\"variable\">$&#123;username&#125;</span>@github.com/<span class=\"variable\">$&#123;username&#125;</span>/<span class=\"variable\">$&#123;git-repo&#125;</span>.git</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h2><h3 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有分支</span></span><br><span class=\"line\">git branch --all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看本地分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看远程仓库地址</span></span><br><span class=\"line\">git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看远端分支</span></span><br><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 2种方法，切换到master分支</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git switch master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换上一个分支</span></span><br><span class=\"line\">git checkout -</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建dev分支</span></span><br><span class=\"line\">git branch dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建develop分支并切换</span></span><br><span class=\"line\">git checkout -b dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换远端分支</span></span><br><span class=\"line\">git checkout -t origin/dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除本地分支</span></span><br><span class=\"line\">git branch -d <span class=\"variable\">$&#123;branchName&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程分支</span></span><br><span class=\"line\">git branch -d -r origin/<span class=\"variable\">$&#123;branchName&#125;</span></span><br><span class=\"line\">git push origin :<span class=\"variable\">$&#123;branchName&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"重命名分支\"><a href=\"#重命名分支\" class=\"headerlink\" title=\"重命名分支\"></a>重命名分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重命名当前分支</span></span><br><span class=\"line\">git branch -m <span class=\"variable\">$&#123;branchName&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"代码合并\"><a href=\"#代码合并\" class=\"headerlink\" title=\"代码合并\"></a>代码合并</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 两步法, 将feature分支代码合并到dev</span></span><br><span class=\"line\"><span class=\"comment\"># 1、切换到dev分支</span></span><br><span class=\"line\">git checkout dev</span><br><span class=\"line\"><span class=\"comment\"># 2、将feature合并到当前dev分支</span></span><br><span class=\"line\">git merge feature</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同上效果</span></span><br><span class=\"line\">git merge feature dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"内容操作\"><a href=\"#内容操作\" class=\"headerlink\" title=\"内容操作\"></a>内容操作</h2><h3 id=\"暂存\"><a href=\"#暂存\" class=\"headerlink\" title=\"暂存\"></a>暂存</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 暂存所有</span></span><br><span class=\"line\">git add -A</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂存某个文件</span></span><br><span class=\"line\">git add ./README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加当前目录所有改动文件</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂存一系列文件</span></span><br><span class=\"line\">git add 1.txt 2.txt ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>git add 的反向操作<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除1.txt 文件</span></span><br><span class=\"line\">git rm 1.txt</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -m 提交的信息</span></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;changes log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交显示diff变化</span></span><br><span class=\"line\">git commit -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"推送\"><a href=\"#推送\" class=\"headerlink\" title=\"推送\"></a>推送</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 推送内容到主分支</span></span><br><span class=\"line\">git push -u origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本地分支推送到远程， 本地分支:远程分支</span></span><br><span class=\"line\">git push origin <span class=\"variable\">$&#123;localBranchName&#125;</span>:<span class=\"variable\">$&#123;remoteBranchName&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 简写，默认推送当前分支</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 强制推送, -f =&gt; --force</span></span><br><span class=\"line\">git push -f</span><br></pre></td></tr></table></figure>\n<h3 id=\"拉取、获取内容\"><a href=\"#拉取、获取内容\" class=\"headerlink\" title=\"拉取、获取内容\"></a>拉取、获取内容</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取远端名为master的分支，但不会进行自动合并，需要手动merge</span></span><br><span class=\"line\">git fetch origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 等同于git fetch 然后 git merge</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉去远端分支master到本地分支master</span></span><br><span class=\"line\">git pull origin master:master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取远端分支master到本地【当前】分支</span></span><br><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看文件的改动\"><a href=\"#查看文件的改动\" class=\"headerlink\" title=\"查看文件的改动\"></a>查看文件的改动</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有文件改动</span></span><br><span class=\"line\">git diff</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看具体文件的改动</span></span><br><span class=\"line\">git diff README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看某个版本的改动, 后面那一窜是commitId， git log后就能看到</span></span><br><span class=\"line\">git diff <span class=\"variable\">$&#123;commitId&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看某个文件的历史修改记录</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> README.md</span><br><span class=\"line\">git show <span class=\"variable\">$&#123;commitId&#125;</span> README.md</span><br></pre></td></tr></table></figure>\n<h3 id=\"回滚版本\"><a href=\"#回滚版本\" class=\"headerlink\" title=\"回滚版本\"></a>回滚版本</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回滚上一个版本</span></span><br><span class=\"line\">git reset --hard HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回滚上两个版本</span></span><br><span class=\"line\">git reset --hard HEAD^^</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回退到指定版本，git log 就能看到commit id了</span></span><br><span class=\"line\">git reset --hard <span class=\"string\">&#x27;$&#123;commitId&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回滚版本是不保存在 git log，如果想查看使用</span></span><br><span class=\"line\">git reflog</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 撤销当前目录下所有文件的改动</span></span><br><span class=\"line\">git checkout -- .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 撤销指定文件修改</span></span><br><span class=\"line\">git checkout -- README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂存区回到工作区, 指定 ./README.md 文件从暂存区回到工作区</span></span><br><span class=\"line\">git reset HEAD ./README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 撤销commit, 回到工作区, 一般commitId是前一个</span></span><br><span class=\"line\">git reset <span class=\"variable\">$&#123;commitId&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 撤销commit, 并且把修改同时撤销</span></span><br><span class=\"line\">git reset --hard <span class=\"variable\">$&#123;commitId&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出本地所有标签</span></span><br><span class=\"line\">git tag</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出远程所有标签</span></span><br><span class=\"line\">git ls-remote --tags origin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按照特定模式查找标签, `*` 模板搜索</span></span><br><span class=\"line\">git tag -l <span class=\"string\">&quot;v1.0.0*&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建带有附注标签</span></span><br><span class=\"line\">git tag -a v1.1.0 -m <span class=\"string\">&quot;标签描述&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建轻量标签, 不需要带任何参数</span></span><br><span class=\"line\">git tag v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后期打标签, 假设之前忘记打标签了，可以通过git log查看commit id</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\">git tag -a v1.1.0 <span class=\"variable\">$&#123;commitId&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推送到远程，默认只是本地创建</span></span><br><span class=\"line\">git push origin v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一次性推送所有标签到远程</span></span><br><span class=\"line\">git push origin --tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除标签, 你需要再次运行 git push origin v1.1.0 才能删除远程标签</span></span><br><span class=\"line\">git tag -d v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程标签</span></span><br><span class=\"line\">git push origin --delete v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查标签</span></span><br><span class=\"line\">git checkout v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看本地某个标签详细信息</span></span><br><span class=\"line\">git show v1.1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"密码配置\"><a href=\"#密码配置\" class=\"headerlink\" title=\"密码配置\"></a>密码配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 记住提交账号密码</span></span><br><span class=\"line\">git config --global credential.helper store</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清除git已保存的用户名和密码</span></span><br><span class=\"line\"><span class=\"comment\"># windows</span></span><br><span class=\"line\">git credential-manager uninstall</span><br><span class=\"line\"><span class=\"comment\"># mac linux</span></span><br><span class=\"line\">git config --global credential.helper store</span><br></pre></td></tr></table></figure>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><h3 id=\"MIT\"><a href=\"#MIT\" class=\"headerlink\" title=\"MIT\"></a>MIT</h3>","categories":[],"tags":[]},{"title":"WinForm事件与消息","url":"http://compilemind.com/2020/02/05/2020-02-05-WinForm事件与消息/","content":"<h3 id=\"消息概述以及在C-下的封装\"><a href=\"#消息概述以及在C-下的封装\" class=\"headerlink\" title=\"消息概述以及在C#下的封装\"></a>消息概述以及在C#下的封装</h3><p>Windows下应用程序的执行是通过消息驱动的。所有的外部事件，如键盘输入、鼠标移动、按动鼠标都由OS系统转换成相应的“消息”，进入到应用程序的消息队列中，由应用程序引擎轮询处理。在C#中，消息被应用程序的工作引擎通过轮询等方式遍历获取并按照消息的类型逐个分发到对应的组件（例如窗体、按钮等），最后调用对应组件所注册的事件进行处理。</p>\n<a id=\"more\"></a>\n<p>在.NET框架类库中的System.Windows.Forms命名空间中微软采用面对对象的方式重新定义了Message。该消息主要有一下的几个公共属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.Windows.Forms.Message</span><br><span class=\"line\">HWnd     获取或设定消息的处理函数</span><br><span class=\"line\">Msg      获取或设定消息的ID号</span><br><span class=\"line\">Lparam   指定消息的LParam字段</span><br><span class=\"line\">Wparam   指定消息的WParam字段</span><br><span class=\"line\">Result   指定为响应消息处理函数而向OS系统返回的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"System-Windows-Forms-Application\"><a href=\"#System-Windows-Forms-Application\" class=\"headerlink\" title=\"System.Windows.Forms.Application\"></a>System.Windows.Forms.Application</h3><p>System.Windows.Forms.Application类具有用于启动和停止应用程序和线程以及处理Windows消息的方法。例如，调用Run以启动当前线程上的应用程序消息循环，并可以选择使其窗体可见；调用Exit或ExitThread来停止消息循环。所以我们经常使用vs初始化一个基本的WinForm程序，显示的下列模板代码：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 应用程序的主入口点。</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">[<span class=\"meta\">STAThread</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Application.EnableVisualStyles();</span><br><span class=\"line\">    Application.SetCompatibleTextRenderingDefault(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    Application.Run(<span class=\"keyword\">new</span> Form1()); <span class=\"comment\">// 调用Run以启动当前线程上的应用程序消息循环</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为Application是在单线程中运行的，所以在Application.Run开始后，Application本身不断轮询检查消息队列，然后根据消息类型进行数据分发。例如，当我们为这个Form1增加一个鼠标的点击事件后，我们运行该打开Form1：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Form1 form1 = <span class=\"keyword\">new</span> Form1();</span><br><span class=\"line\">form1.MouseClick += (sender, e) =&gt; MessageBox.Show(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">form1.MouseClick += (sender, e) =&gt; MessageBox.Show(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">Application.Run(form1);</span><br></pre></td></tr></table></figure><br>运行后点击Form，可以看到首先出现一个MessageBox，展示“1”，我们点击确定后，又会出现MessageBox，展示“2”。实际上整个过程应该如下：</p>\n<p>当我们按下鼠标左键后，消息形成并送往应用程序消息队列中，然后被Application类从应用程序消息队列中取出，然后分发到相应的窗体。窗体使用MouseClick事件中的函数指针调用已经添加的响应函数。所以C#中的事件字段实质上是一个函数指针列表，用来维护一些消息到达时的响应函数的地址。</p>\n<p>到目前为止我们可以看到，消息其实在我们进行事件调用的时候，已经被提取加工了，它已经由Application进行了预处理，形成了所谓的“事件调用”。那么，我们还能更加自定义的干预消息吗？答案是可以的。</p>\n<h3 id=\"WndProc\"><a href=\"#WndProc\" class=\"headerlink\" title=\"WndProc\"></a>WndProc</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\"> &#x2F;&#x2F; 摘要:</span><br><span class=\"line\">&#x2F;&#x2F;     处理 Windows 消息。</span><br><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\">&#x2F;&#x2F; 参数:</span><br><span class=\"line\">&#x2F;&#x2F;   m:</span><br><span class=\"line\">&#x2F;&#x2F;     要处理的 Windows System.Windows.Forms.Message。</span><br><span class=\"line\">protected override void WndProc(ref System.Windows.Forms.Message e);</span><br></pre></td></tr></table></figure>\n<p>对于每个Form来说，我们都可以重写该方法，该方法的参数就是上面提到的Message类的实例，所有的消息在被获取后，正常情况下都会被封装为Message对象，然后由Application工作引擎调用对用的Form.WndProc传入该Messsage，由于Form子类重写了该方法，所以如果希望底层能处理相关的消息，需要通过base.WndProc传递到父类继续调用。下面就是一个代码示例来展示控制如果当前的消息是鼠标左键点击，则弹出MessageBox展示“WndProc MouseClick”：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">WndProc</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Message m</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> WM_LBUTTONDOWN = <span class=\"number\">0x0201</span>;<span class=\"comment\">// 鼠标左键点击</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.Msg == WM_LBUTTONDOWN)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBox.Show(<span class=\"string\">&quot;WndProc MouseClick&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">base</span>.WndProc(<span class=\"keyword\">ref</span> m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"IMessageFilter\"><a href=\"#IMessageFilter\" class=\"headerlink\" title=\"IMessageFilter\"></a>IMessageFilter</h3><p>除了上述的WndProc之外，其实更加便于处理应该的实现IMessageFilter接口，然后让Application将实现该接口的消息过滤器添加到Application中：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MyMessageFilter</span> : <span class=\"title\">IMessageFilter</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">PreFilterMessage</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Message m</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>     &#123;</span><br><span class=\"line\">         <span class=\"comment\">//返回值为true， 表示消息已被处理，不要再往后传递，因此消息被截获</span></span><br><span class=\"line\">         <span class=\"comment\">//返回值为false，表示消息未被处理，需要再往后传递，因此消息未被截获</span></span><br><span class=\"line\">         <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> WM_LBUTTONDOWN = <span class=\"number\">0x0201</span>;<span class=\"comment\">// 鼠标左键点击</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (m.Msg == WM_LBUTTONDOWN)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             MessageBox.Show(<span class=\"string\">&quot;MyMessageFilter MouseClick&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>编写完成后，在应用程序初始化的过程中，添加该过滤器：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application.AddMessageFilter(<span class=\"keyword\">new</span> MyMessageFilter());</span><br></pre></td></tr></table></figure>\n<p>同样的，我们启动应用程序并点击实验，可以看到正常的MessageBox输出。</p>\n","categories":[],"tags":["WinForm"]},{"title":"基于Tesseract组件的OCR识别","url":"http://compilemind.com/2020/02/04/2020-02-04-基于Tesseract组件的OCR识别学习/","content":"<h2 id=\"背景以及介绍\"><a href=\"#背景以及介绍\" class=\"headerlink\" title=\"背景以及介绍\"></a>背景以及介绍</h2><p>欲研究C#端如何进行图像的基本OCR识别，找到一款开源的OCR识别组件。该组件当前已经已经升级到了4.0版本。和传统的版本（3.x）比，4.0时代最突出的变化就是基于LSTM神经网络。Tesseract本身是由C++进行编写，但为了同时适配不同的语言进行调用，开放调用API并产生了诸如Java、C#、Python等主流语言在内的封装版本。本次主要研究C#封装版。</p>\n<a id=\"more\"></a>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>Tesseract本身由C++编写并开源在<a href=\"https://github.com/tesseract-ocr/tesseract\">Github</a>，在3.X版本中，Tesseract的识别模式为字符识别，该种识别方式识别能力较低，所以在后来的4.X版本中，引入了LSTM（Long short-term memory，长短期记忆神经网络），极大的提升了识别率。为了让不同的语言均能够使用Tesseract进行OCR识别，Tesseract也是开放了API并产生了诸如Java、C#、Python等主流语言在内的封装版本。而本次C#端的封装版也开源在了<a href=\"https://github.com/charlesw/tesseract\">Github</a>，目前已知的C#封装版已发布在nuget上，封装了对应Tesseract的版本为3.05.02。所以目前的项目结构如下：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/版本封装.png\" alt=\"版本封装\"></p>\n<h2 id=\"Demo实验\"><a href=\"#Demo实验\" class=\"headerlink\" title=\"Demo实验\"></a>Demo实验</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><h4 id=\"文本识别数据包准备\"><a href=\"#文本识别数据包准备\" class=\"headerlink\" title=\"文本识别数据包准备\"></a>文本识别数据包准备</h4><p>因为图像识别本身需要文本识别数据进行匹配，所以我们需要下载对应Tesseract官方的文本数据包：<br><a href=\"https://tesseract-ocr.github.io/tessdoc/Data-Files\">https://tesseract-ocr.github.io/tessdoc/Data-Files</a><br>注意，针对不同版本的Tesseract-OCR（3.X和4.X底层的实现方式不同，所以文本识别数据包是不同的），我们需要找到对应的不同的文本训练数据包，官网为了更好的兼容性，4.X版本的文本数据包是兼容了3.X版本的。</p>\n<p>&gt;<br>the third set in tessdata is the only one that supports the legacy recognizer. The 4.00 files from November 2016 have both legacy and older LSTM models. The current set of files in tessdata have the legacy models and newer LSTM models (integer versions of 4.00.00 alpha models in tessdata_best).<br>&gt;</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/数据包下载.png\" alt=\"数据包下载\"></p>\n<p>为了Demo，我下载了中文简体和英文的数据包作为实验对象</p>\n<h4 id=\"开发环境准备\"><a href=\"#开发环境准备\" class=\"headerlink\" title=\"开发环境准备\"></a>开发环境准备</h4><p>为了实验并对比上面两个封装版本的识别效果，这里在同一解决方案中创建了两个项目：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/项目创建.png\" alt=\"项目创建\"></p>\n<p>BaseNewBeta使用的是封装了4.1版本Tesseract的C#封装版Tesseract.4.1.0-beta1，因为该版本还还没有上传只Nuget，所以只能从github上下载，放到本地，然后把对应的C++的底层库（leptonica-1.78.0.dll，tesseract41.dll）放置到了x86和x64文件夹下面且需要输出。</p>\n<p>BaseNuget是已经上传至Nuget的封装了底层库3.05.20版本的C#封装版3.3.0.0，因为使用nuget进行组件安装，所以x64和x86的Tesseract组件会在编译输出时候自动输出到对应的生成目录。</p>\n<h4 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h4><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (openFileDialog1.ShowDialog() == DialogResult.OK)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//PictureBox控件显示图片</span></span><br><span class=\"line\">    pictureBox1.Load(openFileDialog1.FileName);</span><br><span class=\"line\">    <span class=\"comment\">//获取用户选择文件的后缀名 </span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extension = Path.GetExtension(openFileDialog1.FileName);</span><br><span class=\"line\">    <span class=\"comment\">//声明允许的后缀名 </span></span><br><span class=\"line\">    <span class=\"keyword\">string</span>[] str = <span class=\"keyword\">new</span> <span class=\"keyword\">string</span>[] &#123; <span class=\"string\">&quot;.jpg&quot;</span>, <span class=\"string\">&quot;.png&quot;</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!str.Contains(extension))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBox.Show(<span class=\"string\">&quot;仅能上传jpg,png格式的图片！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//识别图片文字</span></span><br><span class=\"line\">        Bitmap img = <span class=\"keyword\">new</span> Bitmap(openFileDialog1.FileName);</span><br><span class=\"line\">        <span class=\"comment\">// 构建识别引擎</span></span><br><span class=\"line\">        TesseractEngine orcEngine = <span class=\"keyword\">new</span> TesseractEngine(<span class=\"string\">&quot;./tessdata&quot;</span>, <span class=\"string\">&quot;eng&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 识别并获取文本数据</span></span><br><span class=\"line\">        Page page = orcEngine.Process(img);</span><br><span class=\"line\">        richTextBox1.Text = page.GetText();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h4><h5 id=\"英文识别效果\"><a href=\"#英文识别效果\" class=\"headerlink\" title=\"英文识别效果\"></a>英文识别效果</h5><p>先是3.X版本识别：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/EnNuget.png\" alt=\"EnNuget\"><br>可以看到文本中还有很多识别的错误的，特别是把英文字符C识别为了括号（。<br>而封装了新版本的识别结果比起之前更好：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/EnNewBeta.png\" alt=\"EnNewBeta\"></p>\n<h5 id=\"中文识别效果\"><a href=\"#中文识别效果\" class=\"headerlink\" title=\"中文识别效果\"></a>中文识别效果</h5><p>先是3.X版本识别：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/CNNuget.png\" alt=\"CNNuget\"><br>然后是封装的版本：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/CNNewBeta.png\" alt=\"CNNewBeta\"><br>看的出来，官方的数据包对于中文的识别还是有很大问题的，不过庆幸的是，4.X版本的后的Tesseract支持我们使用的自己的数据进行识别训练。这样一来，虽然该组件还比不上市面上大多数的商业OCR识别，但是我们可以使用训练数据，来训练适用于我们特定业务的文字识别（比如XX码的提取之类）</p>\n","categories":[],"tags":["OCR"]},{"title":"那些我用Windows时必备的软件","url":"http://compilemind.com/2019/02/25/2019-02-25-那些我用Windows时必备的软件/","content":"<a id=\"more\"></a>\n<h1 id=\"坚果云\"><a href=\"#坚果云\" class=\"headerlink\" title=\"坚果云\"></a><a href=\"https://www.jianguoyun.com/s/downloads\">坚果云</a></h1><h1 id=\"Microsoft-YaHei-Mono-字体-（提取码：epsq）\"><a href=\"#Microsoft-YaHei-Mono-字体-（提取码：epsq）\" class=\"headerlink\" title=\"Microsoft YaHei Mono 字体 （提取码：epsq）\"></a><a href=\"https://pan.baidu.com/s/1WuCJ5VW7nypzp4dgCTcMtQ\">Microsoft YaHei Mono 字体</a> （提取码：epsq）</h1><h1 id=\"7-Zip\"><a href=\"#7-Zip\" class=\"headerlink\" title=\"7-Zip\"></a><a href=\"https://www.7-zip.org/\">7-Zip</a></h1><h1 id=\"AIDA64Extreme\"><a href=\"#AIDA64Extreme\" class=\"headerlink\" title=\"AIDA64Extreme\"></a><a href=\"https://www.aida64.com/downloads\">AIDA64Extreme</a></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key：FARRD-CU2D6-J9D59-LD2Q4-3AJG7</span><br></pre></td></tr></table></figure>\n<h1 id=\"apache-maven\"><a href=\"#apache-maven\" class=\"headerlink\" title=\"apache-maven\"></a><a href=\"http://maven.apache.org/download.cgi\">apache-maven</a></h1><ol>\n<li>环境变量设置</li>\n<li>阿里镜像配置<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bin目录conf中复制一份settings.xml到用户目录/.m2/下（没有就手动创建）</span><br><span class=\"line\">// 在settings.xml的mirrors节点下面添加如下子节点</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus-aliyun<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Nexus aliyun<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>命令行进行初始化<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn help:system</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"BaiduNetdisk\"><a href=\"#BaiduNetdisk\" class=\"headerlink\" title=\"BaiduNetdisk\"></a><a href=\"https://pan.baidu.com/download\">BaiduNetdisk</a></h1><h1 id=\"VLC-media-player\"><a href=\"#VLC-media-player\" class=\"headerlink\" title=\"VLC media player\"></a><a href=\"https://www.videolan.org/\">VLC media player</a></h1><h1 id=\"滴答清单\"><a href=\"#滴答清单\" class=\"headerlink\" title=\"滴答清单\"></a><a href=\"https://www.dida365.com/about/download\">滴答清单</a></h1><h1 id=\"eudic\"><a href=\"#eudic\" class=\"headerlink\" title=\"eudic\"></a><a href=\"https://www.eudic.net/v4/en/app/eudic\">eudic</a></h1><h1 id=\"Everything\"><a href=\"#Everything\" class=\"headerlink\" title=\"Everything\"></a><a href=\"https://www.voidtools.com/zh-cn/\">Everything</a></h1><h1 id=\"FSCapture\"><a href=\"#FSCapture\" class=\"headerlink\" title=\"FSCapture\"></a><a href=\"https://faststone.org/FSCaptureDownload.htm\">FSCapture</a></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name：bluman</span><br><span class=\"line\">key：VPISCJULXUFGDDXYAUYF</span><br></pre></td></tr></table></figure>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a><a href=\"https://git-scm.com/downloads\">Git</a></h1><h1 id=\"grepWin\"><a href=\"#grepWin\" class=\"headerlink\" title=\"grepWin\"></a><a href=\"https://github.com/stefankueng/grepWin/releases\">grepWin</a></h1><h1 id=\"ILSpy\"><a href=\"#ILSpy\" class=\"headerlink\" title=\"ILSpy\"></a><a href=\"https://github.com/icsharpcode/ILSpy/releases\">ILSpy</a></h1><h1 id=\"jdk8（AdoptOpenJDK）\"><a href=\"#jdk8（AdoptOpenJDK）\" class=\"headerlink\" title=\"jdk8（AdoptOpenJDK）\"></a><a href=\"https://adoptopenjdk.net/releases.html?variant=openjdk8&amp;jvmVariant=hotspot\">jdk8（AdoptOpenJDK）</a></h1><ol>\n<li>环境变量设置</li>\n</ol>\n<h1 id=\"JetBrains-IntelliJ-IDEA\"><a href=\"#JetBrains-IntelliJ-IDEA\" class=\"headerlink\" title=\"JetBrains IntelliJ IDEA\"></a><a href=\"https://www.jetbrains.com/idea/download/\">JetBrains IntelliJ IDEA</a></h1><h1 id=\"Microsoft-Visual-Studio\"><a href=\"#Microsoft-Visual-Studio\" class=\"headerlink\" title=\"Microsoft Visual Studio\"></a><a href=\"https://visualstudio.microsoft.com/zh-hans/vs/\">Microsoft Visual Studio</a></h1><h1 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a><a href=\"https://nodejs.org/en/\">nodejs</a></h1><h1 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a><a href=\"https://www.vim.org/\">vim</a></h1><h1 id=\"PicGo\"><a href=\"#PicGo\" class=\"headerlink\" title=\"PicGo\"></a><a href=\"https://github.com/Molunerfinn/PicGo/releases\">PicGo</a></h1><h1 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"$$R\"></a><a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\">$$R</a></h1><h1 id=\"SumatraPDF\"><a href=\"#SumatraPDF\" class=\"headerlink\" title=\"SumatraPDF\"></a><a href=\"https://github.com/sumatrapdfreader/sumatrapdf/releases\">SumatraPDF</a></h1><h1 id=\"Thunder-Network-提取码：ufce\"><a href=\"#Thunder-Network-提取码：ufce\" class=\"headerlink\" title=\"Thunder Network (提取码：ufce)\"></a><a href=\"https://pan.baidu.com/s/1b8mJY_wwGO8zt0nCDVW86Q\">Thunder Network</a> (提取码：ufce)</h1><h1 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a><a href=\"https://typora.io/\">Typora</a></h1><h1 id=\"uTools\"><a href=\"#uTools\" class=\"headerlink\" title=\"uTools\"></a><a href=\"https://u.tools/\">uTools</a></h1><h1 id=\"AutoHotKey\"><a href=\"#AutoHotKey\" class=\"headerlink\" title=\"AutoHotKey\"></a><a href=\"https://www.autohotkey.com/\">AutoHotKey</a></h1><h1 id=\"WinSCP\"><a href=\"#WinSCP\" class=\"headerlink\" title=\"WinSCP\"></a><a href=\"https://winscp.net/eng/download.php\">WinSCP</a></h1>","categories":[],"tags":["软件"]},{"title":"关于人的思考","url":"http://compilemind.com/2019/02/16/2019-02-16-关于人的思考/","content":"<p><em>人总是要思考的。人生一世，思考总是每时每刻都伴随我们前行。各种情景中，如：失落、高兴、烦恼等等，我们都要思考。有了思考，我们才能在这个世界立足;有了思考，我们才能与众不同，拥有自己的标志。思考是无形的，但它却在无形中左右着我们的生活，左右着我们的人生之路。“思考”是一件很神奇的东西，因为它，我们才能够解决问题;因为它，我们才能讨论“关于人的思考”。我们的世界正是因为有很多善于思考的人才会如此的进步，也正是因为有那些不善于思考的人才会变的如此复杂。</em></p>\n<a id=\"more\"></a>\n<p>  <strong>关键词：思考;哲学;理解</strong></p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>古往今来，许许多多的人都在思考“人为什么思考”。人们对于这个话题的讨论的热情从未减少过。的确，这个话题是每个人都想要知道的，因为人的大脑是神秘的，人的思想是神秘的，而人类恰恰有着对神秘事物探索的好奇心。我要研究关于人的思考，也正是基于我对与“思考”的好奇心。现在，我正在用“思考”来思考“关于人的思考”这一个话题，想一想，不免觉得这“人的思考”还真有点趣味。</p>\n<h2 id=\"一、人为什么要思考？\"><a href=\"#一、人为什么要思考？\" class=\"headerlink\" title=\"一、人为什么要思考？\"></a>一、人为什么要思考？</h2><p>我们的大脑每一天都没有停歇过，因为它在承担着我们人生之中最重要的一件事，那就是思考。一旦我们忙完一天的事情之后，休息的时候，我们的大脑里的各种想法就会开始浮现出来，各种问题，让我们变得烦恼。偶尔，我们会想为何我们总是毫无成就，偶尔，我们会觉得很郁闷。我们为什么会郁闷的呢？因为我们思考了。<br>人为什么要思考？倘若一个人不思考，可以吗？当然可以，的确，维持生命是每个人或者概括一点的话每个动物的本能，为了让我们能够心中如水般的平静，我们少一点思考也许对我与我们来说反而有好处，毕竟烦恼都是思考出来的，比如很多的人也许曾经或者正在花着大量的时间“思考”一些毫无意义的事情，把这些时间用来睡觉，用来运动，难道不比苦坐着伤害脑细胞好吗？</p>\n<p>十七世纪法国的伟大科学家和思想家布雷兹.巴斯卡曾经在他的《思想录》中这样写到：“世界上只有三种人：找到上帝事奉上帝的人；竭诚寻求上帝而没有找到上帝的人；活着不肯寻求也没有发现上帝的人。第一种人既有理性而有幸福；第二种人有理性而不幸；最后一种人既愚蠢而有不幸。”巴斯卡的这段话曾启迪了不少人的心灵。为什么不寻求上帝的人就不幸呢？这是一个非常重大的课题。谁都知道，人是有智慧的高等动物，人和其它动物之间的本质区别，就在于人有智慧，人能够思考，可以通过思考，透过现象，发现本质、认识本质，而其它动物则不能。然而人类却把思考忽略了，世界上就有很多人没有利用人所特有的这一本质特征，没有利用思考，不肯致力思考这一重大的课题。他们对于鸡虫琐事、各位荣辱金钱享受却绞尽脑汁，充满预感；而对于什么是真正的幸福？什么是真正的不幸？对于身何从来，死往而去这样一些重大的课题，去无动于衷，麻木不仁。这样的理性知识问题，难道可以用鸡犬禽兽的感觉或用庸愚之辈、贪生之徒的理解来回答吗？他们既无远见有无畏惧地玩忽这一重大课题，而不知不觉地走向死亡；明知他们所为之奋斗一切，将来随着死亡而失去，对自己永恒的命运，却漠然无动于衷。这是何等的可悲，何等的不幸啊！</p>\n<h2 id=\"二、人该如何思考？\"><a href=\"#二、人该如何思考？\" class=\"headerlink\" title=\"二、人该如何思考？\"></a>二、人该如何思考？</h2><p>通常来讲，人一天要遇到很多问题。可是有多少是自己认真的处理分析的呢！ 往往都是问题在自己这匆匆而过，就是抓不住。 要想不让问题跑掉，首先要做到的就是守住问题不放，怎么守的住呢！ 就是要淡定，对待自己遇到的事情要淡定。所以，思考问题的第一步，就是要把问题抓住看明白，怎么抓住，就要怎么守住，就要做到淡定！为什么淡定就能守住呢！  因为淡定可以使得人神气稳定不散，所以能守得住。那么，再让我们回到今天要说明的问题上来，就是 “人该如何思考问题”。</p>\n<p>在上面，我们已经把问题抓住了，要做的是要把问题往好的方向去处理，现实的说法就是立场问题。这个立场要符合一个原则就是：积极、发展、上进。 面对问题，唯独积极上进，才可在顺境之中越走越远，在逆境之中越加坚强。在“淡定”的基础之上，再以一种上进的心去思考，我想我们已经获得了一种很好的思考方式了。</p>\n<p>那么，在达到上面的条件后，现在我们可以做到不受任何情绪干扰的来处理问题了，做到这一步真的不容易。可 是事情总有难有易的，那遇到真正的难题怎么办呢！ 一方面非得解决，一方面又解决不了。这个时候也要注意方法。就是不要抓住问题不放，为什么这么说呢。当守住一个难题不放松的时候，外面就因为感到无法解决而觉得空虚，心里呢，也会被问题困住不得解脱。这时，我们就要懂得“止”，何谓“止”？就是停一会，总结一下，接下来再做，这么做，不仅不会在思考的时变得压抑，反而会使得底气更充足。思考问题的效果也很好，有句话叫“思之而不通，鬼神将通之。非鬼神之力，精气之极也”。就是讲，这么来思考问题，就象有神仙帮助一样，能很好的解决问题。</p>\n<p>样下来，问题分析的有结果了。有结果之后也要注意，不要以为分析完成了就了事了。还有重要的一步要去做，就是分析结果出来后，要回到开始遇到的问题上面想想。是这么个问题发生了这样许多的事情。为什么要做这样一步呢！思考的过程我们可以理解为大脑运转的过程，在我看来是一种轮回。所以想的结果要回到思考的问题上，这样才是一个完整的思考过程。如果不回到思考的问题上，实际上就是轮回没有完全终止，给人一种不连续的感觉。<br>小结</p>\n<p>思考，也许对于许多的哲学家来说，是一个永恒的话题。新的问题在思考中诞生，更新的问题又在解决中诞生。我觉得这都是思考在控制着。个人的一生是短暂的，快乐的时间更是短暂的，世界上的人很多，每一个人在社会中都有他的位置，把自己的心思用到自己所能力及的地方，不要花费你宝贵的生命、时间去思考那些属于别人的问题了，重复建设既不利于解决问题又浪费时间和感情。不要花费属于你自己的时间去议论别人的长短了，大家活的都很累，何必烦人又烦己呢？最后，人的思考是不可避免的，但是如何又能避免思考所带来的新的问题呢？我想，人为什么要思考就是这个问题的答案。</p>\n<h2 id=\"文献\"><a href=\"#文献\" class=\"headerlink\" title=\"文献\"></a>文献</h2><blockquote>\n<p>[1] 胡道位. 帕斯卡尔《思想录》读解[D].扬州大学,2012.<br>[2] 陈宣良. 思考的芦苇——读帕斯卡尔《思想录》[J]. 读书,1986,07:39-44.<br>[3] 海伦·杜卡斯,巴纳希·霍夫曼,李宏昀. 爱因斯坦谈人生[J]. 书城,2014,01:130.<br>[4] 杨叶平,李晗龙. 从哲学的角度思考人生价值[J]. 学理论,2009,27:110-111.</p>\n</blockquote>\n","categories":[],"tags":[]},{"title":"硝烟中的Scrum和XP","url":"http://compilemind.com/2019/01/15/2019-01-15-硝烟中的Scrum和XP/","content":"<p>初次接触Scrum和XP（更加准确的说是“看到”），心里不免有些疑问，软件开发为什么会有如此多的方式，难道软件开发、软件工程不就是写写代码的事儿吗？直到后来，才明白，一个庞大的软件工程，不会只是一个人的事儿，倘若我们现在（学生时代）还是只有着一种写代码是自己的事儿的态度来看待软件工程这样的“工程”，是低端的，是不全面的。</p>\n<a id=\"more\"></a>\n<p>作为一名软件工程的学生，编写代码的能力是一方面，理解计算机对于代码编辑、编译、链接、运行过程是一方面，理解算法、数据结构有事另一方面。这些当然是我们软件工程学生应该有的素质，但同时，我们还应该明白，一个只有几个人能胜任的软件工程的小组毕竟只是少数，少数中的少数，更多的则是庞大的集合体，我们（对于一般的程序员、工程师）只这个庞大的集合体中的一两个小小的元素。所以，我们应当有团队意识。</p>\n<p>说了一大堆空白话，让我们回到《硝烟中的Scrum和XP》来。</p>\n<p>何为Scrum？这里我不想复制某度百科一堆，我只想说说我的理解（拙见），在我看来，Scrum更加给人一种具有技术的高效开发团队组织的感觉，这个组织拥有对于时间掌控的能力，能够充分利用时间的分割来进行项目的开发、管理，从这一点来看，Scrum更加注重管理，注重一种形式，一种规则。XP则是在另一番景象，XP所做到的是注重了编程的实践，注重强有力的工程实践，是实际的，具有技术的。为什么二者能够和谐的处在一起，因为它们都是在处理软件工程领域不同的部分，而不同的部分，则是软件工程如今所面临的重要之处，同时，它们都强调了个人与组织的关系，强调了个人应当与组织形成一种高效的交流。本书序章中看到了一句话“实际上，Scrum和XP都关注如何把事情做好”。的确如此，所以才造就了如今的敏捷开发与极限编程所拥有的魅力。</p>\n<p>Scrum与XP的共同点：实践与交流。正如书中所说“但在纷乱芜杂的信息中，我感到最有价值的就是那些真枪实弹的故事。它们把‘原则与实践’变成了‘如何真正动手去做’”。理论知识就是动动嘴皮子，在此我并非贬低理论的形成过程，是的，理论也是需要动用你的大脑去真正的考虑设置一种想法的“实现”，这种“实现”并不是简单想想就能搞定的。但是，现实是残酷的，时间是不等人的，在如今的软将工程这个领域里，你永远不知道“下一个巧克力是什么味道的”。甜的，恭喜你“侥幸”度过了软件工程实践里的难处；哭的，很遗憾，你的项目，你的工程将很有可能面临淘汰。（胡乱扯了一通，拙见）</p>\n<p>在书中我还看到了一个很有意思或者说确实也出现在我身上的事例。就是在backlog这一部分，书中所讲的就是“需求，或故事，或特性等组成的列表”，理解一下就是贴了一些便条的梗概，这些都是业务层次上的（产品负责人来负责），不需要你添加一些技术性的问题在其中（技术人员的事儿）。然而（比如我）在写这个backlog的时候，常常就会添加一些技术性的比如这里用某某算法、这里用某某结构体等来描述，这实际上已经突破了业务的层次，这在实际过程中应当避免。</p>\n<p>本书中还提到了Scrum Master：负责监督整个Scrum进程。是的，Scrum确实需要这样的Master存在，Scrum Master并非团队的领导，而是一个负责屏蔽外界对开发团队干扰的角色。Scrum Master是规则的执行者，他是Scrum团队中的服务型领导。不难看出，SM的需要非常熟悉敏捷开发模式，同时还需要很强的能力。</p>\n<p>我在看这本书的时候，其实并没有太关注Scrum与XP的过程，而是在思考Scrum与XP的思想，这样的思想是如何体现的。其实作为一名程序员，我们不能仅仅关注于技术，而是应当在做技术的同时，思考一些理念，一些想法，一些蕴藏在软件开发之中的文化（当然实在已经有较好的技术的前提下，否则就是理想主义者了）。</p>\n","categories":[],"tags":["read"]},{"title":"人月神话","url":"http://compilemind.com/2019/01/01/2019-01-01-人月神话/","content":"<p>先来讲一讲“睡前”想法，也许会有所偏离主题，请见谅。初次面对“人月神话”这个标题的时候，就不禁从中感受到了一种差距，一种关于国内与国外（西方）计算机软件相关的文化差距。就最近所接触到的计算机相关知识来看，我觉文艺复兴的意义是非同凡响的，是深远的，最近接触到的许多关于计算机、软件程序相关的书籍，尽管还未曾读过，但名字已经给我留下了深刻的印象。例如，《人件》、《大教堂与集市》、《黑客与画家》、《人月神话》等等。也许我监视太过于片面，但我还是想说尽管国内程序开发人员、管理人员在技术层面上与国外同行差距并不是很大，甚至在某些方面更加优秀，然而，文化层面却是差了一大截，缺少了灵性，缺少了思维的敢于跳跃。追根溯源，我认为是西方的历史、文艺复兴、文化、哲学给西方的计算机领域注入了太多有意味的，有营养的东西。正如翻开《软件工程》这本厚重的书的第一页，看到序章的第一句话“文艺复兴以降”。</p>\n<a id=\"more\"></a>\n<p>回顾正题，《人月神话》究竟是怎样的一本书呢。你可以把它当作你以后作为一名程序开发者、产品经理或者是任何与计算机相关开发有关的职位的职业手册，因为你可以从中了解到作为一名开发人员，你讲面临怎样的上司，面临怎样的工作境遇，并且你可以从中懂得作为一名开发人员的自律与抗争（抗争所面临的难题、危机）；同时你也可以从中了解到作为一名产品经理你将如何面对团队、面对堆积如山的难题，以及你那“不听话”的手下。</p>\n<p>然而，你又可以把它看作一本关于哲学的书籍，一本仅仅是用了大量计算机职场语言、管理语言描述的探讨哲学难题的书籍。在书中，无时无刻不充满着具有哲学意味的探讨，简明却引人入胜。对于我说，这本书就是后者。正如上面所讲的“睡前”想法一样，在软件工程这门课程中，说到了这本书《人月神话》，再看看每章的标题：焦油坑、人月神话、贵族专制、民主政治和系统设计…没有银弹…注定，这本书将不是一本因为计算机软件开发需求的快餐阅读产物，而是一本融合了思想的，从真正具有开发管理意义的书籍。看过之后，的确如此，它除去了大量晦涩难懂的，亦或是平淡无味的专业词汇，更像是一本用简明语言阐述在计算机软件开发过程中的文学、哲学问题。对于每章的开头，作者总是以某件贴近生活或者更贴近现象而非抽象的事例来抓住我的阅读胃口。</p>\n<p>讲完了一些玄学的东西以后，让我们再来看看一些更加实质性的东西。《人月神话》所站立的角度，很显然是产品经理的方面，或者笼统的说应该是只要是相关软件开发管理的。但是针对程序开发者同样是有作用的，作为程序开发者你懂得如何规范自身开发行为，因为你已经站立在项目经理的角度思考过了，就如同中学老师所讲的“站在出题人的角度，解题才会得心应手”。以上就是我从外在角度来看待这本书的。</p>\n<p>在从内容上来看，“焦油坑”预示着从大项目、编程系统产品开发是有多么棘手，它远远超过了所谓的针对一个项目的简简单单的规划。“他们相互纠缠在一起的时候，团队的行动就会变得越来越慢”以及，最重要的一点是，编程系统产品开发是独立小程序的九倍，从这点完全可以印证我上面所说的超过了一个简单的规划，因为很多东西在不经意间，就在就在纠缠这你的团队，你的进度。</p>\n<p>而在“人月神话”又向我们表明，“人月”这一估算暗示了工作量与工作进度是可以互换的，然而这种互换有时却又是致命的，显然，15人月的项目，1人15月与5人3月是完完全全不可对等的。再来说一说“没有银弹”，这一章是我最喜欢的章节。作者把一种能将开发效率提高的方法与软件开发分别比作银弹和人狼，又让我心中想起了在前文所说的，一种与西方艺术、西方文化结合的描述。（请原谅我用大把的修辞，譬如“西方艺术”、“西方文化”来结合程序开发管理，因为在我看来这其中定然有着意料之外又在情理之中的联系）回归“没有银弹”，作者在此章预示了“银弹”在未来一段时间内是不可能出现的，尽管技术在不断的革新，但是管理的革新将会是困难的。看完这章以后，我最大的感受就是人不是机器，尽管科技不断革新，编程技术在不断革新，算法在不断革新，但这些终究只是机器方面。一个大型项目，是人机结合的，针对于计算机的、软件的管理是固定的，是有模式，是能够加以限制的。然而对于人来说，却是个“纠缠”的，“不可控”的。</p>\n<p>焦油坑依旧存在。</p>\n","categories":[],"tags":["read"]},{"title":"再见，贰零壹捌","url":"http://compilemind.com/2018/12/31/2018-12-31-再见，贰零壹捌/","content":"<h4 id=\"再见，2018\"><a href=\"#再见，2018\" class=\"headerlink\" title=\"再见，2018\"></a>再见，2018</h4><p>这一年我毕业在6月，离别在7月。似乎每个人都要等到怀念的时候，才会觉得当初的好，就像在毕业之后，我时常怀念起大学的美好时光。要说每一幕都难以忘记似乎太假惺惺，但却依然难以忘记大家的第一次的见面，第一次的聚会，第一次的活动，以及第一次也是最后一次的离别。</p>\n<a id=\"more\"></a>\n<p>今年冬天似乎特别的冷，一开始我也很疑惑，但后来明白了，有时候，孤单会让一个人的感官敏感起来，让人失去热情。多少次我想要离别，多少次我却又害怕离别。与我相别的不仅是我的大学生涯，还有那群伴我成长的朋友，以及，我“终将逝去的青春”。我的青春始于2011年的夏天，那一件淋湿的衬衣，我的青春止于2018年夏天，那几本墨绿色的证书。</p>\n<p>时间就这样过去了。我常常在想，究竟怎样才算长大。究竟要明白多少的道理才算是长大，为什么父母、长辈就是一种成熟的象征？为什么我们就是和他们有所区别，以至于他们常常会说，“等你长大了就明白了”。后来发觉，我们不过是在模仿长辈，模仿他们的行为，模仿他们的口吻，然后在一个合适的时机，对着我们的晚辈说：“等你长大了就明白了”。渐渐的，我们在模仿中“成长”。但这“成长”终究是假象，当我们模仿的对象，比如父母，出现的时候，我们就好像被打回原形一般，乖乖听着他们的教导。然后，爷爷奶奶一旦出现，父母也立刻“显出原形”，我们之于父母，如同父母之于爷爷奶奶辈一样，终究是孩子。</p>\n<p>其实我常常有很多的想法，想要在博客上去诉说，但是正如大多数的常人一样，感觉有千万语言在脑海中涌现，而等到真正下笔的时候，反而一个字写不出来了。这时候我其实总是有点沮丧，沮丧我的“不争气”，“沮丧”我的懒惰。写到此，突然觉得，是该给自己定一些目标来实现了，毕竟如上所说的一样，我们终究是要成长的，定下一些目标，然后一步一步去做些许会让我安心一点。</p>\n<h5 id=\"2018即将过去，定几个重要目标：）\"><a href=\"#2018即将过去，定几个重要目标：）\" class=\"headerlink\" title=\"2018即将过去，定几个重要目标：）\"></a>2018即将过去，定几个重要目标：）</h5><p>其实我很少像这样为自己制定目标，因为我老是这样有点故意作秀之嫌，后来发觉，如果定目标定的太多可能真的会这样，所有我就定两三个小目标以鞭策自己。</p>\n<h6 id=\"每个月至少产出3篇有价值的文章，或生活或学习或工作。\"><a href=\"#每个月至少产出3篇有价值的文章，或生活或学习或工作。\" class=\"headerlink\" title=\"每个月至少产出3篇有价值的文章，或生活或学习或工作。\"></a>每个月至少产出3篇有价值的文章，或生活或学习或工作。</h6><p>以往我都是学些某些东西的时候，有了心得才写上那么一两篇，我渐渐地发现不再那么“勤劳”了。仔细一想还是定一个目标好一些，一来保持写作习惯（虽然我的写作功力真的很差）；二来保持技能的熟悉程度，把心得记录下来也是不错的。</p>\n<h6 id=\"开始坚持每天跳绳锻炼（依据阶段1-3-5-10-min进行）。\"><a href=\"#开始坚持每天跳绳锻炼（依据阶段1-3-5-10-min进行）。\" class=\"headerlink\" title=\"开始坚持每天跳绳锻炼（依据阶段1 - 3 - 5 - 10 min进行）。\"></a>开始坚持每天跳绳锻炼（依据阶段1 - 3 - 5 - 10 min进行）。</h6><p>为什么是跳绳？为什么不是健身、跑步呢？出于场地、时间等考虑（主要是场地），我没有选择进行所谓的“锻炼宏图”，免得弄的过于“专业”，结果适得其反，从一些简单的小锻炼（跳绳）入手，每天晚上回到家，在小区里跳绳，不需要什么专业的场地，我觉得更能长期坚持。而且据我查到的相关知识，让我对跳绳更加有了信心：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、可以减肥，能使全身的肉变得结实有弹性，减少大腿及臀部的脂肪，健美塑性，使得身体动作敏捷。</span><br><span class=\"line\">2、可以长个子。跳绳可以促进骨骼的生长，从而达到长个子的效果。</span><br><span class=\"line\">3、能锻炼耐力。经常跳绳的人，能很好的锻炼耐力。</span><br><span class=\"line\">4、能帮助我们很好的放松情绪。</span><br><span class=\"line\">5、能缓解腰酸背痛。经常做办公室的上班者，可采用跳绳的方法，缓解身体的酸痛。</span><br><span class=\"line\">...balabala</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"找到女朋友\"><a href=\"#找到女朋友\" class=\"headerlink\" title=\"找到女朋友\"></a>找到女朋友</h6><p>这条可以不实现。：）</p>\n","categories":[],"tags":["journal"]},{"title":"演员 Or 开发者的自我修养","url":"http://compilemind.com/2018/11/11/2018-11-11-演员 Or 开发者的自我修养/","content":"<p>时至今日，我都还是很怀念小时候与一群玩伴编写剧本、拍摄，那时候的我还有一个远大的“白日梦”——成为一名导演。很可惜，终究是“白日梦”。在完成了一系列的“艰苦”拍摄以后，一个半成品的微电影就出世了：没有字幕，没有主题，昏暗的镜头，富有浓郁特色的四川方言。随后发布到网上，差评如潮：）。</p>\n<a id=\"more\"></a>\n<p>如今的我，已投奔IT，愈来愈热爱这个职业。成为一名合格的软件开发者，已经成为了我现在的理想，而非“白日梦”。为什么我会去读《演员的自我修养》？大概是在一代喜剧之王周星驰的影响之下，想要看看这本书真正的魅力。尽管是一本完全讲述表演艺术的书籍，不过在阅读的过程中，我却能够联想到很多对于IT，对于软件工程的东西，大概是我的脑洞太大吧。</p>\n<p>《演员的自我修养》第一部分以日记的形式，记叙了一个名叫Kostya的戏剧系大学一年级学生以及他的同班同学们在斯坦尼斯拉夫斯基式的表演教学方法下度过的一年时光。这样一群学生，没有或者极少有表演的经验，在他们的导师也是他们的戏剧排演的导演的协同之下，进行舞台表演。对于这期间的描述，斯坦尼斯拉夫斯基表达出了对于舞台戏剧的各种理论原理的态度，以及指出了在实践中各种各种各样的不良现象。仔细想一想，这一部分和我们软件工程的似乎是很相像的。初出茅庐的一群软件开发者，没有或者极少有实践的经验（毫无疑问，没有或者极少有实践经验在当前的IT领域是常见的），在主管或者部门老大的带领之下一同协作进行软件开发。于是乎，各种各样的弊端出现，没有精确版本控制，没有标准化的代码规范，没有一个明确的项目目标，业务开发ACID日复一日。其实，对于一个软件项目，和一个舞台是很像的。每一位开发者都是上面的表演者，他们各自运用其学到的理论知识，为舞台剧贡献自己的一份力量。但是，若没有真正的体会，没有真正的热爱这项事业，只是抱着假大空的理论，棒读台词（一味地照着别人的代码），这样的舞台剧会有人为其买单吗？结果可想而知。</p>\n<p>斯坦尼斯拉夫斯基在第二部分阐述了一种体验艺术的思想。何谓体验艺术？即不仅仅是在表演的过程中才全身心的投入，而是每时每刻都要有这样一种意识，他认为：“……只有这种充满了人——演员的活生生的、有机的体验的舞台艺术，才能够把角色内心生活的一切不可捉摸的细微变化和全部深度，艺术地表达出来。”在联想一下，对比着我们日常的开发，开发者写下的每一行代码都在不断的塑造整个“舞台”中的内容，每一位开发者都是“演员”，若没有一种奉献的精神，没有一种每时每刻的都为了追求代码质量的意识，没有以工程、以代码的角度去开发，这样的“舞台剧”势必轻则不被人看好，重则影响后续人员的加入。剧本愈来愈难以看懂，难以维护。</p>\n<p>读过《人月神话》的人都知道，软件工程永远充满了焦油坑。我大概没有那么大的神力去挽救如今IT行业充斥的各种各样的“坑”，但是我不会因此而随波逐流，丧失斗志，做一个只在底层打拼的龙套演员。都说，不会写代码的演员不是好的工程师。</p>\n","categories":[],"tags":["think"]},{"title":"九零后","url":"http://compilemind.com/2018/10/25/2018-10-25-九零后/","content":"<p>“70后”是理想，“80后”是仗义，那么“90后”是什么？</p>\n<p>2019年，最小的“90后”应该已经步入了大学校园，正找寻着自己的理想；最大的“90后”应该有的已经成家立业，担起了另一种角色。或许他们曾失落过、迷茫过，但他们终将一一突破。</p>\n<a id=\"more\"></a>\n<p>似乎每一代人，都要经历一个先被否定然后再为自己正名的过程。就像是一个孩子的成人礼，当人们意识到他不再柔弱、不再荒唐的时候，他才是真正地长大了。</p>\n<p>“垮掉的‘90后’”这个标题像是无情的审判，给予他们沉重的打击。后来大家慢慢发现，似乎每一代都陷入了被上一代人否定的怪象，就好像“你们是我教过的最差的一届”。但为什么偏偏又不是““70后”垮掉”？不是““80后”垮掉”的？在我看来，“90后”所处的时代，也就是当前，它是信息最为开放的时代！“90后”有着不循规蹈矩爱创新的秀自我价值观、既开放又理性的消费观、为爱而爱宁缺毋滥的恋爱观、追求品质提前养身的生活观，但这些与70、80后的观念显得大相径庭，以至于“90后”太容易被贴上“不稳重”、“太不传统”的标签。再加上信息的开放，导致“90后”所做的一切都被放大放大再放大。“90后”只想说：求同存异！Why not?</p>\n<p>“我知道我的未来不是梦”，那未来是什么呢？王小波在《黄金时代》曾说：“那一年我二十一岁，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程。”70、80后的生活，已渐渐步入正轨，而90后才开始接受生活的洗礼。他们的双眼前被迷雾遮住，而迷雾来自生活，让他们看不到未来。时代在变化，相比之下“90后”面对的竞争压力更大、诱惑与选择更多、雾霾也更厚。但是，“90后”更愿意在困境中去奋斗，去突破。他们愿意用更加严谨的方式对待工作，用更加幽默的态度面对生活。“90后”身体力行，跟大家论证了“知识就是力量”这一观点，随着高学历青年大批大批的涌入社会，他们默默地担起了这个时代的使命，在迷茫中坚定，在继承中创新。</p>\n<p>很多人说“90后”不稳重，是因为他们爱花钱，缺乏存钱意识，但在我看来，“90后”不穷，他们作为互联网的原住民，早已成为了消费的主力军。品质、版权意识、多元、体验、参与感等成为了90后的消费标签。他们爱花钱，但不任性，他们热衷于享受生活，提高品质，他们更愿意为故事和文化买单，对于恋爱也信奉宁缺毋滥。</p>\n<p>“90后”提前养身，这已经是近几年的热门话题了，他们的特殊养生，似乎是从某个冬天开始，伴随着保温杯里的大枣枸杞，融到了每个“90后”的身体里。“油腻”、“发际线”以及“秃”，每一个词都好像一颗子弹绽放在“90后”的胸口。于是乎，熬夜玩手机对皮肤不好？敷最贵的面膜，用最贵的眼霜；啤酒加冰？No，加枸杞、人参？Yes；暴饮暴食？我有健胃消食。这些年流行一个词叫“佛性”，“90后”表示，这个“佛”既是“济公活佛”，也是“斗战圣佛”。他们明白，倘若就这样默默的接受无情的审判，垮掉的是他们的内心；倘若不试图去拨开眼前的迷雾，未来永远不会到来。</p>\n<p>所以，“90后”是什么？<br>“90后”是不被定义的一代！</p>\n","categories":[],"tags":["article"]},{"title":"CSharpEntityFramework与CodeFirst实践","url":"http://compilemind.com/2018/09/13/2018-09-13-CSharpEntityFramework与CodeFirst实践/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>当我们进行开发的时候,常常会用到数据库来对数据进行持久化的操作，有的时候,我们并不想要在进行代码开发的过程中，还去关注数据库的构建,表的构建等等。于是，就有了Code First模式。何为Code First模式呢？它思想就是先定义模型中的类，再通过这些类生成数据库。这种开发模式适合于全新的项目，它使得我们可以以代码为核心进行设计而不是先构造数据库。这样一来，使得我们更加关注代码的开发。在c#中，我们使用EntityFramework来实现Code First场景。</p>\n<a id=\"more\"></a>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>试想一下，现在有一个图书管理项目，里面会用到Book实体类，Book会唯一编号Id、书名Title、价格Price，在数据库优先的情形下，我们可能会首先创建Book对应的表，里面创建对应于Id、Title和Price的字段，然后回到代码中继续来开发，亦或者先在代码中进行开发，然后在需要DA（数据访问）的时候创建数据库以及表结构。无论怎样，我们作为开发都要与数据库进行打交道，来回切换关注的东西，还要注意数据库的表建立的对不对，数据类型对不对等等。好在c#中有了EF这样的强大的框架以及Code First的思想。带给我们全新的开发体验。</p>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><h4 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h4><p>创建一个项目，并利用Nuget引入EntityFramework6</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/nugetef6.png\" alt=\"nugetef6\"></p>\n<p>当我们引入EF时，我们发现项目下app.config其中的配置会发生更改，这个配置文件<strong>更改的内容</strong>就是EF为我们创建的，也是我们配置数据库连接的地方。</p>\n<p>回到项目中，接下来我们创建Book实体类，为其添加Id、Title以及Price属性，同时使用特性在属性以及类名上标注该实体类在数据库中的体现方式：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">CodeFirstDemo</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Table(<span class=\"meta-string\">&quot;Book&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Book</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Guid id;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Guid Id</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = id == <span class=\"literal\">null</span> ? Guid.NewGuid() : id;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"meta\">Required</span>]</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Title &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">        [<span class=\"meta\">Required</span>]</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> Price &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用Table特性来表名该实体类Book将对应数据库中的book表（不需要此刻已经有Book表），使用[Required]特性来表明字段是否可为空，此外，由于EF默认将Id属性视为主键，所以无需使用[Key]特性来指明上面的Id为主键。</p>\n<p>接下来，我们需要使用继承EF的DbContext来构建数据库上下文类，我们直接使用VS自带生成工具即可生成对应的数据库上下文模型：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/bookdbdemo.png\" alt=\"bookdbdemo\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/genguide.png\" alt=\"genguide\"></p>\n<p>点击完成后我们就得到了如下的一个配置类</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BookDbDemo</span> : <span class=\"title\">DbContext</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"comment\">//您的上下文已配置为从您的应用程序的配置文件(App.config 或 Web.config)</span></span><br><span class=\"line\">       <span class=\"comment\">//使用“BookDbDemo”连接字符串。默认情况下，此连接字符串针对您的 LocalDb 实例上的</span></span><br><span class=\"line\">       <span class=\"comment\">//“CodeFirstDemo.BookDbDemo”数据库。</span></span><br><span class=\"line\">       <span class=\"comment\">// </span></span><br><span class=\"line\">       <span class=\"comment\">//如果您想要针对其他数据库和/或数据库提供程序，请在应用程序配置文件中修改“BookDbDemo”</span></span><br><span class=\"line\">       <span class=\"comment\">//连接字符串。</span></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BookDbDemo</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">           : <span class=\"title\">base</span>(<span class=\"params\"><span class=\"string\">&quot;name=BookDbDemo&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>       &#123;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//为您要在模型中包含的每种实体类型都添加 DbSet。有关配置和使用 Code First  模型</span></span><br><span class=\"line\">       <span class=\"comment\">//的详细信息，请参阅 http://go.microsoft.com/fwlink/?LinkId=390109。</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// public virtual DbSet&lt;MyEntity&gt; MyEntities &#123; get; set; &#125;</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//public class MyEntity</span></span><br><span class=\"line\">   <span class=\"comment\">//&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">//    public int Id &#123; get; set; &#125;</span></span><br><span class=\"line\">   <span class=\"comment\">//    public string Name &#123; get; set; &#125;</span></span><br><span class=\"line\">   <span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure>\n<p>一个十分简单的数据库上下文类就建立完成。</p>\n<p>正如生成的DbContext所说：“为您要在模型中包含的每种实体类型都添加 DbSet。”，我们在该类中添加如下的DbSet属性，并将注释删除，更加直观的看一看当前的结构：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BookDbDemo</span> : <span class=\"title\">DbContext</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BookDbDemo</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">        : <span class=\"title\">base</span>(<span class=\"params\"><span class=\"string\">&quot;name=BookDbDemo&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> DbSet&lt;Book&gt; Books &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个类中，我们声明了一个DbSet属性books，这就对应了数据库中的book表。换句话说，继承了DbContext的类就对应了某一个数据库，其连接属性由配置文件中的连接配置决定，并在DbContext中设置进去（基类构造函数设置），这个DbContext中的所有DbSet就对应到数据库中的表。</p>\n<p>注意到，构造函数调用了基类构造函数，传入了”name=BookDbDemo”字符串，这个字符串就是指app.config配置文件中的数据库连接名，然后我们查看App.config文件，发现vs已经为我们生成了一个连接字符串节点：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;BookDbDemo&quot;</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">&quot;data source=(LocalDb)\\MSSQLLocalDB;initial catalog=CodeFirstDemo.BookDbDemo;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework&quot;</span> <span class=\"attr\">providerName</span>=<span class=\"string\">&quot;System.Data.SqlClient&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是这还段配置还是有点问题，首先连接地址数据库用户名等等都不对，更主要的是，我是MySQL数据库，怎么能用SQL呢，所以，我们要解决EF进行MySQL的连接问题。</p>\n<h4 id=\"使用EF进行MySQL数据库连接配置\"><a href=\"#使用EF进行MySQL数据库连接配置\" class=\"headerlink\" title=\"使用EF进行MySQL数据库连接配置\"></a>使用EF进行MySQL数据库连接配置</h4><p>如果使用ado.net链接mysql数据库则只需要MySql.Data.dll，即使用Nuget安装Mysql.Data就行了，并不需要安装mysql-connector-net驱动程序；</p>\n<p>如果使用EF的话一般来说需要安装mysql-connector-net驱动程序；</p>\n<p>其中mysql-connector-net驱动程序安装目录包含了<br>MySql.Data.dll；<br>MySql.Data.Entity.EF5.dll；<br>MySql.Data.Entity.EF6.dll；<br>MySql.Fabric.Plugin.dll；<br>MySql.Web.dll；</p>\n<p>注意：就算把mysql-connector-net安装目录下所有的类库都拷到bin目录而不在应用环境上安装mysql-connector-net驱动程序，EF代码还是会报错，因为mysql-connector-net安装不仅装了各种dll类库，还在机器上.net环境的全局machine.config里加过如下配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">system.data</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">DbProviderFactories</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;MySQL Data Provider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">invariant</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">description</span>=<span class=\"string\">&quot;.Net Framework Data Provider for MySQL&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">type</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient.MySqlClientFactory, MySql.Data, Version=6.9.6.0, Culture=neutral,        PublicKeyToken=c5687fc88969c44d&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">DbProviderFactories</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">system.data</span>&gt;</span></span><br></pre></td></tr></table></figure><br>所以要使用EF必须在站点服务器安装mysql-connector-net启动程序（数据库所在的服务器不需要安装，只需要c#程序所运行的电脑需要安装）<strong>或者</strong>在应用的配置文件（app.config或web.config）里configuration节点下加上上面的配置。</p>\n<p>这里，为了我们机器环境的纯净，我们使用nuget安装对应项目需要的库（MySql.Fabric.Plugin.dll和MySql.Web.dll这两个库如果没有需要不用安装）到项目中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/mysqldata.png\" alt=\"mysqldata\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/mysqldataentity.png\" alt=\"mysqldataentity\"></p>\n<p><strong>务必注意！MySql.Data和MySql.Data.Entity必须要保持相同的版本！否则会出现 “找到的程序集清单定义与程序集引用不匹配。 (异常来自 HRESULT:0x80131040)” 的错误，所以这里的Mysql.Data版本我并没有选择最新的</strong></p>\n<p>并且在配置文件中加如上述system.data配置，此时app.config配置主要有如下的变化：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configSections</span>&gt;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">configSections</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">startup</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">startup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">entityFramework</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultConnectionFactory</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">...</span></span></span><br><span class=\"line\">    &lt;/defaultConnectionFactory&gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 新增了 MySql.Data.MySqlClient Provider --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">provider</span> <span class=\"attr\">invariantName</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient.MySqlProviderServices, MySql.Data.Entity.EF6, Version=6.10.8.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">entityFramework</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;BookDbDemo&quot;</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">&quot;data source=(LocalDb)\\MSSQLLocalDB;initial catalog=CodeFirstDemo.BookDbDemo;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework&quot;</span> <span class=\"attr\">providerName</span>=<span class=\"string\">&quot;System.Data.SqlClient&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 引入MySql.Data写入的 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">runtime</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">assemblyBinding</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependentAssembly</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">assemblyIdentity</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;MySql.Data&quot;</span> <span class=\"attr\">publicKeyToken</span>=<span class=\"string\">&quot;c5687fc88969c44d&quot;</span> <span class=\"attr\">culture</span>=<span class=\"string\">&quot;neutral&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bindingRedirect</span> <span class=\"attr\">oldVersion</span>=<span class=\"string\">&quot;0.0.0.0-6.9.6.0&quot;</span> <span class=\"attr\">newVersion</span>=<span class=\"string\">&quot;6.9.6.0&quot;</span> /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependentAssembly</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">assemblyBinding</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">runtime</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 手动新增system.data配置节点 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">system.data</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">DbProviderFactories</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;MySQL Data Provider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">invariant</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">description</span>=<span class=\"string\">&quot;.Net Framework Data Provider for MySQL&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">type</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient.MySqlClientFactory, MySql.Data, Version=6.9.6.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">DbProviderFactories</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">system.data</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><br>PS：实际上本人在实践过程中发现，引入Mysql.Data后写如的节点（见上面xml）作用似乎和手动新增的一样，没有求证差别。</p>\n<h4 id=\"实际数据库配置\"><a href=\"#实际数据库配置\" class=\"headerlink\" title=\"实际数据库配置\"></a>实际数据库配置</h4><p>完成EF的Mysql连接环境配置后，最基础的数据库还是需要建立的，所以去数据库创建一个名为bookdbdemo的数据库，按道理来说，我们只需要在这个地方触碰到数据库，况且这还是DBA的事情。创建好的数据库如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/mysqldb.png\" alt=\"mysqldb\"></p>\n<p>于是，我们将其中的连接字符串connectionString内容修改为我们当前的数据库连接字符串：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;BookDbDemo&quot;</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">&quot;Data Source=localhost; Database=bookdbdemo; User ID=root; Password=;&quot;</span> <span class=\"attr\">providerName</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">注意：providerName写的是在引入MySql.Data.Entity之后在app.config中出现的</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">provider</span> <span class=\"attr\">invariantName</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient.MySqlProviderServices, MySql.Data.Entity.EF6, Version=6.10.8.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d&quot;</span>&gt;</span>节点</span><br></pre></td></tr></table></figure><br>完成上面的配置之后，我们接下来就要使用EF最强大的Migration数据库迁移功能。</p>\n<h4 id=\"EF-Database-Migration-EF数据库迁移\"><a href=\"#EF-Database-Migration-EF数据库迁移\" class=\"headerlink\" title=\"EF Database Migration EF数据库迁移\"></a>EF Database Migration EF数据库迁移</h4><p>首先启用迁移功能。在Nuget命令行中输入：Enable-Migrations（有个s，注意）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> <span class=\"built_in\">enable</span>-migrations</span></span><br></pre></td></tr></table></figure><br>注意：如果此处提示：具有固定名称“MySql.Data.MySqlClient”的 ADO.NET 提供程序未在计算机或应用程序配置文件中注册或无法加载。需要在上下文继承类中（此处就是BookDbDemo）上添加特性[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">[<span class=\"meta\">DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BookDbDemo</span> : <span class=\"title\">DbContext</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>启动迁移功能后，Nuget命令行提示：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> <span class=\"built_in\">enable</span>-migrations</span></span><br><span class=\"line\">正在检查上下文的目标是否为现有数据库...</span><br><span class=\"line\">已为项目 CodeFirstDemo 启用 Code First 迁移。</span><br></pre></td></tr></table></figure></p>\n<p>此处提示我们，EF的数据迁移功能已经启用，在项目中我们会发现创建了一个名为Migtaions的文件夹，里面还存在一个Configuration配置类，这个类中，我们需要将AutomaticMigrationsEnabled设置为true，即启用自动迁移功能</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Configuration</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AutomaticMigrationsEnabled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，我们的数据库还没有创建的任何的表。</p>\n<p>接下来，我们使用Add-Migtaion XXX命令来添加一个变更模块。</p>\n<h4 id=\"初始化以及创建表\"><a href=\"#初始化以及创建表\" class=\"headerlink\" title=\"初始化以及创建表\"></a>初始化以及创建表</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> add-migration InitDb</span></span><br><span class=\"line\">正在为迁移“InitDb”搭建基架。</span><br><span class=\"line\">此迁移文件的设计器代码包含当前 Code First 模型的快照。在下一次搭建迁移基架时，将使用此快照计算对模型的更改。如果对要包含在此迁移中的模型进行其他更改，则您可通过再次运行“Add-Migration InitDb”重新搭建基架。</span><br></pre></td></tr></table></figure>\n<p>注意后面的命名，InitDb只是我们取的名字，为了区分对数据库进行的变更，这里是我们第一次构建，所以我取名为InitDb，完成该命令后，你会发现Migrations文件夹下出现了一个以你迁移模块创建时刻+下划线+刚刚迁移模块的命名的类文件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/InitDb.png\" alt=\"InitDb\"></p>\n<p>其类文件内容如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">InitDb</span> : <span class=\"title\">DbMigration</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            CreateTable(</span><br><span class=\"line\">                <span class=\"string\">&quot;dbo.Book&quot;</span>,</span><br><span class=\"line\">                c =&gt; <span class=\"keyword\">new</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        Id = c.Guid(nullable: <span class=\"literal\">false</span>),</span><br><span class=\"line\">                        Title = c.String(nullable: <span class=\"literal\">false</span>),</span><br><span class=\"line\">                        Price = c.Double(nullable: <span class=\"literal\">false</span>),</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                .PrimaryKey(t =&gt; t.Id);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Down</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            DropTable(<span class=\"string\">&quot;dbo.Book&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到里面重写了DbMigration的Up和Down方法，同时从方法中的代码我们能大致推测，Up方法就是发生的变更，这里会创建表Book（dbo是EF的一些配置语法），设置表字段以及设置主键；而Down方法就是回滚操作，将表Book删除。</p>\n<p>但是此时，我们数据库中的表还是没有发生变化，因为我们现在添加了变更模块，只是根据当前的代码来的，要将变更同步到数据库，需要Update-Database命令（添加-Versbose方便我们查看数发生执行的SQL语句）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> update-database -verbose</span></span><br><span class=\"line\">Using StartUp project &#x27;CodeFirstDemo&#x27;.</span><br><span class=\"line\">Using NuGet project &#x27;CodeFirstDemo&#x27;.</span><br><span class=\"line\">指定“-Verbose”标志以查看应用于目标数据库的 SQL 语句。</span><br><span class=\"line\">目标数据库为: “bookdbdemo”(DataSource: localhost，提供程序: MySql.Data.MySqlClient，来源: Configuration)。</span><br><span class=\"line\">正在应用显式迁移: [201809131330306_InitDb]。</span><br><span class=\"line\">正在应用显式迁移: 201809131330306_InitDb。</span><br><span class=\"line\">create table `Book` (`Id` CHAR(36) BINARY default &#x27;&#x27;  not null ,`Title` longtext not null ,`Price` double not null ,primary key ( `Id`) ) engine=InnoDb auto_increment=0</span><br><span class=\"line\">create table `__MigrationHistory` (`MigrationId` nvarchar(150)  not null ,`ContextKey` nvarchar(300)  not null ,`Model` longblob not null ,`ProductVersion` nvarchar(32)  not null ,primary key ( `MigrationId`) ) engine=InnoDb auto_increment=0</span><br><span class=\"line\">INSERT INTO `__MigrationHistory`(</span><br><span class=\"line\">`MigrationId`, </span><br><span class=\"line\">`ContextKey`, </span><br><span class=\"line\">`Model`, </span><br><span class=\"line\">`ProductVersion`) VALUES (</span><br><span class=\"line\">&#x27;201809131330306_InitDb&#x27;, </span><br><span class=\"line\">&#x27;CodeFirstDemo.Migrations.Configuration&#x27;, </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">中间有一大段经过摘要的字符串，应该是变更的摘要</span></span><br><span class=\"line\">, </span><br><span class=\"line\">&#x27;6.2.0-61023&#x27;);</span><br><span class=\"line\">正在运行 Seed 方法。</span><br></pre></td></tr></table></figure>\n<p>我们可以从输出中很容易的看到执行了创建book数据库的sql语句，以及创建了一个MigrationHistory表，这个表就是记录了数据库迁移的一些摘要，供我们以后来进行回退操作。</p>\n<p>完成了迁移之后，查看数据库：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/initcomplete.png\" alt=\"initcomplete\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/tabledetail.png\" alt=\"tabledetail\"></p>\n<p>我们可以看到，表及其结构按照我们预期创建成功了。</p>\n<h4 id=\"删除表\"><a href=\"#删除表\" class=\"headerlink\" title=\"删除表\"></a>删除表</h4><p>为了证明EF再删除表的时候，并不会影响其他的表，我再次利用创建了一个新的实体类EBook并更新DbContext以及进行EF迁移功能：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">CodeFirstDemo</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Table(<span class=\"meta-string\">&quot;EBook&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">EBook</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Guid id;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Guid Id</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = id == <span class=\"literal\">null</span> ? Guid.NewGuid() : id;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">set</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"meta\">Required</span>]</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">string</span> EBookTitle &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新DbContext：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BookDbDemo</span> : <span class=\"title\">DbContext</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BookDbDemo</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    : <span class=\"title\">base</span>(<span class=\"params\"><span class=\"string\">&quot;name=BookDbDemo&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> DbSet&lt;Book&gt; Books &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新增的DbSet</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> DbSet&lt;EBook&gt; EBooks &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进行EF数据库迁移，此时我们不需要再次进行启用迁移功能了，而是使用add-migration检测并增加行的变更模块：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> add-migration AddEBookEntity</span></span><br><span class=\"line\">正在为迁移“AddEBookEntity”搭建基架。</span><br><span class=\"line\">此迁移文件的设计器代码包含当前 Code First 模型的快照。在下一次搭建迁移基架时，将使用此快照计算对模型的更改。如果对要包含在此迁移中的模型进行其他更改，则您可通过再次运行“Add-Migration AddEBookEntity”重新搭建基架。</span><br></pre></td></tr></table></figure>\n<p>此时Migrations文件夹下面又增加了新的类文件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/addebookentity.png\" alt=\"addebookentity\"></p>\n<p>其内容和前面大致，创建表以及回滚，这里不再展示。之后我们再次使用update-database命令将变更更新到数据库中，得到当前的数据库内容：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afteraddtable.png\" alt=\"afteraddtable\"></p>\n<p>此时我们将book表中填充一些数据：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/booktablecontent.png\" alt=\"booktablecontent\"></p>\n<p>然后，我们将DbContext中的DbSet<EBook>属性删除，再次进行迁移：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/delebook.png\" alt=\"delebook\"></p>\n<p>进行更新以后，我们可以看到Ebook表已经删除了，但是book表内容没有发生任何变化：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afterdelebook.png\" alt=\"afterdelebook\"></p>\n<h4 id=\"变更属性\"><a href=\"#变更属性\" class=\"headerlink\" title=\"变更属性\"></a>变更属性</h4><p>有的时候，我们可能很少会将实体类，更多的是对现有实体类中进行属性的增加、删除以及修改，变相的，对数据库中的表的字段进行增加、删除和修改：</p>\n<h5 id=\"增加属性\"><a href=\"#增加属性\" class=\"headerlink\" title=\"增加属性\"></a>增加属性</h5><p>现在，我们想要将Book实体类中增加一个Abstract摘要属性，它会影响我们上面我们已有的数据吗？试一试就知道了。</p>\n<p>首先，在Book类中增加这一属性，不设置Required特性：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">[<span class=\"meta\">Required</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Title &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"><span class=\"comment\">// 增加的摘要属性</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Abstract &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">Required</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> Price &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>此时我们增加变更模块：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> add-migration AddNewProp</span></span><br><span class=\"line\">正在为迁移“AddNewProp”搭建基架。</span><br><span class=\"line\">此迁移文件的设计器代码包含当前 Code First 模型的快照。在下一次搭建迁移基架时，将使用此快照计算对模型的更改。如果对要包含在此迁移中的模型进行其他更改，则您可通过再次运行“Add-Migration AddNewProp”重新搭建基架。</span><br></pre></td></tr></table></figure><br>我们可以看到变更模块类：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">AddNewProp</span> : <span class=\"title\">DbMigration</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Abstract&quot;</span>, c =&gt; c.String(unicode: <span class=\"literal\">false</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Down</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Abstract&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>从这个类的Up方法中，我们看，他调用了AddColumn增加列的方法。而Down回退方法则调用了DropColumn删除列的方法。当我们执行update-database命令有什么效果呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> update-database -verbose</span></span><br><span class=\"line\">Using StartUp project &#x27;CodeFirstDemo&#x27;.</span><br><span class=\"line\">Using NuGet project &#x27;CodeFirstDemo&#x27;.</span><br><span class=\"line\">指定“-Verbose”标志以查看应用于目标数据库的 SQL 语句。</span><br><span class=\"line\">目标数据库为: “bookdbdemo”(DataSource: localhost，提供程序: MySql.Data.MySqlClient，来源: Configuration)。</span><br><span class=\"line\">正在应用显式迁移: [201809131406177_AddNewProp]。</span><br><span class=\"line\">正在应用显式迁移: 201809131406177_AddNewProp。</span><br><span class=\"line\">alter table `Book` add column `Abstract` longtext </span><br><span class=\"line\">INSERT INTO `__MigrationHistory`(</span><br><span class=\"line\">...</span><br><span class=\"line\">）</span><br></pre></td></tr></table></figure>\n<p>重点看到这句SQL：“alter table <code>Book</code> add column <code>Abstract</code> longtext ”，这句SQL就是对我们表添加了一个字段，类型为longtext。我们进入数据库中，看一看变化：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afteraddprop.png\" alt=\"afteraddprop\"></p>\n<p>可以看到数据库中其他字段的值都没有发生变化，仅仅多出了这个字段，同时符合我们设置的可以为空的预期</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/addpropdetail.png\" alt=\"addpropdetail\"></p>\n<h5 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h5><p>删除与增加同理，我们直接将Book实体类的属性删除，然后增加变更，最后同步更新变更到数据库。这里我们将Price和Abstract属性都删除，变更模块如下：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">RemoveProp</span> : <span class=\"title\">DbMigration</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Abstract&quot;</span>);</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Price&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Down</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Price&quot;</span>, c =&gt; c.Double(nullable: <span class=\"literal\">false</span>));</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Abstract&quot;</span>, c =&gt; c.String(unicode: <span class=\"literal\">false</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>得到如下的结果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afterdel2prop.png\" alt=\"afterdel2prop\"></p>\n<h5 id=\"重命名属性\"><a href=\"#重命名属性\" class=\"headerlink\" title=\"重命名属性\"></a>重命名属性</h5><p>重命名比起前面的增删属性有所不同，就当前情形为例子，当前Book类属性如下：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">CodeFirstDemo</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Table(<span class=\"meta-string\">&quot;Book&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Book</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Guid id;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Guid Id</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = id == <span class=\"literal\">null</span> ? Guid.NewGuid() : id;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">set</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"meta\">Required</span>]</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Title &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>对应数据库为<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/beforerename.png\" alt=\"beforerename\"></p>\n<p>此时如果我们想要修改属性名，我们将Book中的Title属性改为Name属性：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">[<span class=\"meta\">Required</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Name &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>然后执行Add-Migration命令：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PM&gt; <span class=\"keyword\">add</span>-migration ChangePropName</span><br></pre></td></tr></table></figure><br>我们看到变更类的内容为：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">ChangePropName</span> : <span class=\"title\">DbMigration</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Name&quot;</span>, c =&gt; c.String(nullable: <span class=\"literal\">false</span>, unicode: <span class=\"literal\">false</span>));</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Title&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Down</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Title&quot;</span>, c =&gt; c.String(nullable: <span class=\"literal\">false</span>, unicode: <span class=\"literal\">false</span>));</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Name&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们发现，只要更新到数据库，EF会在表中先添加一个字段Name，然后删除字段Title，很显然，这样更新，会将我们现有的数据清空。如何不造成这样的情况呢？其实我们首先知道，在进行Update-database的时候，EF框架会执行Up方法，同时，AddColumn、DropColumn很显然是DbMigration这个类中的方法，我们找一找看有没有重命名的方法呢。令我们欣喜的是，有：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//AddColumn(&quot;dbo.Book&quot;, &quot;Name&quot;, c =&gt; c.String(nullable: false, unicode: false));</span></span><br><span class=\"line\">    <span class=\"comment\">//DropColumn(&quot;dbo.Book&quot;, &quot;Title&quot;);</span></span><br><span class=\"line\">    RenameColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Title&quot;</span>, <span class=\"string\">&quot;Name&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>注释掉Add和DropColumn，使用RenameColumn，填入表、原字段名、新字段名；接下来我们执行Update-Database -Verbose：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> UPDATE-DATABASE -VERBOSE</span></span><br><span class=\"line\">...</span><br><span class=\"line\">Fatal error encountered during command execution. ---&gt; MySql.Data.MySqlClient.MySqlException (0x80004005): Parameter &#x27;@columnType&#x27; must be defined.</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>我们发现报了一个错误，实际上解决方法在链接字符串中加入这样一句话“;Allow User Variables=True”就可以了，即如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;BookDbDemo&quot;</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">&quot;Data Source=localhost; Database=bookdbdemo; User ID=root; Password=;Allow User Variables=True&quot;</span> <span class=\"attr\">providerName</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这样一来，再次运行，不报错。查看数据库：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afterrename.png\" alt=\"afterrename\"></p>\n","categories":[],"tags":["C#","EF"]},{"title":"WebXml文件与SpringMVC的联系","url":"http://compilemind.com/2018/08/26/2018-08-26-WebXml文件与SpringMVC的联系/","content":"<p>无论采用何种框架来进行Java Web的开发，只要是Web项目必须在WEB-INF下有web.xml，这是java规范。 当然，我们最早接触到Java Web容器通常是tomcat，但这并不意味着web.xml是属于Tomcat的，同样，Servlet本身也不属于Tomcat，它与JSP等是Java Web的基础规范。而Servlet的运行需要有Servlet容器的支持，常见的容器有Tomcat、Jetty、JBoss等。</p>\n<a id=\"more\"></a>\n<p>对于一个web.xml文件，比较重要的节点有context-param、listener、filter以及servlet：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- context-param元素声明应用范围内的初始化参数 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- filter 过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- filter-mapping 一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- listener 对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。Listener元素指出事件监听程序类。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- servlet 在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><br>其他关于web.xml解释可以参考这里，本文不再详细介绍。本文主要是在整理关于Java Web使用SpringMVC过程的心得。</p>\n<p>我们知道一个最基本的Spring MVC项目需要在web.xml中区配置如下信息：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;WebApp_ID&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.5&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:application-context.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">            org.springframework.web.context.ContextLoaderListener</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>web-app<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">            org.springframework.web.servlet.DispatcherServlet</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:context-mvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>web-app<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br>对于这样一份配置，我们不仅要知其然还要知其所以然。这样不仅能够加深对Java web以及web.xml的理解，对于以后排错也会有很大的帮助。</p>\n<h4 id=\"回到一个普通的Java-Web项目\"><a href=\"#回到一个普通的Java-Web项目\" class=\"headerlink\" title=\"回到一个普通的Java Web项目\"></a>回到一个普通的Java Web项目</h4><p>为什么要这么配置，首先我们要<strong>回到</strong>web.xml加载顺序介绍。web.xml基础节点的加载顺序是context-param &gt; listener &gt; filter &gt; serlvet。</p>\n<h5 id=\"context-param节点\"><a href=\"#context-param节点\" class=\"headerlink\" title=\"context-param节点\"></a>context-param节点</h5><p>context-param节点中的键值对首先会被容器读取并存放到ServletContext对象中，这里面的键值对信息被整个web项目共享。</p>\n<p>如何读取context-param中的值呢？我们只要获得ServletContext对象，然后再调用它的getInitParameter提供键名来获得方法就可以获得。在哪些地方能获得SerlvetContext对象呢？我们继承HttpServlet的Serlvet中去调用getServletContext就能获取ServletContext对象；这里我首先来编写一个简单Java web项目来读取相关的参数，首先是配置文件：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">version</span>=<span class=\"string\">&quot;4.0&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>test-param<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>this is a test-param string<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>simple-web-app<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">            servlet.SimpleServlet</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>simple-web-app<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在这个配置文件中，我只定义了最简单的两个节点context-param与servlet，对于context-param节点，我定义了”test-param” : “this is a test-param string”键值对，然后定义了servlet相关配置（这一部分我认为你已经明白了）。最后，SimpleServlet中的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        doPost(req, resp); <span class=\"comment\">// 将所有的Get请求转移到Post请求方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        ServletContext context = <span class=\"keyword\">this</span>.getServletContext();</span><br><span class=\"line\">        String param = context.getInitParameter(<span class=\"string\">&quot;test-param&quot;</span>);</span><br><span class=\"line\">        resp.getWriter().print(param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在doPost方法中，我们按照前面说的方式获取ServletContext对象，然后再通过getInitParameter方法获取”test-param”键对应的字符串，然后输出到网页上：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-08-26-JavaWeb/print.png\" alt=\"print.png\"></p>\n<h5 id=\"listener节点\"><a href=\"#listener节点\" class=\"headerlink\" title=\"listener节点\"></a>listener节点</h5><p>web.xml第二步加载就是listener节点，该节点的形式如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">        listener.MyInitListener</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><br>而MyInitListener类需要实现ServletContextListener接口，并重写其中的方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInitListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletContextListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> Date() + <span class=\"string\">&quot; contextInitialized....&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextDestroyed</span><span class=\"params\">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>当web.xml在加载监听器节点之后，会创建我们定义的对应的MyInitListener对象，并且会执行其中的contextInitialized方法，在整个项目关闭的时候会执行contextDestroyed方法。上面我们编写了contextInitialized方法中的内容，然后启动项目，会在控制台看到输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sun Aug 26 13:02:19 CST 2018 contextInitialized....</span><br></pre></td></tr></table></figure></p>\n<p>当然，我们也可以ServletContextEvent.getServletContext().getInitParam(“xxx”)来获取context-param了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"keyword\">new</span> Date() + <span class=\"string\">&quot;contextInitialized....&quot;</span>);</span><br><span class=\"line\">    System.out.println(sce.getServletContext().getInitParameter(<span class=\"string\">&quot;test-param&quot;</span>) + <span class=\"string\">&quot; in contextInitialized()&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// OUTPUT</span></span><br><span class=\"line\">    <span class=\"comment\">// Sun Aug 26 13:19:16 CST 2018 contextInitialized....</span></span><br><span class=\"line\">    <span class=\"comment\">// this is a test-param string in contextInitialized()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"回到Spring-MVC配置\"><a href=\"#回到Spring-MVC配置\" class=\"headerlink\" title=\"回到Spring MVC配置\"></a>回到Spring MVC配置</h4><p>回到Spring。为什么想要使用spring mvc，需要设置param-name=contextConfigurationLocation，param-value=xxxx-spring（非mvc部分配置）.xml；然后设置listener节点中监听器类是org.springframework.web.context.ContextLoaderListener。其实就比较好理解了，因为在这一步通过首先将spring基础上下文的配置文件通过ContextLoaderListener监听器去加载，然后读取出基础spring IOC以及AOP部分配置，将一些基础组件加载到spring的bean容器中，在接下来的无论是filter节点中的对象还是serlvet节点中的对象需要依赖注入的部分，都已经通过加载context-param中对于spring基础配置文件定位加载好了，后续spring相关的bean的创建以及注入等都交给了spring来进行管理。</p>\n<p>同时在加载serlvet时候，因为所有的请求都交给了DispatcherSevlet，且指定了mvc.xml配置文件的路径参数，所以，我们在这个mvc.xml中去设置静态资源的处理规则以及试图和控制器等处理规则。</p>\n","categories":[],"tags":["SpringMVC","Servlet"]},{"title":"CSharp委托与匿名函数","url":"http://compilemind.com/2018/08/04/2018-08-04-CSharp委托与匿名函数/","content":"<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>面对事件处理，我们通常会通过定义某一个通用接口，在该接口中定义方法，然后在框架代码中，调用实现该接口的类实例的方法来实现函数的回调。可能这样来说有些抽象，那我们提供一个具体的情形来实现这一情形。</p>\n<a id=\"more\"></a>\n<p>假设目前我在编写某一个服务，这个服务通过Start启动，并在一定的时间内不停地监听某一个事件的发生：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Service</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Random rand = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt;= <span class=\"number\">10000</span>)<span class=\"comment\">// 一段时间内</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> eventInt = rand.Next(<span class=\"number\">10</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 监听事件的发生，这里就是i能够被随机数整除的事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % eventInt == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODU</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>以上这段代码就大致描述了我的服务运行过程。往往我们都是自行的编写服务代码，在上面的TODU处编写处理函数，以应对这些事件发生的时候进行的操作。比如，现在我想要当事件发生的时候，能够打印eventInt，只需要在TODU处编写输出函数就行了。</p>\n<p>然而，我们编写这样的代码扩展性受到了严重的限制。因为假如我要修改事件处理的函数，就必须要到这个地方来修改。其次，假设我现在的想法是这段框架代码我编写好了，而你作为客户端代码使用者，想要定义其他的处理函数，当我打包编译好了这段代码，你完全没法修改它，只能够告诉我，然后将你的代码加入TODU中，这样的维护几乎不现实。</p>\n<p>但是，接口（或者是抽象类等其他同思想）可以帮助我们改变这一现状。我们使用一个通用的接口比如EventHandler，在其中定义一个名为EventHandle的方法，就像下面这样：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IEventHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后在原先的服务代码，定义一个接口对象域，通过构造函数或者是定义一个注册方法来注册这个处理类，就像下面这样：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Service</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个接口对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IEventHandler _eventHandler;</span><br><span class=\"line\">    <span class=\"comment\">// 通过构造函数注册这个处理对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Service</span>(<span class=\"params\">IEventHandler eventHandler</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._eventHandler = eventHandler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 通过顶定义一个方法来注册这个对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RegistHandler</span>(<span class=\"params\">IEventHandler eventHandler</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._eventHandler = eventHandler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>(<span class=\"params\"></span>) </span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        ...<span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % eventInt == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把操作全部交给 _eventHandler 来进行</span></span><br><span class=\"line\">            _eventHandler.EventHandle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>于是，在我们客户端代码，只需要实现这个接口，并定义自己的方法处理内容，然后实例化这个对象并将其注册到Service中就能够，那么当事件发生的时候，就能够通过运行时候的多态，动态根据我们new出来的不同的Handler对象进行定制的操作，并且，Service端是可以与客户端分离出来的。</p>\n<h4 id=\"更好的语法糖——c-委托\"><a href=\"#更好的语法糖——c-委托\" class=\"headerlink\" title=\"更好的语法糖——c#委托\"></a>更好的语法糖——c#委托</h4><h5 id=\"使用委托的角度\"><a href=\"#使用委托的角度\" class=\"headerlink\" title=\"使用委托的角度\"></a>使用委托的角度</h5><p>诚然，在学习的初期，我十分推荐完全利用面向对象的思想来构建和理解接口与事件处理的代码。但是我们可以发现，这样的代码还不足够的简练。还是以上面的例子来说，每次我要去定制属于自己的事件处理代码的时候，都需要我们去实现这个接口，然后实现其中的接口的方法，然后把这个实例化对象，再注册到代码中去。实际上，在c#中，我们可以利用更加舒服的语法糖来实现：委托。委托的声明类似于函数，但是不带函数体，且要用delegate关键字。大致形式如下：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">XXX</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 不同的返回类型以及参数类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">Check</span>(<span class=\"params\"><span class=\"keyword\">int</span> param</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实际上，委托的语法应该这样理解：第一个是我定义了一个名为EventHandle的委托，它代表了一个函数，这个函数名字我也不知道是什么，只知道他是参数为空，返回为void的函数；第二个是我定义了一个名为Check的委托，它代表了一个只有一个int类型参数的，返回值为bool的函数。</p>\n<p>定义规则如下：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">XXX</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 不同的返回类型以及参数类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">Check</span>(<span class=\"params\"><span class=\"keyword\">int</span> param</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>使用的方式如下：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">ServiceSimulate</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">namespace</span> <span class=\"title\">XXX</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">Check</span>(<span class=\"params\"><span class=\"keyword\">int</span> param</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">MyEventHandle</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">&quot;Do IT&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">MyCheck</span>(<span class=\"params\"><span class=\"keyword\">int</span> param</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> param &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            EventHandle myEventHandle = <span class=\"keyword\">new</span> EventHandle(Program.MyEventHandle);</span><br><span class=\"line\">            myEventHandle();</span><br><span class=\"line\">            Check myCheck = <span class=\"keyword\">new</span> Check(Program.MyCheck);</span><br><span class=\"line\">            Console.WriteLine(myCheck(<span class=\"number\">2</span>));</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在上面的Program类中，我分别定义了两个函数MyEventHandle和MyCheck，这两个函数的签名（只考虑参数和返回类型）与定义的两个委托EventHandle和Check的语义是一样的。在这样的情况下，我在使用这两个委托的时候，可以上面Main方法中的语法一样，首先定义一个委托类型（EventHandle myEventHandle），通过new 委托的方式将方法设置到委托中（= new EventHandle(Program.MyEventHandle)）。<br>于是接下来我可以直接使用委托变量来达到和使用函数一样的作用，输出见下方：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// OUTPUT</span></span><br><span class=\"line\">DO IT</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure><br>当然，我们还可以通过更加简洁的声明方式，不用new关键字，而是直接将函数赋予委托类型变量：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventHandle myEventHandle = Program.MyEventHandle;</span><br><span class=\"line\">Check myCheck = Program.MyCheck;</span><br></pre></td></tr></table></figure></p>\n<p>目前位置大致介绍了委托的语法与语义，那么回到一开始的服务代码中，我们可以看到，每次我们去实现接口，都会去实现接口中的固定的方法，然后再注册，被调用。实际上，我们完全可以使用委托的方式来来简化代码：</p>\n<p>我们现在可以不用定义统一的接口了，而是定义一个委托，然后想Service注册这个委托，就完全能够达到一开始调用实现接口的类中的方法的目的了（有点拗口）。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">ServiceSimulate</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;<span class=\"comment\">// 定义委托类型</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Service</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> EventHandle _eventHandle;</span><br><span class=\"line\">        <span class=\"comment\">// 通过构造函数注册委托对象</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Service</span>(<span class=\"params\">EventHandle eventHandle</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._eventHandle = eventHandle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 通过定义的方法注册委托对象</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RegistHandler</span>(<span class=\"params\">EventHandle eventHandle</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._eventHandle = eventHandle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            Random rand = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt;= <span class=\"number\">10000</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> eventInt = rand.Next(<span class=\"number\">10</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i % eventInt == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 注意这里直接就是委托对象语法形式来调用方法了</span></span><br><span class=\"line\">                    _eventHandle();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在客户端代码中，我们就可以定义满足委托类型语法语义的函数，将函数注册到委托对象上：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义处理方法就行了，不用再实现接口，再定义处理内容</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">MyEventHandle</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Do IT&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        Service ss = <span class=\"keyword\">new</span> Service(MyEventHandle);<span class=\"comment\">// 通过构造函数注册委托对象</span></span><br><span class=\"line\">        ss.Start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如此以来，利用委托，能够更加方便的函数回调。实际上，我个人对委托的理解，再代码的底层编译器处理的过程中，应该还是将委托转化为了接口函数（个人猜测，技艺不深，无法验证）。</p>\n<h5 id=\"定义委托的角度\"><a href=\"#定义委托的角度\" class=\"headerlink\" title=\"定义委托的角度\"></a>定义委托的角度</h5><p>在前面的介绍中，我谈了关于委托的使用过程及其思想，主要是从客户端的角度，谈了谈如何使用定义好的委托。在这一节中，我将从结合泛型来谈一谈在我们编写框架代码的时候，如何更为高效的定义我们的委托。</p>\n<p>回到一开始的例子，当作为服务端（此服务端是指为客户端程序员提供代码）代码编写者，在以后的开发中，我们会发现我们会定义大量的委托，并且，这些委托实际上绝大部分是具有共性的。有点抽象，具体一点讲，上面的例子中Service我们定义了一个名为EventHandle的委托，他代表了一个返回值为void，无参的函数类型。在以后的开发中，我们可能会定义更多的类似结构的委托，返回值或有不同，参数列表或有不同，就像下面这种情形：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">XXX</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle2</span>(<span class=\"params\"><span class=\"keyword\">int</span> p1</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">EventHandle3</span>(<span class=\"params\"><span class=\"keyword\">int</span> p1</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">EventHandle4</span>(<span class=\"params\"><span class=\"keyword\">int</span> p1, <span class=\"keyword\">double</span> p2</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">EventHandle5</span>(<span class=\"params\"><span class=\"keyword\">double</span> p1, <span class=\"keyword\">int</span> p2</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，我们定义如此多的事件处理委托类型，他们由于返回值、参数的差异彼此不同。不难看出，不同的返回值、参数类型的搭配，可以定义成千上万个委托类型，同时他们彼此还很接近。为了解决这一定义爆炸，c#提供了三种基本的泛型委托，我们只需要改变泛型参数，就能够达到定义不同的委托：</p>\n<h6 id=\"Predicate\"><a href=\"#Predicate\" class=\"headerlink\" title=\"Predicate\\\"></a>Predicate\\<T></h6><p>该泛型委托的原型定义如下：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">Predicate</span>&lt;<span class=\"keyword\">in</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">T obj</span>)</span>;</span><br></pre></td></tr></table></figure><br>该委托只需要指定一个参数类型，就能够定义一个返回值类型为bool，一个参数的函数语义委托定义。</p>\n<h6 id=\"Action-or-Action\"><a href=\"#Action-or-Action\" class=\"headerlink\" title=\"Action or Action\"></a>Action<T1, T2, ......T16> or Action</h6><p>泛型Action\\<T>委托表示引用一个void返回类型的方法。Action\\<T>委托类存在不同的变体，可以传递至多16种不同的参数类型，没有泛型参数的Action类可以调用没有参数的方法。例如：Action\\<in T1>调用带一个参数的方法，Action\\<in T1,in T2>调用带两个参数的方法等.。其<strong>某两个</strong>原型定义如下：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">Action</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">Action</span>&lt;<span class=\"keyword\">in</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">T obj</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 极限 void Action&lt;T1,..., T16&gt;(T1 arg1, ...., T16 arg16)</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"Func-lt-T1-T2-…T16-TResult-gt\"><a href=\"#Func-lt-T1-T2-…T16-TResult-gt\" class=\"headerlink\" title=\"Func&lt;[T1, T2, …T16,] TResult&gt;\"></a>Func&lt;[T1, T2, …T16,] TResult&gt;</h6><p>Func\\<T>的用法和Action\\<T>用法类似，但是Func\\<T>表示引用一个带返回类型的方法，Func\\<T>也存在不同的变体，至多可以传递16个参数类型和1个返回类型，例如：Func\\<in T1,out Resout>表示带一个参数的方法，Func\\<in T1,in T2,out Resout>表示调用带两个参数的方法。其<strong>某两个</strong>原型定义如下：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有参数 + 1个返回类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> TResult <span class=\"title\">Func</span>&lt;<span class=\"keyword\">out</span> <span class=\"title\">TResult</span>&gt;(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 2个参数 + 个返回类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> TResult <span class=\"title\">Func</span>&lt;<span class=\"keyword\">in</span> <span class=\"title\">T1</span>, <span class=\"title\">int</span> <span class=\"title\">T2</span>, <span class=\"keyword\">out</span> <span class=\"title\">TResult</span>&gt;(<span class=\"params\">T1 arg1, T2 arg2</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 极限 TResult Func&lt;T1,..., T16, TResult&gt;(T1 arg1, ...., T16 arg16)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h4><p>通过前面的介绍，我们已经能够更为简洁通用的定义自己的委托类型了，比如现在我需要一个定义一个返回值为string，参一个int类型与一个double类型的参数形式的委托类型，可以按照如下定义：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">Test</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            Func&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, <span class=\"keyword\">string</span>&gt; myFunc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为了使用这个委托，我们定义一个方法并赋予这个委托myFunc：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">string</span> <span class=\"title\">f</span>(<span class=\"params\"><span class=\"keyword\">int</span> p1, <span class=\"keyword\">double</span> p2</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p1 + <span class=\"string\">&quot;, &quot;</span> + p2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        Func&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, <span class=\"keyword\">string</span>&gt; myFunc = f;</span><br><span class=\"line\">        Console.WriteLine(myFunc(<span class=\"number\">2</span>, <span class=\"number\">3.33</span>));</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们会发现，每次要“实例化”一个委托，我们都要在某个地方去编写一个函数，无论是static的还是实例的方法，都需要我们到一个地方去显式指定好方法函数名等等。而且，通常这些函数我们都是某种工具函数，只会在一些特定的地方去调用，为了这些函数，我们还需要给他们创建一个类，这往往是很多余的（尽管贯彻了OO思想，但是匿名方法往往更体现在函数式编程FP而不是面向对象编程OOP，这是一种编程哲学）。于是，为了脱离面向对象，更好的方式是采取匿名的形式，因为既然我们定义好了委托类型，他制定了返回值制定了参数类型，我们还有必要去显示制定一个函数的名称吗？正如委托语义一样，委托类型就是定义了一个返回值是XXX类型，参数列表是XX t1, xx t1…的函数，至于这个函数到底叫什么根本不用关心。而匿名函数就符合这样的要求。而匿名函数在c#中又分为两种：Lambda表达式和匿名方法表达式。在几乎所有的情况下，Lambda表达式都比匿名方法表达式更为简介具有表现力。</p>\n<h6 id=\"Lambda表达式：\"><a href=\"#Lambda表达式：\" class=\"headerlink\" title=\"Lambda表达式：\"></a>Lambda表达式：</h6><p>(匿名的函数签名) =&gt; (匿名的函数体) </p>\n<p>其中匿名的函数签名可以包括两种，一种是隐式的匿名函数签名另一种是显式的匿名函数签名： </p>\n<ol>\n<li>隐式的函数签名：(p)、(p1,p1) </li>\n<li>显式的函数签名：(int p)、(int p1,int p2)、(ref int p1, out int p2) </li>\n</ol>\n<p>在显式类型化参数列表中，每个参数的类型是显式声明的，在隐式类型化参数列表中，参数的类型是从匿名函数出现的上下文中推断出来的。 </p>\n<p>匿名的函数体可以是表达式或者代码块。</p>\n<p>当Lambda表达式只有<strong>一个</strong>具有隐式类型化参数的时候，参数列表可以省略圆括号，也就是说： </p>\n<p>(参数) =&gt; 表达式 可以简写为 参数 =&gt; 表达式</p>\n<h6 id=\"匿名方法表达式：\"><a href=\"#匿名方法表达式：\" class=\"headerlink\" title=\"匿名方法表达式：\"></a>匿名方法表达式：</h6><p>delegate (显式的匿名函数签名) {代码块}</p>\n<p>从表达式来看，匿名方法实际上就是单纯的将函数名省去，而其他部分都和一般定义一个方法一样。</p>\n<p>下面是是综合了上述两种表达式形式的是实例<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lambda表达式</span></span><br><span class=\"line\">x =&gt; x + <span class=\"number\">1</span> <span class=\"comment\">//隐式的类型化，函数体为表达式</span></span><br><span class=\"line\">x =&gt; &#123;<span class=\"keyword\">return</span> x + <span class=\"number\">1</span>;&#125; <span class=\"comment\">//隐式的类型化，函数体为代码块</span></span><br><span class=\"line\">(<span class=\"keyword\">int</span> x) =&gt; x + <span class=\"number\">1</span> <span class=\"comment\">//显式的类型化，函数体为表达式</span></span><br><span class=\"line\">(<span class=\"keyword\">int</span> x) =&gt; &#123;<span class=\"keyword\">return</span> x + <span class=\"number\">1</span>;&#125; <span class=\"comment\">//显式的类型化，函数体为代码块</span></span><br><span class=\"line\">(x , y) =&gt; x * y <span class=\"comment\">//多参数</span></span><br><span class=\"line\">() =&gt; Console.WriteLine() <span class=\"comment\">//无参数</span></span><br><span class=\"line\"><span class=\"comment\">// 匿名函数方法表达式</span></span><br><span class=\"line\"><span class=\"keyword\">delegate</span> (<span class=\"keyword\">int</span> x) &#123;<span class=\"keyword\">return</span> x + <span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">delegate</span> &#123;<span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"number\">1</span>;&#125; <span class=\"comment\">//参数列表省略</span></span><br></pre></td></tr></table></figure><br>那么，匿名方法表达式和Lambda表达式有什么区别呢？从上面的介绍看来有以下的几点：</p>\n<ol>\n<li>在参数列表上，Lambda表达式能够通过上下文推断参数的类型信息，故可以使用隐式类型化参数。而匿名方法表达式必须要显示的参数类型化。</li>\n<li>当没有参数或者是多个参数的时候，Lambda表达式是不能够省略括号的；匿名方法表达式允许完全省略参数列表。</li>\n<li>在函数体上，Lambda表达式的主题可以是表达式，也可以是代码块；而匿名方法表达式只能是代码块。 </li>\n</ol>\n<p>回到上面的代码，我们利用匿名函数来实现f方法，这一次我们完全不需要在其他类中去定义这个f方法了：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Func&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, <span class=\"keyword\">string</span>&gt; myFunc = (x, y) =&gt; x + <span class=\"string\">&quot;, &quot;</span> + y;</span><br><span class=\"line\">Func&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, <span class=\"keyword\">string</span>&gt; myFunc2 = <span class=\"keyword\">delegate</span> (<span class=\"keyword\">int</span> x, <span class=\"keyword\">double</span> y) &#123; <span class=\"keyword\">return</span> x + <span class=\"string\">&quot;, &quot;</span> + y; &#125;;</span><br><span class=\"line\">Console.WriteLine(myFunc(<span class=\"number\">2</span>, <span class=\"number\">3.33</span>));</span><br><span class=\"line\">Console.WriteLine(myFunc2(<span class=\"number\">2</span>, <span class=\"number\">3.33</span>));</span><br><span class=\"line\">Console.ReadKey();</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\"><span class=\"number\">2</span>, <span class=\"number\">2.33</span></span><br><span class=\"line\"><span class=\"number\">2</span>, <span class=\"number\">2.33</span></span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["C#","delegate","lambda"]},{"title":"做你所做","url":"http://compilemind.com/2018/07/29/2018-07-29-做你所做/","content":"<h4 id=\"昨夜\"><a href=\"#昨夜\" class=\"headerlink\" title=\"昨夜\"></a>昨夜</h4><p>昨晚我失眠了，因为在自己的机器上装东西，顺便看了小米的纪录片《一团火》。也许是太久没有看到关于非产品方面的小米了，也许是太想要看到小米一路走来的路了，看完后我内心久久不能平复。待到后半夜，我内心依然如纪录片一般“一团火”。那一群人，那样的坚定，让我羡慕与感动。</p>\n<a id=\"more\"></a>\n<h4 id=\"眼下\"><a href=\"#眼下\" class=\"headerlink\" title=\"眼下\"></a>眼下</h4><p>今天是入职第二周周末，之所以没有在前些日子就写博文，因为那段时间单纯的是报道——领东西——装机器——配环境——培训，似乎每一位到新环境工作的人总要经历的东西，还有什么可写的呢？真正让我内心激动的是昨夜的“一团火”还有这几天以来的感受，回想起去年实习的日子，我庆幸于没有因为苟且而留在那里。而在这里，我的体会是满足的，是充实的。</p>\n<h5 id=\"“温柔”\"><a href=\"#“温柔”\" class=\"headerlink\" title=\"“温柔”\"></a>“温柔”</h5><p>每一位同事都给我一种“温柔”的感觉，这“温柔”绝不是那些小说女主角一般的依偎与可爱，更贴切的是一种淡然自若。他们的眉头也偶有骤紧，但绝不会是重压下的无法呼吸，而是紧凑而繁忙的工作带给他们的充实。其次的工作环境与氛围也是”温柔“的。在我看来，工作环境对于一个人的内心或多或少都有影响。这里给了我很舒服的感觉，一种温馨的，好似家一般的感觉。或许是因为并不是单纯的开发中心的原因吧，少了理工的那种统一呆板，更多的是像成都一般的闲适。</p>\n<h5 id=\"Not-Hei\"><a href=\"#Not-Hei\" class=\"headerlink\" title=\"Not Hei\"></a>Not Hei</h5><p>回想起去年的在苏州某为的实习，好似我在黑它一般。没有人情味的工作，没有人情味的活动。好像每一个人在工作，但仅仅是每”一个“人。那段时间，我好担忧，因为进入的第一周，我就似乎看到了假如我在这里工作以后，一年两年三年的日子。以至于实习结束的时候，我没有丝毫的充实感。跟导师发出道别消息的那一刹那，我甚至没有一丝的眷念。接下来，回家，收拾行李，买回学校的车票，一切在欣欣然之中。</p>\n<p>是过于言重了吗？可我就如把一件难缠的事情磕磕碰碰磨平了一般解脱了！心情线在实习开始的顶点一路缓缓跌下，然后结束实习，又直入云霄了：）。就如鸡汤常说的，很多事情，只有经历了才知道。对，我经历了某为的实习之后，再也不想回去了！</p>\n<p>前段时间入职之前，我依然有些许的担忧——是不是还像去年那样，氛围、人情味毫无，如果那样，我该怎么办啊！事实证明，我多虑了：）。最近刚好在组内有幸参加了六月的回顾会，”老老大“让每一位员工说说自己这一个月的时间的心情变化。作为新人，当然没有处理项目的复杂心情，也只能谈一谈如之前后的一些所以想：</p>\n<p>去年在别处的实习与这段是时间的入职感受截然不同。这里的工作氛围、人与人之间的交互，让我感到十分的舒适。同样，只要是我需要接触的技术，在入门以及较为深入的学习之后，总能够给予我足够的兴趣与信心。因为好多都不懂，所以好多都想要学习。于是继续学习，继续总结心得，进而激发了更多的兴趣。如此良性的循环 + 工作环境氛围 =&gt; 继续以一个乐观的心态去面对工作中的一切。其实这种类似的话也曾在许多鸡汤中见过，那时还觉得不过尔尔，可是当我真正去体会的时候，”在听已是曲中人“，：）。</p>\n<h5 id=\"为什么会这样\"><a href=\"#为什么会这样\" class=\"headerlink\" title=\"为什么会这样\"></a>为什么会这样</h5><p>我也不知道什么时候，我的心态就变得如此乐观。但一次与高中挚友的交谈，我们大概得出了一个为什么的结论：因为家人的支持。我感激于我的家人在背后给予了我莫大的帮助，无论精神上还是物质上。对于精神层面，他们总是希望我能够在无论是生活还是工作上都学到东西，希望我能够关注过程带来的收获，而不仅仅看结果；而从物质上来说，他们无私的为我创造条件，让我不要花过多的时间来关注物质方面的需求，从而能全身心的投入到工作学习中。这两方面其实是相互结合的。说了好多大话，可这就是我最真切的感受。：）。</p>\n<h4 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h4><p>未来会是怎样呢？</p>\n<p>当我们受制于生活的”苦难“</p>\n<p>是不满命运的挣脱</p>\n<p>还是”哪里跌倒哪里趴着“的苟且</p>\n<p>当我们总是沉迷于表象安逸</p>\n<p>是当一位睁着眼睛的瞎子</p>\n<p>还是做一名不停反思的Thinker</p>\n<p>当我们发现经常无所事事</p>\n<p>是走一步看一步的慵懒</p>\n<p>还是勇敢迈出第一步去充实自己</p>\n<p>我会告诫自己：Keep Real, Keep 3</p>\n<hr>\n<h5 id=\"符号说明：）\"><a href=\"#符号说明：）\" class=\"headerlink\" title=\"符号说明：）\"></a>符号说明：）</h5><p><strong>：）</strong>：嘻嘻</p>\n<p><strong>+</strong>：结合</p>\n<p><strong>=&gt;</strong>：促使</p>\n<p><strong>3</strong>：011</p>\n","categories":[],"tags":["think"]},{"title":"Spring配置文件结构对于生成Bean的影响","url":"http://compilemind.com/2018/07/02/2018-07-02-Spring配置文件结构对于生成Bean的影响/","content":"<p>由于前段时间忙于毕设，导致Spring学习的东西忘了很多，所以最近又开始从头看Spring的基础。基础的Bean的装配不再多说了。这一次，主要是深入一点了解Spring配置文件结构搭配对于Bean装配的影响。</p>\n<a id=\"more\"></a>\n<p>首先，我们设定一个简单的场景：播放器播放歌曲。所以基于此，我们定义两个接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo;</span><br><span class=\"line\"><span class=\"comment\">// CD接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CompactDisc</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo;</span><br><span class=\"line\"><span class=\"comment\">// 媒体播放器接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MediaPlayer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>按照是实际来讲，我们定义一个BlankDisc，空白的唱片，其包含三个属性：title、artist和tracks，分别代表了唱片的标题、歌手以及歌曲目录：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.cd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.CompactDisc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlankDisc</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String artist;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; tracks; <span class=\"comment\">// 简化结构，只存放歌曲目录名称并保存为List</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BlankDisc</span><span class=\"params\">(String title, String artist, List&lt;String&gt; tracks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.artist = artist;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tracks = tracks;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Playing &quot;</span> + title + <span class=\"string\">&quot; \\n\\tby &quot;</span> + artist);</span><br><span class=\"line\">        tracks.stream().forEach(t -&gt; System.out.println(<span class=\"string\">&quot; \\t&gt;&gt;&gt; &quot;</span> + t));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>同样的，实现MediaPlayer接口，定义实际的唱片播放器，能够持有cd的引用，同时，这里我们并没有通过构造器来定义，原因是唱片播放器并非一定放有cd（当然代码没有对null进行约束，这是不好的，实际编写请勿这样编写）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.player;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.CompactDisc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.MediaPlayer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayer</span> <span class=\"keyword\">implements</span> <span class=\"title\">MediaPlayer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CompactDisc cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCd</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cd = cd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CDPlayer 开始播放: &quot;</span>);</span><br><span class=\"line\">        cd.play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下来，要说明的是，Spring支持xml与Java文件同时存在的配置方式，这里我们也会这么做，尽可能的复杂化配置依赖，因为本片文章就是探讨各种配置文件交叉依赖的情形，并理清依赖的思路。</p>\n<p>首先我们将CD类Bean与CDPlayer类Bean分离开来。</p>\n<h4 id=\"首先是CD类Bean\"><a href=\"#首先是CD类Bean\" class=\"headerlink\" title=\"首先是CD类Bean\"></a>首先是CD类Bean</h4><h5 id=\"Java类型配置文件\"><a href=\"#Java类型配置文件\" class=\"headerlink\" title=\"Java类型配置文件\"></a>Java类型配置文件</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.cd.BlankDisc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BlankDisc <span class=\"title\">yeHuiMei</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; tracks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        tracks.add(<span class=\"string\">&quot;以父之名&quot;</span>);</span><br><span class=\"line\">        tracks.add(<span class=\"string\">&quot;懦夫&quot;</span>);</span><br><span class=\"line\">        tracks.add(<span class=\"string\">&quot;晴天&quot;</span>);</span><br><span class=\"line\">        tracks.add(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlankDisc(<span class=\"string\">&quot;YeHuiMei&quot;</span>, <span class=\"string\">&quot;JayChou&quot;</span>, tracks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个配置文件中，只定义了一个Bean，Bean id名称为yeHuiMei（方法名），同时也将相关的属性设置完毕。</p>\n<h5 id=\"xml类型配置文件\"><a href=\"#xml类型配置文件\" class=\"headerlink\" title=\"xml类型配置文件\"></a>xml类型配置文件</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;onTheRun&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">class</span>=<span class=\"string\">&quot;demo.cd.BlankDisc&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;title&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;On The Run&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;artist&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;JayChou&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;tracks&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>牛仔很忙<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>彩虹<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>青花瓷<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在这个xml配置文件中，我定义了一个名为onTheRun的Bean，同时也设置了对应的属性。</p>\n<h4 id=\"CDPlayer的Bean\"><a href=\"#CDPlayer的Bean\" class=\"headerlink\" title=\"CDPlayer的Bean\"></a>CDPlayer的Bean</h4><h5 id=\"Java类型配置文件-1\"><a href=\"#Java类型配置文件-1\" class=\"headerlink\" title=\"Java类型配置文件\"></a>Java类型配置文件</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayerInJava</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;onTheRun&quot;)</span> CompactDisc cd)</span> </span>&#123;</span><br><span class=\"line\">        CDPlayer cdPlayer = <span class=\"keyword\">new</span> CDPlayer();</span><br><span class=\"line\">        cdPlayer.setCd(cd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cdPlayer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"xml类型配置文件-1\"><a href=\"#xml类型配置文件-1\" class=\"headerlink\" title=\"xml类型配置文件\"></a>xml类型配置文件</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cdPlayerInXML&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;demo.player.CDPlayer&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cd&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;yeHuiMei&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>目前配置文件搞定了，并且我们现在的配置以来结构如下：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/dependency.png\" alt=\"dependency\"></p>\n<p>当然，目前还是有一定的问题的，因为很显然，我们的配置文件都独立与彼此。尽管在CDPlayer中的配置文件通过相关的语法制定了CD Bean的选择（@Qualifier和ref），但是我们可以看到文件本身并没有明确的引入另外的配置文件，所以在IDEA中通常会有这样的提示：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/norefinjava.png\" alt=\"norefinjava\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/norefinxml.png\" alt=\"norefinxml\"><br>同时打开，IDEA的项目结构Project Structs（win默认ctrl+shift+alt+s），点击左侧的Modules，可以看到Spring项目上右下角IDEA提示我们“Unmapped Spring configuration files”并列举除了上述的四个文件。</p>\n<p>我们点击上面的+将所有的配置文件追踪上，刚刚所有的索引问题都OK了。此时，我们任意找到一个xml文件，可以看到左上方有一个小标志，点击并选择第一个：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/clickdpdiagram.png\" alt=\"clickdpdiagram\"><br>打开之后就能够看到整个项目对于配置文件的依赖：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/dpdiagram.png\" alt=\"dpdiagram\"><br>可以看到我们的项目（springdemo）具有一个是上下文应用模块，这个应用上下文包含了四份配置文件。但一定要注意，在后续我们加载配置文件的时候，必须要将有依赖关系的配置文件全部加载进来才能够读取到对应的Bean。这里我们进行一个简单的测试：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"comment\">// 设置所要加载的配置文件</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &#123;&quot;classpath:cdconfig.xml&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;onTheRun&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CompactDisc cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cdShouldNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cd.play();</span><br><span class=\"line\">        assertNotNull(cd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这个测试是可以直接通过的，因为这里我们加载的是cdconfig.xml配置文件，里面我们定义了名为onTheRun的Bean，所以打印还有非空测试也通过：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/cdxmltest.png\" alt=\"cdxmltest\"><br>然而接下来我们更换配置文件为cdplayerconfig.xml，相关注入如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &#123;&quot;classpath:cdplayerconfig.xml&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;cdPlayerInXML&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MediaPlayer mp;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mediaPlayerNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(mp);</span><br><span class=\"line\">        mp.play();</span><br><span class=\"line\">        assertNotNull(mp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这里我们指定注入的就是xml中的CDPlayer Bean，然而，并不能通过测试，在错误提示中，我们可以找到这样一行：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cannot resolve reference to bean <span class=\"string\">&#x27;yeHuiMei&#x27;</span> <span class=\"keyword\">while</span> setting bean property <span class=\"string\">&#x27;cd&#x27;</span>; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named <span class=\"string\">&#x27;yeHuiMei&#x27;</span> is defined</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:<span class=\"number\">328</span>)</span><br></pre></td></tr></table></figure><br>前面我们知道，cdPlayerInXML这个bean中我们还注入了Java配置文件下的名为yeHuiMei Bean，而在测试的过程中，我们只加载了cdplayerconfig.xml这个配置文件。所以实际上除了这个配置文件意外的其他bean都没有被Spring生成并放入Bean容器中。</p>\n<p>也许会有疑问，在上面的Bean依赖图中，我们看到所有的配置文件都有已经被放入到了Spring Application Context中，为什么不被自动加载呢？道理很简单，这只是IDE的辅助而已。IDEA中的那个部分只是IDEA自身的一些辅助功能比如静态检查，所以需要我们手动的将这些文件给添加进去。当我们还是移除掉刚刚的结构之后，进行第一次的只对没有依赖的CDBean进行测试依然有效。</p>\n<p>一定要明确，Spring的注入是发生在代码中的！不要被IDE遮蔽了双眼！这里何时会被注入呢？当我们配置了Spring的配置文件并将其加载进来了，当Spring遇到@Autowired等注入注解的时候，就会为我们注入Bean。</p>\n<p>通常，当我们有多个配置文件的是，最优的结构思路是将多个配置文件导入到一个专门的独立的配置文件中，就像下面这样，我将开始的四个配置文件全部导入到一个名为AllConfig的Java配置文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;CDConfig.class, CDPlayerConfig.class&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">// 一定要注意！！！classpath:后面一定不要带空格！否则会被识别为【[空格]cdconfig.xml】这样的文件名而不被找到，血的教训。</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource(&#123;&quot;classpath:cdconfig.xml&quot;, &quot;classpath:cdplayerconfig.xml&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后在测试文件中我们将加载配置文件为Java配置文件AllConfig，此时，所有的以来问题全部解决：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = &#123;AllConfig.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;onTheRun&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CompactDisc cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cdShouldNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cd.play();</span><br><span class=\"line\">        assertNotNull(cd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;cdPlayerInXML&quot;)</span><span class=\"comment\">// 一开始由于配置文件没有引入全导致注入失败</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MediaPlayer mp;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mediaPlayerNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(mp);</span><br><span class=\"line\">        mp.play();</span><br><span class=\"line\">        assertNotNull(mp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/passed.png\" alt=\"passed\"></p>\n","categories":[],"tags":["Spring","Bean"]},{"title":"毕业所想","url":"http://compilemind.com/2018/06/17/2018-06-17-毕业所想/","content":"<p>距离上一次博文过了接近一个月了，这期间毕设虽忙，但不至于忙到连博文都写不了的地步。早就在寻思着什么时候更一篇文章，但是就是懒，好像每天忙完毕设的事情之后，就感觉自己今天做完一件事，就可以休息了，就可以放纵自己了。其实不过都是借口罢了。趁着这个时间，写写东西，回顾一下写过的东西，觉得写的东西还是太分散了，或者说，目前为止都没有一个明确的写作目标，这里也表明一下，顺便也为今后的写作约束一下自己。</p>\n<a id=\"more\"></a>\n<h4 id=\"我的博客到底要有些什么？\"><a href=\"#我的博客到底要有些什么？\" class=\"headerlink\" title=\"我的博客到底要有些什么？\"></a>我的博客到底要有些什么？</h4><p>这段时间看Effective Java，看Scala，做做练习，其实一直都是有心得体会的，不过都只是一些小的点，没有像之前的一些博文心得，有宏观的大的系统知识结构，特别是Effective Java，本身就是对于Java的各个方面来总结的，更是说不上宏大了。于是，对于通过博文来总结这些心得体会，如果硬要写出一篇来，总感觉到时候会纯粹地拼凑。我不想我的博文到头来<strong>纯粹</strong>成为一些Tips的合集（以前写的Linux命令就有这种嫌疑）。过了这么久了，我希望我的博文能够提升一下水平，加入更多的自己的元素在其中，当然，Tips类型的还是会有的，因为我坚持一个观点：<strong>当你需要花一定的时间反复琢磨、寻找解决问题的方法的时候，就是你需要记录的时候。</strong>所以，当我花费了一定的时间去配置某些东西的时候，我就会写一篇博文来进行记录，一来是训练自己的写作表述能力（虽然找资源，装环境这种博文提升不了太多的写作能力），二来是保持写作的心态。此外，我虽然是一位普通的程序员，但是心里还是有文学写作的心的。回忆起初中时期，就写过一本诗集，很可惜未保存好而遗失了。所以，我的博文同样会有一些偏向于更为文学的东西存在，譬如诗、杂记等，希望能够纪念且告诫自己不要因为成为一名程序员而遗失对于生活，对于人生的思考与感悟。</p>\n<p>综上（好生刻板的文字），我的博文会<strong>尽量</strong>控制70%是包含有自己见解的技术类博文，20%时日常开发过程中的配置记录等相关的文章，剩下的10%则是更为文学的文章。</p>\n<h4 id=\"再谈毕业所感所想\"><a href=\"#再谈毕业所感所想\" class=\"headerlink\" title=\"再谈毕业所感所想\"></a>再谈毕业所感所想</h4><p>这一天总归是要到来的。14年的盛夏来到了大学，是平淡的，是卑微的。还记得初到校园时候的迷茫，拿着预存有200快的校园卡，跑到教育超市买了一堆东西，发现超支了，尴尬的找附近的一位他同样是新生的女同学借了饭卡代刷。面容早已忘记了，但相比此时此刻，她也在忙于离校的琐事吧。这段时间老是和杨同学聊天，这四年到底怎么过来的，怎么一晃眼就要毕业了，最后嬉笑着打住了话题。</p>\n<p>是啊，怎么过来的呢？能够回想起这四年的点点滴滴，但也觉得太快了一点。大一的军训，大一的晚自习，大一对自己写的信；大二的上课的回答，大二时候的起早贪黑的学习；大三的课设，大三的比赛；大四的实习，大四的毕设（right now），一切都是历历在目。是因为大学的生活不像高中那样的三点一线，这些事情就变“稀薄”了吗？还是因为我们的心在成长，面对未来有了更多的从容不迫了吗？说不出来，大一到大四就这么过来了，这四年，这八个学期就这么过来了。有时候时间的改变，就这么过来了，就好像两个人相互的日久生情的喜欢，就这么过来了。</p>\n<p>有那么一瞬间，我还有点羡慕就在学校所在省的同学们。这毕业一别之后，他们再见的概率超过50%，就算没有，也能创造见面的机会，毕竟如今发达的交通让他们能再短时间相见。而我就不一样了，家乡距此超过两千公里，见面是多么的不容易。也许这一别，同一个宿舍的也许还能因为某些重大的事情而见面，不是同一个宿舍的，就是永远的不再相见了。想来也是神奇，有这样一群人，你和他曾有过四年的交集，这一别之后，就再无交集了。</p>\n<p>大学的生活对于绝大多数的人来说就是一两个宿舍的小圈子。我们往往在这一个小圈子中自由的生活着，交流着。于是，临近惜别之时，就会有一些人没能参与到班级的聚会中，想来挺替他们感到遗憾的，但也能理解。大学的同学之间的交情往往还不到初高中的一半，凝聚力自然也没有初高中那么强。想起初中写过辣鸡电影剧本，“担任”导演一职，一大波同学饶有兴致地参与扮演、拍摄（我可能对电影制作有什么误解，哈哈）。但至少还是有一群可爱地大学同学们啊！不过对于我来说，也许是要永别了。</p>\n<p>作为一名即将毕业成为程序员的我，当然经常看到别说程序员怎么怎么呆板，怎么怎么冰冷。我想要做的就是成为一名积极的程序员，成为一名通俗一点来讲，“多才多艺”的程序员。所以，我始终会坚持锻炼，始终会尝试不同于一般程序员所干的事情，譬如文学方面的写作、声乐的学习。我想要成为一名乐观主义者，而不是一名单纯的极客。这始终是我的理想。我想我能够带给人们的无限的可能，这样也许说的太宏观了，太雄伟了。具体一点，我希望我的家人，我的另一半能够看到丰富多彩的我，而不是众口中的“普通”程序员。我希望，我是一个理想的，有思考的，有<strong>活力</strong>的，爱生活的人！今后的博文，我也许会介绍我曾经触碰过的很多东西，虽然有一点“不务正业”。</p>\n<p>拒绝无病呻吟。我对于别人的无病呻吟虽谈不上鄙夷，但至少总是会不去理会他们，当一个“瞎子”忽视就好。一谈到写文章，就往往会和这些东西或多或少有些联系。所以我也时常告诫自己，不要带上这样的情绪。带上这些情绪，我们往往会“迷失”自己，进而形成一种“自我感动”的情形。还是那句话，我是一个乐观实用主义者，不要因为琐事而丧失自己的前进的心态。面对任何困难，不要无病呻吟，动手去做，去处理，不要等到一切都逼近的时候才后知后觉，才忙碌，才一阵匆忙之后，说出无病呻吟的话语，这样真的只是“感动自己”。</p>\n<h4 id=\"毕\"><a href=\"#毕\" class=\"headerlink\" title=\"毕\"></a>毕</h4><p>仲夏将至，夜不能寐。其由唯二，一来夏蚊成雷，挥之不去，甚是烦恼；二来完业临近，欲与学业惜别，些许惆怅。遂起身信步于闲庭之中，观夜中明星，忆四载春秋，不禁感慨万千。吾已二十有二，求学多年，虽无当今能人之卓越，也不失一心向前之意志。<br>人生漫漫，从未停息。</p>\n","categories":[],"tags":["Graduation"]},{"title":"Java枚举细节","url":"http://compilemind.com/2018/05/18/2018-05-18-Java枚举细节/","content":"<a id=\"more\"></a>\n<h4 id=\"枚举的简单使用\"><a href=\"#枚举的简单使用\" class=\"headerlink\" title=\"枚举的简单使用\"></a>枚举的简单使用</h4><p>在java中，我们可以使用enum关键字来定义枚举：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED, GREEN, BLUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>就像上面一样，我们定义了一个名为Color的枚举类，包含了RED、GREEN、BLUE三个常量。当我们使用枚举类的时候，直接通过枚举类名.枚举常量即可。就像如下的形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(Color c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (c) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RED: System.out.println(<span class=\"string\">&quot;It&#x27;s RED&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GREEN: System.out.println(<span class=\"string\">&quot;It&#x27;s GREEN&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: System.out.println(<span class=\"string\">&quot;It&#x27;s BLUE&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">f(Color.RED);</span><br><span class=\"line\"><span class=\"comment\">// 输出 &quot;It&#x27;s RED&quot;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"枚举的本质\"><a href=\"#枚举的本质\" class=\"headerlink\" title=\"枚举的本质\"></a>枚举的本质</h4><p>虽然Java提供枚举类的定义，但是实际上他并不是Java中一个新的对象类型，我们通过对Color枚举类进行反编译，得到如下的反编译结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ javap Color.class </span><br><span class=\"line\"><span class=\"comment\">// 反编译结果</span></span><br><span class=\"line\">Compiled from <span class=\"string\">&quot;Color.java&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnumerationAndAnnotation</span>.<span class=\"title\">Color</span> <span class=\"keyword\">extends</span> <span class=\"title\">java</span>.<span class=\"title\">lang</span>.<span class=\"title\">Enum</span>&lt;<span class=\"title\">EnumerationAndAnnotation</span>.<span class=\"title\">Color</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EnumerationAndAnnotation.Color RED;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EnumerationAndAnnotation.Color GREEN;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EnumerationAndAnnotation.Color BLUE;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> EnumerationAndAnnotation.Color[] values();</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> EnumerationAndAnnotation.<span class=\"function\">Color <span class=\"title\">valueOf</span><span class=\"params\">(java.lang.String)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到，枚举类实际上在编译的过程中，被编译器进行调整，它并不是一个新的类型，本质上依然是一个类（Color），这个类继承了java.lang.Enum<T>，而对于每一个枚举常量，实际上是public static final修饰的枚举类的静态实例对象。</p>\n<p>同时注意，编译器会为我们添加两个新的static方法：values() 和 valueOf(java.lang.String)，其实分别作用是返回枚举类中定义的所有的枚举常量，以及根据枚举名来获取枚举常量（注意，这里就是定义枚举常量的枚举名）。</p>\n<p>当然，由于每一个枚举常量实际上是实现了java.lang.Enum<T>的枚举类的一个静态实例对象，而这个过程是编译器为我们进行的，所以，自然，我们可以在枚举类中定义任何的方法、变量，以及构造函数的定义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED(<span class=\"string\">&quot;RED&quot;</span>), GREEN(<span class=\"string\">&quot;GREEN&quot;</span>), BLUE(<span class=\"string\">&quot;BLUE&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 定义类中的实例变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String colorName;</span><br><span class=\"line\">    <span class=\"comment\">// 定义构造函数，注意上面的枚举常量必须满足这种构造方式</span></span><br><span class=\"line\">    Color(String colorName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.colorName = colorName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义实例对象的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printColorName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Color name is &quot;</span> + colorName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 重写toString方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> colorName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>自然，我们可以枚举常量当作一个枚举的实例化对象，调用枚举类中的方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(Color.RED); <span class=\"comment\">// RED</span></span><br><span class=\"line\">    Color.RED.printColorName();\t<span class=\"comment\">// Color name is RED</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"为什么枚举构造器不能访问枚举的静态域\"><a href=\"#为什么枚举构造器不能访问枚举的静态域\" class=\"headerlink\" title=\"为什么枚举构造器不能访问枚举的静态域\"></a>为什么枚举构造器不能访问枚举的静态域</h4><p>查看下面这段代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED, GREEN, BLUE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Color() &#123;</span><br><span class=\"line\">        System.out.println(value); <span class=\"comment\">// 编译错误！构造器无法访问静态变量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到这里编译不通过，提示我们<strong>枚举构造器</strong>不能够访问枚举的静态域（以及静态变量）。我们知道，一般的类中，静态域以及静态变量是优于实例对象的变量、方法的初始化的。这里简要复习一下类中变量的加载机制：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 辅助静态变量的初始化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Init</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Init</span><span class=\"params\">(String init)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Init()&quot;</span> + init);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fa</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 父类静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Init initFa = <span class=\"keyword\">new</span> Init(<span class=\"string\">&quot;Fa&#x27;s static&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 父类实例变量</span></span><br><span class=\"line\">    Init initFa2 = <span class=\"keyword\">new</span> Init(<span class=\"string\">&quot;Fa&#x27;s no static&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 父类静态域</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Fa&#x27;s static&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 父类构造方法</span></span><br><span class=\"line\">    Fa() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Fa()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Su</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fa</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 子类静态域</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Su&#x27;s static&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 子类静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Init initSu = <span class=\"keyword\">new</span> Init(<span class=\"string\">&quot;Su&#x27;s static&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 子类实例变量</span></span><br><span class=\"line\">    Init initSu2 = <span class=\"keyword\">new</span> Init(<span class=\"string\">&quot;Su&#x27;s no static&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\">    Su() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Su()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下来，我们new出Su实例对象，并观察输出结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Su();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 输出</span></span><br><span class=\"line\"><span class=\"comment\">Init()Fa&#x27;s static \t// 1</span></span><br><span class=\"line\"><span class=\"comment\">Fa&#x27;s static\t\t\t// 2</span></span><br><span class=\"line\"><span class=\"comment\">Su&#x27;s static\t\t\t// 3</span></span><br><span class=\"line\"><span class=\"comment\">Init()Su&#x27;s static\t// 4</span></span><br><span class=\"line\"><span class=\"comment\">Init()Fa&#x27;s no static// 5</span></span><br><span class=\"line\"><span class=\"comment\">Fa()\t\t\t\t// 6</span></span><br><span class=\"line\"><span class=\"comment\">Init()Su&#x27;s no static// 7</span></span><br><span class=\"line\"><span class=\"comment\">Su()\t\t\t\t// 8</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure><br>我们可以看到，有static修饰的始终优于实例对象的相关的初始化的，在输出中 1 - 4 是static修饰部分，5 - 8是实例域部分。此外，在继承情形下，父类由于子，输出中 1- 2 是父类static域的初始化，3 - 4 是子类static域的初始化。在static域加载完成之后，才开始加载父类非static域，最后加载子类的非static域。注意，都为static修饰的情况下，加载顺序根绝定义时候的顺序而来，1、2与3、4就可以看出。</p>\n<p>看到这里，也许会有点疑问，既然静态域加载优于实例域（包含构造函数），那为什么在枚举类中就不行呢？让我们回到前面对枚举类的反编译，其实答案就出来了。反编译的过程我们可以看到，我们的枚举常量实际上是我们枚举类的静态实例化对象，在编译器的修改下，我们运行加载枚举类的过程中，枚举常量是static修饰的，其他静态域也是static修饰的，枚举常量又排在其他静态域的前面，按照上面的额初始化顺序，首先就会调用构造器实例化枚举常量对象，此时，枚举类中的其他静态域都还没来得及初始化，自然在构造函数中不能访问静态域了。有人可能想说，那我静态域放到枚举常量前面，让他先加载怎么样？很遗憾，Java不允许这样做：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123; <span class=\"comment\">// 编译不通过！！！</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</span><br><span class=\"line\">    RED, GREEN, BLUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用抽象函数为枚举统一方法\"><a href=\"#使用抽象函数为枚举统一方法\" class=\"headerlink\" title=\"使用抽象函数为枚举统一方法\"></a>使用抽象函数为枚举统一方法</h4><p>上面的内容探讨了枚举类的一些基础，这里提一些关于使用枚举的代码策略设计。<br>有的时候，我们想要给枚举常量定义某一些通用的方法，同时，针对不同的枚举，该通用方法呈现不同的具体内容。例如，我现在有一个如下的Color枚举类，当针对不同的Color常量的时候，能有一个方式给我返回该颜色的十六进制颜色码。也许你会如下来实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED, GREEN, BLUE;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> RED:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;#FF0000&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> GREEN:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;#00FF00&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;#0000FF&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>以上的方式较为简洁与易读，但是存在问题：枚举常量越来越多，case会不断增长，如果编写代码的过程由于不注意，增加颜色常量的时候，忘记了增加对应的case，那么编译是不会有任何的问题的，但是却隐含的将增加的颜色常量也返回的是BLUE的十六进制颜色码。</p>\n<p>鉴于上述的问题，我们需要某种方式来防止我们犯错，能够想到的，就是通过编译器来告诉我们。于是，我们在枚举类中定一个抽象方法getHexCode，于是乎，对于每一个枚举常量，编译器会提示我们实现具体实例的getHexCode：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;#FF0000&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, GREEN &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;#00FF00&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, BLUE &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;#0000FF&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在这样的定义下，代码牺牲了一定的简洁性，但是易读性丝毫不输于最开始的方式。针对Color枚举类，我们定义了抽象方法，表明了对于Color中的每一个枚举常量，都应该有getHexCode方法，返回自己的十六进制颜色码。如果我们新添加了枚举常量，而没有实现该方法，编译器会报错警告我们。</p>\n","categories":[],"tags":["Java","Enumeration"]},{"title":"Java泛型中的细节","url":"http://compilemind.com/2018/05/03/2018-05-03-Java泛型中的细节/","content":"<h3 id=\"如果没有泛型\"><a href=\"#如果没有泛型\" class=\"headerlink\" title=\"如果没有泛型\"></a>如果没有泛型</h3><p>学习Java，必不可少的一个过程就是需要掌握泛型。泛型起源于JDK1.5，为什么我们要使用泛型呢？泛型可以使编译器知道一个对象的限定类型是什么，这样编译器就可以在一个高的程度上验证这个类型消除了强制类型转换，使得代码可读性好，而这个过程是发生在编译时期的，即在编译时期发现代码中类型转换的错误所在，及时发现，而不必等到运行时期抛出运行时期的类型转换异常。</p>\n<a id=\"more\"></a>\n<p>泛型主要运用在譬如Java中的容器API等需要对多个对象进行管理的部分。</p>\n<p>早期（不支持泛型的时期）的Java代码，我们在使用容器的时候，需要在类型转换前手动的进行类型转换验证工作来防止异常。假设目前我们定义了一个Apple类，含有一个pare（削皮）方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Apple is pared&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下里，我们定义了一个方法void pareAll(List apples);传入包含有多个Apple实例的List，并逐一对每一个Apple进行pare操作：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">pareAll</span><span class=\"params\">(List apples)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object a : apples) &#123;</span><br><span class=\"line\">            Apple aa = (Apple)a;</span><br><span class=\"line\">            aa.pare();</span><br><span class=\"line\">            <span class=\"comment\">// 为了清晰认识出错的地方，我没有采用下面的代码</span></span><br><span class=\"line\">            <span class=\"comment\">// ((Apple)a).pare();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List apples = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">        apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">        pareAll(apples);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>首先明确一点，List、Set、Map等早期只能默认其实是Object类型的集合，即由于类型转换，像上面的List能够存放Object及其子类的对象，所以你当然可以添加多个Apple对象实例（上转型）。而在pareAll方法体中，由于我们刚刚说过，List存放的是上转型后的Object类型的对象，所以当我们获取List的对象的时候，自然只能拿到Object类型的对象，之后需要我们手动的进行下转型：((Apple)a).pare()。这段代码我们运行一下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Apple is pared</span><br><span class=\"line\">Apple is pared</span><br></pre></td></tr></table></figure><br>似乎没有问题，然而，由于容器能够接受的是Object对象，所以，我们再定一个譬如Banana类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Banana</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Banana is pared&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后将这个类也添加List中去，由于上转型，这里完全没有编译的错误：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List apples = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">apples.add(<span class=\"keyword\">new</span> Banana()); <span class=\"comment\">// 编译通过！</span></span><br><span class=\"line\">pareAll(apples);</span><br></pre></td></tr></table></figure><br>然而在运行的时候，去出现了错误：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Apple is pared</span><br><span class=\"line\">Apple is pared</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.ClassCastException: Banana cannot be cast to Apple</span><br><span class=\"line\"><span class=\"comment\">// 编译器告诉我们 Apple aa = (Apple)a;这里一段代码出错了</span></span><br></pre></td></tr></table></figure><br>首先，将List中的所有Object对象转换为Apple对象的时候，并没有出错，同时还正确输出了。但是，我们上面曾添加过Banana对象，在进行转换的过程中，却发生了类型转化的运行时异常。怎样解决这个问题？我们可以使用instanceof关键字，这个关键字可以判断一个对象是否是某一个类的实例化，所以我们修改pareAll方法，添加上实例判断：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果对象是Apple类的实例化，才进行转换</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (a <span class=\"keyword\">instanceof</span> Apple) &#123;</span><br><span class=\"line\">    ((Apple)a).pare();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>既然用这种方式就可以解决类型转换异常，那么为什么还要有泛型呢？首先，有了泛型进行麻烦的类型判断了；其次，通过编译器的支持，当我们使用泛型的时候，编译器会在编译时期就为我们解决好类型的问题，这样一来，可以保证，在运行时期，肯定不会因为类型转换出现异常。</p>\n<h3 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h3><p>JDK1.5给我们带来了泛型，当我们使用容器类的时候，自然更加推荐使用带有泛型的容器类，那么为什么那些不具备泛型的容器类还存在呢？因为早期还有很多遗留代，为了考虑兼容问题，所以才需要保留它们。</p>\n<p>说了这么多，我们来看如何在刚刚的情境中，使用泛型来为我们带来便利与类型安全：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用泛型</span></span><br><span class=\"line\">    List&lt;Apple&gt; apples = <span class=\"keyword\">new</span> ArrayList&lt;Apple&gt;();</span><br><span class=\"line\">    apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">    apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">    apples.add(<span class=\"keyword\">new</span> Banana()); <span class=\"comment\">// 这一句话就会出现编译错误</span></span><br><span class=\"line\">    pareAll(apples);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在Java中，在jdk自带的容器类加上尖括号&lt;&gt;，里面加上我们要明确的类名即可。而在pareAll方法，我们首先修改形参为List\\<Apple> apples，这样一来明确告诉编译器，我传入的是只能装Apple类型对象的List，如此一来，类型的判断就可以不用出现了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">pareAll</span><span class=\"params\">(List&lt;Apple&gt; apples)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先形参改变了，其次for中的类型发生了变化，注意与原来的区分和理解</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Apple a : apples) &#123;</span><br><span class=\"line\">        a.pare();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义泛型类\"><a href=\"#定义泛型类\" class=\"headerlink\" title=\"定义泛型类\"></a>定义泛型类</h4><h5 id=\"定义一般的泛型类\"><a href=\"#定义一般的泛型类\" class=\"headerlink\" title=\"定义一般的泛型类\"></a>定义一般的泛型类</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gen</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T x;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Gen</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就像我们在使用泛型容器一样，在类的后面加上尖括号，并且使用一个合法定义符号，表明Gen是一个泛型类，对于T来说，到底是什么类型，目前还不知道，只有当我需要使用的时候才确定的下来：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：jdk1.7之后类型推断的加入，使得我们可以省略后面的类型定义</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里我明确定义Gen的类型是String</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以当我想要传入一个int类型的数字时，编译会不通过</span></span><br><span class=\"line\">    Gen&lt;String&gt; x = <span class=\"keyword\">new</span> Gen&lt;&gt;(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Gen&lt;String&gt; x = new Gen&lt;&gt;(2); 编译不通过</span></span><br><span class=\"line\">    x.print(); <span class=\"comment\">// 输出“hello”</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"定义有边界的泛型类\"><a href=\"#定义有边界的泛型类\" class=\"headerlink\" title=\"定义有边界的泛型类\"></a>定义有边界的泛型类</h5><p>有的时候，即使是我们想要定义一个泛型的类，但并不意味着我们就想要任何一个类型都可以作为我们想要定义的泛型类的参数，这个时候怎么办？这就需要我们定义起边界，即这个泛型类能容许你能够定义具体的什么类型。首先我们定义三个基础的类：分别为Father、Son、MrWang。Father类是Sun超类，MrWang类与这两个类无关：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MrWang</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>接下来我们定义具有边界的泛型类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法为&lt;泛型符号 extends 已存在类型&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gen</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span>&gt; </span>&#123;</span><br><span class=\"line\">    T x;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Gen</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>于是，我们在使用我们定义的泛型类的时候，就会有所限制了：我们只能定义类型为Father以及Father子类的泛型类，除此之外都不行。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Gen&lt;Son&gt; g1;</span><br><span class=\"line\">    Gen&lt;Father&gt; g2;</span><br><span class=\"line\">    Gen&lt;MrWang&gt; g3; <span class=\"comment\">// 编译出错！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"泛型类的本质\"><a href=\"#泛型类的本质\" class=\"headerlink\" title=\"泛型类的本质\"></a>泛型类的本质</h5><p>在上面我们提到了两种泛型，一种是原始泛型类（\\<T>），另一种是为了对泛型参数进行限制而使用的边界（\\<T extends BorderClass>）；我们通过相关的定义可以知道，泛型只在编译阶段起作用，他只对编译阶段进行类型的限制，从而实现类型安全。实际上，任何的泛型类到运行的时候，都会将其泛型类型<strong>擦除</strong>到边界。对于一般的泛型类来说，在运行阶段会擦除到Object类型为止；而进行限制的使用extends的泛型则会擦除到其边界为止。综合来说就是，一般泛型类与限制了边界的泛型类都可以统一为\\<T extends BorderClass>。只是前者的BorderClass就是Object（因为任何对象都继承自Object），而后者是特定的边界类。再具体一点：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先这里有一个Father类，其定义如下：</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fatherMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Father&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Son继承自Father类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 定义一个有边界的类以及一个没有边界的泛型类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HasBorder</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尽管是泛型T，但是由于制定了边界</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以我们可以确定知道运行时，其类型会擦除到Father类</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以x一定有fatherMethod方法</span></span><br><span class=\"line\">        x.fatherMethod();</span><br><span class=\"line\">        <span class=\"comment\">// 此外还有Object类中的譬如toString、hashCode等方法</span></span><br><span class=\"line\">        x.toString();</span><br><span class=\"line\">        x.hashCode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoBorder</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于没有指定泛型的边界，T在运行时会擦除到Object</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以只能看到Object中的一些方法</span></span><br><span class=\"line\">        x.toString();</span><br><span class=\"line\">        x.hashCode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义泛型方法\"><a href=\"#定义泛型方法\" class=\"headerlink\" title=\"定义泛型方法\"></a>定义泛型方法</h4><p>泛型方法的定义则是在方法的返回值前添加\\<T>来定义的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意&lt;K&gt;是紧跟返回类型的</span></span><br><span class=\"line\">[<span class=\"keyword\">public</span> | ...] [<span class=\"keyword\">static</span>] [<span class=\"keyword\">final</span>] [<span class=\"keyword\">synchronized</span>] &lt;K&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(K x)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回类型同样可以是泛型</span></span><br><span class=\"line\">[<span class=\"keyword\">public</span> | ...] [<span class=\"keyword\">static</span>] [<span class=\"keyword\">final</span>] [<span class=\"keyword\">synchronized</span>] &lt;K&gt; <span class=\"function\">K <span class=\"title\">f</span><span class=\"params\">(K x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>使用泛型方法的时候，我们可以在方法前来定义具体的类型来确定：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.&lt;Apple&gt;f(<span class=\"keyword\">new</span> Apple())</span><br><span class=\"line\"><span class=\"comment\">// 由于类型推到，当我们传入一个Apple对象的时候，Java会为我们自动推导其类型，所以可以省略：</span></span><br><span class=\"line\">obj.f(<span class=\"keyword\">new</span> Apple());</span><br></pre></td></tr></table></figure><br>但是请注意，在一个泛型类中再定义泛型方法，它们是没有联系的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gen</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T x;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Gen</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">f</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">g</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在上面的泛型类中，我们定义了两个方法：f、g，注意前者并没有在返回类型前添加<T>，后者有\\<T>，尽管这两个方法都使用了T这个泛型符号，但是，其含义截然不同。前者的T是跟随泛型类的T来确定的，而后者是根据具体方法来确定的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Gen&lt;Father&gt; gen = <span class=\"keyword\">new</span> Gen&lt;&gt;(<span class=\"keyword\">new</span> Father());</span><br><span class=\"line\">    <span class=\"comment\">// 泛型类中的方法</span></span><br><span class=\"line\">    gen.f(<span class=\"keyword\">new</span> Father());</span><br><span class=\"line\">    <span class=\"comment\">// 泛型方法</span></span><br><span class=\"line\">    gen.g(<span class=\"keyword\">new</span> MrWang());</span><br><span class=\"line\">    <span class=\"comment\">// 互不相关</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"关于-lt-gt-的一二\"><a href=\"#关于-lt-gt-的一二\" class=\"headerlink\" title=\"关于 &lt;?&gt; 的一二\"></a>关于 &lt;?&gt; 的一二</h3><p>\\&lt;?&gt;其实和\\<T>非常的类似，都表示一种不确定性，都是告诉编译器，我现在有一个泛型，但是这个东西的具体类型我不确定到底是什么。但是，它们还是有一定的区别的。首先说一个最基础的，\\&lt;?&gt;无界通配符是不能用做声明泛型类的或者是泛型方法的；而\\<T>可以，不再赘述。<strong>在理解&lt;?&gt;的时候，请暂时不要和\\<T>联系起来，这二者的使用没有必然的联系</strong>! 它们之外的差别这里使用一个情景：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f0</span><span class=\"params\">(List&lt;T&gt; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : lists) &#123;</span><br><span class=\"line\">            System.out.println(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object o = lists.size() &gt; <span class=\"number\">0</span> ? lists.get(<span class=\"number\">0</span>) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        lists.add((T) <span class=\"keyword\">new</span> Object());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(List&lt;?&gt; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : lists) &#123;</span><br><span class=\"line\">            System.out.println(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object o = lists.size() &gt; <span class=\"number\">0</span> ? lists.get(<span class=\"number\">0</span>) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        lists.add(<span class=\"keyword\">new</span> Object()); <span class=\"comment\">// 编译出错！！！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>首先上面的f0方法接收List<T>对象，而f1方法接收List&lt;?&gt;对象。首先我们来看共同点，我们看到两个方法均可以遍历其List中的对象并且上转型为Object类型，当然，这是完全没有问题的，无论你的list中存放的是什么对象，你再不确定，但你始终可以将其上转型为Object类型，因为一切类都继承自Object这个类。</p>\n<p>上面来两个方法的不同点在于，最后一句向lists中添加一个Object对象。首先看f0，这里将Object对象往lists中添加的时候，需要我们转型为T，这里没有问题，因为既然我们定义的这个方法已经告诉了编译器，我们传入的是一个某种类型T的List，自然，往里面的添加的对象必须要上转型为T，否则如果不进行转型，那么任何的类都往里面的添加岂不是违背了类型安全。也许你有些疑问：不是说在运行时候会擦出到边界（这里就是Object），那为什么我添加Object对象都需要类型转换呢？其实不管你添加什么类型的对象，都需要类型转换，其理由在我看来是这样：在使用的泛型<strong>定义</strong>的某些类功能，尤其是添加或获取容器类中的元素，如果在一开始往里面添加的时候类型转换就失败了，肯定可以确定一点，你往里面添加的类是不正确的！是不符合我到时候（真正在使用确定了泛型类型的容器的时候）想要添加的类型的。所以这里强制需要你进行转型，以在添加的时候就保证其类型的安全。</p>\n<p>看完f0，在看f1。f1中最后一句add一个Object对象的时候始终编译不通过，其原因就是&lt;?&gt;无界通配符只告诉编译器，我这里要使用一个带有泛型的List，但是其具体类型我不知道，也不想知道！所以为了保证你到时候使用的时候的多样性（你有可能会传入List\\<String>，也有可能会传入List\\<Integer>），这里我就不支持转型操作了，请你进行一些与类型无关的操作。</p>\n<h4 id=\"关于-lt-extends-SomeClass-gt-与-lt-super-SomeClass-gt-的一二\"><a href=\"#关于-lt-extends-SomeClass-gt-与-lt-super-SomeClass-gt-的一二\" class=\"headerlink\" title=\"关于 &lt;? extends SomeClass&gt; 与 &lt;? super SomeClass&gt; 的一二\"></a>关于 &lt;? extends SomeClass&gt; 与 &lt;? super SomeClass&gt; 的一二</h4><p>在上面实例中我们使用了&lt;?&gt;这样的无界通配符，但是它太宽泛了，甚至可以说它与List无差别。于是，我们需要一种限定方式，来限定我们的容器类的类型有一定的边界。我们首先定义是那个类从上到下依次继承：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Top</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mid</span> <span class=\"keyword\">extends</span> <span class=\"title\">Top</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mid</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>接下来我们定义带有有界通配符的相关参数：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(List&lt;? extends Mid&gt; ls)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> Mid&gt; ls)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>这里解读一下：对于方法f来说，他接受一个List，但是这个List需要满足泛型？必须是extends于Mid，即定义了目标List的泛型的上界是Mid，就是说我们传入的泛型List的其类型必须是Mid的子类；而对于g方法来说，则是必须满足泛型？必须是super于Mid，即定义了其List的泛型的下界是Mid，即我们传入的List的泛型必须是Mid的超类，所有也就有了下面的编译中的细节：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">List&lt;Top&gt; topList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">List&lt;Mid&gt; midList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">List&lt;Bottom&gt; bottomList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">f(list); <span class=\"comment\">// 1、编译出错</span></span><br><span class=\"line\">f(topList); <span class=\"comment\">// 2、编译出错</span></span><br><span class=\"line\">f(midList); <span class=\"comment\">// 3、编译通过</span></span><br><span class=\"line\">f(bottomList); <span class=\"comment\">// 4、编译通过</span></span><br><span class=\"line\">g(list); <span class=\"comment\">// 5、编译通过</span></span><br><span class=\"line\">g(topList); <span class=\"comment\">// 6、编译通过</span></span><br><span class=\"line\">g(midList); <span class=\"comment\">// 7、编译通过</span></span><br><span class=\"line\">g(bottomList); <span class=\"comment\">// 8、编译出错</span></span><br></pre></td></tr></table></figure><br>1与2编译出错的原因很显然就是因为分别不满足 Object extends Mid 和 Top extends Mid；3与4通过编译的原因也就显而易见了（Mid本身是本身的子类）；5、6和7同样满足其对应的类型是Mid的超类（Mid本身也可以是本身的超类），故通过编译，而8中的Bottom不是Mid的超类，故不通过编译。</p>\n<h4 id=\"进阶-lt-extends-T-gt-与-lt-super-T-gt\"><a href=\"#进阶-lt-extends-T-gt-与-lt-super-T-gt\" class=\"headerlink\" title=\"进阶 &lt;? extends T&gt; 与 &lt;? super T&gt;\"></a>进阶 &lt;? extends T&gt; 与 &lt;? super T&gt;</h4><p>在上面的讨论中，我们都是用一个特定的类来限定了？的边界（上面就是Mid类），但是泛型同样适用于此，就像下面：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genF</span><span class=\"params\">(List&lt;? extends T&gt; ls)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genG</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt; ls)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>当我们指定了泛型的类型为特定的类型的时候，比如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericTest.&lt;Mid&gt;genF(midList);</span><br></pre></td></tr></table></figure><br>他其实等同于上面的3中的方法，因为就是直接将对应的泛型替换为具体的类。那么genF方法与genG方法究竟有什么区别呢？答案就是PECS原则。</p>\n<h4 id=\"PECS原则\"><a href=\"#PECS原则\" class=\"headerlink\" title=\"PECS原则\"></a>PECS原则</h4><p>什么是PECS？PECS指“Producer Extends，Consumer Super”。换句话说，如果参数化类型表示一个生产者，就使用&lt;? extends T&gt;；如果它表示一个消费者，就使用&lt;? super T&gt;。</p>\n<p>这里一定要明确一点，我们在使用这两种的时候，通常是在使用容器（绝大多数）；其次，生产者和消费者的概念是针对容器的。怎么理解呢？先用一段代码来表达这个场景：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genF</span><span class=\"params\">(List&lt;? extends T&gt; ls)</span> </span>&#123;</span><br><span class=\"line\">    T o = ls.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们先看PE（Producer Extends）部分，这里我们通过方法，可以知道，我们定义了一个genF方法，接收一个泛型List，其具体类型我们还不知道，但至少可以确定的是，它的上界是T，也就是说，我传入的List中的存放的对象一定是T的子类，由于如此，我可以在这个方法中，定义T类型的对象，然后从List中取得对象，由于上面的描述，我们一定可以确定，无论你传入的List去具体的类型到底是什么，但一定可以上转型为T，这里List是一个生产者（Producer），它生产出来的（get(0)）的对象（某个类型，但一定是T的子类），一定可以传给T的引用（上转型）。这就是PE部分。</p>\n<p>而CS（Consumer Super）也很好理解，下面的代码不够严谨，但是可以让我们清楚其中的意义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genG</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt; ls)</span> </span>&#123;</span><br><span class=\"line\">    ls.add((T)<span class=\"keyword\">new</span> Object());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的方法接收一个List&lt;? super T&gt;参数，意味着，ls虽然我不知道到底会有什么样的类型的List传入，但是我一定知道，这个类型一定是T类型的超类，也就是说，ls.add方法能够存放的对象，是某个类型，而这个类型是T的超类（或本身），那么，T类型的对象我一定能够放进去（通过上转型到“？”，而这个“？”到底是什么我不知道，只知道是T的超类，T当然能够上转型到T的某个超类）。这里的List就是一个消费者，它消费（add）T类型，凭什么能够add，因为ls本身的类型是T的超类。</p>\n<h5 id=\"最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除\"><a href=\"#最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除\" class=\"headerlink\" title=\"最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除\"></a>最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除</h5>","categories":[],"tags":["Java","generic"]},{"title":"Scala trait特质 深入理解","url":"http://compilemind.com/2018/04/24/2018-04-24-Scala trait特质 深入理解/","content":"<h3 id=\"初探Scala-特质trait\"><a href=\"#初探Scala-特质trait\" class=\"headerlink\" title=\"初探Scala 特质trait\"></a>初探Scala 特质trait</h3><p>在Scala中，trait（特质）关键字有着举足轻重的作用。就像在Java中一样，我们只能在Scala中通过extends进行单一继承，但trait可以让我们从语义上实现了多重继承。通过对继承的类混入（mixin）多个特质，来达到多重继承的目的。乍一看，trait和Java中的interface接口很像，但是，细节上它们又有着大不同。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义超类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Super</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">定义特质</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">trait</span> <span class=\"title\">Trait</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">定义子类，将特质使用with关键字混入</span> <span class=\"title\">Super</span> <span class=\"title\">类，并继承之</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Super</span> <span class=\"keyword\">with</span> <span class=\"title\">Trait</span></span></span><br></pre></td></tr></table></figure>\n<p>请务必体会上面的最后一条注释，早期学习的时候，我们往往容易将特质理解为Java中的接口，同时将with理解为Java中的implements，于是我们编写出如下的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">with</span> <span class=\"title\">T</span> // 错误✖️</span></span><br></pre></td></tr></table></figure><br>这样想是因为我们没有正确理解特质，特质是对我们要<strong>被继承</strong>的类的补充，是要混入我们要继承的类的，不是我们本身类！即我们要明确，对于混入特质的子类定义，其实整体分为两个部分：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ class A ] extends [ S with T1 with T2 ...] </span><br></pre></td></tr></table></figure><br>中括号的表示两个部分才是正确的结构！</p>\n<p>此外，与Java中的接口相比，我们还能够在特质中直接实现完整的方法，就像如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 1&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在Java8以前我们无法在接口中定义并实现完整的方法，而在Java8及以后我们可以通过default关键字来后面接完整的方法来实现。</p>\n<p>现在，我们定义两个如下的特质：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 1&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 2&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>之后，我们定义一个名为Bottom的类，继承Scala中的Any类，同时混入上面定义的特质<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Any</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">/*</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">这里的Any是scala中的特殊对象</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">这里使用Any会报错</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Error</span></span>:(<span class=\"number\">16</span>, <span class=\"number\">31</span>) illegal inheritance; superclass <span class=\"type\">Any</span></span><br><span class=\"line\"> is not a subclass of the superclass <span class=\"type\">Object</span></span><br><span class=\"line\"> of the mixin <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid2</span></span></span><br><span class=\"line\"><span class=\"class\">...</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">*/</span></span></span><br></pre></td></tr></table></figure><br>“超类Any不是混入特质TrMid2的超类Object的子类”，即我们extends的类需要是Object的子类才行。面对上面的错误，我们可以将Any修改为AnyRef，这个类是scala内建类，本质上对应Java中的java.lang.Object类。修改之后，编译还是会报错：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">AnyRef</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span></span></span><br><span class=\"line\"><span class=\"class\">...</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">/*</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Error</span></span>:(<span class=\"number\">16</span>, <span class=\"number\">7</span>) <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"title\">inherits</span> <span class=\"title\">conflicting</span> <span class=\"title\">members</span></span>:</span><br><span class=\"line\">  method f in <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid2</span> <span class=\"title\">of</span> <span class=\"title\">type</span> <span class=\"title\">=&gt;</span> <span class=\"title\">Unit</span>  <span class=\"title\">and</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">method</span> <span class=\"title\">f</span> <span class=\"title\">in</span> <span class=\"title\">trait</span> <span class=\"title\">TrMid1</span> <span class=\"title\">of</span> <span class=\"title\">type</span> <span class=\"title\">=&gt;</span> <span class=\"title\">Unit</span></span></span><br><span class=\"line\"><span class=\"class\">(<span class=\"params\"><span class=\"type\">Note</span>: this can be resolved by declaring an override in class <span class=\"type\">Bottom</span>.</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">AnyRef</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> </span>&#123;</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure><br>这个错误提示我们在上面的两个特质中，均定义了相同签名的方法f，这里编译不通过，建议我们在Bottom类中实现f方法。换言之，当混入的多个特质中，分别定义了同名的方法，那么Scala会编译报错。在Java中也有类似的错误情形，下面就是关于Java，当然你可以跳过这一部分</p>\n<hr>\n<h4 id=\"Java接口中的同名方法\"><a href=\"#Java接口中的同名方法\" class=\"headerlink\" title=\"Java接口中的同名方法\"></a>Java接口中的同名方法</h4><p>以上的讨论，务必与Java中区分开来，这里需要补充一下。在Java中，首先由于我们无法进行多重继承，我们只能编写形如这样的class AA extends BB implements CC, DD这样的代码，想要建立像上面的测试情形，我们还只能使用JDK8之后的能够在接口中使用default关键字来定义具有具体实现的方法，最终我们的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [abstract] 为可选</span></span><br><span class=\"line\">[<span class=\"keyword\">abstract</span>] <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BB</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;In BB&#x27;s f()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// JDK8及以后的default关键字</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;In CC&#x27;s f()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AA</span> <span class=\"keyword\">extends</span> <span class=\"title\">BB</span> <span class=\"keyword\">implements</span> <span class=\"title\">CC</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对比验证类，保证我们接口中的方法没问题</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZZ</span> <span class=\"keyword\">implements</span> <span class=\"title\">CC</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> AA().f();</span><br><span class=\"line\">        <span class=\"comment\">// In BB&#x27;s f()</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ZZ().f();</span><br><span class=\"line\">        <span class=\"comment\">// In CC&#x27;s f()，接口方法是没有问题的</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>根据上面的区别，我们首先确定是类似这样的class AA extends BB implements CC，同时BB，CC有同名的方法，Java中首先（只会？）找类中的实现。可能你有疑惑了，为什么不能够让多个接口都创建同名的默认方法，让一个类来实现它们，调用同名方法，就想这样：class AA implements CC, DD，遗憾的是（高兴的是？），当你这样做的时候，Java编译期就给你报错了啦！<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;In CC&#x27;s f()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DD</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;In DD&#x27;s f()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AA</span> <span class=\"keyword\">implements</span> <span class=\"title\">CC</span>, <span class=\"title\">DD</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译就会报错</span></span><br><span class=\"line\"><span class=\"comment\">// Error:(25, 1) java: 类 AA从类型 CC 和 DD 中继承了f() 的不相关默认值</span></span><br></pre></td></tr></table></figure><br>要解决这个错误，要么，让其中一个接口中的同名方法改名，要么，实现类重写这个方法。</p>\n<hr>\n<h4 id=\"继续Scala特质的讨论\"><a href=\"#继续Scala特质的讨论\" class=\"headerlink\" title=\"继续Scala特质的讨论\"></a>继续Scala特质的讨论</h4><p>上面的关于同名方法的报错曾提示我们，在底层类重写实现Bottom中的f方法。这是办法之一。但是，我们还有另一种方式。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先我们定义一个顶层的抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbTop</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 让TrMid1、TrMid2均继承AbTop这个顶层抽象类，同时均重写抽象类中的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid1</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbTop</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 1&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid2</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbTop</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 2&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Bottom类继承AbTop类并混入上面定义的两个特质</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbTop</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 进行测试</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">TraitTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> top: <span class=\"type\">Bottom</span> = <span class=\"keyword\">new</span> <span class=\"type\">Bottom</span></span><br><span class=\"line\">    top.f</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们编译运行这段程序，得到了如下的结果：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">In</span> <span class=\"type\">TrMid</span> <span class=\"number\">2</span><span class=\"symbol\">&#x27;s</span> f.</span><br></pre></td></tr></table></figure><br>首先我们可以确定，我们按照上面的类层级结构混入了两个带有同名方法f的特质，并没有像上面那样出现二义性错误；为什么会这样？让我们再次理解这一段话“特质是对我们要<strong>被继承</strong>的类的补充，是要混入我们要继承的类的，不是我们本身类”。也就是说，报错的那个二义性，是由于我们想要将两个同名的f方法混入AnyRef这个类中，然而，我们没有override关键字（也无法加上），那么混入过程只是单纯的向AnyRef类中添加两个签名一样的方法f，而语法上我们无法向同一个类中添加连个签名完全一样的方法，故报错；解决方法就是在我们的子类中override这个f方法，重写覆盖它，消除二选一。</p>\n<p>而后者，我们能够编译运行还是像上面这样理解，由于我们是要向AbTop这个类中去混入特质，而我们每一个特质都是继承了AbTop类的，故我们应当重写覆盖顶层抽象类中的f方法，所以，在混入的过程中，从左到右每混入一次，他就加上一层外壳，所以这就是为什么，输出的结果是打印的第二个特质中f方法的输出，因为逐渐混入加壳的过程是从左到右的，先对AbTop加了壳，混入TrMid1特质，然后又对这一个结构加壳过程，混入TrMid2特质，就像下图：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/wrap.png\" alt=\"wrap\"><br>这样一来，不难理解混入特质的过程（加壳的过程）本身就像一个一层一层继承的过程。还是上面那段带有AbTop的代码中，这一次我们添加一个新的抽象类AbNewTop，但是其中包含一个抽象方法其名称依然为f，然我们修改Bottom的定义：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbNewTop</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbNewTop</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> </span>&#123;&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>注意我们让Bottom不再继承AbTop，而是继承新定义的AbNewTop，其他诸如TrMid1依然继承的是AbTop不变。让我们运行代码，报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:(19, 36) illegal inheritance; superclass AbNewTop</span><br><span class=\"line\"> is not a subclass of the superclass AbTop</span><br><span class=\"line\"> of the mixin trait TrMid2</span><br><span class=\"line\">class Bottom extends AbNewTop with TrMid2 with TrMid1 &#123;</span><br></pre></td></tr></table></figure><br>英语有点绕口，我们这里翻译并分割一下：“非法的继承；<em>超类AbNewTop</em> 不是 混入特质的TrMid2的 <em>超类AbTop</em> 的子类”。再次对应这个结构：[ class A ] extends [ S with T1 with T2 …] 那么错误就在与后面的 S 与 T1、T2 对应不上了，及要实现正确的混入，S必须是T1、T2的超类的子类，当然，隐含的，本身也可以。转化为类图应该要满足如下的情形：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/class_map.png\" alt=\"class_map\"><br>可能有些人有疑惑，为什么特质不继承自任何其他的类的时候，依然可以被混入到其他的类中，就像如下的形式：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">T1</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> <span class=\"keyword\">with</span> <span class=\"title\">T1</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>因为在Scala任何的非值类（或特质）有默认的继承了scala.AnyRef类！这里的类图是如下的情形：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/animal_class.png\" alt=\"animal_class\"></p>\n<h3 id=\"使用特质来做可堆叠的改动——过滤\"><a href=\"#使用特质来做可堆叠的改动——过滤\" class=\"headerlink\" title=\"使用特质来做可堆叠的改动——过滤\"></a>使用特质来做可堆叠的改动——过滤</h3><p>试想一种情形：现在有一个客户需要我们编写一种整形数字容器，这个容器的类似于Java中的List，我们可以往里面去添加数据，但是添加数据的过程是可过滤的，或者说可按条件进行预处理的。首先我们定义一个Container类：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span>  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> list: util.<span class=\"type\">ArrayList</span>[<span class=\"type\">Int</span>] = <span class=\"keyword\">new</span> util.<span class=\"type\">ArrayList</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(n: <span class=\"type\">Int</span>): <span class=\"type\">Unit</span> = list.add(n)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span></span>(idx: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> = list.get(idx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>目前为止，这个类似乎没什么特殊之处，甚至可以说是多此一举 —— 定义Container类的结构还不如直接使用一个util.ArrayList来的快。但是，试想一个场景，我现在要在添加之前 想要 首先检查这个是是否是偶数，如果不是，直接丢弃；如果是，则除以2再加入到容器中。如果仅仅使用现在的版本，你可能会直接在Container.add方法中去进行筛选，就像如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractContainer</span> </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(n: <span class=\"type\">Int</span>): <span class=\"type\">Unit</span> = <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) list.add(n / <span class=\"number\">2</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>诚然，这段简单的代码的确能工作的很好。但是每一次的我改变规则，你难道就要在这个add代码中进行修改吗？亦或者假设这个类的源码根本就无法修改。你又如何操作？于是，使用特质来堆叠能够发挥作用：<br>首先我们还原add代码为最初始的状态，然后，我们定义如下的两个特质，并且定义我们的MyContainer类继承Container类并混入这两个特质：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Even</span> <span class=\"keyword\">extends</span> <span class=\"title\">Container</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x: <span class=\"type\">Int</span>): <span class=\"type\">Unit</span> = <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">super</span>.add(x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Divide</span> <span class=\"keyword\">extends</span> <span class=\"title\">Container</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x: <span class=\"type\">Int</span>): <span class=\"type\">Unit</span> = <span class=\"keyword\">super</span>.add(x / <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Container</span> <span class=\"keyword\">with</span> <span class=\"title\">Divide</span> <span class=\"keyword\">with</span> <span class=\"title\">Even</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">测试这段代码</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">object</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> myContainer = <span class=\"keyword\">new</span> <span class=\"type\">MyContainer</span></span><br><span class=\"line\">    myContainer.add(<span class=\"number\">1</span>)</span><br><span class=\"line\">    myContainer.add(<span class=\"number\">6</span>)</span><br><span class=\"line\">    println(myContainer.get(<span class=\"number\">0</span>)) <span class=\"comment\">// 输出3</span></span><br><span class=\"line\">    <span class=\"comment\">// println(myContainer.get(1)) // 超出边界</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在前面的讨论中我们知道，如果是一个类混入了多个特质，这多个特质含有同名的方法，会从左到右包装出来，即最终调用的是靠近右侧的实现了的方法。首先要实现筛选偶数，再除以2，最终添加到容器中。所以最先发挥作用的Even特质放在了最右侧。为什么这里，不仅能够筛选出偶数，同时还能除以2呢？答案就在super这个关键点。super.add即调用超类的add方法。这里再次用图来说明：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/evendivide.png\" alt=\"evendivide\"><br>我想这个图足以说明了吧。调用过程就是先调用最右侧的Even.add方法，进行偶数筛选；然后调用超类super.add(x)；超类即从右到左开始Even左侧是Divide，Divide.add(x)，Divide.add内部对x除以2，传入super.add()方法，即再次向左侧，是Container.add()，此时接收到的数已经是除以2的数了：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/flow.png\" alt=\"flow\"><br>还有一种情况是更为复杂的：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In A&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;In B&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.f</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;In C&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.f</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> <span class=\"keyword\">with</span> <span class=\"title\">C</span></span></span><br></pre></td></tr></table></figure><br>关系图对应如下：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/classrelation.png\" alt=\"classrelation\"><br>输出：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> t: <span class=\"type\">T</span> = <span class=\"keyword\">new</span> <span class=\"type\">T</span></span><br><span class=\"line\">    t.f</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"type\">In</span> <span class=\"type\">C</span></span><br><span class=\"line\"><span class=\"type\">In</span> <span class=\"type\">B</span></span><br><span class=\"line\"><span class=\"type\">In</span> <span class=\"type\">A</span></span><br></pre></td></tr></table></figure><br>看到输出，再根据前面的内容，我们也很容易理解，当某一个特质本生继承了其他的类的时候，super一定是其对应的超类，而不是class AA extends BB with TT中的BB这个类！</p>\n","categories":[],"tags":["Scala","trait"]},{"title":"Linux下iptables学习笔记","url":"http://compilemind.com/2018/04/18/2018-04-18-Linux下iptables笔记/","content":"<p>在Centos7版本之后，防火墙应用已经由从前的iptables转变为firewall这款应用了。但是，当今绝大多数的Linux版本（特别是企业中）还是使用的6.x以下的Centos版本，所以对iptables的了解还是很有必要的。此外，需要说明的是iptables自身并不具备防火墙的功能，它需要通过内核netfilter（网络过滤器）来实现，与firewalld一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结构以及使用方法不一样，他们都只是一个外壳应用罢了。打个比方，就好像有一本书，同样的内容，一种是纸质的，另一种是电子的，我们翻阅它的方式不同，给它做笔记的方式不同，但是内容（内核）一样。</p>\n<a id=\"more\"></a>\n<h3 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h3><p><strong>iptables概念</strong></p>\n<p>iptables中的规则（rule）。在我看来，规则是iptables中进行数据包检查的基本单元。每一条规则都定义了对于数据包的条件验证，譬如网络地址的验证、端口验证、协议验证等。</p>\n<p>iptables中的链（chain）。链是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。就像这里，我们有一个INPUT链（INPUT概念之后再作解释），数据包来到这条链时，就会根据该链中的规则进行检查，譬如源、目的地址是否符合规则；源、目的端口是否符合规则等等。当一个数据包到达一个<strong>链</strong>时，iptables就会从INPUT链中规则1开始检查，看该数据包是否满足规则所定义的条件——如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则2，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/inputchain.png\" alt=\"inputchain\"></p>\n<p>iptables中的表（table）。表是一组链的集合，在iptables中默认定义了四张表：filter、nat、mangle和raw，分别用于实现包过滤（最常用去配置的表），网络地址转换、包重构(修改)和数据跟踪处理。如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/alltables.png\" alt=\"alltables\"><br>当然，上图只是一个大致示意，并不意味着每个表中的例如想PREROUTING这样的链是独自在各个表中的，实际上表与链之间是一种交叉的关系，为什么这么说呢？这需要我们理解在iptables中传输数据包的流程（请结合下图慢慢阅读）。<br>（1）当一个数据包进入网卡时，它首先进入PREROUTING链，根据该链中的规则判定数据包的处理方式（ACCEPT？DROP？REJECT？），一旦通过规则检测，Linux内核根据数据包的IP地址决定是将数据包留下传入进入内部，还是转发出去。<br>1）如果数据包就是进入本机的（IP地址表明），它就会到达INPUT链。数据包到了INPUT链后，便开始根据INPUT链中的规则来检查数据包是否满足一系列的条件，满足之后，完全进入主机，任何进程都会收到它。同时，主机中的任何程序都可以发送数据包，发送出来的数据包会走到OUTPUT链，再根据里面的规则判定处理，最后到POSTROUTING链，再判定处理。<br>2）如果数据包是准备转发的，他就会到达FORWARD链，再根据FORWARD链中的规则进行检查判定决定接下来的处理。如果通过了FORWARD链，说明内核允许该数据包转发，那么数据包就会到POSTROUTING链进行最后的判断。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/flow.png\" alt=\"flow\"><br>同时我们可以看到，这里的角度并不是以table来看的，而是以chain来看的，这就是为什么我在上面提到的，尽管table是chain的集合，但并不意味着当我们定义防火墙的时候是按照table角度来定义，而是要根据chain角度来定义。我们要根据上图来决定我们要在何处怎样处理进入的数据包。这个flow在我看来必须要非常熟悉，对之后的命令行配置也有很大的帮助，因为iptables的命令行配置十分复杂。</p>\n<h4 id=\"iptables命令行配置\"><a href=\"#iptables命令行配置\" class=\"headerlink\" title=\"iptables命令行配置\"></a>iptables命令行配置</h4><p>iptables的命令格式如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables [-t table] COMMAND chain rules [-j action]</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> table 表名</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> chain 链名</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rules 规则</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> action 动作</span></span><br></pre></td></tr></table></figure><br><strong>table</strong> </p>\n<p>表选项用于指定命令要作用于哪一个表（raw、mangle、nat、filter）</p>\n<p><strong>COMMAND</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、对某一条的整条链进行管理的命令</span><br><span class=\"line\">-P或–policy &lt;链名&gt; 定义默认策略</span><br><span class=\"line\">  设置默认策略的（设定默认门是关着的还是开着的）</span><br><span class=\"line\">  默认策略一般只有两种（DROP 关闭 | ACCEPT 打开 ）</span><br><span class=\"line\">  比如：</span><br><span class=\"line\">  iptables -P INPUT DROP </span><br><span class=\"line\">  这条命令就是我们将INPUT链默认的策略设置为关闭，即所有的想要进入我们主机的连接全部被拒绝。</span><br><span class=\"line\">-F或-flush &lt;链名&gt; 清空某个表中的某条链中的所有规则</span><br><span class=\"line\">  比如：</span><br><span class=\"line\">  iptables -t filter -F INPUT # 清空filter表中的INPUT链中的所有规则</span><br><span class=\"line\">  iptables -t filter -F # 清空filter表中的所有链的所有规则</span><br><span class=\"line\">-Z或–zero &lt;链名&gt; 将表中数据包计数器和流量计数器归零</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">2、对某一条链的具体规则进行相关的定义</span><br><span class=\"line\">-A或—append &lt;链名&gt; 追加，在当前链的最后新增一个规则</span><br><span class=\"line\">-I或–insert num &lt;链名&gt; 在指定的num位置插入1条规则</span><br><span class=\"line\">-D或–delete num &lt;链名&gt; 从规则列表中删除第num条规则</span><br><span class=\"line\">-R或–replace num &lt;链名&gt; 替换规则列表中的第num条规则</span><br><span class=\"line\"></span><br><span class=\"line\">3、查看管理命令 “-L”</span><br><span class=\"line\">-L或–list &lt;链名&gt; 查看iptables规则列表</span><br><span class=\"line\">附加命令</span><br><span class=\"line\">  -n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名。</span><br><span class=\"line\">  -v：显示详细信息</span><br><span class=\"line\">  -vv</span><br><span class=\"line\">  -vvv :越多越详细</span><br><span class=\"line\">  -x：在计数器上显示精确值，不做单位换算</span><br><span class=\"line\">  --line-numbers : 显示规则的行号</span><br><span class=\"line\">  -t nat：显示所有的关卡的信息</span><br></pre></td></tr></table></figure><br><strong>rules</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i或–in-interface &lt;网络接口名&gt; 指定数据包从哪个网络接口进入，如ppp0、eth0和eth1等</span><br><span class=\"line\">-o或–out-interface &lt;网络接口名&gt; 指定数据包从哪块网络接口输出，如ppp0、eth0和eth1等</span><br><span class=\"line\">-p或—proto协议类型 &lt;协议类型&gt; 指定数据包匹配的协议，如TCP、UDP和ICMP等</span><br><span class=\"line\">-s或–source &lt;源地址或子网&gt; 指定数据包匹配的源地址</span><br><span class=\"line\">–sport &lt;源端口号&gt; 指定数据包匹配的源端口号，可以使用“起始端口号:结束端口号”的格式指定一个范围的端口</span><br><span class=\"line\">-d或–destination &lt;目标地址或子网&gt; 指定数据包匹配的目标地址</span><br><span class=\"line\">–dport目标端口号 指定数据包匹配的目标端口号，可以使用“起始端口号:结束端口号”的格式指定一个范围的端口</span><br></pre></td></tr></table></figure><br><strong>action</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 主要的action有如下的几个</span><br><span class=\"line\">ACCEPT 接受数据包</span><br><span class=\"line\">DROP 丢弃数据包（只丢弃，不作回应，与下面的REJECT不一样）</span><br><span class=\"line\">REJECT 明确的拒绝，还向发送者返回错误信息。</span><br><span class=\"line\">SNAT 源地址转换，即改变数据包的源地址</span><br><span class=\"line\">DNAT 目标地址转换，即改变数据包的目的地址</span><br><span class=\"line\">REDIRECT：重定向，主要用于实现端口重定向</span><br><span class=\"line\">MASQUERADE IP伪装，即是常说的NAT技术</span><br><span class=\"line\">LOG 日志功能，将符合规则的数据包的相关信息记录在日志中，以便管理员的分析和排错</span><br></pre></td></tr></table></figure><br>这里大致整理一下iptables命令的格式：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/fullformat.png\" alt=\"fullformat\"></p>\n<p>接下来详细的讲解一下实际使用命令的要点：</p>\n<p><strong>1、定义默认策略</strong></p>\n<p>什么叫默认策略？可以试想这样的场景，首先结合上面的当一个数据包到达链的时候，会根据链中定义的规则进行处理，但是很显然，我们没法对任何一种数据包的处理方式都定义在规则中，当我们的数据包进入链的时候，如果不满足所有规则的进入条件，那么我们起码要有一种默认的策略方式来处理这个数据包。这个定义默认策略就是这个作用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables [-t表名] &lt;-P&gt; &lt;链名&gt; &lt;动作&gt; </span><br><span class=\"line\">参数说明如下。</span><br><span class=\"line\">[-t表名]：指默认策略将应用于哪个表，可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认使用filter表。</span><br><span class=\"line\">&lt;-P&gt;：定义默认策略。</span><br><span class=\"line\">&lt;链名&gt;：指默认策略将应用于哪个链，可以使用INPUT、OUTPUT、FORWARD、PREROUTING、OUTPUT和POSTROUTING。</span><br><span class=\"line\">&lt;动作&gt;：处理数据包的动作，可以使用ACCEPT（接受数据包）和DROP（丢弃数据包）。</span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/defaultPolicy.png\" alt=\"defaultPolicy\"><br><strong>2、增加、插入、删除和替换规则</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">相关规则定义的格式为：</span><br><span class=\"line\">iptables [-t表名] &lt;-A | I | R | D&gt; 链名 [规则编号] [-i | o 网卡名称] [-p 协议类型] [-s 源IP地址 | 源子网] [--sport 源端口号] [-d 目标IP地址 | 目标子网] [--dport目标端口号] &lt;-j动作&gt;</span><br><span class=\"line\">参数说明如下。</span><br><span class=\"line\">[-t表名]：定义默认策略将应用于哪个表，可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认使用filter表。</span><br><span class=\"line\">-A：新增加一条规则，该规则将会增加到规则列表的最后一行，该参数不能使用规则编号。</span><br><span class=\"line\">-I：插入一条规则，原本该位置上的规则将会往后顺序移动，如果没有指定规则编号，则在第一条规则前插入。</span><br><span class=\"line\">-R：替换某条规则，规则被替换并不会改变顺序，必须要指定替换的规则编号。</span><br><span class=\"line\">-D：从规则列表中删除一条规则，可以输入完整规则，或直接指定规则编号加以删除。</span><br><span class=\"line\">&lt;链名&gt;：指定查看指定表中哪个链的规则列表，可以使用INPUT、OUTPUT、FORWARD、PREROUTING、OUTPUT和POSTROUTING。</span><br><span class=\"line\">[规则编号]：规则编号用于插入、删除和替换规则时用，编号是按照规则列表的顺序排列，规则列表中第一条规则的编号为1。</span><br><span class=\"line\">[-i | o 网卡名称]：i是指定数据包从哪块网卡进入，o是指定数据包从哪块网卡输出。网卡名称可以使用ppp0、eth0和eth1等(注意CentOS6.x与7.x网卡命名区别)。</span><br><span class=\"line\">[-p 协议类型]：可以指定规则应用的协议，包含TCP、UDP和ICMP等。</span><br><span class=\"line\">[-s 源IP地址 | 源子网]：源主机的IP地址或子网地址。</span><br><span class=\"line\">[--sport 源端口号]：数据包的IP的源端口号。</span><br><span class=\"line\">[-d目标IP地址 | 目标子网]：目标主机的IP地址或子网地址。</span><br><span class=\"line\">[--dport目标端口号]：数据包的IP的目标端口号。</span><br><span class=\"line\">&lt;-j动作&gt;：处理数据包的动作，各个动作的详细说明可以参考前面的说明。</span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/modifyRule.png\" alt=\"modifyRule\"></p>\n<p><strong>3、查看iptables规则</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看iptables规则的命令格式为：</span><br><span class=\"line\">iptables [-t表名] &lt;-L&gt; [链名]</span><br><span class=\"line\">参数说明如下。</span><br><span class=\"line\">[-t表名]：指查看哪个表的规则列表，表名用可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认查看filter表的规则列表。</span><br><span class=\"line\">&lt;-L&gt;：查看指定表和指定链的规则列表。</span><br><span class=\"line\">[链名]：指查看指定表中哪个链的规则列表，可以使用INPUT、OUTPUT、FORWARD、PREROUTING、OUTPUT和POSTROUTING，如果不指明哪个链，则将查看某个表中所有链的规则列表。</span><br></pre></td></tr></table></figure><br>由于这个命令比较简单，就不贴图了。</p>\n<p><strong>4、清除规则和计数器</strong></p>\n<p>在新建规则时，往往需要清除原有的、旧的规则，以免它们影响新设定的规则。如果规则比较多，一条条删除就会十分麻烦，这时可以使用iptables提供的清除规则参数达到快速删除所有的规则的目的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义参数的格式为：</span><br><span class=\"line\">iptables [-t表名] &lt;-F | Z&gt;</span><br><span class=\"line\">参数说明如下。</span><br><span class=\"line\">[-t表名]：指定默认策略将应用于哪个表，可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认使用filter表。</span><br><span class=\"line\">-F：删除指定表中所有规则。</span><br><span class=\"line\">-Z：将指定表中的数据包计数器和流量计数器归零。</span><br></pre></td></tr></table></figure><br>同上，由于这个命令比较简单，就不贴图了。</p>\n<p>当然，我们只看命令格式是枯燥的，这里我们使用一些实例来结合命令，使我们更加直观的理解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">禁止客户机访问某个网站或者某个IP地址</span><br><span class=\"line\">【例1】添加iptables规则禁止用户访问域名为www.xxx.com的网站。</span><br><span class=\"line\">iptables &lt;-A | I&gt; FORWARD -d www.xxx.com -j DROP</span><br><span class=\"line\">【例2】添加iptables规则禁止用户访问IP地址为xxx.xxx.xxx.xxx的网站。</span><br><span class=\"line\">iptables &lt;-A | I&gt; FORWARD -d xxx.xxx.xxx.xxx -j DROP</span><br></pre></td></tr></table></figure>\n<p>解析：首先我们可以确定是需要添加或者是插入一条我们的规则，所以使用&lt;-A | I&gt;；由于这里的拓扑是客户机连接我们的Linux服务器，客户机访问某一个网站，数据包到我们这里并不进入我们主机内部，而是经过转发FORWARD，所以我们要给FORWARD链插入或添加规则；由于指定了目标IP或域名，所以使用 -d 参数，又因为是禁止访问，所以 -j 之后的操作我们使用DROP。</p>\n<p>总结：这条命令告诉防火墙，我们现在添加了一条规则在默认的filter表中的FORWARD链，其规则为如果数据包到我们目前这个Linux服务器时，是要准备转发访问IP或域名为XXX的目标（-d），那么我们禁止它访问（DROP）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">禁止某些客户机上网</span><br><span class=\"line\">【例1】添加iptables规则禁止IP地址为192.168.1.X的客户机上网。</span><br><span class=\"line\">iptables &lt;-A | I&gt; FORWARD -s 192.168.1.X -j DROP</span><br><span class=\"line\">【例2】添加iptables规则禁止192.168.1.0子网里所有的客户机上网。</span><br><span class=\"line\">iptables &lt;-A | I&gt; FORWARD -s 192.168.1.0&#x2F;24 -j DROP</span><br></pre></td></tr></table></figure>\n<p>解析：同上的拓扑一样，客户机连接我们的Linux服务器，我们的Linux服务器是要准备做转发服务器，替我们的客户机去访问资源。所以还是对FORWARD链添加或者插入规则；但是这一次我们是要准备禁止某个IP地址的客户机上网，或者是某一子网下所有的客户机上网，也就是说，只要数据包的源IP地址或者是源子网下的我们都要禁止，所以这里采用 -s 参数。后面 -j 接DROP代表我们要丢弃来自这些源地址的数据包</p>\n<p>总结：这条命令告诉防火墙，我们现在添加了一条规则在默认的filter表中的FORWARD链，其规则为如果客户机的数据包到我们的服务器了，如果其源地址是xxx或者是某个子网下的地址，那么我们禁止转发他。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">禁止客户机访问某些服务</span><br><span class=\"line\">【例1】禁止192.168.1.0子网里所有的客户机使用FTP协议下载。</span><br><span class=\"line\">iptables -I FORWARD -s 192.168.1.0&#x2F;24 -p tcp –dport 21 -j DROP</span><br><span class=\"line\">【例2】禁止192.168.1.0子网里所有的客户机使用Telnet协议连接远程计算机。</span><br><span class=\"line\">iptables -I FORWARD -s 192.168.1.0&#x2F;24 -p tcp –dport 23 -j DROP</span><br></pre></td></tr></table></figure>\n<p>解析：以例1为例，首先我们要知道FTP协议使用的是TCP下默认21号端口。禁止192.168.1.0子网里所有的客户机使用FTP协议下载，首先还是转发的地方进行限定所以要在FORWARD链添加规则，源地址为192.168.1.0/24这个子网下的所有客户机，协议使用的是TCP，目的端口为21号。后面 -j 接DROP代表我我们要丢弃满足上述规则的数据包。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">强制访问指定的站点</span><br><span class=\"line\">【例】强制所有的客户机访问192.168.1.x这台Web服务器。</span><br><span class=\"line\">iptables -t nat -I PREROUTING -i eth0 -p tcp –dport 80 -j DNAT –to-destination 192.168.1.x:80</span><br><span class=\"line\"></span><br><span class=\"line\">禁止使用ICMP协议</span><br><span class=\"line\">【例】禁止Internet上的计算机通过ICMP协议ping到NAT服务器的ppp0接口，但允许内网的客户机通过ICMP协议ping的计算机。</span><br><span class=\"line\">iptables -I INPUT -i ppp0 -p icmp -j DROP</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"补充学习-NAT类型\"><a href=\"#补充学习-NAT类型\" class=\"headerlink\" title=\"[补充学习]NAT类型\"></a>[补充学习]NAT类型</h3><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。</p>\n<p>这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。</p>\n<p>另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。</p>\n<p>静态NAT(Static NAT)<br>静态NAT设置起来最为简单和最容易实现的一种，内部网络中的每个主机都被永久映射成外部网络中的某个合法的地址。</p>\n<p>动态地址NAT(Pooled NAT)<br>动态地址NAT是在外部网络中定义了一系列的合法地址，采用动态分配的方法映射到内部网络。<br>动态地址NAT只是转换IP地址，它为每一个内部的IP地址分配一个临时的外部IP地址，主要应用于拨号，对于频繁的远程联接也可以采用动态NAT。</p>\n<p>网络地址端口转换NAPT（Port－Level NAT）<br>NAPT是把内部地址映射到外部网络的一个IP地址的不同端口上。<br>最熟悉的一种转换方式。NAPT普遍应用于接入设备中，它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的TCP端口号。</p>\n<h3 id=\"了解-在Centos7-x上卸载firewalld，安装iptables\"><a href=\"#了解-在Centos7-x上卸载firewalld，安装iptables\" class=\"headerlink\" title=\"[了解]在Centos7.x上卸载firewalld，安装iptables\"></a>[了解]在Centos7.x上卸载firewalld，安装iptables</h3><p>由于CentOS7.x开始，防火墙应用已经不实用iptables，而是使用firewalld了。其应用的管理理念与iptables有着很大的区别。鉴于你确实可能不想用firewalld而是习惯使用iptables，这里提供相关的操作方式来卸载firewalld安装iptables。</p>\n<h4 id=\"安装iptables、iptables-service\"><a href=\"#安装iptables、iptables-service\" class=\"headerlink\" title=\"安装iptables、iptables-service\"></a>安装iptables、iptables-service</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先检查是否安装了iptables</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl status iptables.service</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装iptables</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install -y iptables</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 升级iptables（安装的最新版本则不需要）</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum update iptables </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装iptables-services</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install iptables-services <span class=\"comment\"># service!s!</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"禁用-停止自带的firewalld服务\"><a href=\"#禁用-停止自带的firewalld服务\" class=\"headerlink\" title=\"禁用/停止自带的firewalld服务\"></a>禁用/停止自带的firewalld服务</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">停止firewalld服务</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl stop firewalld</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">禁用firewalld服务</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl mask firewalld</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"设置现有的规则\"><a href=\"#设置现有的规则\" class=\"headerlink\" title=\"设置现有的规则\"></a>设置现有的规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查看iptables现有规则</span><br><span class=\"line\">$ iptables -L -n</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/iptables-L-n.png\" alt=\"iptables-L-n\"><br>可以看到显示的INPUT、FORWARD、OUTPUT上没有任何规则配置且默认策略均为ACCEPT<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 务必先配置INPUT链的默认规则为ACCEPT，这样一来，避免误配置导致我们无法进入</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -P INPUT ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">清空所有默认规则</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -F</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">清空所有自定义规则</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -X</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">所有计数器归0</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -Z</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">允许来自于lo接口的数据包(本地访问)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -i lo -j ACCEPT</span></span><br></pre></td></tr></table></figure><br>接下来定义特别的入站规则<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开放22端口</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开放21端口(FTP)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开放80端口(HTTP)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开放443端口(HTTPS)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 允许ping</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 允许接受本机请求之后的返回数据 RELATED,是为FTP设置的</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -m state --state  RELATED,ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure><br>在上面的入站规则配置好以后，接下来我们可以将INPUT默认策略转为DROP（拒绝）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 其他入站一律丢弃</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -P INPUT DROP</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 所有出站一律允许</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -P OUTPUT ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 所有转发一律丢弃</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -P FORWARD DROP</span></span><br></pre></td></tr></table></figure><br>最终我们可以看到我们目前定义的配置表：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/finalConfig.png\" alt=\"finalConfig\"></p>\n<h4 id=\"保存规则设定、开启iptables服务\"><a href=\"#保存规则设定、开启iptables服务\" class=\"headerlink\" title=\"保存规则设定、开启iptables服务\"></a>保存规则设定、开启iptables服务</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 保存上述规则</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> service iptables save</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注册iptables服务</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 相当于以前的chkconfig iptables on</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl <span class=\"built_in\">enable</span> iptables.service</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开启服务</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl start iptables.service</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看状态</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl status iptables.service</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/enableAndStart.png\" alt=\"enableAndStart\"><br>防火墙配置完成！</p>\n","categories":[],"tags":["Linux","iftables"]},{"title":"树莓派3B搭建NODE-RED运行环境并构建数据流","url":"http://compilemind.com/2018/04/12/2018-04-12-树莓派3B搭建NODE-RED运行环境并进行基础练习/","content":"<p><strong>树莓派搭建Node-RED环境</strong></p>\n<p>树莓派自2015年开始是默认就带NODE-RED的，但是如今已是2018年：）自带的版本已经很老了，可通过下面的命令进行自动升级NODE.JS和NODE-RED</p>\n<a id=\"more\"></a>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash &lt;(curl -sL https://raw.githubusercontent.com/node-red/raspbian-deb-package/master/resources/update-nodejs-and-nodered)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果出现失败请多尝试几次</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 之后进入如下界面，展示更新进度</span></span><br><span class=\"line\">  Stop Node-RED                       ✔</span><br><span class=\"line\">  Remove old version of Node-RED      ✔</span><br><span class=\"line\">  Remove old version of Node.js</span><br><span class=\"line\">  Install Node.js</span><br><span class=\"line\">  Clean npm cache</span><br><span class=\"line\">  Install Node-RED core</span><br><span class=\"line\">  Move global nodes to local</span><br><span class=\"line\">  Install extra Pi nodes</span><br><span class=\"line\">  Npm rebuild existing nodes</span><br><span class=\"line\">  Add menu shortcut</span><br><span class=\"line\">  Update systemd script</span><br><span class=\"line\">  Update update script</span><br><span class=\"line\"></span><br><span class=\"line\">Any errors will be logged to   /var/log/nodered-install.log</span><br></pre></td></tr></table></figure>\n<p>一段时间过后，升级完毕：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">All done.</span><br><span class=\"line\">  You can now start Node-RED with the command  node-red-start</span><br><span class=\"line\">  or using the icon under   Menu / Programming / Node-RED</span><br><span class=\"line\">  Then point your browser to localhost:1880 or http://&#123;your_pi_ip-address&#125;:1880</span><br></pre></td></tr></table></figure><br>根据提示我么可以知道，通过如下的命令启用NODE-RED服务，并且访问树莓派地址并加上1880端口访问WEB下的NODE-RED：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> node-red-start</span></span><br><span class=\"line\">Start Node-RED</span><br><span class=\"line\"></span><br><span class=\"line\">Once Node-RED has started, point a browser at http://192.168.2.7:1880 # 这里是树莓派分配到IP地址</span><br><span class=\"line\">On Pi Node-RED works better with the Firefox or Chrome browser</span><br><span class=\"line\"></span><br><span class=\"line\">Use   node-red-stop                          to stop Node-RED</span><br><span class=\"line\">Use   node-red-start                         to start Node-RED again</span><br><span class=\"line\">Use   node-red-log                           to view the recent log output</span><br><span class=\"line\">Use   sudo systemctl enable nodered.service  to autostart Node-RED at every boot</span><br><span class=\"line\">Use   sudo systemctl disable nodered.service to disable autostart on boot</span><br><span class=\"line\"></span><br><span class=\"line\">To find more nodes and example flows - go to http://flows.nodered.org</span><br><span class=\"line\"></span><br><span class=\"line\">Starting as a systemd service.</span><br><span class=\"line\">Started Node-RED graphical event wiring tool..</span><br><span class=\"line\">12 Apr 04:33:27 - [info]</span><br><span class=\"line\">Welcome to Node-RED</span><br></pre></td></tr></table></figure><br>然后我们打开浏览器访问web网页，能够看到如下的界面：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/node-red-web.png\" alt=\"node-red-web\"><br>Node-RED  UI——显示节点选择板（左）、流的编辑界面（中心）和输出窗格（右）</p>\n<p>左侧里面全是node-red包含的节点，而节点就是node-red的基本单位，它包含了生成数据的节点、处理数据的节点以及最终输出的节点。</p>\n<p>中间是我们的工作区，在该区域内，我们按照正确的形式构建节点，来形成一套数据流生成、处理过程。</p>\n<p>右侧是输出窗格可以切换信息和调试选项卡等。选择信息后，将显示所选节点的文档。当调试被选中时，它将显示调试节点的信息、错误和警告。</p>\n<p>作为Node-red最基本的单位：节点。在Node-red中主要分为3类：</p>\n<p>1、输入节点（例如inject）<br>2、处理节点（例如function）<br>3、输出节点（例如debug）</p>\n<p>输入节点</p>\n<p>输入节点允许数据输入到整个流工作空间中。它们至少有一个输出（端点由右边的小灰色方块表示）。同时也可以将其他服务数据连接到输入节点，例如TCP、WebSockets、UDP等节点，或利用手动输入数据到一个流之中。</p>\n<p>处理节点</p>\n<p>处理节点主要功能是处理数据。它们有一个输入端点和一个或多个输出端点。我们通常使用function节点来处理收到的数据。当然它页可以转换数据类型（例如：JSON、CSV、XML）节点。</p>\n<p>输出节点</p>\n<p>输出节点允许在Node-RED的流之外发送数据。它们的左侧有一个输入端点。使用输出节点将数据发送到其他服务，TCP等或者使用调试节点输出到调试窗进行观察。</p>\n<p>而对于各种数据来说，其本质的最简单的数据结构如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg=&#123;</span><br><span class=\"line\">  payload:”负载数据”</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>即每一条数据都会有其本身的负载数据。</p>\n<p>讲完了基础的知识，我们来通过动手实践来更加直观的了解node-red</p>\n<p><strong>构建时间戳流</strong></p>\n<p>这个例子十分简单，我们不需要任何的处理节点，只需要一个输入和一个输出就可以了：</p>\n<p>我们首先从左侧拉取一个inject输入节点，放置到工作空间中，它会自动变为默认的时间戳节点，单击这个时间戳节点，查看右侧信息栏，我们能看到这个节点的描述：这个时间戳节点能够生成自1970年1月1号以来的所过的毫秒数<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/inject-timestamp.png\" alt=\"inject-timestamp\"><br>通过双击该节点我们还可以看到更加具体的细节：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/inject-detail.png\" alt=\"inject-detail\"></p>\n<p>接下来我们拉取一个debug节点到工作空间中，它会自动转变为msg.payload节点，这个节点就是会将数据直接输出：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/debug-node-info.png\" alt=\"debug-node-info\"><br>接下来我们连接两个节点，同时可以看到每个节点上面都有一个小蓝点，意味着我们的节点只放置到了工作空间中，但是并没有部署：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/node-linked.png\" alt=\"node-linked\"><br>点击右上角的部署之后，我们发现小蓝点消失了。接下来我们让时间戳节点产生时间数据并输出查看。首先点击右侧的调试窗口，然后点击时间戳节点左侧的蓝色矩形按钮：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/clickit.png\" alt=\"clickit\"><br>点击过程中我们可以看到提示我们注入成功，并且在右侧的还能看到输出的数据：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/successinject.png\" alt=\"successinject\"><br>此外，当我们双击debug节点，然后在输出那一栏选择“完整消息”，我们发现输出节点变成了“msg”即整个msg消息体，同时再次部署并点击时间戳产生数据，我们发现输出的信息变得更加完整：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/completeinfo.png\" alt=\"completeinfo\"></p>\n<p>最后，让我们产生编程界的经典输出：Hello, World!</p>\n<p>首先双击“注入节点”，我们不选时间戳类型了，而是替换为文字列：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/change2String.png\" alt=\"change2String\"><br>再次部署并点击消息注入按钮（就是蓝色矩形）<br>得到如下的结果：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/injecthw.png\" alt=\"injecthw\"></p>\n<p>至此，我们成功的使用Node-RED构建了我们的第一条简单的流。</p>\n","categories":[],"tags":["Raspberry","nodejs","NODE-RED"]},{"title":"树莓派3B上手一二","url":"http://compilemind.com/2018/04/12/2018-04-12-树莓派3B上手一二/","content":"<p>早些时间心血来潮买过一个树莓派，但是当时只是玩一玩，买来按照网上的教程摆弄了一下就闲置了。最近毕业设计，做时序数据分析的相关的工作，刚好想起能够用到树莓派+Node-RED来生成模拟的时序数据。于是开始搭建相关的环境。特此记录一下。</p>\n<a id=\"more\"></a>\n<p><strong>系统镜像下载</strong></p>\n<p>树莓派如今已是一个状态的生态圈。其本身有Linux定制的发行版树莓派系统。首先<a href=\"https://www.raspberrypi.org/downloads/raspbian/\">官网</a>去下载系统系统镜像：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/officialwebsite.png\" alt=\"officialwebsite\"><br>上面有两个版本左边是带有图形界面的，右边是没有图形界面的。个人推荐不带图形界面的，既然是玩树莓派的，我想大多数还是有一定Linux基础的，真没有必要装图形界面。</p>\n<p>下载好以后我们能够看到压缩包中存在一个.img后缀的文件，这个就是系统镜像。</p>\n<p><strong>系统烧录</strong></p>\n<p>由于本人使用的macOS，所以接下来实际操作的都是在macOS环境下进行的，在windows下进行系统烧录，可以参考<a href=\"https://blog.csdn.net/u012313335/article/details/53405734\">这篇文章</a>。</p>\n<p>1）格式化SD卡</p>\n<p>这里我使用SD官方的SD格式化工具SD Card Formatter，<a href=\"https://www.sdcard.org/chs/downloads/formatter_4/index.html\">下载地址</a></p>\n<p>下载好以后，安装并打开该工具，然后插入SD卡，SD Card Formatter会自动识别插入的Sd卡，我们直接点击format进行格式化。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/sdformat.png\" alt=\"sdformat\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/formatsuccess.png\" alt=\"formatsuccess\"></p>\n<p>2）烧录系统镜像</p>\n<p>在mac下烧录系统是很容易的，因为Linux/UNIX本身有相关的命令操作。</p>\n<p>首先在命令行我们使用命令df -h来显示目前的挂载情况<br>这里稍微补充一下Linux/UNIX下的磁盘的命名规则：<br>本人的mac只有一块磁盘就像下面的disk1，而后面的s1、s4则代表这块磁盘上的分区<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> df -h  <span class=\"comment\"># 我只粘贴了有代表性的输出</span></span></span><br><span class=\"line\">Filesystem                        Size   Used  Avail Capacity iused               ifree %iused  Mounted on</span><br><span class=\"line\">/dev/disk1s1                     234Gi   99Gi  132Gi    43% 1230474 9223372036853545333    0%   /</span><br><span class=\"line\">/dev/disk1s4                     234Gi  2.0Gi  132Gi     2%       2 9223372036854775805    0%   /private/var/vm</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重点是下面这一个条</span></span><br><span class=\"line\">/dev/disk3s1                      15Gi  2.4Mi   15Gi     1%       0                   0  100%   /Volumes/BOOT</span><br></pre></td></tr></table></figure><br>上面的disk3则是我们的SD的磁盘，并且，只有一个分区s1，我们还可以看到容量为15Gi就是我们预期的格式化好了之后的容量。当然，既然这里能够显示则说明，这些磁盘我们已经挂载好了。接下来首先需要取消挂载：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 千万注意一定要取消挂载正确的磁盘！不要把你的mac磁盘给取消挂载了：）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 另外，请记住disk3s1这个名称，后面要用</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> diskutil unmount /dev/disk3s1</span></span><br><span class=\"line\">Volume BOOT on disk3s1 unmounted</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这个时候再df发现我们的SD已经不再显示里面了，说明卸载成功</span></span><br></pre></td></tr></table></figure><br>接下来进行正式的烧录，使用dd命令将系统镜像写入，需要特别特别注意disk后的数字，不能搞错！/dev/disk3s1是分区，/dev/disk3是块设备，/dev/rdisk3是原始字符设备<br>我们接下来就是要吧镜像烧录到原始字符设备<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 下面dd用于将系统镜像写入</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> bs代表了文件系统的页大小这里设置为4m</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"keyword\">if</span>=后面接上镜像文件的对应路径</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> of=后面接上原始字符设备的路径，因为上面是我们卸载之前是disk3s1，所以这里就是rdisk3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo dd bs=4m <span class=\"keyword\">if</span>=(镜像存放路径)/XXX.img of=/dev/rdisk3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 不放心可以在命令行末尾双击tab会出现类似下面的输出</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rdisk3    rdisk3s1</span></span><br></pre></td></tr></table></figure><br>回车开始烧录，这个过程按机器的差异时间会有所不同。烧录完成以后会出现下面的输出：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">443+0 records in</span><br><span class=\"line\">443+0 records out</span><br><span class=\"line\">1858076672 bytes transferred in 237.453302 secs (7825019 bytes/sec)</span><br></pre></td></tr></table></figure><br>至此，树莓派系统的烧录工作就完成了。<strong>补充</strong>：为了方便以后的SSH连接树莓派，完成树莓派的系统烧录之后，先别着急推出SD，打开SD卡（通常在桌面），我们在系统目录下创建一个名为SSH（大写，没有文件后缀）的文件，以供树莓派开启SSH。</p>\n<p>命令行下如何进入SD卡？所有挂载的外部设备都会在/Volumes下查创建对应的文件夹：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /Volumes</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l</span></span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel     1  4  8 10:59 Macintosh HD -&gt; /</span><br><span class=\"line\">drwxr-xr-x+ 3 root  wheel    96 11 11 15:22 Preboot</span><br><span class=\"line\">drwxrwxrwx@ 1 zhen  staff  2560  4 12 10:30 boot # 这个boot名称的设备就是SD卡</span><br></pre></td></tr></table></figure>\n<p>至此，系统初始化工作完全搞定。</p>\n<p><strong>登陆系统</strong></p>\n<p>以下的操作我们都是在没有显示器的情况下进入树莓派系统，如果你本身有外接显示器，自然不需要这么麻烦，连接然后开机就行了：）</p>\n<p>树莓派3B本身带有wifi模块，但是，如果要开启首先你需要进入系统进行配置：），所以最开始你需要有线连接树莓派</p>\n<p>理论上，mac在有以太网转雷电或者是转USB情况下，我们可以通过网线直连树莓派和mac，但是本身尝试了多次发现就是发现不了同一网段的树莓派（树莓派都给mac分配了IP地址了），猜测macOS High Serria安全性增强了？这个坑以后在研究一下，填了。</p>\n<p>另外一种是路由器组网方式<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/topology.png\" alt=\"topology\"><br>按照这样的连接，你的mac和树莓派都在同一网段中，同时你还可以登陆路由器的管理界面去查看树莓派分配到的IP地址，然后通过ssh连接树莓派。</p>\n<p>组网完成以后，登陆网关，找到设备管理（不同品牌的路由器界面不同，道理上类似）<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/alldevice.png\" alt=\"alldevice\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/netgate.png\" alt=\"netgate\"><br>可以看到我们的树莓派已经分配到了IP，然后我们直接通过命令行登陆：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh pi@192.168.1.100</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意默认的用户名和密码分别为pi和raspberry</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将树莓派加入到已识别的主机中</span></span><br><span class=\"line\">The authenticity of host &#x27;192.168.1.100 (192.168.1.100)&#x27; can&#x27;t be established.</span><br><span class=\"line\">ECDSA key fingerprint is SHA256:p1UPTb5aXIOUiiqdpdaP/e2MV+vbkZJVey0wCYOUEJE.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输入密码，看到一堆信息之后，我们成功进入系统</span></span><br><span class=\"line\">pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure><br>注意：由于我们使用的lite版的树莓派系统，vi使用过程中会出现上下左右方向键成为ABCD等字符，同时mac上的delete（windows上是backspace）都会失效，我们要进行如下的操作：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 1、编辑/etc/vim/vimrc.tiny</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo vi /etc/vim/vimrc.tiny</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将 <span class=\"built_in\">set</span> compatible 改为 <span class=\"built_in\">set</span> nocompatible 这里解决方向键ABCD问题</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 2、依旧在该文件中添加 <span class=\"built_in\">set</span> backspace=2 解决删除问题</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> :wq保存</span></span><br></pre></td></tr></table></figure><br><strong>打开wifi模块</strong></p>\n<p>首先我们扫描当前环境中能够找到的wifi<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo iwlist wlan0 scan <span class=\"comment\"># 此步骤非必须，如果你本来就知道wifi名称就可以不用扫描</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果当前环境中有很多会出现类似下面的格式的信息：</span></span><br><span class=\"line\">Cell 10 - Address: 94:D9:B3:15:7F:28</span><br><span class=\"line\">                    Channel:6</span><br><span class=\"line\">                    Frequency:2.437 GHz (Channel 6)</span><br><span class=\"line\">                    Quality=70/70  Signal level=-16 dBm</span><br><span class=\"line\">                    Encryption key:on</span><br><span class=\"line\">                    ESSID:&quot;210&quot;</span><br><span class=\"line\">                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s</span><br><span class=\"line\">                              9 Mb/s; 12 Mb/s; 18 Mb/s</span><br><span class=\"line\">                    Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s</span><br><span class=\"line\">                    Mode:Master</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 我删除很多不重要的输出信息，这里重点看ESSID，这个就是wifi名称。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 接下来我们需要在下面的文件中开启它：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo vi /etc/wpa_supplicant/wpa_supplicant.conf</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加如下的信息</span></span><br><span class=\"line\">network=&#123;</span><br><span class=\"line\">        ssid=&quot;你的Wi-Fi名称&quot;</span><br><span class=\"line\">        psk=&quot;Wi-Fi密码&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果有多个wifi，你可以创建多个network</span></span><br></pre></td></tr></table></figure><br>最后一步，首先请重启（$ sudo reboot）树莓派，然后拔掉网线，通过mac登陆网关，你会发现树莓派已经通过wifi连接到了。下面两款设备都是wifi连接的。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/twowifi.png\" alt=\"twowifi\"><br>此外，由于lite版本，树莓派不具备vim，所以需要我们手动下载：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 首先移除掉旧的vi</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo apt-get remove -y vim-common</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 然后安装vim</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo apt-get install -y vim</span></span><br></pre></td></tr></table></figure><br>接下来在用户目录下打开（没有就创建）.vimrc，并添加如下的vim配置<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vim ~/.vimrc</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加：</span></span><br><span class=\"line\">set nocompatible &quot;不兼容vi</span><br><span class=\"line\">set nu &quot;显示行号</span><br><span class=\"line\">set nowrap &quot;不自动折行</span><br><span class=\"line\">set scrolloff=3 &quot;距离顶部底部3行</span><br><span class=\"line\">hi MatchParen ctermbg=DarkRed guibg=lightblue</span><br><span class=\"line\">set encoding=utf-8 &quot;编码方式</span><br><span class=\"line\">set fenc=utf-8 &quot;存储时候的编码方式</span><br><span class=\"line\">set hlsearch &quot;搜索高亮</span><br><span class=\"line\">syntax on &quot;语法高亮</span><br><span class=\"line\">set ts=4 &quot;一个tab长度为4</span><br><span class=\"line\">set expandtab &quot;tab替换为空格（配合上面即一个tab四个空格）</span><br><span class=\"line\">set autoindent &quot;自动缩进</span><br></pre></td></tr></table></figure><br>至此，树莓派的初始环境已经OK！</p>\n","categories":[],"tags":["Linux","Raspberry"]},{"title":"Linux文件系统与inode、Block笔记","url":"http://compilemind.com/2018/04/08/2018-04-08-Linux文件系统与inode、Block笔记/","content":"<p>在Linux下一切都是文件，无论是设备还是接口，亦或是网卡等均被抽象成了文件，并且有相关的内核代码进行调度。然而，在一切都是文件的前提下，最需要进行探讨的则是文件存储的根源：文件系统。文件系统的好坏能够更加完美的解决在一个操作系统中对于文件的管理。</p>\n<a id=\"more\"></a>\n<p>Linux下的文件系统是按照inode + block模式来进行了的。通俗一点讲，类似于指针一样的形式存在。即inode作为“指针”记录并指向了真正的”数据块“block。 </p>\n<p><strong>环境</strong></p>\n<p>为了方便后面的实际操作，我们按照如下进行环境的搭建<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 首先在<span class=\"built_in\">test</span>目录下创建一个名为temp的文件夹与一个普通的文件test.txt</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/root/test</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir temp &amp;&amp; touch test.txt</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 文件结构如下</span></span><br><span class=\"line\">test</span><br><span class=\"line\">├── temp</span><br><span class=\"line\">└── test.txt</span><br><span class=\"line\">1 directory, 1 file</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 向test.txt写入一句话</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Its&#x27;s a test.txt&quot;</span> &gt;&gt; test.txt</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>inode</strong></p>\n<p>在Linux中，每一份文件都对应了独一无二的inode编号，通过使用命令ls加参数-i，则可以在显示的文件前显示inode编号。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -i</span></span><br><span class=\"line\">33933113 temp 17414066 test.txt</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 前面的数字就是inode且独一无二</span></span><br></pre></td></tr></table></figure><br>除此之外，inode中还存储更加关键的文件元信息：权限、属性等。例如当我们使用ls -l显示文件的相关属性时，这里面的信息就存储在inode：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l</span></span><br><span class=\"line\">total 4</span><br><span class=\"line\">drwxr-xr-x. 2 root root  6 Apr  8 13:05 temp</span><br><span class=\"line\">-rw-r--r--. 1 root root 16 Apr  8 13:08 test.txt</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 文件夹、文件名前面的诸如读、写、执行权限，修改时间等均存储在inode中</span></span><br></pre></td></tr></table></figure><br>当然，对于inode来说，既然它本身能够记录这些信息，所以自身是有大小的，每个inode 大小均固定为128 bytes，虽然不大，但是记录元信息完全足够了。同时，它本身还记录此文件数据所在的block数据块的编号。inode记录一个block编号需要花掉4bytes</p>\n<p><strong>block</strong></p>\n<p>既然inode是记录文件的元信息的，那么一般文件本身的数据记录在何处呢？答案则是block数据块。在Linux中，block文件快大小通常选择4KB，当然我们还可以选择1KB、2KB等。这是不定的，但是如果选择的太小，那么inode需要记录block编号就要增多，如果太大，容易造成存储碎片。如何理解？其实我们可以把block看作是文件的基本单位，例如，我们现在有一个22KB大小的文件，一个简单的计算，倘若我们使用4KB的block需要6块才能完全装下，不过会有2KB是浪费了的。如果我们采用2KB的block则刚好11块可以装下。这里虽然是选择2KB是最合适的，但是在一般Linux系统中是4KB，为什么？请自行查阅相关的资料，不再赘述。</p>\n<p><strong>综合inode与block进行探讨</strong></p>\n<p>上面的inode与block只是大致介绍了相关的，下面才是更加实在的内容。</p>\n<p>inode具体包含了哪些东西？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、文件的字节数</span><br><span class=\"line\">2、文件拥有者的User ID</span><br><span class=\"line\">3、文件的Group ID</span><br><span class=\"line\">4、文件的读、写、执行权限</span><br><span class=\"line\">5、文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class=\"line\">6、链接数，即有多少文件名指向这个inode</span><br><span class=\"line\">7、文件数据block的位置</span><br></pre></td></tr></table></figure><br>1-5点不难理解，第6点在后面的软硬连接再叙，第七点这里要提一下。上面说过inode本身128 Bytes，还是能记录很多信息的，这里1-6点不至于花光128 Bytes，而对于第7点，inode本身能够记录12个block，如果采用4KB block显然，我们只能存储12 <em> 4KB大小的文件，这显然是不现实的。为了解决这个问题，inode中在第12个记录block编号之后，还能动态的增加二级、甚至三级间接指向，这里我们使用如下的图更为形象的说明：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-08-inode-block/inode-block.png\" alt=\"inode-block\"><br>在上图的情况下，我们可以知道假设我们使用4KB大小的block，并且刚好使用满二次间接，能够存储的数据大小为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12*4KB + 1024*4KB + 1024*1024*4KB</span><br><span class=\"line\">&#x3D; 48KB + 4MB + 4GB</span><br><span class=\"line\">≈ 4GB</span><br></pre></td></tr></table></figure><br><em>*关于文件夹的inode、block</em></em></p>\n<p>上面讨论inode与block我们都是以一个普通文件的角度来看待的。然而，文件夹inode与block与普通文件是有一定的差别的。对于一个文件夹来说，inode与普通文件类似，包含了关于文件夹的属性、读写执行权限、时间戳等。然而，文件夹inode中的直接block通常不会超过12个直接的。为什么呢？因为文件夹所指向的block只会存储这个文件夹拥有的文件的inode编号，并不会存储实际的文件内容。</p>\n<p>例如，当我们拥有一个文件夹dir，这个文件夹下面只有一份文件大小为4GB的inode为1234的文件，那么实际上，文件夹inode中存储的block中只会存储类似inode=1234这样的信息。下图能够更加形象的展示：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-08-inode-block/dir-inode-block.png\" alt=\"dir-inode-block\"><br>总结一下，文件夹的block只会存储对应文件夹下面的文件的inode。所以当我们访问某一个文件的时候，譬如我问需要查看/root/test.txt的时候，流程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先检查根目录下的权限“&#x2F;”，符合权限</span><br><span class=\"line\">通过之后，检查根目录的block是否存储有“root&#x2F;”目录以及对应inode</span><br><span class=\"line\"></span><br><span class=\"line\">查找成功，找到&#x2F;root&#x2F;目录的inode，检查权限等信息，符合权限</span><br><span class=\"line\">通过之后，检查&#x2F;root&#x2F;inode下的block中是否存在test.txt以及inode</span><br><span class=\"line\"></span><br><span class=\"line\">查找成功，找到&#x2F;root&#x2F;test.txt的inode检查权限等信息，符合</span><br><span class=\"line\">查询inode中的直接或间接block将数据读出</span><br></pre></td></tr></table></figure><br>那么，通过以上的分析，我们也很容易的能够理解，如果我们没有对文件夹有写的权限，是不能够删除文件夹下面的文件或者是创建文件的。因为当我们删除一个文件的时候，是对<strong>文件夹</strong>inode对应的block中存储的文件信息进行删除或添加。由于root用户的特殊性，我们使用一个普通用户zhen，并在zhen用户的home目录下创建一个temp文件夹<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l</span></span><br><span class=\"line\">drwxrwxr-x. 2 zhen zhen  6 Apr  8 13:05 temp</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> temp文件夹对于zhen用户有读写以及执行的权限，所以我们（zhen）可以自由的在里面添加删除文件</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ./temp</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> touch <span class=\"built_in\">test</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">test</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> rm <span class=\"built_in\">test</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建删除都没有问题</span></span><br></pre></td></tr></table></figure><br>接下来我们首先在temp文件夹中创建一个test2文件，再回到上一目录，将temp的写权限移除<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建test2文件</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> touch test2</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">test2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 回到上一目录</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ..</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将temp对于zhen的写权限移除</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> chmod 500 ./temp</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l</span></span><br><span class=\"line\">total 4</span><br><span class=\"line\">dr-x------. 2 zhen zhen  6 Apr  8 14:52 temp</span><br></pre></td></tr></table></figure><br>然后，我们再次进入temp文件夹，试图创建文件，发现失败：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ./temp</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> touch test3</span></span><br><span class=\"line\">touch: cannot touch ‘test3’: Permission denied</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> rm test2</span></span><br><span class=\"line\">rm: cannot rm ‘test3’: Permission denied</span><br></pre></td></tr></table></figure><br>操作发现，无论是在该文件夹下创建还是删除文件，都是失败的。那么，我们还能不能编辑该文件夹该文件夹下面的文件呢？譬如想test2文件插入一句“Hello”？理论上来讲，是可以的，因为我们修改test2文件内容，并不会影响temp文件夹的block内容，而事实上也是如此：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello&quot;</span> &gt; test2</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat test2</span></span><br><span class=\"line\">Hello</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 没有问题</span></span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Linux","inode","block"]},{"title":"Java编译运行环境讨论（复古但能加深对Java项目的理解）","url":"http://compilemind.com/2018/03/30/2018-03-30-Java编译运行环境讨论（复古但能加深对Java项目的理解）/","content":"<p>如今我们大多数情况都会使用IDE来进行Java项目的开发，而一个如今众多优秀的IDE已经能够帮助我们自动的部署并调试运行我们的Java程序。然而在早期我们进行Java开始需要手动的建立逻辑包（package）与目录来管理我们的Java项目或是更高级一点的则是使用ant这样的构建工具。作为Javaer，对于Java的编译过程应当是熟悉的，这样即使脱离了IDE我们依然能够很好的理解Java的构建过程。</p>\n<a id=\"more\"></a>\n<p>初级</p>\n<p>我们首先建立一个基础的项目文件夹java-demo，并在其中建立Main.java文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim Main.java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tips:</span><br><span class=\"line\">在Java中，.java文件中至多有一个共有类，并且文件名和改共有类相同，如果没有共有类，则任选一个类名作为文件名即可。</span><br></pre></td></tr></table></figure><br>完成了我们的编辑工作之后，我们使用javac命令进行编译工作：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> javac -d . ./Main.java</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">Main.class Main.java</span><br><span class=\"line\">tips:上述的-d .表示在当前目录下生成class文件</span><br></pre></td></tr></table></figure><br>之后我们可以使用java命令运行得到的.class文件（不需要带.class文件后缀）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> java Main</span></span><br><span class=\"line\">Hello</span><br></pre></td></tr></table></figure><br>初级++</p>\n<p>在上述的示例中，我们并没有在代码中对我们的Java程序打包（package xxx;），我们知道Java中对程序进行package有很重要的意义：能够模块化程序，通过定义不同的包来实现模块化的开发，同时也能够帮助其他接手或者学习代码的人能够有很好的引导作用，能够明白整个Java项目模块的分布。</p>\n<p>所以我们现在需要在代码中定义包，从而模块化我们的代码，这里我们在Main.java代码的第一句加上这样一句代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> src.main;</span><br><span class=\"line\">tips: 这句话代表了我先要把该Main类定义在包src包中的main包中</span><br></pre></td></tr></table></figure><br>然后我们删除刚刚编译过的class文件，为了之后的生成class文件的删除方便，我们在java-demo文件夹下创建一个target文件夹，为以后的class文件的生成目标文件夹。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前工作目录以及文件结构如下：</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">xxx/java-demo</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 目录结构</span></span><br><span class=\"line\">./</span><br><span class=\"line\">├── Main.java</span><br><span class=\"line\">└── target</span><br></pre></td></tr></table></figure><br>接着我们重新编译<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> javac -d ./target Main.java</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">Main.java target</span><br><span class=\"line\">进入target目录之后，我们可以看到如下的结构：</span><br><span class=\"line\">./</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        └── Main.class</span><br></pre></td></tr></table></figure><br>我们可以看到，即使我们并没在原先的工作目录下创建src/main/Main.java这样的源码结构，只是在代码中定义了逻辑上的src.main，在javac之后，java会为我们自动生成这样的目录结构。</p>\n<p>接下来我们通过java命令运行Main.class。这里有很重要的一点，通过我们上面的代码定义，<strong>我们最终生成的是一个名为src.main.Main类，不是单纯的名为Main类</strong>，不能像上面java Main那样去直接运行这个Java程序，同时我们应当在目标类生成的根目录下去运行java命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在target目录下</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> java src.main.Main(或者java src/main/Main)</span></span><br><span class=\"line\">Hello</span><br></pre></td></tr></table></figure><br>即使我们进入到了target/src/main目录中（只要不是target/这样的目标根目录），直接使用java Main或者是java src.main.Main都是不行的。前者会提示：“错误: 找不到或无法加载主类 Main”， 原因就是我们定义是一个src.main.Main的类，很显然这里没有类名为Main的类；后者会提示：“错误: 找不到或无法加载主类 src.main.Main”，原因则是当我们使用java命令去运行譬如src.main.Main等在非默认包下的类时，java命令会自动将src.main.Main转换为 <strong>$classpath/</strong> src/main/Main这样路径下的类文件，而你有没有定义classpath，那么java会在当前（这个例子就是main目录类），再找src/main/Main类，这里当然没有，所以报错。诚然，你可以在使用java命令时通过-classpath来指定类加载根路径，但是这样显然没有直接在类编译根目录下来的直接。</p>\n<p>（初级++）++</p>\n<p>目前为止，我们只讨论了只有一个类的情况，当我们在一个类中通过import来引入其他类的时候，又该注意什么呢？</p>\n<p>首先我们重构整个文件目录结构如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx/java-demo</span><br><span class=\"line\">    ├── dir1</span><br><span class=\"line\">    │   └── Main.java</span><br><span class=\"line\">    ├── dir2</span><br><span class=\"line\">    │   └── Sub.java</span><br><span class=\"line\">    └── target</span><br></pre></td></tr></table></figure><br>首先在Sub.java中我们编写如下的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> myutil;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态工具方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printWithFormat</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&quot;</span> + str + <span class=\"string\">&quot;&lt;&lt;&lt;&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后编写Main.java中的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main;</span><br><span class=\"line\"><span class=\"comment\">// 引入Sub类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> myutil.Sub;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用Sub类中的静态方法</span></span><br><span class=\"line\">        Sub.printWithFormat(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这里我们定义了dir1、2两个文件加，虽然和Main类与Sub类中package的包名不同，但是，当我们在编译时，只要指定了正确目录下的对应的java类即可，就像我们可以进入dir1类中使用如下命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">xxx/java-demo/dir1</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> javac -d ../target/ ./Main.java ../dir2/Sub.java <span class=\"comment\"># 自行理解对应文件的位置关系</span></span></span><br></pre></td></tr></table></figure><br>接着我们查看对应的target下生成的class文件：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target/</span><br><span class=\"line\">├── main</span><br><span class=\"line\">│   └── Main.class</span><br><span class=\"line\">└── myutil</span><br><span class=\"line\">    └── Sub.class</span><br></pre></td></tr></table></figure><br>同样的，我们按照<strong>初级++</strong>中提到的，在根目录下，使用java main.Main命令，可以看到，没有问题：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> java main.Main</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt;Hello&lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure><br>关于java编译运行的路径相关的注意点大致就讲这些，以后会继续补充相关的更多的注意点。</p>\n","categories":[],"tags":["Java","Javac"]},{"title":"macOS下Java与JDK关系与相关路径","url":"http://compilemind.com/2018/03/15/2018-03-15-macOS下Java与JDK关系与相关路径/","content":"<p>macOS下的Java与JDK的路径曾经困扰过我一段时间，今天稍有些忘记，故记下笔记，整理一下。Java与JDK的关系不在本文笔记之内，Javaer常识。</p>\n<a id=\"more\"></a>\n<p><strong>偏好设置中的Java</strong></p>\n<p>在偏好设置中的Java是浏览器的插件，仅提供Java运行环境，其目录我们通过点击该Java图标，进入Java控制面板 —— Java —— 查看，可以显示对应的目录，本人的Java已经升级到了1.8_161，目录如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;Library&#x2F;Internet Plug-Ins&#x2F;JavaAppletPlugin.plugin&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;java</span><br></pre></td></tr></table></figure><br>通过/Library/Internet\\ Plug-Ins目录名称我们也可以知道这个Java是作为网络相关（如浏览器）的Applet插件的。再次强调，这个目录下的Java<strong>仅仅</strong>提供Java基础运行环境，进入bin中我们可以看到<strong>并没有</strong>javac，也可以说明这一点。</p>\n<p>所以，我们完全可以删除Internet  Plug-Ins文件夹下的JavaAppletPlugin.plugin这个文件夹，并且同时为了删除偏好设置中的图标，需要删除/Library/PreferencesPanes/JavaControlPanel.prefPane这个文件夹，看文件夹名不难理解。（理论上是这样的，但是没有必要删除）</p>\n<p><strong>通过oracle安装的jdk</strong></p>\n<p>当我们安装了oracle的jdk之后，我们在命令行中输入which java，通常会显示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;java</span><br></pre></td></tr></table></figure><br>进入/usr/bin中，查看该目录下java的详细信息，可以看到如下的信息：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l java</span></span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  74 11 11 15:08 java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</span><br></pre></td></tr></table></figure><br>可以看到这里的java是一个软链接，链接到上述输出目录中。我们进入到<strong>Versions</strong>目录中，这里我们只安装了一个版本的jdk，所以只会有如下的显示信息：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drwxr-xr-x  8 root  wheel  256  1 24 22:01 A</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel    1 11 11 15:05 Current -&gt; A</span><br></pre></td></tr></table></figure><br>可以看到，Current也只是一个软链接，链接到该目录下的A文件夹（这样的好处是装了多个版本java后，可以方便地调整Current指向，使得不同版本java变成系统默认的）</p>\n<p>我们可以看到，实际上这里面也还不是真正的jdk目录，A文件夹是安装java后系统生成的。它里面的Commands文件夹下有个java可执行文件，然而，我们可以看到这个目录下结构明显不是正常的jdk的目录结构，我们会发下这个目录下有一个java_home，使用如下命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./java_home -V</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">Matching Java Virtual Machines (1):</span><br><span class=\"line\">    1.8.0_121, x86_64:\t&quot;Java SE 8&quot;\t/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home</span><br></pre></td></tr></table></figure><br>上面是我机器上的输出，这个输出才是真正的jdk目录。所以在我看来，oracle安装过程应该是如下流程的：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.首先解压完整的JDK到</span><br><span class=\"line\">/Library/Java/JavaVirtualMachines/jdk&#123;version&#125;.jdk/Content/Home</span><br><span class=\"line\"></span><br><span class=\"line\">2.在/System/Library/Frameworks/JavaVM.framework/Versions/目录中</span><br><span class=\"line\"></span><br><span class=\"line\">  1)创建对应的A或者其他版本的文件夹（猜测是不同的JDK版本依次B、C、D之类的）</span><br><span class=\"line\"></span><br><span class=\"line\">  2)创建Current文件夹（已存在就忽略）并软链接到A或其他版本的文件夹上</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 从A中的Commands文件夹内容本人认为，这个文件夹就是用来协调jdk相关的资源的，比如java与javac，而这里面的java、javac一类的命令会去调用第一步中对应版本的jdk目录中的java、javac</span></span><br><span class=\"line\">3.将/usr/bin下的java、javac、javadoc等软链接到第二步中对应的bin上</span><br><span class=\"line\">ls -l /usr/bin/java*</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  74 11 11 15:08 /usr/bin/java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  75 11 11 15:08 /usr/bin/javac -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javac</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  77 11 11 15:08 /usr/bin/javadoc -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javadoc</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  75 11 11 15:08 /usr/bin/javah -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javah</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  75 11 11 15:08 /usr/bin/javap -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javap</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  82 11 11 15:08 /usr/bin/javapackager -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javapackager</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  76 11 11 15:08 /usr/bin/javaws -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javaws</span><br></pre></td></tr></table></figure><br>根据上面的常识，我们也完全可以卸载oracle安装的Java，同时，我们可以将真正的Java目录提取出来，放置到我们需要的地方，通过设置环境变量的方式来设置JAVA_HOME。</p>\n","categories":[],"tags":["Java","macOS"]},{"title":"Linux Bash命令杂记(tr col join paste expand)","url":"http://compilemind.com/2018/03/13/2018-03-13-Linux Bash命令杂记(tr col join paste expand)/","content":"<a id=\"more\"></a>\n<p><strong>tr命令</strong></p>\n<p>tr命令可以将输入的数据中的某些字符做替换或者是作删除<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tr [-ds] STR</span><br><span class=\"line\">d: 删除输入数据的中的STR</span><br><span class=\"line\">s: 替换重复的字符</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例</span></span><br><span class=\"line\">last | tr &#x27;[a-z]&#x27; &#x27;A-Z&#x27;</span><br><span class=\"line\">将last输出的数据中的所有小写字符替换为大写字符</span><br><span class=\"line\">SPPU     UUZ1                          TVF MBS 13 18:45   TUJMM MPHHFE JO   </span><br><span class=\"line\">SFCPPU   TZTUFN CPPU  3.10.0-693.17.1. TVF MBS 13 18:45 - 18:47  (00:01)    </span><br><span class=\"line\">SPPU     UUZ1                          TVF MBS 13 10:55 - 13:15  (02:20)    </span><br><span class=\"line\">SFCPPU   TZTUFN CPPU  3.10.0-693.17.1. TVF MBS 13 10:54 - 18:47  (07:52)    </span><br><span class=\"line\">SPPU     UUZ1                          MPO MBS 12 18:33 - 19:35  (01:02)  </span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">cat /etc/passwd | tr -d &#x27;:&#x27;</span><br><span class=\"line\">将cat /etc/passwd输出的数据中的&#x27;:&#x27;全部删除</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">rootx00root/root/bin/bash</span><br><span class=\"line\">binx11bin/bin/sbin/nologin</span><br><span class=\"line\">daemonx22daemon/sbin/sbin/nologin</span><br><span class=\"line\">admx34adm/var/adm/sbin/nologin</span><br><span class=\"line\">lpx47lp/var/spool/lpd/sbin/nologin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br><strong>col命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">col [-xb]</span><br><span class=\"line\">-x: 将tab键替换为等长的空个</span><br><span class=\"line\">-b: 在文字内由反斜杠时，仅保留反斜杠后接的那个字符</span><br><span class=\"line\"></span><br><span class=\"line\">cat -A ~/.bashrc</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用cat -A可以讲输出中所有的特殊按键</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Source global definitions$</span></span><br><span class=\"line\">if [ -f /etc/bashrc ]; then$</span><br><span class=\"line\">^I. /etc/bashrc$</span><br><span class=\"line\"><span class=\"meta\">fi$</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意这里有个^I就是tab字符。</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat -A ~/.bashrc | col -x</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Source global definitions$</span></span><br><span class=\"line\">if [ -f /etc/bashrc ]; then$</span><br><span class=\"line\">    . /etc/bashrc$</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tab字符不再出现</span></span><br></pre></td></tr></table></figure>\n<p><strong>join命令</strong></p>\n<p>用于对两个文件按照某一个字符或者字段进行按行连接<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">join [-ti12] file1 file2</span><br><span class=\"line\">-t: 选择分割字符，并且对比“第一个字段”的数据，如果两个文件相同，则将两条数据连成一行，并将第一个字段放在最前</span><br><span class=\"line\">-i: 忽略大小写</span><br><span class=\"line\">-1: 表示第一个文件</span><br><span class=\"line\">-2: 表示第二个文件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例1</span></span><br><span class=\"line\">head -n 3 /etc/passwd /etc/shadow</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先查看这两个文件前三行数据</span></span><br><span class=\"line\">==&gt; /etc/passwd &lt;==</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; /etc/shadow &lt;==</span><br><span class=\"line\">root:&lt;密码太长，我忽略了方便查看&gt;:17593:0:99999:7:::</span><br><span class=\"line\">bin:*:17110:0:99999:7:::</span><br><span class=\"line\">daemon:*:17110:0:99999:7:::</span><br><span class=\"line\"></span><br><span class=\"line\">join -t &#x27;:&#x27; /etc/passwd /etc/shadow | head -n 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash:&lt;密码太长，我忽略了方便查看&gt;:17593:0:99999:7:::</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin:*:17110:0:99999:7:::</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin:*:17110:0:99999:7:::</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">  我们可以看到，按照<span class=\"string\">&#x27;:&#x27;</span>分割，并且默认一第一个字段进行连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例2</span></span><br><span class=\"line\">我们知道/etc/passwd中第四个字段是GID，而/etc/group中第三个字段是GID，我们就可以像如下进行整合：</span><br><span class=\"line\">join -t &#x27;:&#x27; -1 4 /etc/passwd -2 3 /etc/group | head -n 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">0:root:x:0:root:/root:/bin/bash:root:x:</span><br><span class=\"line\">1:bin:x:1:bin:/bin:/sbin/nologin:bin:x:</span><br><span class=\"line\">2:daemon:x:2:daemon:/sbin:/sbin/nologin:daemon:x:</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 我们可以看到，将我们需要的字段提到了最前</span></span><br></pre></td></tr></table></figure><br><strong>paste命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">直接讲两个文件中的数据按行连接</span><br><span class=\"line\">paste [-d] file1 file2</span><br><span class=\"line\">-d: 设定每行数据连接的字符，默认为tab</span><br><span class=\"line\">paste /etc/passwd /etc/group | head -n 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash\troot:x:0:</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin\tbin:x:1:</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin\tdaemon:x:2:</span><br></pre></td></tr></table></figure><br><strong>expand命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expand [-t] file</span><br><span class=\"line\">-t: 后面接数字，代表了将一个tab替换为多少个空格键</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例</span></span><br><span class=\"line\">cat -A ~/.bashrc</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用cat -A可以讲输出中所有的特殊按键</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Source global definitions$</span></span><br><span class=\"line\">if [ -f /etc/bashrc ]; then$</span><br><span class=\"line\">^I. /etc/bashrc$</span><br><span class=\"line\"><span class=\"meta\">fi$</span></span><br><span class=\"line\">注意看有个^I，是tab符号</span><br><span class=\"line\">cat -A ~/.bashrc | expand -t 10 -(标准输入) | cat -A</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Source global definitions$</span></span><br><span class=\"line\">if [ -f /etc/bashrc ]; then$</span><br><span class=\"line\">          . /etc/bashrc$</span><br><span class=\"line\"><span class=\"meta\">fi$</span></span><br><span class=\"line\">我们可以看到原先的tab变为了10个空格</span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Linux","Bash"]},{"title":"Linux Bash命令杂记(cut sort uniq wc tee)","url":"http://compilemind.com/2018/03/12/2018-03-12-Linux Bash命令杂记(cut sort uniq wc tee)/","content":"<a id=\"more\"></a>\n<p><strong>数据流重定向</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">标准输入（stdin）：代码为0，使用&lt;或&lt;&lt;；</span><br><span class=\"line\">标准输出（stdout）：代码为1，使用&gt;或&gt;&gt;；</span><br><span class=\"line\">标准错误输出（stderr）：代码为2，使用2&gt;或2&gt;&gt;；</span><br><span class=\"line\">&gt;：覆盖的方式，&gt;&gt;：追加的方式</span><br></pre></td></tr></table></figure>\n<p>如果想要一般输出与错误输出同时输入到某一个文件，如果采取如下的方式进行输出是错误的：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出数据  1&gt; list 2&gt; list</span><br></pre></td></tr></table></figure><br>如果按照上面的方式输出到list文件中时而没有采用特殊的语法，会因为两个输出进程的同步问题，导致正确的数据与错误的数据可能会交叉的输入到list文件中。正确的方式应该如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出数据 &gt; list 2&gt;&amp;1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 或者是</span></span><br><span class=\"line\">输出数据 &amp;&gt; list</span><br></pre></td></tr></table></figure><br><strong>命令执行&amp;&amp; ||</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd1 &amp;&amp; cmd2</span><br><span class=\"line\">若cmd1执行完毕且正确执行($?&#x3D;&#x3D;0)，则执行cmd2</span><br><span class=\"line\">若cmd1执行完毕且错误执行($?!&#x3D;0)，则不执行cmd2</span><br><span class=\"line\"></span><br><span class=\"line\">cmd1 || cmd2</span><br><span class=\"line\">若cmd1执行完毕且执行正确($?&#x3D;&#x3D;0)，则不执行cmd2</span><br><span class=\"line\">若cmd1执行完毕且执行错误($?!&#x3D;0)，则执行cmd2</span><br></pre></td></tr></table></figure><br><strong>cut命令</strong></p>\n<p>cut命令按行数据进行处理，常用的方式如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">参数 -d -f（组合使用）</span></span><br><span class=\"line\">输出数据 | cut -d &#x27;分个字符&#x27; -f fields</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例</span></span><br><span class=\"line\">str=ni:hao:ma:?</span><br><span class=\"line\">echo $str | cut -d &#x27;:&#x27; -f 2</span><br><span class=\"line\">表示将echo出的str字符串按照&#x27;:&#x27;字符分割，且取第2个字段</span><br><span class=\"line\">得到的结果是</span><br><span class=\"line\">hao</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 补充</span></span><br><span class=\"line\">-f 1,3 代表取第1和第3字段，输出 ni:man</span><br><span class=\"line\">-f 1-3 取1到3字段，输出 ni:hao:ma</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 参数 -c</span></span><br><span class=\"line\">输出数据 | cut -c 字符范围</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例</span></span><br><span class=\"line\">str=hello</span><br><span class=\"line\">echo $str | cut -c 1</span><br><span class=\"line\">输出</span><br><span class=\"line\">h</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 补充</span></span><br><span class=\"line\">-c 1-，输出 hello</span><br><span class=\"line\">-c 1-3，输出 hel</span><br></pre></td></tr></table></figure><br><strong>sort命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head -4 /etc/passswd</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class=\"line\">我们可以看到并没有按照首字母排序</span><br><span class=\"line\"></span><br><span class=\"line\">head -4 /etc/passwd | sort</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">我们可以看到已经按照首字母排序了</span><br><span class=\"line\"></span><br><span class=\"line\">同样，我们可以指定想按照哪一个字段来排序，</span><br><span class=\"line\">head /etc/passwd | sort -t &#x27;:&#x27; -k 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 不看前4行了，准备输出所有行</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将输出按照类型<span class=\"string\">&#x27;:&#x27;</span>分割(-t <span class=\"string\">&#x27;:&#x27;</span>)，并且取第3个字段(-k 3)</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 然而此时的字段依然是按照字符进行，如本测试机上输出的结果注意看第二行：</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意第三个字段，11跑到了2前面去了，因为字符串11排在2前面</span></span><br><span class=\"line\">此时我们需要加上 -n 参数提示按照数字进行</span><br><span class=\"line\">head /etc/passwd | sort -t &#x27;:&#x27; -k 3 -n</span><br></pre></td></tr></table></figure><br><strong>last命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 该命令用来列出目前与过去登录系统的用户相关信息</span></span><br><span class=\"line\">last</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">root     tty1                          Mon Mar 12 18:33   still logged in   </span><br><span class=\"line\">reboot   system boot  3.10.0-693.17.1. Mon Mar 12 18:33 - 19:02  (00:29)    </span><br><span class=\"line\">root     tty1                          Sat Mar 10 20:18 - 20:18  (00:00)    </span><br><span class=\"line\">reboot   system boot  3.10.0-693.17.1. Sat Mar 10 20:18 - 20:18  (00:00)    </span><br><span class=\"line\">root     tty1                          Fri Mar  9 19:10 - 20:50  (01:40)    </span><br><span class=\"line\">...</span><br><span class=\"line\">其中：</span><br><span class=\"line\">第一列：用户名</span><br><span class=\"line\">第二列：终端位置。(pts/0通过ssh或者telnet远程连接的用户，tty：直接连接到计算机或者本地用户)</span><br><span class=\"line\">第三列：登陆IP或者内核（看到0.0或者什么都没有，意味着用户通过本地终端连接，除了重启，内核版本会显示在状态中）</span><br><span class=\"line\"></span><br><span class=\"line\">第四列：开始时间(如：sun apr 3 ：四月三号星期天)</span><br><span class=\"line\">第五列：结束时间（still login in 还未退出，down：直到正常关机，crash：直到强制关机）</span><br><span class=\"line\">第六列:持续时间</span><br></pre></td></tr></table></figure><br><strong>uniq命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">last | cut -d &#x27; &#x27; -f 1 | sort | uniq</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先取用户名，然后排序，最后去重</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">reboot</span><br><span class=\"line\">root</span><br><span class=\"line\">wtmp</span><br><span class=\"line\">zhen</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 加上 -c 显示统计</span></span><br><span class=\"line\">last | cut -d &#x27; &#x27; -f 1 | sort | uniq -c</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">1</span><br><span class=\"line\">27 reboot</span><br><span class=\"line\">26 root</span><br><span class=\"line\">1 wtmp</span><br><span class=\"line\">3 zhen</span><br></pre></td></tr></table></figure>\n<p>务必注意，uniq命令是通过叠加去重<strong>相邻</strong>的字符串，如果你不首先进行排序，那么会出现下面的情况：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">      1 zhen</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br><strong>wc命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc [-lwm]</span><br><span class=\"line\">-l: 仅列出行</span><br><span class=\"line\">-w: 仅列出多少个英文单词</span><br><span class=\"line\">-m: 仅列出多少个字符</span><br><span class=\"line\">head /etc/passwd | wc</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">  10  10  385</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 分别代表行数，词数，字符数（这里10个“词”应该是因为每一行没有空格的原因，wc统计是按空格来分词的）</span></span><br></pre></td></tr></table></figure><br><strong>tee双向重定向</strong></p>\n<p>由前面的数据流我们可以知道，我们在将数据定向时，如果不采取特殊的操作，数据要么输出到屏幕，要么输出到文件或者是设备中，没有办法，既输出到屏幕有输出到文件中；又或者是，我们想要对数据进行处理存放到一个文件中，但是同时对原始数据又存到另一个文件中。使用tee命令，我们就可以做到。</p>\n<p>例如，我们使用last命令首先要把数据存放到last.log中，同时要对用户去重并输出到屏幕上：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">last | tee [-a 追加] last.log | cut -d &#x27; &#x27; -f 1 | sort | uniq</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\"></span><br><span class=\"line\">reboot</span><br><span class=\"line\">root</span><br><span class=\"line\">wtmp</span><br><span class=\"line\">zhen</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 同时我们打开last.log文件可以看到没有做任何处理的原始数据</span></span><br><span class=\"line\">root     tty1                          Mon Mar 12 18:33   still logged in   </span><br><span class=\"line\">reboot   system boot  3.10.0-693.17.1. Mon Mar 12 18:33 - 19:29  (00:56)    </span><br><span class=\"line\">root     tty1                          Sat Mar 10 20:18 - 20:18  (00:00)    </span><br><span class=\"line\">reboot   system boot  3.10.0-693.17.1. Sat Mar 10 20:18 - 20:18  (00:00)    </span><br><span class=\"line\">root     tty1                          Fri Mar  9 19:10 - 20:50  (01:40)    </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Linux","Bash"]},{"title":"Spring自动装配歧义性笔记","url":"http://compilemind.com/2018/03/11/2018-03-11-Spring自动装配歧义性笔记/","content":"<a id=\"more\"></a>\n<p><a href=\"/2018/03/10/Spring-Bean装配笔记/\">前情提要</a>，如果系统中存在两个都实现了同一接口的类，Spring在进行@Autowired自动装配的时候，会选择哪一个？如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一下两个类均被标记为bean</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CD is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Video</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Video is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//配置类仅打开自动扫描</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;zhen&quot;</span></span><br><span class=\"line\"><span class=\"meta\">public class MyConfig &#123;</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">//测试类</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = MyConfig.class)</span></span><br><span class=\"line\"><span class=\"meta\">public class MyConfigTest &#123;</span></span><br><span class=\"line\"><span class=\"meta\">    @Autowired</span></span><br><span class=\"line\"><span class=\"meta\">    Playable playable;</span></span><br><span class=\"line\"><span class=\"meta\">    @Test</span></span><br><span class=\"line\"><span class=\"meta\">    public void checkNULL() &#123;</span></span><br><span class=\"line\"><span class=\"meta\">        Assert.assertNotNull(playable);</span></span><br><span class=\"line\"><span class=\"meta\">    &#125;</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>此时再次运行测试类会发现，FAILD并且报错：</p>\n<p>Unsatisfied dependency expressed through field ‘playable’; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘zhen.Playable’ available: <strong>expected single matching bean but found 2: CD,video</strong> //  找到了两个都bean都能匹配</p>\n<p><strong>自动装配歧义性问题</strong></p>\n<p>上面的异常就是出现了歧义性。Spring为我们扫描了我们代码中的bean（这个部分是没有问题的），但是，在自动装配的过程中却由于歧义性而报错，并且，造成这样的歧义性还有由于Autowired这个注解仅仅按照类型进行装配——上面的CD与Video都实现了Playable接口，Autowired注解仅告诉Spring在测试类中的playable接受一个Playable类型的对象但是这里有两个bean：CD、video都是Playable类型的，所以Spring不知道。</p>\n<p>为了解决这个问题，我们需要通过一定的手段来限定：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">声明首选的bean</span><br><span class=\"line\">限定自动转配的bean</span><br></pre></td></tr></table></figure><br><strong>声明首选的bean</strong></p>\n<p>根据名字我们很容易理解，就是声明在有歧义性情况下，Spring到底选择哪一个bean来装配。方式就是在bean组件下添加@Primary注解,例如在原先的CD的@Component下加上首选注解，再次运行测试代码，PASS。但是，这种方式通常只在同类型bean较少的或者是系统简单的情况使用，而且还存在一个情况：假如目前有两位开发人员，在各自的环境编写bean，他们都希望自己的bean是Primary的，都加该注解，实际上还是会报错，因为系统现在同样有两个Primary bean，Spring还是不能判断选择哪一个bean注入。</p>\n<p><strong>限定自动装配的bean——@Qualifier注解</strong></p>\n<p>首先，我们可以通过在@Component中加入字符串来更明确的指定bean id而不是使用Spring的默认bean id策略。就像如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;myCD&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Component(&quot;myVideo&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Video</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当这样指定以后，我们在自动转配的地方，使用@Qualifier(“指定id”)来限定我们要注入的确定的bean：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"meta\">@Qualifier(&quot;myCD&quot;)</span></span><br><span class=\"line\">  Playable playable;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>再次运行不会报错。</p>\n<p>关于@Qualifier，最佳的情形应该是来标记bean特性。但是，如果多个bean都有相同的特性，都是用了相同的标记的@Qualifier注解，那么同样又会出现歧义性问题。所以我们又要添加新的@Qualifier注解来进一步限定，这样做没有问题，但是Java语法规定，不允许在同一条目上重复出现相同类型的多个注解。你<strong>不能</strong>这么做：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译器会报错</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;myCD&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Qaulifier(&quot;JayChou&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为了结局这样的问题，我们可以创建自己的注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.TYPE, ElementType.METHOD&#125;)</span> <span class=\"comment\">//字段注解  </span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span> <span class=\"comment\">//在运行期保留注解信息</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span> <span class=\"comment\">// 需要使用@Qualifier注解来限定</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MyCD &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> JayChou &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如此定义了注解以后，我们就可以在原先的@Component下如下定义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@MyCD</span></span><br><span class=\"line\"><span class=\"meta\">@JayChou</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>并且在测试类下如下声明：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@MyCD</span></span><br><span class=\"line\"><span class=\"meta\">@JayChou</span></span><br><span class=\"line\">Playable playable;</span><br></pre></td></tr></table></figure><br>测试通过！</p>\n","categories":[],"tags":["Spring","Bean"]},{"title":"Spring Bean装配笔记","url":"http://compilemind.com/2018/03/10/2018-03-10-Spring Bean装配笔记/","content":"<p>Spring中的Bean是一个很重要的概念。Spring作为一个Bean容器，它可以管理对象和对象之间的依赖关系，我们不需要自己建立对象，把这部分工作全部转交给容器完成，具有低耦合，对代码没有侵略性。</p>\n<a id=\"more\"></a>\n<p>目前本人的水平还不足以透彻的分析Spring是如何来构建Bean的装配的概念的，这里仅来记录总结Spring中多种Bean的装配方式。</p>\n<p>Spring的配置方式有Java类配置形式与XML配置两种形式。大致提一下，不赘述，如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java类config形式，需要@Configuration注解来声明</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 类路径下的XML形式</span></span><br><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;beans ...&gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><br>Spring提供了三种装配机制：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">隐式的bean发现机制和自动装配</span><br><span class=\"line\">在Java中进行显示配置</span><br><span class=\"line\">在XML中进行显示配置</span><br></pre></td></tr></table></figure><br><strong>隐式的bean发现机制和自动装配</strong></p>\n<p><strong>隐式bean发现与自动装配即我们完全不必在配置类或者配置文件中定义bean属性（但是这两者必要提供一种）。</strong> 如何定义一个Java类是bean？我们可以在类上使用@Component注解声明一个bean。<br>首先定义一个接口：Playable<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下来，我们定一个CD类，实现该接口，并添加@Component注解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CD is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如此定义，即可表明CD是一个bean。接下来如何开启扫描？</p>\n<p>如果使用Java类配置的方式来配置Spring，我们可以使用@ComponentScan注解在配置类上，告诉Spring开启了组建扫描。并且进行形如如下的bean配置：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"comment\">// 务必注意此处的自动扫描的基础包</span></span><br><span class=\"line\"><span class=\"comment\">// 因为通常配置类与其他类的包在不同的地方</span></span><br><span class=\"line\"><span class=\"comment\">// 默认的包路径是当前配置类所在包下</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(backPakages = &quot;xxx&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果使用XMl来定义，则如下定义：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span></span></span><br></pre></td></tr></table></figure><br>接下来编写测试类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = MyConfig.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfigTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    Playable playable; <span class=\"comment\">// 运行时，将扫描到的在容器中的CD bean装配到这里的playable</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkNULL</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Assert.assertNotNull(playable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果自然是PASS</span></span><br></pre></td></tr></table></figure></p>\n<p>这里在配置类中我们完全没有定义任何的bean，Spring自动为我们扫描出对应的组件进行自动装配（Autowired）到测试类中。</p>\n<p>CD这个类过于简单了，现在重构CD，使其拥有一个title属性，用以表示CD的名字。如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CD</span><span class=\"params\">(String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CD:&quot;</span> + title + <span class=\"string\">&quot; is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果我们再次运行测试代码，会发现报错：</p>\n<p>Unsatisfied dependency expressed through constructor parameter 0;// 大意是提示我们，CD这个类没有默认的参数个数为0的构造器。这里我们大致可以猜测，Spring在进行普通的构建对象时，是调用的该类的默认构造函数，在Java中我们知道，在一个类中若定义了任意形式的构造函数，原先的默认无参构造函数自然失效，而我们定义了有参数的构造函数，所以这里Spring调用不了无参构造函数，顾不能为我们构造这个bean。解决办法就是添加一个无参构造函数。</p>\n<p>但是问题还没有彻底解决，这里Spring只是为我们创建了一个title没有初始化的CD实例对象，我们应该如何去初始化这个title呢？注入的是一个普通的对象，我们同样可以使用@Autowired注入，但是这里只是一个字面量String，如何注入？其实我们可以采用一种更加直观的方式来注入——<strong>显式配置</strong></p>\n<p><strong>通过显式配置</strong></p>\n<p>配置类形式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;zhen&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">Playable <span class=\"title\">cd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CD(<span class=\"string\">&quot;JayChou&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面通过@Bean来声明下面我们将要定义一个bean，紧接着定义一个方法，返回值为Playable（这里没有严格的要求是接口类还是本身实现类，满足语法即可），方法名即为该bean对应的id，参数虽没有定义，但是不代表不能有，这里可以注入其它的bean。方法体中的内容自然是返回具体的实现类了，然而这里就很灵活，我们可以将字符串通过这里构造函数传入，假如我们的CD类中如果有setTitle方法，甚至还可以像下面这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\">Playable <span class=\"title\">cd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CD cd = <span class=\"keyword\">new</span> CD(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    cd.setTitle(<span class=\"string\">&quot;JayChou&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>配置文件XML如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cd&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;zhen.CD&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;JayChou&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br>对比上面的两种显示注入的用法，对应也是很清楚的，Java类中的方法名即为bean id，返回对象对应的类即为XML中的class属性。同时，根据构造函数参数类型的不同，也有不同的形式，这里本篇笔记不多提，以后会有相关的笔记探讨的。</p>\n<p>但是请注意，如果Java类配置文件中已经有一个@Bean，同时还启动了自动扫描，在原先的组件类上添加了@Component注解，Spring是会我们创建两个同为CD类实例bean的。如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意已经添加了@Component注解</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title = <span class=\"string\">&quot;Default Title&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//  定义一个可以设置的title的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTitle</span><span class=\"params\">(String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CD:&quot;</span> + title + <span class=\"string\">&quot; is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//配置类中开启了组建扫描，且也定义了一个bean</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;zhen&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">Playable <span class=\"title\">cd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CD cd = <span class=\"keyword\">new</span> CD();</span><br><span class=\"line\">        cd.setTitle(<span class=\"string\">&quot;JayChou&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在测试类不变的情况下，运行测试代码，会报错：</p>\n<p>No qualifying bean of type ‘zhen.component.Playable’ available: expected single matching bean but found 2: CD,cd</p>\n<p>这行报错告诉我们，发现了两个bean：CD cd都满足Playable，都可以注入到此处。 <strong>（注意，如果一个类有@Component组件注解，该类的bean id默认为类名首字母小写，这里CD由于其本身两个字母都是大写，Spring所以给其的默认名没有将首字母小写，一定注意命名特殊性）</strong> 到底该选谁呢？如果我们不指定，Spring也不能为我们做主。如果我们将测试类中的Playable playable改为Playable cd 或者 CD，如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = MyConfig.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfigTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"comment\">// 为了配合下面输出title进行验证</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里我将类型改为了CD，且CD类中的私有title我修改为了公有</span></span><br><span class=\"line\">    CD cd;</span><br><span class=\"line\">    <span class=\"comment\">// CD CD;</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkNULL</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(cd.title); <span class=\"comment\">// 输出 “CD:JayChou is playing...”</span></span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(CD.title); // 输出 &quot;CD:Default String is playing...&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 下面均通过</span></span><br><span class=\"line\">        Assert.assertNotNull(cd);</span><br><span class=\"line\">        <span class=\"comment\">// Assert.assertNotNull(CD);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>由上面的现象，我们可以推测Spring在注入的时候，首先根据@Autowired下面的引用名来查找对应类型的bean id，如果没有，再找同类型的bean（这里要补充一下，@Autowired是根据类型来匹配注入的）</p>\n<p>以上笔记大致总结了一下Spring bean装配问题，然而还有问题没有解决：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面提到过的报错，Spring如果找到了多个同类型的bean会提示报错，在没有声明的情况下，Spring不知道到底改选哪一个，这就是自动装配的歧义性问题。</span><br></pre></td></tr></table></figure><br>以上两个问题，我会继续做笔记的。</p>\n","categories":[],"tags":["Spring","Bean"]},{"title":"Linux下关于用户账户的几个文件解析","url":"http://compilemind.com/2018/03/09/2018-03-09-Linux下关于用户账户的几个文件解析/","content":"<p>Linux是一个多用户系统，但是对于一个多用户共存的系统中，当然不能够出现用户相互越权等一系列的安全问题，所以如何正确的管理账户成为了Linux系统中至关重要的一环。</p>\n<a id=\"more\"></a>\n<p>在Linux下，与用户账户有着紧密联系的文件又如下的几个：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/passwd   #管理用户的UID、GID等重要用户信息</span><br><span class=\"line\">/etc/shadow   #管理用户密码的等重要信息</span><br><span class=\"line\">/etc/group    #管理用户组</span><br><span class=\"line\">/etc/gpasswd  #管理用户组密码</span><br></pre></td></tr></table></figure>\n<p><strong>1./etc/passwd</strong></p>\n<p>虽说这个文件的文件名写着passwd，但是里面并没有存放密码（早起存放，后来为了安全将密码分离出来）</p>\n<p>打开该文件，里面的内容大致如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>上面的每一行代表了存在你系统中的一个用户。按照“:”来进行字段的划分，可以划分为7个字段，从左到右依次如下意义：</p>\n<ul>\n<li><strong>账号名称（1）</strong>。用以来对应UID，例如上面的第一行root。</li>\n<li><strong>密码位（2）</strong>。早期的该字段的确用来存放密码，但是这个文件特性是所有程序都能读取，为了安全起见，后来将密码放置在了/etc/shadow中了，所以这里只有一个“x”。</li>\n<li><strong>UID（3）</strong>。用户标识，在Linux中，该UID是整数。且多个账号可以对应一个UID，因为Linux系统内核只认UID的。不同的区间有不同的意义：<br>0（系统管理员）。如果你希望其他的某些账号也是系统管理员，可以讲其UID修改为0。（极度不推荐，一是安全性，二是UID还与多处文件及系统有关联，单一修改往往设置不全会出问题）<br>1～499。保留给系统账户使用的ID，不强制，只是一个习惯。<br>500～2^32-1。给一般用户使用的。</li>\n<li><strong>GID（4）</strong>。这个与/etc/group有关，即与用户组相关，后续会提到。</li>\n<li><strong>用户信息说明（5）</strong>。没有重要用途，单纯作简单描述。</li>\n<li><strong>主文件夹（6）</strong>。例如上面的/root目录，当root登陆以后，直接进入root的主目录中。当然你可以进行个性化配置。</li>\n<li><strong>Shell（7）</strong>。当用户root登陆以后，会查找该字段并使用该字段指定的shell（这里是/bin/bash）。但这是里有一个特殊的shell（nologin）可以用来替代成让账号无法取得shell环境的登陆操作。譬如，你当然不希望一个在你Linux上的邮件账户来通过shell操作你的电脑。</li>\n</ul>\n<p>当然，如果记不住的话，可以使用finger命令与id命令，例如：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finger root</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出如下：</span></span><br><span class=\"line\">Login: root           \t\t\tName: root</span><br><span class=\"line\">Directory: /root                    \tShell: /bin/bash</span><br><span class=\"line\">On since Fri Mar  9 19:10 (CST) on tty1   7 seconds idle</span><br><span class=\"line\">Mail last read Sat Mar  3 15:58 2018 (CST)</span><br><span class=\"line\">No Plan.</span><br><span class=\"line\"></span><br><span class=\"line\">id root</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出如下：</span></span><br><span class=\"line\">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><br>输出内容不在解释，十分 -h 了。</p>\n<p><strong>2./etc/shadow</strong></p>\n<p>打开该文件，内容大致如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:$6$tVBKdRxY$myJhWrhIwlXh42zNYLz1fmwu4ONQWP03O/5ccx1/34koU8GTn0M0ACx3xI4Bl.wPN3DPrrGbQX7vbPqqR//xv0:17593:0:99999:7:::</span><br><span class=\"line\">bin:*:17110:0:99999:7:::</span><br><span class=\"line\">daemon:*:17110:0:99999:7:::</span><br><span class=\"line\">adm:*:17110:0:99999:7:::</span><br></pre></td></tr></table></figure><br>shadow文件夹自然也以“:”作为分隔符，这里一共有9个字段，从左到右依次具有如下意义：</p>\n<ul>\n<li><strong>账号名称（1）</strong>。</li>\n<li><strong>密码（2）</strong>。该处使用了摘要加密技术，即不容易逆向破译，只可做验证。</li>\n<li><strong>最近改动密码的日期（3）</strong>。自1970年1月1日以来累加的天数。</li>\n<li><strong>密码不可被改动的天数（4）</strong>。相当于改密码的冻结天数。root中为0代表你随时可以更改，如果修改为20就代表了20天内不可修改。</li>\n<li><strong>密码需要重新更改的天数（5）</strong>。这里root行填写的99999代表了root的密码在99999天以内需要修改，可以理解为允许你永不更改。</li>\n<li><strong>密码需要更改前的警告天数（6）</strong>。这一字段与上一字段配合。例如，上一字段设置为了20，即希望你在20天要重新修改密码，这里设置为5，就代表了第15天到第20天之前你登录的时候会提示你洗修改密码。</li>\n<li><strong>密码过期后的账号宽限天数（7）</strong>。例如，在字段（5）设置为了20，即希望你在20天内要修改密码，但是你在20天以后都还没有修改，那么该密码就过期了（密码过期你的账户依然可以使用bash等，但是重新登录时系统会提醒你修改密码），在过期期间你还没有修改密码，那么这个账户就失效了，该账号再也无法使用该密码登录了。</li>\n<li><strong>账号失效日期（8）</strong>。同样基于1970年1月1号以来的天数，日期到了以后，该账号会直接失效，与账号是否过期无关。</li>\n<li><strong>保留（9）。</strong></li>\n</ul>\n<p><strong>3./etc/group</strong></p>\n<p>/etc/group文件中存放的是用户组的相关的信息，打开大致如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:x:0:root</span><br></pre></td></tr></table></figure><br>一共有四个字段：</p>\n<ul>\n<li><strong>用户组名称(1)</strong>。</li>\n<li><strong>用户组密码(2)</strong>。通常不需要设置，是给“用户组管理员”来使用的。</li>\n<li><strong>GID(3)</strong>。/etc/passwd中第四个字段使用GID就是对应于此的。</li>\n<li><strong>此用户组支持的账户名(4)</strong>。当我们想要将一个用户添加到该用户组时，就可以将其写在该字段中，使用“,“无空格连接。</li>\n</ul>\n<p><strong>4./etc/gpasswd</strong></p>\n<p>/etc/gpasswd文件中存放的是用户组没密码的相关信息，大致如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:::root</span><br></pre></td></tr></table></figure></p>\n<p>同样有四个字段：</p>\n<ul>\n<li><strong>用户组名(1)</strong>。</li>\n<li><strong>密码(2)</strong>。</li>\n<li><strong>用户组管理员账号(3)</strong>。</li>\n<li><strong>该用户组所属账号(4)</strong>。</li>\n</ul>\n<p>当然，对于一个用户来说，当然可以在多个组当中。但是，当我们使用一个账户进行某些操作时，系统如何判断我们当前属于哪个组呢？例如，当前有个文件属性如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----r----- root group1  x.txt</span><br></pre></td></tr></table></figure><br>有一个用户名为user既属于group1又属于group2。那该用户到底能不能读取这个txt呢？</p>\n<p>其实这就涉及到了一个有效用户组与初始用户组两个概念了。使用groups命令，可以看到类似如下的输出（这里模拟有groups1、2两个组）：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groups</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出</span></span><br><span class=\"line\">groups1 groups2</span><br></pre></td></tr></table></figure><br>第一个就是有效用户。有效用户组意味着目前你身份是user，现在属于group1。所以你是可以读取那个txt的。如何进行切换呢？使用newgrp命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newgrp group2</span><br><span class=\"line\">groups</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出</span></span><br><span class=\"line\">group2 group1</span><br></pre></td></tr></table></figure><br>此时尝试读取x.txt会提示权限不足。</p>\n<p>那么初始用户组是什么呢？其实就是/etc/passwd中的GID对应的用户组，也是我们在登陆是的第一个用户组。</p>\n","categories":[],"tags":["Linux"]},{"title":"CentOS7下Hadoop伪分布式环境搭建","url":"http://compilemind.com/2018/03/08/2018-03-08-CentOS7下Hadoop伪分布式环境搭建/","content":"<a id=\"more\"></a>\n<p>前期准备</p>\n<p><strong>1.配置hostname(可选，了解)</strong></p>\n<p>在CentOS中，有三种定义的主机名:静态的（static），瞬态的（transient），和灵活的（pretty）。“静态”主机名也称为内核主机名，是系统在启动时从/etc/hostname自动初始化的主机名。“瞬态”主机名是在系统运行时临时分配的主机名，例如，通过DHCP或mDNS服务器分配。静态主机名和瞬态主机名都遵从作为互联网域名同样的字符限制规则。而另一方面，“灵活”主机名则允许使用自由形式（包括特殊/空白字符）的主机名，以展示给终端用户（如Linuxidc）。</p>\n<p>在CentOS7以前，配置主机的静态hostname是在/etc/sysconfig/network中配置HOSTNAME字段值来配置，而CentOS7之后若要配置静态的hostname是需要在/etc/hostname中进行。</p>\n<p>进入Linux系统，命令行下输入hostname可以看到当前的hostname，而通常默认的hostname是local.localadmin。</p>\n<p>本次试验环境在CentOS7下，所以我们编辑/etc/hostname文件，试验hostname为：hadoop.w4ng，填入其中，重启Linux，可以看到已经生效。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-08-hadoop-install/hostname.png\" alt=\"hostname.png\"></p>\n<p><strong>2.配置静态IP</strong></p>\n<p>同样，在CentOS7以后，其网卡配置已经有原先的/etc/sysconfig/network/network-scripts下面的ifcfg-eth0等改名为乐ifcfg-enpXsY（en表示ethnet，p表示pci设备，s表示soket）<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-08-hadoop-install/ll-network-scripts.png\" alt=\"ll-network-scripts.png\"><br>本人这里有两个ifcfg文件是因为配置了两块网卡<a href=\"http://blog.csdn.net/wangshfa/article/details/8813505\">分别做NAT以及与虚拟机Host-Only两个功能，实现双网卡上网</a></p>\n<p>打开ifcfg-enp0s8，配置如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEVICE=enp0s8 #设备名</span><br><span class=\"line\">HWADDR=08:00:27:10:6B:6B #硬件地址</span><br><span class=\"line\">TYPE=Ethernet #类型</span><br><span class=\"line\">BOOTPROTO=static #静态IP(必备)</span><br><span class=\"line\">IPADDR=192.168.56.88 #IP地址</span><br><span class=\"line\">NETMASK=255.255.255.0 #子网掩码</span><br><span class=\"line\">ONBOOT=yes #设备开机自动启动该网卡</span><br></pre></td></tr></table></figure><br><strong>3.配置hosts</strong></p>\n<p>打开/etc/hosts<br>配置为如下的：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class=\"line\">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class=\"line\">192.168.56.88   hadoop.w4ng</span><br></pre></td></tr></table></figure><br>配置hosts的理由是后期hadoop配置中相关的主机填写我们都是使用域名的形式，而IP地址与域名的转换在这里进行查询（还有DNS，但是这里不讨论）。</p>\n<p><strong>4.关闭防火墙</strong></p>\n<p>CentOS7与6的防火墙不一样。在7中使用firewall来管理防火墙，而6是使用iptables来进行管理的。<a href=\"https://www.cnblogs.com/silent2012/archive/2015/07/28/4682770.html\">当然，我们可以卸载7的firewall安装6的iptables来管理</a>。本人就切换回了6的防火墙管理方式。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]#servcie iptables stop  # 临时关闭防火墙</span><br><span class=\"line\">[root@localhost ~]#chkconfig iptables off # 永久关闭防火墙</span><br></pre></td></tr></table></figure><br><strong>5.JDK与Hadoop的安装</strong></p>\n<p><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\">下载JDK8</a><br><a href=\"http://hadoop.apache.org/releases.html\">下载Hadoop3-binary</a><br>下载完毕将文件传到主机中。</p>\n<p>在/usr/local/下创建java文件夹，并将JDK解压至该文件夹下。<br>在根目录下创建/bigdata文件夹，并将Hadoop解压至其中。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解压命令 tar -zxv -f [原压缩文件.tar.gz] -C [目标文件夹目录] # 实际命令没有中括号，其次，命令参数重-z对应gz压缩文件，若为bz2则使用-j</span><br></pre></td></tr></table></figure><br>在JDK解压完成后，在~/.bash_profile中配置环境变量 <a href=\"http://blog.csdn.net/field_yang/article/details/51087178\">点这里看/etc/bashrc、~/.bashrc、~/.bash_profile关系</a><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/usr/local/java/jdkx.x.x_xxx</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><br>配置完成，保存退出并 source ~/.bash_profile</p>\n<p>hadoop无需配置环境变量</p>\n<p><strong>6.配置hadoop</strong></p>\n<p>在hadoop的home下，进入etc文件夹，有五个主要的文件需要进行配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hadoop-env.sh</span><br><span class=\"line\">core-site.xml</span><br><span class=\"line\">hdfs-site.xml</span><br><span class=\"line\">mapred-site.xml</span><br><span class=\"line\">yarn-site.xml</span><br></pre></td></tr></table></figure><br>基本配置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.配置 hadoop-env.sh</span><br><span class=\"line\">export JAVA_HOME</span><br><span class=\"line\">#找到该处，填写上上面配置的JAVA_HOME，因为hadoop是基于Java的，需要Java的环境</span><br><span class=\"line\"></span><br><span class=\"line\">2.配置 core-site.xml</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;hdfs:&#x2F;&#x2F;hostnameXXX:9000&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">    &lt;!-- 配置hadoop文件系统目录 --&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;&#x2F;bigData&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">&lt;&#x2F;configuration&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">3.配置 hdfs-site.xml</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">&lt;&#x2F;configuration&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">4.配置 mapred-site.xml</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">&lt;&#x2F;configuration&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">5.配置 yarn-site.xml</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;yarn.resourecemanager.hostname&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;hostnameXXX&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><br>然后配置相关服务启动过程中需要的配置变量：<br>进入${HADOOP_HOME}/sbin中，在start-dfs.sh与stop-dfs.sh中添加字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HDFS_DATANODE_USER&#x3D;root</span><br><span class=\"line\">HDFS_DATANODE_SECURE_USER&#x3D;hdfs</span><br><span class=\"line\">HDFS_NAMENODE_USER&#x3D;root</span><br><span class=\"line\">HDFS_SECONDARYNAMENODE_USER&#x3D;root</span><br></pre></td></tr></table></figure><br>在start-yarn.sh与stop-yarn.sh中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YARN_RESOURCEMANAGER_USER&#x3D;root</span><br><span class=\"line\">HADOOP_SECURE_DN_USER&#x3D;yarn</span><br><span class=\"line\">YARN_NODEMANAGER_USER&#x3D;root</span><br></pre></td></tr></table></figure></p>\n<p>配置完成以后，进行hadoop的文件系统格式化，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;HADOOP_HOME&#125;&#x2F;bin&#x2F;hdfs namenode -format</span><br></pre></td></tr></table></figure><br>最后是启动服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行$&#123;HADOOP_HOME&#125;&#x2F;sbin&#x2F;start-all.sh  # 他会去调用start-dfs.sh与start-yarn.sh</span><br></pre></td></tr></table></figure></p>\n<p>根据配置中我们都是配置的root用户，显然需要我们以root身份进行，且过程中需要root密码。当然，通过ssh免密可以方便很多。启动完成以后，命令行中使用jps命令打印Java进程，会看到下图五个进程（忽略Jps进程）：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-08-hadoop-install/jps.png\" alt=\"jps.png\"><br>当然，Hadoop在服务启动以后以提供web端：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visit hdfs manage page</span><br><span class=\"line\">xxx.xxx.xxx.xxx:50070</span><br><span class=\"line\">visit yarn manage page</span><br><span class=\"line\">xxx.xxx.xxx.xxx:8088</span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Linux","Hadoop"]},{"title":"IntelliJ中Spring识别BUG","url":"http://compilemind.com/2018/03/07/2018-03-07-IntelliJ中Spring提示BUG/","content":"<p>最近开始学习Spring，在看《Spring实战4th》3.3“处理自动装配的歧义性”那一部分时，书上提到（也从网上看到了类似的用法）:<br>通过在一个类上加注@Component以及@Qualifier(“x”)可以为其配置限定符来标识区分同一个接口下的不同实现类，用以在需要进行@Autowired自动装配的地方使用@Qualifier(“x”)来指定特定的实现类对象bean。</p>\n<a id=\"more\"></a>\n<p>但是本人在练习过程中，IntelliJ通过上述方式识别不了，只能在@Bean处添加@Qualifier(“x”)，在后续的测试中才能识别。如下：</p>\n<p>在Dessert的实现类Cake上加上@Component以及@Qualifier(“Lovely”)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;Lovely&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cake</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dessert</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>然后是配置类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">Dessert <span class=\"title\">cake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cake();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">Dessert <span class=\"title\">iceCream</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IceCream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类中无法识别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = JavaConfig.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlateTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;Lovely&quot;)</span> <span class=\"comment\">// IDEA 提示&quot;Cannot find bean with qualifier &#x27;Lovely&#x27; &quot;</span></span><br><span class=\"line\">    Dessert dessert;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Assert.assertNotNull(dessert);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，测试能PASS，应该是IntelliJ中的识别BUG。虽然是一个BUG，但是个人的理解是推荐在配置Bean中，进行限定，而不是在每一个类处进行限定。如下在JavaConfig类中进行配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;Lovely&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Dessert <span class=\"title\">cake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cake();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就不会出现报提示错。<br><strong>以上在运行过程均没有错误，只是IDE辅助出现了问题。</strong></p>\n","categories":[],"tags":["Spring","IntelliJ"]},{"title":"在macOS上通过虚拟机搭建基础CentOS7系统环境","url":"http://compilemind.com/2018/03/06/2018-03-06-在macOS上通过虚拟机搭建基础CentOS系统环境/","content":"<p>尽管从Mac的Terminal可以看出，macOS与UNIX、Linux或多或少都有血缘关系（shell、bash等），但是在mac进行Linux开发，或者把macOS直接当作Linux来使用依然是说不过去的，这其中包括一些命令行的使用，一些基本的文件夹体系等（如，在Linux上的/home目录与在macOS下的/Users）不一致。如果想要在macOS上进行Linux的学习，或者进行Linux开发，最完美的方案自然是安装虚拟机。</p>\n<a id=\"more\"></a>\n<h3 id=\"虚拟机的选择\"><a href=\"#虚拟机的选择\" class=\"headerlink\" title=\"虚拟机的选择\"></a>虚拟机的选择</h3><p>mac平台上的主流虚拟机有VMWare Fusion、Parallels Desktop、VrtualBox。前两者均是付费产品，价格虽不是很贵（参考JetBrains、Adobe系列），但是对于只是在Linux上进行学习或者是进行一些简单的开发颇有些大材小用了。所以，本次教程选择免费的VirtualBox进行搭建。</p>\n<p>地址：<a href=\"https://www.virtualbox.org/\">VirtualBox</a></p>\n<p>下载好以后，打开dmg双击pkg正常安装即可。</p>\n<ul>\n<li><p><strong>注意</strong></p>\n<p>VirtualBox在安装的时候需要安装内核扩展（Kernel extenstion）由于macOS 10.13 High Sierra的新安全特性会阻止外部内核扩展的安装，所以安装总是会被系统拦截，出现安装失败的情况，这时候打开“系统偏好设置 - 安全性与隐私”在界面下方会出现提示“来自Oracle America, Inc….”，点击“允许”再次安装即可。</p>\n</li>\n<li><p><strong>点击“允许”没反应？</strong></p>\n<p>本人安装VBox还有其他软件曾经出现过点击“允许”没有反应的情况，可能是macOS存在的一个BUG。此时首先关闭“安全性与隐私”，进入“系统偏好设置 - 键盘 - 快捷键”，选择“所有控制”，然后在此进入“安全性与隐私”，按tab键移动光标焦点到“允许”按钮处按空格键即可点击成功。</p>\n</li>\n</ul>\n<h3 id=\"Linux的选择\"><a href=\"#Linux的选择\" class=\"headerlink\" title=\"Linux的选择\"></a>Linux的选择</h3><p>本人选择CentOS 7作为本次的教程的Linux版本。</p>\n<p>官方地址：<a href=\"https://www.centos.org/\">CentOS</a></p>\n<p>在download界面我们可以看到三种iso镜像：</p>\n<ul>\n<li>DVD.iso 可以用安装程序安装的所有安装包。</li>\n<li>Everything.iso 包含centos7的一套完整的软件包，可以用来安装系统或者填充本地镜像。</li>\n<li>Minimal.iso 最小安装盘，只有必要的软件，自带的软件最少。（<strong>只有命令行界面</strong>）</li>\n</ul>\n<p>这里我们选择minimal，首先因为它是最精炼的一个，其次，一步一步定制我们的系统才能够更好的熟悉Linux系统。<br>下载好以后，打开VirtualBox安装CentOS系统。</p>\n<p><strong>开始安装</strong></p>\n<p>打开VirtualBox，点击“新建” - “专家模式”<br>按照如下的方式配置<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/create-v.png\" alt=\"create-v.png\"><br>内存大小会使用到你mac的运行时内存，请合理分配，这里我们分配1G内存<br>点击创建，进入下一步：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/create-v2.png\" alt=\"create-v2.png\"><br>创建完成之后界面如下（CentOS7是我们创建的）：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/create-v3.png\" alt=\"create-v3.png\"><br>由于我们只是为虚拟机分配了相关的空间以及配置，但是并没有将系统挂载，点击“启动”会提示我们选择镜像文件，点击右侧小图标来选择镜像文件：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/chooseimg-detail.png\" alt=\"chooseimg-detail\"><br>选择完毕，准备启动：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/chooseimg.png\" alt=\"chooseimg\"><br>接下来点击“start”，经过短暂的等待，我们进入到系统安装界面，我们点击该界面，直接进入虚拟机内部（mac上退出虚拟机操控请按 command 键），此时可以操作方向键来选择我们接下来的步骤，这里我们选择“Install CentOS 7”并回车：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/installUI.png\" alt=\"installUI\"><br>接下来我们会进入到一个鼠标操控极差的界面来安装我们的系统，这里我们选择中文语言来进行系统安装：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/chooseEn.png\" alt=\"chooseCN\"><br>选择过语言之后，会看到“安装位置”有红色警告提示是自动分区，这里CentOS已经为我们选择好了“自动分区”<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/installCentos.png\" alt=\"installCentos\"><br>此时只需要点击进去然后在左上角点击“完成”即可，只做一个确认即可：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/partition.png\" alt=\"partition\"><br>回到主界面我们可以点击“开始安装”进行安装了。这里还要说一下，在安装过程中，就像下面的图示，系统是一直在安装的，但是此时系统中只有一个没有设置密码的root用户，就连管理员用户也没有，这里<strong>需要</strong>你设置root用户密码，可以不配置新的管理员用户：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/installing.png\" alt=\"installing\"><br>密码设置短一点没有事儿，毕竟是练习机：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/setpasswd.png\" alt=\"setpasswd\"><br>然后完成配置<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/completeInstall.png\" alt=\"completeInstall\"><br>之后等待最后的收尾工作结束，点击“重启”，进入命令行界面（选择的minimal，只有命令行界面），选择第一个系统，登陆root用户：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/chooseFirst.png\" alt=\"chooseFirst\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/login.png\" alt=\"login\"><br>至此，虚拟机下Linux基本配置完成。</p>\n<h3 id=\"配置双网卡实现虚拟机-与主机（mac）与外网通信\"><a href=\"#配置双网卡实现虚拟机-与主机（mac）与外网通信\" class=\"headerlink\" title=\"配置双网卡实现虚拟机 与主机（mac）与外网通信\"></a>配置双网卡实现虚拟机 与主机（mac）与外网通信</h3><p>在上面的配置中，我们已经搭建好了一个最基本的，不具备网络通信的CentOS7操作系统，但是不能与外网通信，我们不能通过在线安装我们需要的软件，这样的单机操作系统用处是不大的。接下来我将介绍如何通过双网卡的方式来实现实现虚拟机 与主机（mac）与外网通信。</p>\n<h4 id=\"配置仅仅与主机通信的仅主机模式网卡\"><a href=\"#配置仅仅与主机通信的仅主机模式网卡\" class=\"headerlink\" title=\"配置仅仅与主机通信的仅主机模式网卡\"></a>配置仅仅与主机通信的仅主机模式网卡</h4><p>以下配置方式是不能与外网通信的，仅仅与主机通信，但好处在于我们可以使用静态IP地址，避免IP地址的变动。如果你没有这方面的需求，可以直接进入下一节。</p>\n<p>无论是哪一台计算机，要进行网络通信，都必须要至少有一块网卡来进行通信，当然，我们可以通过软件来虚拟出网卡，让这个虚拟的网卡获取IP来通信，更多的细节需要你有计算机网络的相关知识来支撑，这里不多提。这里既然我们需要让虚拟机中的系统来与我们的主机（mac）来通信，自然而然，需要让我们mac有一块网卡，虚拟机有一块网卡，让它们处于同一网段，这样一来，我们自然就实现了虚拟机与主机（mac）之间的通信。主机上怎么创建一块虚拟网卡呢？这里VirtualBox就可以帮我们实现。</p>\n<p>点击主界面上的“全局工具” - “主机网络管理器”，进入后点击“创建”（<strong>注意</strong>：这里可能会存在显示BUG，导致你点击创建之后没反应，<strong>请不要</strong>连续点击创建，点了一次之后切换一下画面），之后你就会在主机上（mac）创建一块用于和VirtualBox中的虚拟机进行通信的虚拟网卡：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/createHostNetworkUI.png\" alt=\"createHostNetworkUI\"><br>这里VBox自动为我们在mac主机上创建了一块名称为vboxnet0的网卡<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/createHostNetwork.png\" alt=\"createHostNetwork\"><br>我们进入mac终端，显示当前的所有的网卡信息也能看到这块网卡在我们的mac主机上已经创建成功了：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ifconfig</span></span><br><span class=\"line\">...</span><br><span class=\"line\">vboxnet0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class=\"line\">\tether 0a:00:27:00:00:00</span><br><span class=\"line\">\tinet 192.168.56.1 netmask 0xffffff00 broadcast 192.168.56.255</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 我们看到这块网卡已经有一个IP地址为192.168.56.1</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 要让我们的虚拟机与我们的主机通信，只要虚拟机中有一块我们主机在同一网段的网卡就行了</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br><strong>注意：请明确以上操作是为我们的主机mac，不是为我们的虚拟机创建网卡：）</strong></p>\n<p>接下来，我们可以通过VirtualBox给CentOS配置一块网卡，用于我们的虚拟机中的操作系统与我们的主机（mac）之间的通信，所以首先我们要配置一块“仅主机（Host-Only）网络”：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/host-only.png\" alt=\"host-only\"><br>我们可以看到，VirtualBox已经很智能的为我们选择了我们刚刚为主机mac创建的网卡。点击“OK”之后，我们虚拟机与主机之间的通信网卡配置完成（<strong>注意</strong>：仅仅是虚拟网卡配置好了，IP地址什么还没有配置）。接下来我们登录我们的虚拟机查看网卡的配置情况。<br>进入系统之后，我们使用命令ip addr来查看CentOS下的网卡配置情况（默认是没有ifconfig命令的，我们之后再装）<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ip_addr.png\" alt=\"ip_addr\"><br>注意查看此处第二块网卡，我们可以看到它的硬件地址是08:00…:3d，和我们上面的配置Host-Only处显示的硬件MAC地址是一样的，同时请记住这块网卡的名称。</p>\n<p><strong>配置网络</strong></p>\n<p>在CentOS7中，我们进入/etc/sysconfig/network-script目录，显示当前目录下的文件：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /etc/sysconfig/network-script</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在众多的配置文件中，我们应该是能够找到和我们上面ip addr命令中显示的那块网卡名称一样的带有“ifcfg-”前缀的配置文件</span></span><br><span class=\"line\">...</span><br><span class=\"line\">ifcfg-enp0s3</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br><strong>注意</strong>：在CentOS6.x及一下，网卡的命名规则和7不一样，相关的差别请自行搜索。</p>\n<p>接下来我们需要配置网卡的具体信息，由于我们选择的是minimal版本的CentOS，所以使用vi来打开编辑它：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vi ifcfg-enp0s3</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 同时为了配合上面的我们主机的IP网段，我们按照如下的方式来配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 类型=以太网</span></span><br><span class=\"line\">TYPE=Ethernet(默认)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设备名</span></span><br><span class=\"line\">DEVICE=enp0s3(默认)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">BOOTPROTO=dhcp(dhcp为自动分配ip地址,我们把他注释了，在下面另外加)</span></span><br><span class=\"line\">BOOTPROTO=static(新添加)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> IP地址</span></span><br><span class=\"line\">IPADDR=192.168.56.66(新添加)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 子网掩码</span></span><br><span class=\"line\">NETMASK=255.255.255.0(新添加)</span><br><span class=\"line\"></span><br><span class=\"line\">ONBOOT=yes(默认为no,修改为yes意为每次启动之后自动启动该网卡)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以上就是一个最精简的网卡配置文件</span></span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ifcfg.png\" alt=\"ifcfg\"><br>接下来reboot重启CentOS，重启之后通过ip addr再次查看我们网卡信息，也可以看到其网卡已经配置好了IP地址：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ipaddrNew.png\" alt=\"ipaddrNew\"><br>最后来进行测试，由于mac本身的安全防火墙是打开的，所以我们通过虚拟机（ip=192.168.56.66）去ping我们mac主机（ip=192.168.56.1）是ping不通的，我们只有在mac终端下去ping我们的虚拟机，发现已经ping通：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ping.png\" alt=\"ping\"></p>\n<h4 id=\"配置既能与主机通信同时还能与外网通信的桥接模式\"><a href=\"#配置既能与主机通信同时还能与外网通信的桥接模式\" class=\"headerlink\" title=\"配置既能与主机通信同时还能与外网通信的桥接模式\"></a>配置既能与主机通信同时还能与外网通信的桥接模式</h4><p>配置第二块网卡的原理十分简单，就是我们将我们主机的一块能够上网的网卡作为桥接网卡（可以理解为抽象成一台路由器上的网卡），这样，首先毫无疑问，我们的既然都是我们主机上的网卡了，自然主机与虚拟机之间是能够通信的，同时，我们的虚拟机还能够通过这块桥接网卡来与外界通信。</p>\n<p>以上的简略了解以后，我们首先可以知道，我们可以不再需要Host-Only这样的主机模式了。所以我们不再选择主机模式。</p>\n<p>选择桥接模式之前，我们首先查看我们当前能够使用的桥接的网络，在本次实验中，本人mac使用的是无线网卡en0连接的网络本地的局域网：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ifconfig</span></span><br><span class=\"line\">...</span><br><span class=\"line\">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tinet 172.20.10.12 netmask 0xfffffff0 broadcast 172.20.10.15</span><br><span class=\"line\">\tnd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class=\"line\">\tmedia: autoselect</span><br><span class=\"line\">\tstatus: active</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>在此基础之上，我们设置虚拟机的网络为桥接模式，取消仅主机模式网络，并且选择我们的无线网卡：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/nohostonly.png\" alt=\"nohostonly\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/en0.png\" alt=\"en0\"><br>接下来进入系统，验证网卡是否配置成功，之后在测试ping外网：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ipaddrBridgeAndPing.png\" alt=\"ipaddrBridgeAndPing\"><br>再使用主机ping我们的虚拟机，发现没有问题<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/pingVM.png\" alt=\"pingVM\"><br>综上，我们的虚拟机 + 网络完全配置完成！</p>\n<h3 id=\"安装VirtaulBox增强工具包\"><a href=\"#安装VirtaulBox增强工具包\" class=\"headerlink\" title=\"安装VirtaulBox增强工具包\"></a>安装VirtaulBox增强工具包</h3><p>VirtualBox的增强工具包通常不需要我们再去下载，它通常伴随VirtualBox下载好了。一般会存放在对应应用的根目录下（在Windows中就是安装根目录），在mac中我们知道应用的根目录就是当我们安装的应用的包内容中：找到VitualBox应用，右键，“显示包内容”，“Contents”，“MacOS”，可以看到一个名为VBoxGuestAddition.iso镜像文件：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/additioniso.png\" alt=\"additioniso\"><br>接下来，就需要我们将这个iso镜像文件挂载到我们的Linux系统中。<strong>注意，一定要明确这个增强工具是给我们虚拟机中的Linux系统安装的</strong>。</p>\n<h4 id=\"为CentOS安装必要的开发库工具库\"><a href=\"#为CentOS安装必要的开发库工具库\" class=\"headerlink\" title=\"为CentOS安装必要的开发库工具库\"></a>为CentOS安装必要的开发库工具库</h4><p>进入Linux中，在前面安装配置好网络的基础上，我们使用yum安装如下待会增强功能包需要用到的工具库：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum update</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install gcc gcc-c++ make kernel-headers kernel-devel bzip2</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 务必注意先安装gcc、gcc-c++、make，这三个工具是后面编译的基础工具</span></span><br></pre></td></tr></table></figure><br>安装完成以后，reboot重启。<strong>(务必要重启，为了更新kernel内核系统信息)</strong></p>\n<h4 id=\"挂载增强功能镜像文件\"><a href=\"#挂载增强功能镜像文件\" class=\"headerlink\" title=\"挂载增强功能镜像文件\"></a>挂载增强功能镜像文件</h4><p>这里必须要提到Linux中的一个概念：<strong>挂载（mount）</strong>。根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”。实际上，我们Windows上同样也有挂载，比如U盘的插入并读写，新添加的硬盘并读写等等。这一切由于在Windows上已经有对应的驱动程序帮助我们自动的进行了，所以我们不太熟悉这个过程。而在Linux上，特别是在命令行界面下，我们要去读取一些系统以外的文件（就比如上面的U盘，光驱等），就必须要手动的去做这样一个操作。</p>\n<p>挂在的过程我们需要明确最主要的两点：设备以及挂载点。设备其实就是Linux操作系统中/dev/目录下显示那一些设备。挂载点其实就是Linux文件系统中的我们可以自定义的文件夹，在到时候使用挂在命令的时候，将外部文件系统与Linux内部文件系统关联起来的入口。可能还有些模糊，下面安装增强功能包会进一步根据实际来解释的。</p>\n<p>在上面我们已经安装好了开发工具并重启之后，我们首先点击VirtualBox上的“devices”选项，找到“Install Guest Addition CD image”：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/installdevices.png\" alt=\"installdevices\"><br>找到这一栏以后，我们点击它，现在是没有任何反应的，但是这里VirtualBox已经为我们将CD镜像“连接”到了Linux中了，就好像我们普通电脑装入光驱一个道理。</p>\n<p>补充：VirtualBox上的devices其实就是我们的外设接口一样。我们可以看到devices显示的Optical Drivers、Audio、Network以及USB，实际上就是为我们虚拟化的接口。假设我们想要将U盘数据传到Linux中，就可以现在电脑上插入U盘，然后在USB中找到我们这个插入的U盘对应的驱动选项，VirtualBox就会为我们读入U盘，之后在Linux中我们把对应的设备挂载到某一文件夹就可以读取了。</p>\n<p>继续上面的安装。接下来我们创建一个挂载点，挂载点通常就是创建一个临时的文件夹：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir tempdir</span></span><br></pre></td></tr></table></figure><br>创建完成以后，我们将cd设备挂载到这个文件夹上：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mount -t auto /dev/cdrom ./tempdir</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 完成挂载以后会打印设备的访问权限</span></span><br></pre></td></tr></table></figure><br>接下来，我们就可以进入刚刚创建的tempdir，我们可以看到这个文件中，出现了一些新的文件，这些文件其实就是刚刚增强功能包中的文件：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/tempdir.png\" alt=\"tempdir\"><br>看到这里，读者应该就能对挂载有基本更形象的认识了吧。其实就是将外部文件通过某一个我们内部创建的文件夹（挂载点）连接到我们Linux内部文件系统。<br>这个增强包中包含了Linux、Windows以及macOS系统的增强工具包。我们是Linux系统，所以运行VBoxLinuxAdditions.sh即可：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sh ./VBoxLinuxAdditions.sh</span></span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/building.png\" alt=\"building\"><br>完成以后，我们会发现系统的分辨率发生了变化，并且通过输出也知道增强工具安装成功了。</p>\n<p>最后请类似于像Windows上弹出U盘一样，卸载挂载点<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> umount tempdir</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"设置共享文件夹\"><a href=\"#设置共享文件夹\" class=\"headerlink\" title=\"设置共享文件夹\"></a>设置共享文件夹</h3><p>VirtualBox为我们设计了“共享文件夹”，方便Linux与主机之间的文件传输。这一功能需要增强功能包安装完成了才可以使用。</p>\n<p>这一步其实很简单，同样是在VirtualBox上的devices选项中，我们点击“Shared Folders” - “Shared Folders Settings”，点击新建共享文件夹按钮：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/newsf.png\" alt=\"newsf\"><br>在弹出来的界面设置在主机上的共享文件夹，这里我在桌面上创建了一个名为“sharefolder”的文件夹，并选择了它，同时为了方便，文件名我设置为了“sf”。下方第一条“只读”按需勾选（以后可以修改），“Auto-mount”自动挂载选上，方便系统中自动挂载读取，“Make Permanet”永久化一般也选上，以后一直用这个文件夹与虚拟机中的Linux进行文件共享。</p>\n<p>回到Linux中，我们为了方便文件的管理，创建一个名为myshare的文件夹作为挂载点。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir myshare</span></span><br></pre></td></tr></table></figure><br>接下来使用如下的命令将主机上的共享文件夹挂载进来：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mount -t vboxsf sf ./myshare</span></span><br></pre></td></tr></table></figure><br>于是，当我们在主机上往共享文件夹中操作文件的时候，刷新Linux中的文件夹，就可以实时的看到（反之亦然）：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/sharefile.png\" alt=\"sharefile\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/deleteshare.png\" alt=\"deleteshare\"></p>\n<p>在此基础上，整个使用VirtualBox进行Linux虚拟机的搭建工作完成！</p>\n","categories":[],"tags":["Linux"]},{"title":"Java中的Integer","url":"http://compilemind.com/2017/08/22/2017-08-22-JavaInteger小记/","content":"<a id=\"more\"></a>\n<p>众所周知，在Java中，存在着值比较与应用比较两种情况。例如，如下的比较，可以根据值比较与引用比较来跟容易的判断出结果来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">123</span>;</span><br><span class=\"line\">String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">String s2 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(s1 == s2); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>这里，a与b由于是基本类型，所以Java在比较的时候直接就是按值来比较，而下面的s1与s2则是由于分别指向内容为“123”的字符串对象引用（关于string的细节，见本人的另一篇文章），而这两个字符串的地址并不一样，所以结果是false。</p>\n<p>那么，今天要讨论的是，对于Java自动拆装箱的问题的深入探讨。如下所示，请问结果是什么呢？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"number\">666</span>;</span><br><span class=\"line\">Integer b = <span class=\"number\">666</span>;</span><br><span class=\"line\">System.out.println(a == b);</span><br></pre></td></tr></table></figure></p>\n<p>结果是false，您可能会说，这有什么好问的，Integer对象的比较，引用的比较，而这两个只是值相同，而对象不同的Integer对象罢了，所以当然为false。好，那么我再问你，下面的结果是什么？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer b = <span class=\"number\">100</span>;</span><br><span class=\"line\">System.out.println(a == b);</span><br></pre></td></tr></table></figure><br>您可能说，哇，当我傻吗，当然还是false了。可是，结果是true。</p>\n<p>为什么同样的情况下，当值变小了，结果就变为true了呢。</p>\n<p>其实，Java中，对于可装箱的对象类型，都存在一个1字节的范围：-128到127。在这个范围类的数字，Java认为是常用的数字，所以自动进行了值比较，而不是进行引用的比较。所以，无论是Long还是Integer，只有你的值在-128到127，这两个对象的比较直接按照其所存储的值来进行。就像如下的情况：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer b = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer c = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer d = <span class=\"number\">127</span>;</span><br><span class=\"line\">Long e = -<span class=\"number\">129L</span>;</span><br><span class=\"line\">Long f = -<span class=\"number\">129L</span>;</span><br><span class=\"line\">Long g = -<span class=\"number\">128L</span>;</span><br><span class=\"line\">Long h = -<span class=\"number\">128L</span>;</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(c == d); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(e == f); <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(g == h); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Java","Integer"]},{"title":"理解$hadow$ocks与Proxy原理","url":"http://compilemind.com/2017/04/24/2017-04-24-理解$hadow$ocks与Proxy原理/","content":"<a id=\"more\"></a>\n<p><strong>以下所有提到$hadow$ocks的均以ss指代</strong></p>\n<h3 id=\"为什么要用ss呢？\"><a href=\"#为什么要用ss呢？\" class=\"headerlink\" title=\"为什么要用ss呢？\"></a>为什么要用ss呢？</h3><p>在早期（如今绝大多数也是），对于互联网的访问流程是及其简单的：浏览器（或其他客户端）向互联网服务器提出一个请求（request），然后等待互联网服务器回应（response），最后在本地解析渲染。麻烦一点的，中间会有多个代理帮助我们进行数据的请求。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/requestresponse.png\" alt=\"requestresponse\"></p>\n<p>后来，墙出现了，我们不能再愉快的访问外网了。因为墙相当于一个巨大的墙阻挡着我们和外界，当我们想要访问外网的时候，这个请求数据包必然会经过墙的检查：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/checkbyw.png\" alt=\"checkbyw\"><br>当检查到被墙禁止访问的内容请求的时候，自然会被“过滤”或被“忽视”掉。但，有人还是想要往墙外看看。怎么办呢？有人想出了一个方法，如同最上面图中右边的拓扑，但是中间代理服务器本身就在国外，当我们想要访问外部内容的时候，首先和这个在国外的代理服务器进行ssh通信，告诉它，我想要请求xx资源，再让这台代理服务器去访问目标服务器，得到回应之后，再把我们想要的数据通过ssh传递给我们：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/byssh.png\" alt=\"byssh\"></p>\n<p>刚开始这样还不错。因为ssh本身基于RSA加密，所以首先，墙无法查看其请求内容（ip、内容等），所以也就无法分析你的请求关键词（用于筛选连接），避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh本身的特征是明显的，我们的墙研发人员根据相关的如连接频率、连接时间等进行分析，再通过一定的手段干预连接，于是后来墙愈来越强了。使用ssh tunnel的方式不太灵了！ </p>\n<p>既然ssh你还能看出连接时间、频率等特征值。那我干脆不用了，转换一下，我往外界发送合法的TCP数据包该没有问题吧？好，每次我访问某个资源的时候，首先将请求在本地转换为（拆分、加密等手段）一个个非常规端口的TCP数据包，里面的内容也是加密过的。当我发送给外部服务器的时候，墙只能知道你发送的是合法TCP数据包，它也不敢妄自丢弃和查看特征值，因为他没法保证这个TCP数据包究竟是要请求什么，外面看来本身就是个普通的数据包。等发到外部的代理服务器的时候，我运用相关的协议进行重组解密，得到原始请求。后面就和ssh tunnel有异曲同工之妙。于是，如下的拓扑出现了：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/bysock.png\" alt=\"bysock\"></p>\n<p>理解了这个之后，搭建服务器就是一件很简单的事情了。网上资源很多，这里不再赘述。</p>\n<h3 id=\"Privoxy作用\"><a href=\"#Privoxy作用\" class=\"headerlink\" title=\"Privoxy作用\"></a>Privoxy作用</h3><p>当我们搭建好了ss服务器之后，我们本地需要使用ss客户端监听1080（通常的默认端口），配置相关的命令，从而实现当我们本地机器访问外部网络的时候，请求数据首先经过本的1080端口进行加密拆分为原始的TCP数据包。然而需要注意的是，当我们监听了默认的1080端口之后，并不意味着，我们访问数据的时候，所有网络数据就走1080这个ss客户端监听的端口了。由于Windows和macOS客户端通常包含了相关的代理转发功能，所以我们在进行HTTP或者是HTTPS的时候，会默认的启动一个代理转发的模块，来替我们监听HTTP和HTTPS请求，并将这些请求数据送入1080端口应用（即ss客户端）。</p>\n<p>然而，在Linux下的ss客户端，并没有包含这个功能，所以，但我们进行HTTP(s)请求的时候，需要设置代理，当我们使用Privoxy的时候，安装Privoxy：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo yum -y install epel-release</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo yum -y install privoxy</span></span><br></pre></td></tr></table></figure><br>第一步的安装epel这是因为像centos这类衍生出来的发行版，他们的源有时候内容更新的比较滞后，或者说有时候一些扩展的源根本就没有。EPEL(<a href=\"http://fedoraproject.org/wiki/EPEL\">http://fedoraproject.org/wiki/EPEL</a>) 是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。</p>\n<p>默认的配置文件地址在 /etc/privoxy/config 目录下。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 把本地HTTP流量转发到本地1080 SOCKS5代理</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 即当我们发出HTTP(S)请求的时候，会将请求转为Socks5</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意最后的 <span class=\"string\">&quot;.&quot;</span></span></span><br><span class=\"line\">forward-socks5 / 127.0.0.1:1080 .</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 可选，默认监听本地连接端口为8118</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> listen-address 127.0.0.1:8118</span></span><br></pre></td></tr></table></figure><br>接下里启动：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start privoxy</span><br></pre></td></tr></table></figure><br>配置完成以后还没有结束！请考虑一下，目前我们只是设定了如果有对于所有HTTP(S)的访问（即foward-sock5后面的“/”）都将转为socks5送入被ss客户端监听的1080端口中去，但是并没有设定HTTP(S)代理服务器！，所以，最后你还需要在.bash_profile（或者是.bashrc）中设定代理服务器的环境变量：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy=http://127.0.0.1:8118</span><br><span class=\"line\">export https_proxy=https://127.0.0.1:8118</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 最后再<span class=\"built_in\">source</span>一下</span></span><br></pre></td></tr></table></figure><br>最后，我们再以一个整体拓扑来表达一下我们的访问流程：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/flow.png\" alt=\"flow\"></p>\n","categories":[],"tags":["shadowsocks","proxy"]},{"title":"Java String的探讨","url":"http://compilemind.com/2017/04/18/2017-04-18-JavaString探讨/","content":"<p>关于String相关内容的学习，历来都是Java学习必不可少的一个经历。</p>\n<p>以前一直想要好好总结一下String的相关的知识点，苦于没有时间，终于在今天有一个闲暇的时间来好好总结一下，也希望这文章能够加深我对于String相关内容的理解~（ps:在我看来，学习某些知识点的时候把学到的想到的都记录下一方面能够加深自己学习印象，二者能够锻炼锻炼我的文笔~）</p>\n<a id=\"more\"></a>\n<p>首先JVM中存在着一个字符串池String pool，其中保存着很多String对象，这些String对象可以被共享使用，因此这个pool的存在在很多方面提高Java一些String操作的效率。 而这一些都是基于String类是final的，它的值一经创建就不可改变。String pool由String类维护，所以我们可以调用intern()方法来访问字符串池。</p>\n<p>接下里我们来看第一个例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"string\">&quot;abc&quot;</span>;     </span><br><span class=\"line\">String s2 = <span class=\"string\">&quot;abc&quot;</span>;       </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s1 == s2 : &quot;</span>+(s1==s2)); <span class=\"comment\">//true     </span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s1.equals(s2) : &quot;</span> + (s1.equals(s2))); <span class=\"comment\">//true </span></span><br></pre></td></tr></table></figure><br>在这个例子中，虚拟机进行了哪些操作呢？首先，因为在此s1我是直接使用了”abc”，那么系统会在String pool中创建了一个String对象,他的值就是”abc”，s2进行创建的时候，系统先搜索String pool中是否已经存在了”abc”，由于String pool中已经存在了一个”abc”的String对象，很好，系统直接将s2指向了String pool中的那个”abc”地址。所以下面两个输出都是true。<br>上面都是使用””来创建String对象的，第二个例子我们使用new来创建：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s3 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;abc&quot;</span>);   </span><br><span class=\"line\">String s4 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;abc&quot;</span>);   </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s3 == s4 : &quot;</span>+(s3==s4)); <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s3.equals(s4) : &quot;</span>+(s3.equals(s4))); <span class=\"comment\">//true </span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s1 == s3 : &quot;</span>+(s1==s3)); <span class=\"comment\">//false   </span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s1.equals(s3) : &quot;</span>+(s1.equals(s3))); <span class=\"comment\">//true  </span></span><br></pre></td></tr></table></figure><br>在这里，应当要提一点。对于new String来说，该构造函数的对象接收一个String字符串对象。其实这里进行了两件事情：</p>\n<p>步骤一：系统首先会创建一个String对象”abc”，通过String temp = “abc”来创建的（temp只是我自己取得名字，至于到底叫什么，我们是不用关心的），这个创建过程和第一个例子是一样的道理，他会在String pool去寻找’”abc”，然后根据有没有来判断是额外的创建还是直接用String pool中的那个”abc”。</p>\n<p>步骤二：new String接受了刚刚的temp参数以后，在堆上去创建一个对象，把刚刚的temp的值”abc”赋给这个在堆中的String对象的值。</p>\n<p>步骤三：把s3指向刚刚在堆中的这个String对象。</p>\n<p>通过以上的几步我们可以知道，使用new String完全没有直接使用=””来的快。</p>\n<p>s4的创建是同样的道理，所以s3、s4最终都各自指向了内容相同，地址不同的，在堆中的String对象。所以又由于==在对于对象的比较的时候是直接比较的引用的地址。所以第一、三个输出是false。但是equals对于String比较的是内容的是否相等，所以第二、四个输出true。</p>\n<p>接下来是第三种例子，String中 + 的重载：</p>\n<p>由于我们知道，常量的值在编译的时候就已经进行了优化了。所以这一行代码：</p>\n<p> String str1 = “ab” + “cd”;<br>在编译的时候就等价于优化过的</p>\n<p>String str1 = “abcd”;<br>所以执行下面这几行代码的时候，根据常量编译优化，加上我对于第一个例子的讲解，我们可以知道输出是true：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">&quot;ab&quot;</span> + <span class=\"string\">&quot;cd&quot;</span>;  <span class=\"comment\">//1个对象  </span></span><br><span class=\"line\">String str2 = <span class=\"string\">&quot;abcd&quot;</span>;   </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;str1 = str2 : &quot;</span>+ (str1 == str2));  <span class=\"comment\">//输出为true</span></span><br></pre></td></tr></table></figure><br>接下来就是第四种情形了，这种情况依然是String + 的重载，但是比起第三种是有本质的不同的。首先看代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str2 = <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\">String str3 = <span class=\"string\">&quot;cd&quot;</span>;                                       </span><br><span class=\"line\">String str4 = str2 + str3;                                        </span><br><span class=\"line\">String str5 = <span class=\"string\">&quot;abcd&quot;</span>;    </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;str4 = str5 : &quot;</span> + (str4 == str5));</span><br></pre></td></tr></table></figure><br>解读这一段代码，str2、str3就是情况一，我们不再讨论。此刻str4比起第三种的 + 两端都是String常量而言，这里是对于编译器来说是两个变量。这一个部分，系统会干什么呢？首先，系统会new 一个StringBuilder对象，然后调用该对象的append函数，把str2、str3按顺序连接起来。连接好以后，调用StringBuilder的toString方法，该方法内部new 一个String对象，并把它return。得到str2 + str3的结果，接着str4指向堆中的这个String对象。</p>\n<p>注意：对于StringBuilder的创建还有其他的情况。比如假设此处的String str4 = “ab” + “c” + str2 那么，编译器首先会进行一个优化，也就是第三种情况所说的他会优化为String str4 = “abc” + str2 然后，new StringBuilder(“abc”)，然后append(str2)。也就是说，从=号右边开始前部分，他首先会在编译过程判断能否进行优化，可以优化，由优化为最大的常量子串，然后new一个以该最大子串的为初始值的StringBuilder对象，然后再append。</p>\n<p>所以，在以上的这四条String创建语句中，创建了str2、str3、str5三个在String pool中的字符串常量，以及在系统内部进行append的StringBuilder，以及toString函数return的在堆中创建的String对象，一共五个对象。</p>\n<p>那么最终输出结果当然是false，前者是指向堆中的String对象的地址，而后者是S指向tring pool中String对象的地址。</p>\n<p>但是，还有一种变量情况是不一样的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> String str1 = <span class=\"string\">&quot;b&quot;</span>;  </span><br><span class=\"line\">String str2 = <span class=\"string\">&quot;a&quot;</span> + str1;  </span><br><span class=\"line\">String str3 = <span class=\"string\">&quot;ab&quot;</span>;  </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;str2 = str3 : &quot;</span>+ (str2 == str3)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure><br>这里按照情况四中注意部分来说，输出本来应该是false，但是为什么是true呢？注意看str1前面的修饰符，这里使用了final修饰符，final修饰的变量表示是一个常量，在创建额时候就需要初始化，并且不可修改。在final关键字的修饰下，编译器会在编译过程中就进行优化，其实这里的道理就和例子三是一样的了。这也是为什么这里输出的是true。</p>\n","categories":[],"tags":["Java","String"]},{"title":"修改MySql Root密码（包含忘记密码的方式）","url":"http://compilemind.com/2017/04/04/2017-04-04-修改MysqlRoot密码/","content":"<p>曾几何时，我也是记得MySQL root密码的人，想要修改root密码还不是轻而易举的事？下面前三种修改改方式都是在记得密码的情况下进行修改，如果你忘记了原本的root，请直接跳至 <strong>终极</strong></p>\n<a id=\"more\"></a>\n<p><strong>第一种：</strong><br>在MySQL中修改：mysql&gt; set password for root@localhost = password(‘新密码’);<br>当然，你也可以在root账户下去修改其他账户的密码，只需要将root换为其他账户即可<br>（注意：后面的localhost是指只能在本地登陆的账户，在修改其他账户密码时一定要对应其可登录范围修改@后面的字段属性）</p>\n<p><strong>第二种：</strong><br>直接进入mysql数据库中，修改user表中的root的password。<br>mysql&gt; use mysql;<br>mysql&gt; update user set password = password(‘新密码’) where user = ‘root’ and host = ‘localhost’;<br>(注意：这个host后面的东西的意义和上面一样)<br>mysql&gt; flush privileges; （记得刷新权限）</p>\n<p><strong>第三种：</strong><br>不要忘了mysqladmin<br><figure class=\"highlight plain\"><figcaption><span>-u root -p 123456 password 123``` 就行了</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">然而重点来了，在以上的几种方法，都是针对于我们还记得root用户密码。可是一开始就忘了root密码了怎么办？</span><br><span class=\"line\">**终极：**</span><br><span class=\"line\">1．首先确认服务器出于安全的状态，也就是没有人能够任意地连接MySQL数据库。</span><br><span class=\"line\"></span><br><span class=\"line\">2．修改MySQL的登录设置：</span><br><span class=\"line\">&#96;&#96;&#96;# vi &#x2F;etc&#x2F;my.cnf&#96;&#96;&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">在[mysqld]的段中加上一句：skip-grant-tables （这一句话表示，绕过所有的用户权限）</span><br><span class=\"line\">例如：</span><br></pre></td></tr></table></figure><br>[mysqld]<br>datadir=/var/lib/mysql<br>socket=/var/lib/mysql/mysql.sock<br>skip-grant-tables<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">保存并且退出vi。</span><br><span class=\"line\"></span><br><span class=\"line\">3．重新启动mysqld</span><br><span class=\"line\">&#96;&#96;&#96;service mysqld restart&#96;&#96;&#96;</span><br><span class=\"line\">好了，在此基础上，你就可以直接mysql进入数据库了</span><br><span class=\"line\"></span><br><span class=\"line\">4．登录并修改MySQL的root密码</span><br></pre></td></tr></table></figure><br>mysql<br>mysql&gt; USE mysql ;<br>mysql&gt; UPDATE user SET Password = password ( ‘新密码’ ) WHERE User = ‘root’ ;<br>mysql&gt; flush privileges ;<br>mysql&gt; quit<br>Bye</p>\n<pre><code>5．将MySQL的登录设置修改回来\n```# vi /etc/my.cnf\n</code></pre><p>将刚才在[mysqld]的段中加上的skip-grant-tables删除<br>保存并且退出vi。</p>\n<p>6．重新启动mysqld<br><code>service mysqld restart</code></p>\n<p>好了，重新使用新密码的root账户吧</p>\n","categories":[],"tags":["Mysql"]},{"title":"Java学习路线【转】","url":"http://compilemind.com/2017/02/21/2017-02-21-Java学习路线【转】/","content":"<a id=\"more\"></a>\n<ol>\n<li><strong>第一阶段：JavaSE（Java基础部分）</strong></li>\n</ol>\n<ul>\n<li>Java开发前奏<br>计算机基本原理，Java语言发展简史以及开发环境的搭建，体验Java程序的开发，环境变量的设置，程序的执行过程，相关反编译工具介绍，java开发工具Eclipse的安装和使用，javadoc的说明。</li>\n<li>Java基础语法<br>Java语法格式，常量和变量，变量的作用域，方法和方法的重载，运算符，程序流程控制，数组和操作数组的类，对数组循环遍历以及针对数组的常用查找、排序算法原理，最后使用Java程序进行功能实现。</li>\n<li>面向对象编程<br>理解对象的本质，以及面向对象，类与对象之间的关系，如何用面向对象的思想分析和解决显示生活中的问题，并java程序的手段编写出来。如何设计类，设计类的基本原则，类的实例化过程，类元素：构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类，Java的垃圾对象回收机制。对象的三大特性：封装、继承和多态。子类对象的实例化过程、方法的重写和重载、final关键字、抽象类、接口、继承的优点和缺点。 对象的多态性：子类和父类之间的转换、父类纸箱子类的引用、抽象类和接口在多态中的应用、多态优点。常用设计模式如单利、模版等模式。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用import关键字。</li>\n<li>多线程应用<br>多线程的概念，如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁问题的剖析。</li>\n<li>JavaAPI详解<br>JavaAPI介绍、String和StringBuffer、各种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。常用的集合类使用如下：Java Collections Framework：Collection、Set、List、ArrayList、Vector、LinkedList、Hashset、TreeSet、Map、HashMap、TreeMap、Iterator、Enumeration等常用集合类API。</li>\n<li>IO技术<br>什么是IO，File及相关类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应缓冲流和管道流，字节和字符的转化流，包装流，以及常用包装类使用，分析java的IO性能。</li>\n<li>网络编程<br>Java网络编程，网络通信底层协议TCP/UDP/IP，Socket编程。网络通信常用应用层协议简介：HTTP、FTP等，以及WEB服务器的工作原理。</li>\n<li>Java高级特性<br>递归程序，Java的高级特性：反射、代理和泛型、枚举、Java正则表达式API详解及其应用。</li>\n</ul>\n<ol>\n<li><strong>第二阶段：数据库技术</strong></li>\n</ol>\n<ul>\n<li>ORACLE基础管理<br>Oracle背景简介，数据库的安装，数据库的用户名和密码，客户端登录数据库服务SQLPLUS，数据库基本概。</li>\n<li>SQL语句<br>数据库的创建，表的创建，修改，删除，查询，索引的创建，主从表的建立，数据控制授权和回收，事务控制，查询语句以及运算符的详解，sql中的函数使用。</li>\n<li>多表连接和字查询<br>等值和非等值连接，外连接，自连接；交叉连接，自然连接，using子句连接，完全外连接和左右外连接，子查询使用以及注意事项。</li>\n<li>触发器、存储过程<br>触发器和存储过程使用场合， 通过实例进行详解。</li>\n<li>数据库设计优化<br>WHERE子句中的连接顺序，选择最有效率的表名顺序，SELECT子句中避免使用 ‘ * ’计算记录条数等等。</li>\n<li>数据备份与移植<br>移植技巧，备份方案；导入导出等。</li>\n</ul>\n<ol>\n<li><strong>第三阶段：JDBC技术</strong></li>\n</ol>\n<ul>\n<li>JDBC基础<br>JDBC Connection、Statement、PreparedStatement、CallableStatement、ResultSet等不同类的使用。</li>\n<li>连接池技术<br>了解连接池的概念，掌握连接池的建立、治理、关闭和配置。</li>\n<li>ORM与DAO封装<br>对象关系映射思想，JDBC的DAO封装，实现自己的JDBC。</li>\n</ul>\n<ol>\n<li><strong>第四阶段：WEB基础技术</strong></li>\n</ol>\n<ul>\n<li>XML技术<br>使用jdom和dom4j来对xml文档的解析和生成操作，xml的作用和使用场合。</li>\n<li>HTML/CSS<br>Java掌握基本的html标签的格式和使用，css层叠样式表对div的定义，实现对网站布局的基本实现。</li>\n<li>JavaScript<br>了解javascript的基本语法以及相关函数的使用，并结合html页面实现流程控制和页面效果展示。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用import关键字。</li>\n<li>JSP/Servlet<br>Servlet和JSP技术、上传下载、Tomcat服务器技术、servlet过滤器和监听器。</li>\n<li>JSTL与EL<br>JSTL核心标签库、函数标签库、格式化标签库、自定义标签技术、EL表达式在jsp页面的使用。</li>\n<li>AJAX及框架技术<br>AJAX框架Jquery渲染页面效果和相关的强大的第三方类库，dwr如何和后台服务进行数据传输，以及页面逻辑控制等。</li>\n<li>JSON高级应用<br>Java使用JSON支持的方式对字符串进行封装和解析，实现页面和Java后台服务的数据通信。</li>\n<li>Fckeditor编辑器<br>FCKEditor在线编辑器技术、配置、处理图片和文件上传。</li>\n<li>JavaMail技术<br>了解域名解析与MX记录、电子邮件工作原理、邮件传输协议：SMTP、POP3、IMAP、邮件组织结构：RFC822邮件格式、MIME协议、邮件编码、复合邮件结构分析、JavaMail API及其体系结构、编程创建邮件内容：简单邮件内容、包含内嵌图片的复杂邮件、包含内嵌图片和附件的复杂邮件。</li>\n<li>JfreeChart报表<br>统计报表；图表处理。</li>\n<li>BBS项目实战<br>采用Jquery+dwr+jsp+servlet+Fckeditor+JfreeChart+tomcat+jdbc(oracle)完成BBS项目的实战。学完此实战你至少已经是拥有近1年开发经验的程序员了，但是你不应该满足现状，继续下去！</li>\n</ul>\n<ol>\n<li><strong>第五阶段：WEB主流框架技术（项目实战）</strong></li>\n</ol>\n<ul>\n<li>Struts2.x<br>struts2框架的工作原理和架构分析，struts-default.xml与default.properties文件的作用，struts。Xml中引入多个配置文件。OGNL表达式、Struts2 UI和非UI标签、输入校验、使用通配符定义action、动态方法调用、多文件上传、自定义类型转换器、为Action的属性注入值、自定义拦截器、异常处理、使用struts2实现的CRUD操作的案例。</li>\n<li>Hibernate<br>Hibernate应用开发基础； ORM基础理论； 关系映射技术； 性能调优技术； 性能优化 一级缓存 二级缓存 查询缓存 事务与并发 悲观锁、乐观锁。</li>\n<li>Spring4.x<br>Spring IoC技术；Spring AOP技术；Spring声明事务管理；Spring常用功能说明，spring4.x的新特性，Spring整合Struts2和Hibernate3的运用。</li>\n<li>Log4j与Junit<br>Logging API；JUnit单元测试技术； 压力测试技术：badboy进行测试计划跟踪获取以及JMeter压力测试。</li>\n<li>在线支付技术<br>完成支付宝的支付接口的在线支付功能。</li>\n<li>电子商务网站实战<br>采用Spring4.x + Hibernate3 + Struts2 + Jquery + dwr + FckEditor + Tomcat完成电子商务网站实战开发。</li>\n</ul>\n<ol>\n<li><strong>第六阶段：WEB高级进阶（项目实战）</strong></li>\n</ol>\n<ul>\n<li>OpenJPA技术<br>JPA介绍及开发环境搭建、单表实体映射、一对多/多对一、一对一、多对多关联、实体继承、复合主键、JPQL语句、EntityManager API、事务管理，了解一下jpa2.0的新特性以及应用。</li>\n<li>Lucene搜索引擎<br>了解全文搜索原理、全文搜索引擎、什么是OSEM、OSEM框架Compass、基于使用Lucene使用Compass实现全文增量型索引创建和搜索、探索Lucene 3.0以及API。</li>\n<li>电子商务重构<br>此项目采用了Lucene+compass+openJpa+上一版电子商务网站的技术进行重构。</li>\n<li>Excel/PDF文档处理技术<br>Java对Excel和pdf文档分别利用poi和itext来进行解析和生成。此技术在企业级系统的报表中经常使用。</li>\n<li>OA工作流技术JBPM<br>工作流是什么、JBPM介绍、JBPM的主要用法、各类节点的用法、任务各种分派方式、JBPM的整体架构原理、工作流定义模型分析、运行期工作流实例模型分析、数据库表模型分析、流程定义管理、流程实例监控、对JBPM的相关接口进行封装，构建自己的工作流应用平台等。</li>\n<li>WebService技术<br>WebService技术原理、WebService技术的应用、Soap服务的创建与管理、WSDL描述文档规范、UDDI注册中心运行原理;使用Axis和Xfire创建WEB服务、Webservice客户端的编写、使用TCPMonitor监听SOAP协议、异构平台的整合。</li>\n<li>Linux操作系统<br>Linux系统安装，卸载、linux使用的核心思想、Linux下的用户管理，文件管理,系统管理、程序的安装，使用，卸载。Linux下作为server的基本应用：web服务器，j2ee服务器，ftp服务器的安装和项目的部署。</li>\n<li>CRM项目实战<br>此项目能了解和熟悉客户关系管理的基本流程以及功能的实现，采用上面几个阶段学到的主流框架实现，同时加入了JBPM的技术。！</li>\n</ul>\n<ol>\n<li><strong>第七阶段：大型高并发网站优化解决（项目实战）</strong></li>\n</ol>\n<ul>\n<li>如何构建一个高性能网站详解<br>什么样的网站需要高性能，高性能的指标体系，构建高性能网站需要做哪些工作，注意哪些细节。</li>\n<li>SSI技术<br>什么是SSI，使用他有什么好处，什么样的系统才使用SSI，SSI技术详解和使用，应用到项目中。</li>\n<li>静态页面生成技术<br>什么是静态页，为什么需要静态页以及带来的好处，生成静态页的模版技术Velocity和Freemark，生成静态页的访问规则等。</li>\n<li>缓存技术<br>为什么使用缓存技术，oscache缓存技术的介绍和使用，memcached缓存技术的介绍和使用、两者缓存技术的比较和如何去使用。</li>\n<li>经典WEb服务器<br>什么是web服务器，什么是JavaWeb服务器，他们存在什么关系，当前技术主流中常用的Web服务器有哪些，WEB服务器Apache和Nginx的应用。</li>\n<li>Nginx架构实战<br>什么是反向代理，负载均衡以及集群，在Nginx中如何实现这些高性能的系统架构。</li>\n</ul>\n","categories":[],"tags":["Java"]},{"title":"about","url":"http://compilemind.com/about/index.html","content":"<h1 id=\"ZHEN\"><a href=\"#ZHEN\" class=\"headerlink\" title=\"ZHEN\"></a>ZHEN</h1><p>1996 Spring</p>\n<p>常用语言：Java、JS、C#</p>\n<p>技术爱好：Java、Scala、C#、JS，喜欢Linux，喜欢VIM，喜欢编译原理</p>\n<p>现居地：成都</p>\n","categories":[],"tags":[]},{"title":"search","url":"http://compilemind.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://compilemind.com/tags/index.html","content":"","categories":[],"tags":[]}]