[{"title":"低代码平台前端的设计与实现（一） 渲染模块的基本实现","url":"http://compilemind.com/2022/09/18/2022-09-18-低代码平台设计与实现（一）渲染模块的基本实现/","content":"<p>这两年低代码平台的话题愈来愈火，一眼望去全是关于低代码开发的概念，鲜有关于低代码平台的设计实现。本文将以实际的代码入手，逐步介绍如何打造一款低开的平台。</p>\n<p>低开概念我们不再赘述，但对于低开的前端来说，至少要有以下3个要素：</p>\n<ol>\n<li>使用能被更多用户（甚至不是开发人员）容易接受的DSL（领域特定语言），用以描述页面结构以及相关UI上下文。</li>\n<li>内部具有渲染引擎，用以渲染DSL JSON到实际页面元素。</li>\n<li>提供设计器（Designer）支持以拖拉拽方式来快速处理DSL，方便用户快速完成页面设计。</li>\n</ol>\n<p>本文我们首先着眼于如何进行渲染，后面的文章我们再详细介绍设计器的实现思路。</p>\n<h1 id=\"DSL\"><a href=\"#DSL\" class=\"headerlink\" title=\"DSL\"></a>DSL</h1><p>对于页面UI来说，我们总是可以将界面通过树状结构进行描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 页面</span><br><span class=\"line\">    1-1. 标题</span><br><span class=\"line\">       1-1-1. 文字</span><br><span class=\"line\">    1-2. 内容面板</span><br><span class=\"line\">       1-2-1. 一个输入框</span><br></pre></td></tr></table></figure>\n<p>如果采用xml来描述，可以是如下的形式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">page</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>标题文字<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">content</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">input</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">content</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">page</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当然，xml作为DSL有以下的两个问题：</p>\n<ol>\n<li>内容存在<strong>较大的信息冗余</strong>（page标签、title标签，都有重复的字符）。</li>\n<li>前端需要<strong>引入单独处理xml的库</strong>。</li>\n</ol>\n<p>自然，我们很容易想到另一个数据描述方案：JSON。使用JSON来描述上述的页面，我们可以如下设计：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;page&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;children&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;title&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;value&quot;</span>: <span class=\"string\">&quot;标题文字&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;content&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;children&quot;</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;input&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初看JSON可能觉得内容比起xml更多，但是在前端我们拥有原生处理JSON的能力，这一点就很体现优势。</p>\n<p>回顾一下JSON的方案，我们首先定义一个基本的数据结构：元素节点（<code>ElementNode</code>），它至少有如下的内容：</p>\n<ol>\n<li><strong>type</strong>属性：表明当前节点所属的类型。</li>\n<li><strong>children</strong>属性：一个数组，存放所有的子节点。</li>\n<li><strong>额外</strong>属性：额外剩余的属性，可以应用到当前type，产生作用。</li>\n</ol>\n<p>例如，对于一个页面（<code>page</code>），该页面有一个属性配置背景色（<code>backgroundColor</code>），该页面中有一个按钮（<code>button</code>），并且该按钮有一个属性配置按钮的尺寸（<code>size</code>），此外还有一个输入框（<code>input</code>）。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;page&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;backgroundColor&quot;</span>: <span class=\"string\">&quot;pink&quot;</span>, <span class=\"comment\">// page的 backgroundColor 配置</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;children&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;button&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;size&quot;</span>: <span class=\"string\">&quot;blue&quot;</span> <span class=\"comment\">// button的size配置</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;input&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在我们的平台中，我们定义如下的结构：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> ElementNode &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Element 唯一类型type</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 组件的各种属性：</span></span><br><span class=\"line\"><span class=\"comment\">     * 扩展的、UI的</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    [props: <span class=\"built_in\">string</span>]: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">any</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Element 的所有子元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    children?: ElementNode[]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构建与渲染\"><a href=\"#构建与渲染\" class=\"headerlink\" title=\"构建与渲染\"></a>构建与渲染</h1><p>上文定义了我们低开平台的DSL，但是数据如果没有渲染在界面上，是没有任何意义的。我们必须要有渲染引擎支持将JSON转换为web页面的内容。</p>\n<h2 id=\"类型渲染器（TypeRenderer）\"><a href=\"#类型渲染器（TypeRenderer）\" class=\"headerlink\" title=\"类型渲染器（TypeRenderer）\"></a>类型渲染器（TypeRenderer）</h2><p>首先我们需要定义基本的渲染器：<code>TypeRenderer</code>。其作用是和<code>ElementNode.type</code>相绑定，一个type对应一个renderer。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;ReactNode&#125; from &quot;react&quot;;</span><br><span class=\"line\">import &#123;ElementNode&#125; from &quot;.&#x2F;ElementNode&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 渲染器渲染上下文，至少包含ElementNode的相关数据</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">export interface TypeRendererContext &#123;</span><br><span class=\"line\">    elementNode: Omit&lt;ElementNode, &#39;&#39;&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 绑定Type的渲染器</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">export interface TypeRenderer &#123;</span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 根据ElementNode上下文信息，得到JXS.Element，供React渲染</span><br><span class=\"line\">     * @param rendererContext 渲染器接受的数据上下文</span><br><span class=\"line\">     * @param childrenReactNode 已经完成渲染的子节点的ReactNode</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    render(</span><br><span class=\"line\">        rendererContext: TypeRendererContext,</span><br><span class=\"line\">        childrenReactNode?: ReactNode[],</span><br><span class=\"line\">    ): JSX.Element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * TypeRenderer构造函数类型</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">export type TypeRendererConstructor &#x3D; new (args: any) &#x3D;&gt; TypeRenderer;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里的<code>TypeRenderer</code>只是接口抽象，具体的实现，是需要根据type来创建对应的renderer实例。</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-18/010-TypeRenderer-flow.png\" alt=\"010-TypeRenderer-flow\"></p>\n<p>这里我们先简单实现page、button和input：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; type &#x3D; &#39;page&#39;的renderer，使用div作为实际组件</span><br><span class=\"line\">export class PageRenderer implements TypeRenderer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    render(rendererContext: TypeRendererContext,</span><br><span class=\"line\">           childrenReactNode?: ReactNode[]): JSX.Element &#123;</span><br><span class=\"line\">        const style: CSSProperties &#x3D; &#123;</span><br><span class=\"line\">            width: &#39;100%&#39;,</span><br><span class=\"line\">            height: &#39;100%&#39;,</span><br><span class=\"line\">            padding: &#39;10px&#39;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; 对于type &#x3D; &#39;page&#39;，就是用一个div进行渲染</span><br><span class=\"line\">        &#x2F;&#x2F; 注意，对于容器类组件，始终需要将传入的子元素放到对应的位置，控制子元素的展示</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div style&#x3D;&#123;style&#125;&gt;</span><br><span class=\"line\">                &#123;childrenReactNode&#125;</span><br><span class=\"line\">            &lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; type &#x3D; &#39;button&#39;的renderer，使用antd的Button作为实际组件</span><br><span class=\"line\">export class ButtonRenderer implements TypeRenderer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    render(rendererContext: TypeRendererContext,</span><br><span class=\"line\">           childrenReactNode?: ReactNode[]): JSX.Element &#123;</span><br><span class=\"line\">        const &#123;elementNode &#x3D; &#123;&#125;&#125; &#x3D; rendererContext;</span><br><span class=\"line\">        const &#123;text &#x3D; &#39;button&#39;&#125; &#x3D; elementNode;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;Button</span><br><span class=\"line\">                type&#x3D;&#39;primary&#39;&gt;</span><br><span class=\"line\">                &#123;text&#125;</span><br><span class=\"line\">            &lt;&#x2F;Button&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; type &#x3D; &#39;input&#39;的renderer，使用antd的Input作为实际组件</span><br><span class=\"line\">export class InputRenderer implements TypeRenderer &#123;</span><br><span class=\"line\">    render(rendererContext: TypeRendererContext,</span><br><span class=\"line\">           childrenReactNode?: ReactNode[]): JSX.Element &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;Input&#x2F;&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，每个renderer具体返回的组件，都可以任意根据要求进行定制开发，后续我们会深入介绍这一块的内容。但需要再次强调，正如上面<code>PageRenderer</code>中的注释一样，<strong>对于容器类组件，需要将<code>childrenReactNode</code>放到对应的节点位置，才能正常渲染所有的子元素。</strong></p>\n<p>实现了renderer以后，为了方便管理，我们使用一个所谓的TypeRendererManager（渲染器管理器）来管理我们定义的所有的TypeRenderer：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;TypeRenderer, TypeRendererConstructor&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./TypeRenderer&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;PageRenderer&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./impl/PageRenderer&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ButtonRenderer&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./impl/ButtonRenderer&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;InputRenderer&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./impl/InputRenderer&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * TypeRenderer管理器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> TypeRendererManager &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单实例</span></span><br><span class=\"line\"><span class=\"comment\">     * @private</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> instance: TypeRendererManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 内存单例获取</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> getInstance(): TypeRendererManager &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!TypeRendererManager.instance) &#123;</span><br><span class=\"line\">            TypeRendererManager.instance = <span class=\"keyword\">new</span> TypeRendererManager();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TypeRendererManager.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单例，构造函数private控制</span></span><br><span class=\"line\"><span class=\"comment\">     * @private</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里记录了目前所有的TypeRenderer映射，</span></span><br><span class=\"line\"><span class=\"comment\">     * 后续可以优化为程序进行扫描实现，不过是后话了</span></span><br><span class=\"line\"><span class=\"comment\">     * @private</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> typeRendererConstructors: Record&lt;<span class=\"built_in\">string</span>, TypeRendererConstructor&gt; = &#123;</span><br><span class=\"line\">        page: PageRenderer,</span><br><span class=\"line\">        button: ButtonRenderer,</span><br><span class=\"line\">        input: InputRenderer</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据元素类型得到对应渲染器</span></span><br><span class=\"line\"><span class=\"comment\">     * @param elementType</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    getTypeRenderer(elementType: <span class=\"built_in\">string</span>): TypeRenderer &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.typeRendererConstructors.hasOwnProperty(elementType)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;找不到处理&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 采用ES6的Reflect反射来处理对象创建，供后续扩展优化</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.construct(<span class=\"built_in\">this</span>.typeRendererConstructors[elementType], [])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">    TypeRendererManager</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"渲染引擎（RenderEngine）\"><a href=\"#渲染引擎（RenderEngine）\" class=\"headerlink\" title=\"渲染引擎（RenderEngine）\"></a>渲染引擎（RenderEngine）</h2><p>接下来是实现我们的渲染引擎（<code>RenderEngine</code>，叫引擎高大上）。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;ElementNode&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ElementNode&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;TypeRendererManager&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./TypeRendererManager&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 渲染引擎</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> RenderEngine &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构建：通过传入ElementNode信息，得到该节点对应供React渲染的ReactNode</span></span><br><span class=\"line\"><span class=\"comment\">     * @param rootEleNode</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    build(rootEleNode: ElementNode): JSX.Element | <span class=\"literal\">undefined</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.innerBuild(rootEleNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构建：通过传入ElementNode信息，得到该节点对应供React渲染的ReactNode</span></span><br><span class=\"line\"><span class=\"comment\">     * @param rootEleNode</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> innerBuild(rootEleNode: ElementNode): JSX.Element | <span class=\"literal\">undefined</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!rootEleNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">type</span>, children&#125; = rootEleNode;</span><br><span class=\"line\">        <span class=\"comment\">// 通过 typeRendererManager 来统一查找对应ElementType的Renderer</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> typeRenderer = TypeRendererManager.getInstance().getTypeRenderer(<span class=\"keyword\">type</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!typeRenderer) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.warn(<span class=\"string\">`找不到type=&quot;<span class=\"subst\">$&#123;<span class=\"keyword\">type</span>&#125;</span>&quot;的renderer`</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 递归调用自身，获取子元素处理后的ReactNode</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> childrenReactNode =</span><br><span class=\"line\">            (children || []).map(<span class=\"function\">(<span class=\"params\">childEleNode</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.innerBuild(childEleNode)</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> reactNode = typeRenderer.render(</span><br><span class=\"line\">            &#123;elementNode: rootEleNode&#125;,</span><br><span class=\"line\">            childrenReactNode</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reactNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目前的代码并不复杂，流程如下：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-18/020-RenderEngine-handle-flow-v1.png\" alt=\"020-RenderEngine-handle-flow-v1\"></p>\n<p>需要注意，这个Engine的公共API是build，由外部调用，仅需要传入根节点ElementNode即可得到整个节点数的UI组件树。但是为了后续我们优化内部的API结构，我们内部使用innerBuild作为内部处理的实际方法。</p>\n<h2 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h2><p>建立一个样例项目，编写一个简单的样例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const renderEngine &#x3D; new RenderEngine();</span><br><span class=\"line\"></span><br><span class=\"line\">export function SimpleExample() &#123;</span><br><span class=\"line\">    const [elementNodeJson, setElementNodeJson] &#x3D; useState(JSON.stringify(&#123;</span><br><span class=\"line\">        &quot;type&quot;: &quot;page&quot;,</span><br><span class=\"line\">        &quot;backgroundColor&quot;: &quot;pink&quot;, &#x2F;&#x2F; page的 backgroundColor 配置</span><br><span class=\"line\">        &quot;children&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;type&quot;: &quot;button&quot;,</span><br><span class=\"line\">                &quot;size&quot;: &quot;blue&quot; &#x2F;&#x2F; button的size配置</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;type&quot;: &quot;input&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;, null, 2))</span><br><span class=\"line\"></span><br><span class=\"line\">    const onChange &#x3D; (e: ChangeEvent&lt;HTMLTextAreaElement&gt;) &#x3D;&gt; &#123;</span><br><span class=\"line\">        const value &#x3D; e.target.value;</span><br><span class=\"line\">        setElementNodeJson(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    let reactNode;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        const eleNode &#x3D; JSON.parse(elementNodeJson);</span><br><span class=\"line\">        reactNode &#x3D; renderEngine.build(eleNode);</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 序列化出异常，返回JSON格式出错</span><br><span class=\"line\">        reactNode &#x3D; &lt;div&gt;JSON格式出错&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div style&#x3D;&#123;&#123;width: &#39;100%&#39;, height: &#39;100%&#39;, padding: &#39;10px&#39;&#125;&#125;&gt;</span><br><span class=\"line\">            &lt;div style&#x3D;&#123;&#123;width: &#39;100%&#39;, height: &#39;calc(50%)&#39;&#125;&#125;&gt;</span><br><span class=\"line\">                &lt;Input.TextArea</span><br><span class=\"line\">                    autoSize&#x3D;&#123;&#123; minRows: 2, maxRows: 10 &#125;&#125;</span><br><span class=\"line\">                    value&#x3D;&#123;elementNodeJson&#125; onChange&#x3D;&#123;onChange&#125;&#x2F;&gt;</span><br><span class=\"line\">            &lt;&#x2F;div&gt;</span><br><span class=\"line\">            &lt;div style&#x3D;&#123;&#123;width: &#39;100%&#39;, height: &#39;calc(50%)&#39;, border: &#39;1px solid gray&#39;&#125;&#125;&gt;</span><br><span class=\"line\">                &#123;reactNode&#125;</span><br><span class=\"line\">            &lt;&#x2F;div&gt;</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-18/030-simple-example-show.gif\" alt=\"030-simple-example-show\"></p>\n<h2 id=\"设计优化\"><a href=\"#设计优化\" class=\"headerlink\" title=\"设计优化\"></a>设计优化</h2><h3 id=\"路径设计\"><a href=\"#路径设计\" class=\"headerlink\" title=\"路径设计\"></a>路径设计</h3><p>目前为止，我们已经设计了一个简单的渲染引擎。但是还有两个需要解决的问题：</p>\n<ol>\n<li>循环创建的ReactNode数组没有添加key，会导致渲染性能问题。</li>\n<li>渲染的过程中，无法定位当前ElementNode的所在位置。</li>\n</ol>\n<p>我们先讨论问题2。对于该问题具体是指：<strong>TypeRenderer.render方法接受的入参可以知道当前ElementNode节点自身的信息，但是却无法知道ElementNode所在的位置具体处于整体ElementNode的哪个位置。</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;page&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;children&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;panel&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;children&quot;</span>: [</span><br><span class=\"line\">                &#123;    </span><br><span class=\"line\">                    <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;input&quot;</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;button&quot;</span>,</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;    </span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;input&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于上述的每一个type，都应当有其标志其唯一的一个key。可以知道，每一个元素的路径是唯一的：</p>\n<ul>\n<li>page：/page</li>\n<li>panel：/page/panel@0</li>\n<li>第一个input：/page/panel@0/input@0。page下面有个panel（面板）元素，位于page的子节点第0号位置（基于0作为起始）。panel下面有个input元素，位于panel的子节点第0号位置。</li>\n<li>button：/page/panel@0/button@1</li>\n<li>第二个input：/page/input@1</li>\n</ul>\n<p>也就是说，路径由<code>&#39;/&#39;</code>拼接，每一级路径由<code>&#39;@&#39;</code>分割type和index，type表明该节点类型，index表明该节点处于上一级节点（也就是父级节点）的children数组的位置（基于0起始）。</p>\n<p>那么，如何生成这样一个路径信息呢？逐级遍历ElementNode即可。其实遍历的这个动作，我们已经在之前渲染引擎的innerBuild地方进行过了（递归），现在只需要进行简单的修改方法：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RenderEngine.ts代码</span><br><span class=\"line\"><span class=\"deletion\">-    private innerBuild(rootEleNode: ElementNode): JSX.Element | undefined &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+    private innerBuild(rootEleNode: ElementNode, path: string): JSX.Element | undefined &#123;</span></span><br><span class=\"line\">         if (!rootEleNode) &#123;</span><br><span class=\"line\">             return undefined;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">// ... ...</span><br><span class=\"line\">         // 递归调用自身，获取子元素处理后的ReactNode</span><br><span class=\"line\">         const childrenReactNode =</span><br><span class=\"line\"><span class=\"deletion\">-            (children || []).map((childEleNode) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"deletion\">-                return this.innerBuild(childEleNode)</span></span><br><span class=\"line\"><span class=\"addition\">+            (children || []).map((childEleNode, index) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+                // 子元素路径：</span></span><br><span class=\"line\"><span class=\"addition\">+                // 父级路径（也就是当前path）+ &#x27;/&#x27; + 子元素类型 + 子元素所在索引</span></span><br><span class=\"line\"><span class=\"addition\">+                const childPath = `$&#123;path&#125;/$&#123;childEleNode.type&#125;@$&#123;index&#125;`;</span></span><br><span class=\"line\"><span class=\"addition\">+                return this.innerBuild(childEleNode, childPath)</span></span><br><span class=\"line\">             &#125;);</span><br><span class=\"line\">         const reactNode = typeRenderer.render(</span><br><span class=\"line\">             &#123;elementNode: rootEleNode&#125;,</span><br><span class=\"line\">// ... ...</span><br></pre></td></tr></table></figure>\n<p>首先，我们修改了innerBuild方法入参，增加了参数<code>path</code>，用以表示当前节点所在的路径；其次，在生成子元素ReactNode的地方，将<code>path</code>作为基准，根据上述规则<code>&quot;$&#123;elementType&#125;@$&#123;index&#125;&quot;</code>，来生成子元素节点的路径，并传入到的递归调用的innerBuild中。</p>\n<p>当然，build内部调用innerBuild的时候，需要构造一个起始节点的path，传入innerBuild。</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RenderEngine.ts代码</span><br><span class=\"line\">     build(rootEleNode: ElementNode): JSX.Element | undefined &#123;</span><br><span class=\"line\"><span class=\"deletion\">-        return this.innerBuild(rootEleNode);</span></span><br><span class=\"line\"><span class=\"addition\">+        // 起始节点，需要构造一个起始path传入innerBuild</span></span><br><span class=\"line\"><span class=\"addition\">+        // 注意，根节点由于不属于某一个父级的子元素，所以不存在&#x27;@$&#123;index&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"addition\">+        return this.innerBuild(rootEleNode, &#x27;/&#x27; + rootEleNode.type);</span></span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<p>另外，为了让每一个renderer能够获取到需要渲染的ElementNode的路径信息这个上下文，我们在TypeRendererContext中添加path属性：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> export interface TypeRendererContext &#123;</span><br><span class=\"line\"><span class=\"addition\">+    /**</span></span><br><span class=\"line\"><span class=\"addition\">+     * path：让每个TypeRenderer知道当前渲染的元素所在的路径</span></span><br><span class=\"line\"><span class=\"addition\">+     */</span></span><br><span class=\"line\"><span class=\"addition\">+    path: string;</span></span><br><span class=\"line\">     elementNode: Omit&lt;ElementNode, &#x27;&#x27;&gt;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>同时，innerBuild中也要进行一定的修改，需要在调用<code>TypeRender.render</code>方法的时候把path传入：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        // innerBuild函数</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">        const reactNode = typeRenderer.render(</span><br><span class=\"line\"><span class=\"deletion\">-            &#123;elementNode: rootEleNode&#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+            &#123;path: path, elementNode: rootEleNode&#125;,</span></span><br><span class=\"line\">            childrenReactNode</span><br><span class=\"line\">        )</span><br><span class=\"line\">        // ...</span><br></pre></td></tr></table></figure>\n<p>这样一来，每个renderer的render方法里面，都可以从RenderContext中获取到当前实际渲染的ElementNode唯一具体路径path。在后续的优化中，我们就可以利用该path做一些事情了。</p>\n<p>现在，如何处理<strong>问题1：key值未填写</strong>的问题呢？其实，当我们解决了问题2以后，我们现在知道path是唯一的，那么我们可以将path作为每个元素的key，例如：</p>\n<p>Button渲染器：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export class ButtonRenderer implements TypeRenderer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     render(rendererContext: TypeRendererContext,</span><br><span class=\"line\">            childrenReactNode?: ReactNode[]): JSX.Element &#123;</span><br><span class=\"line\"><span class=\"deletion\">-        const &#123;elementNode = &#123;&#125;&#125; = rendererContext;</span></span><br><span class=\"line\"><span class=\"addition\">+        const &#123;path, elementNode = &#123;&#125;&#125; = rendererContext;</span></span><br><span class=\"line\">         const &#123;text = &#x27;button&#x27;&#125; = elementNode;</span><br><span class=\"line\">         return (</span><br><span class=\"line\">             &lt;Button</span><br><span class=\"line\"><span class=\"addition\">+                key=&#123;path&#125;</span></span><br><span class=\"line\">                 type=&#x27;primary&#x27;&gt;</span><br><span class=\"line\">                 &#123;text&#125;</span><br><span class=\"line\">             &lt;/Button&gt;)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Input渲染器：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> export class InputRenderer implements TypeRenderer&#123;</span><br><span class=\"line\">     render(rendererContext: TypeRendererContext,</span><br><span class=\"line\">            childrenReactNode?: ReactNode[]): JSX.Element &#123;</span><br><span class=\"line\"><span class=\"addition\">+        const &#123;path&#125; = rendererContext;</span></span><br><span class=\"line\">         return (</span><br><span class=\"line\"><span class=\"deletion\">-            &lt;Input /&gt;</span></span><br><span class=\"line\"><span class=\"addition\">+            &lt;Input key=&#123;path&#125;/&gt;</span></span><br><span class=\"line\">         )</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>我们只需要将所有的组件使用path作为key即可</strong>。</p>\n<h1 id=\"关于构建与渲染的总结\"><a href=\"#关于构建与渲染的总结\" class=\"headerlink\" title=\"关于构建与渲染的总结\"></a>关于构建与渲染的总结</h1><p>目前为止，我们设计了一套十分精简的渲染引擎，以一套基于antd组件的组件渲染器，通过接受JSON，渲染出对应结构的页面。该渲染器需要考虑，渲染时候元素的上下文，所以在遍历元素节点的时候，需要把相关的上下文进行封装并交给对应的渲染用于自行处理。当然，渲染部分还有很多很多的处理以及各种基本UI元素的创建还有很多的方法（譬如CDN挂载基础类型等），但是基于本系列，我们由浅入深逐步建立整个低代码平台。下篇文章，笔者将开始介绍设计器Designer的实现。</p>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><p>本章内容对应代码已经推送到github上</p>\n<p><a href=\"https://github.com/w4ngzhen/light-lc\">w4ngzhen/light-lc (github.com)</a></p>\n<p>main分支与最新文章同步，chapterXX对应本系列的第几章，本文在分支chapter01上体现。</p>\n<p>且按照文章里各段介绍顺序完成了提交：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modify: use &#39;path&#39; as key for component.</span><br><span class=\"line\">0535765 modify: add path info for innerBuild.</span><br><span class=\"line\">9d1007b add: SimpleExample.</span><br><span class=\"line\">7658f83 add: root index.ts for exporting all types and instance.</span><br><span class=\"line\">74f9089 add: RenderEngine for build UI component.</span><br><span class=\"line\">3bc90cb add: TypeRendererManager for managing all TypeRenderer instance.</span><br><span class=\"line\">42083f4 add: TypeRenderer and implements.</span><br><span class=\"line\">be4d31f add: ElementNode 映射schema节点.</span><br><span class=\"line\">d62f830 init config for project</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["low-code","render"]},{"title":"使用CEF（五）— 在QT中集成CEF（2）基于CLion+CMake搭建环境","url":"http://compilemind.com/2022/09/12/2022-09-12-使用CEF（五）— 在QT中集成CEF（2）基于CLion+CMake搭建环境/","content":"<p>在前文《使用CEF（四）— 在QT中集成CEF（1）：基本集成》中，我们使用VS+QT的插件搭建了一个基于QT+CEF的项目。时过境迁，笔者目前用的最多的就是CLion+CMake搭建C/C++项目，并且CLion提供了对C/C++强大的开发环境。此外，也想将CMake搭建QT项目作为一次实践，故由此文。</p>\n<a id=\"more\"></a>\n<h1 id=\"基础环境\"><a href=\"#基础环境\" class=\"headerlink\" title=\"基础环境\"></a>基础环境</h1><ul>\n<li>QT 5.14.2</li>\n<li>CEF 105.3.33以及对应版本wrapper（<strong>特别注意，wrapper以动态库（MD）版本进行编译</strong>。为了方便更多的开发者了解如何编译，我做了一个<a href=\"https://www.bilibili.com/video/BV1GV4y1u7KM\">视频</a>，视频是MT版本，请读者自行修改配置。）</li>\n<li>CMake 3.24-rc5</li>\n<li>VS2019</li>\n</ul>\n<h1 id=\"工程搭建\"><a href=\"#工程搭建\" class=\"headerlink\" title=\"工程搭建\"></a>工程搭建</h1><p>创建<code>QtCefCMakeDemo</code>文件夹，将基础环境提到的CEF的wrapper编译产物（<code>libcef_dll_wrapper</code>）+CEF相关库文件（<code>libcef</code>）、资源文件（<code>*.pak</code>）放置于<code>QtCefCMakeDemo/CefFiles</code>中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QtCefCMakeDemo</span><br><span class=\"line\"> └─ CefFiles</span><br><span class=\"line\">    ├─bin</span><br><span class=\"line\">    │  ├─Debug</span><br><span class=\"line\">    │  │  │  ...</span><br><span class=\"line\">    │  │  │  libcef.dll</span><br><span class=\"line\">    │  │  │  libcef.lib</span><br><span class=\"line\">    │  │  │  libcef_dll_wrapper.lib</span><br><span class=\"line\">    │  │  │  ...</span><br><span class=\"line\">    │  │  │</span><br><span class=\"line\">    │  │  └─swiftshader</span><br><span class=\"line\">    │  │          ...</span><br><span class=\"line\">    │  │</span><br><span class=\"line\">    │  └─Release</span><br><span class=\"line\">    │      │  ...</span><br><span class=\"line\">    │      │  libcef.dll</span><br><span class=\"line\">    │      │  libcef.lib</span><br><span class=\"line\">    │      │  libcef_dll_wrapper.lib</span><br><span class=\"line\">    │      │  ...</span><br><span class=\"line\">    │      │  </span><br><span class=\"line\">    │      └─swiftshader</span><br><span class=\"line\">    │              ...</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─include</span><br><span class=\"line\">    │  各种.h头文件</span><br><span class=\"line\">    │  ...</span><br><span class=\"line\">    └─Resources</span><br><span class=\"line\">        │  cef.pak</span><br><span class=\"line\">        │  ..</span><br><span class=\"line\">        └─locales</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                zh-CN.pak</span><br><span class=\"line\">                zh-TW.pak</span><br></pre></td></tr></table></figure>\n<p>并且在<code>QtCefCMakeDemo</code>目录下创建一个<code>src</code>目录，用以存放cpp代码。将咱们在《在QT中集成CEF（1）》中编写的相关代码存放于该目录下（<a href=\"https://github.com/w4ngzhen/QtCefDemo/tree/main/QtCefDemo\">QtCefDemo/QtCefDemo at main · w4ngzhen/QtCefDemo (github.com)</a>）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QtCefCMakeDemo</span><br><span class=\"line\"> ├─ CefFiles</span><br><span class=\"line\"> └─ src</span><br><span class=\"line\">      app.manifest</span><br><span class=\"line\">      main.cpp</span><br><span class=\"line\">      qtcefwindow.cpp</span><br><span class=\"line\">      qtcefwindow.h</span><br><span class=\"line\">      qtcefwindow.qrc</span><br><span class=\"line\">      qtcefwindow.ui</span><br><span class=\"line\">      simple_app.cpp</span><br><span class=\"line\">      simple_app.h</span><br><span class=\"line\">      simple_handler.cpp</span><br><span class=\"line\">      simple_handler.h</span><br><span class=\"line\">      stdafx.cpp</span><br><span class=\"line\">      stdafx.h</span><br><span class=\"line\">  ... ...</span><br></pre></td></tr></table></figure>\n<p><strong>请注意，这份代码已经已经有些许过时了，该份代码是基于cef_binary_87.1.13版本，而我们本文是基于cef_binary_105.3.33。所以使用新的cef、cef wrapper，但使用旧的应用层代码，势必会有问题。但是我们目前先不处理，后文会逐一列举并修改。</strong></p>\n<h2 id=\"CMakeLists-txt\"><a href=\"#CMakeLists-txt\" class=\"headerlink\" title=\"CMakeLists.txt\"></a>CMakeLists.txt</h2><p>使用CMake来搭建QT+CEF项目，最核心的就是CMakeLists.txt文件内容：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class=\"number\">3.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">PROJECT</span>(QtCefCMakeDemo LANGUAGES CXX)</span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_BUILD_TYPE DEBUG)</span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_CXX_STANDARD <span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"keyword\">ON</span>)</span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_INCLUDE_CURRENT_DIR <span class=\"keyword\">ON</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 【QT】CMAKE_PREFIX_PATH 实际值为本地安装的QT中的对应编译环境的目录</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_PREFIX_PATH <span class=\"string\">&quot;D:\\\\Programs\\\\Qt\\\\Qt5.14.2\\\\5.14.2\\\\msvc2017_64&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 配置了上述后，可以通过find_package来查找QT相关的cmake文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 【QT】UIC、MOC、RCC启用</span></span><br><span class=\"line\"><span class=\"comment\"># 引入的QT模块则会对.ui文件、.qtc文件以及QT中的元信息机制自动进行处理</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_AUTOUIC <span class=\"keyword\">ON</span>)</span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_AUTOMOC <span class=\"keyword\">ON</span>)</span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_AUTORCC <span class=\"keyword\">ON</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 【QT】通过FIND_PACKAGE，CMake会查找QT相关模块cmake文件，</span></span><br><span class=\"line\"><span class=\"comment\"># 这些cmake文件自动处理了头文件的查找等，</span></span><br><span class=\"line\"><span class=\"comment\"># 不需要像配置CEF的头文件查找一样来配置QT的头文件引入</span></span><br><span class=\"line\"><span class=\"keyword\">FIND_PACKAGE</span>(Qt5 COMPONENTS Widgets REQUIRED)</span><br><span class=\"line\"><span class=\"comment\"># 【CEF】CEF相关头文件的引入</span></span><br><span class=\"line\"><span class=\"keyword\">INCLUDE_DIRECTORIES</span>(<span class=\"string\">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/CefFiles&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">INCLUDE_DIRECTORIES</span>(<span class=\"string\">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/CefFiles/include&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加项目所有的文件：</span></span><br><span class=\"line\"><span class=\"comment\"># 头文件、源文件、ui文件、qrc资源文件</span></span><br><span class=\"line\"><span class=\"comment\"># 特别的，在Windows下VS下，还需要manifest文件，并且该文件在cmake3.4以后就能够自动是被并被引入</span></span><br><span class=\"line\"><span class=\"keyword\">ADD_EXECUTABLE</span>(qt-cef</span><br><span class=\"line\">        WIN32</span><br><span class=\"line\">        src/qtcefwindow.h</span><br><span class=\"line\">        src/simple_app.h</span><br><span class=\"line\">        src/simple_handler.h</span><br><span class=\"line\">        src/main.cpp</span><br><span class=\"line\">        src/qtcefwindow.cpp</span><br><span class=\"line\">        src/simple_app.cpp</span><br><span class=\"line\">        src/simple_handler.cpp</span><br><span class=\"line\">        src/qtcefwindow.ui</span><br><span class=\"line\">        src/qtcefwindow.qrc</span><br><span class=\"line\">        src/app.manifest</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># QT库链接</span></span><br><span class=\"line\"><span class=\"keyword\">TARGET_LINK_LIBRARIES</span>(qt-cef</span><br><span class=\"line\">        PRIVATE</span><br><span class=\"line\">        <span class=\"comment\"># 【QT】QT库链接</span></span><br><span class=\"line\">        Qt5::Widgets</span><br><span class=\"line\">        <span class=\"comment\"># 【CEF】cef相关库链接</span></span><br><span class=\"line\">        <span class=\"string\">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/CefFiles/bin/Debug/libcef.lib&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/CefFiles/bin/Debug/libcef_dll_wrapper.lib&quot;</span></span><br><span class=\"line\">        )</span><br></pre></td></tr></table></figure>\n<p>CMake的基础配置请各位读者自行了解。关于QT的配置，我都在CMakeLists.txt中以<code>【QT】</code>标识出；关于CEF的配置部分，我都在配置文件中以<code>【CEF】</code>标识出。</p>\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><p>此时，我们尝试编译整个项目的时候，会发现有一些编译/链接的错误，相关的错误大多数来源于CEF的头文件升级，接下来我将一一列举并处理。</p>\n<h2 id=\"error-C3646-“OVERRIDE”-未知重写说明符\"><a href=\"#error-C3646-“OVERRIDE”-未知重写说明符\" class=\"headerlink\" title=\"error C3646: “OVERRIDE”: 未知重写说明符\"></a>error C3646: “OVERRIDE”: 未知重写说明符</h2><p>出现点：simple_app.h、simple_handler.h</p>\n<p>原因以及解决方案：实际上在87版本中这个<code>OVERRIDE</code>是一个宏，指代的就是关键字：<code>override</code>，不过在105版本中已经不存在了，所以手动修改为c++标准关键词即可。所以解决方案就是将所有出现<code>OVERRIDE</code>的地方改为关键词<code>override</code>。</p>\n<h2 id=\"error-C2039-“Bind”-不是-“base”-的成员\"><a href=\"#error-C2039-“Bind”-不是-“base”-的成员\" class=\"headerlink\" title=\"error C2039: “Bind”: 不是 “base” 的成员\"></a>error C2039: “Bind”: 不是 “base” 的成员</h2><p>出现点：simple_handler.cpp</p>\n<p>原因以及解决方案：cef团队移除了该API（<a href=\"https://github.com/chromiumembedded/cef/commit/07bc800f0080f62e0d299d3e1a878510085bebc3\">Remove deprecated base::Bind APIs (see issue #3140)</a>），而是要求使用BindOnce，且该BindOnce所在定义的头文件由原来的<code>#include &quot;include/base/cef_bind.h&quot;</code>变为<code>#include &quot;include/base/cef_callback.h&quot;</code>。所以解决方案就是将头文件<code>include/base/cef_bind.h</code>改为引入<code>include/base/cef_callback.h</code>，且将base::Bind改为base::BindOnce。</p>\n<h2 id=\"warning-C4819-该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失\"><a href=\"#warning-C4819-该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失\" class=\"headerlink\" title=\"warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失\"></a>warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失</h2><p>出现点：只要不是UTF-8 with BOM的文件，都可能出现这个警告</p>\n<p>原因以及解决方案：CLion 默认使用 UTF-8 编码，MSVC 除非明确指定否则就使用 UTF-8 with BOM 或者当前代码页（详情可以参考这篇博文：<a href=\"https://www.cnblogs.com/Chary/p/13608011.html\">解决 CLion + MSVC 下的字符编码问题)</a>），所以在CMakeLists.txt中，<strong>在ADD_EXECUTABLE之前加上</strong>：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 解决warning C4819</span></span><br><span class=\"line\"><span class=\"keyword\">ADD_COMPILE_OPTIONS</span>(<span class=\"string\">&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">ADD_COMPILE_OPTIONS</span>(<span class=\"string\">&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"error-C2664-“void-CefWindowInfo-SetAsChild-HWND-const-CefRect-amp-”-无法将参数-2-从“RECT”转换为“const-CefRect-amp-”\"><a href=\"#error-C2664-“void-CefWindowInfo-SetAsChild-HWND-const-CefRect-amp-”-无法将参数-2-从“RECT”转换为“const-CefRect-amp-”\" class=\"headerlink\" title=\"error C2664: “void CefWindowInfo::SetAsChild(HWND,const CefRect &amp;)”: 无法将参数 2 从“RECT”转换为“const CefRect &amp;”\"></a>error C2664: “void CefWindowInfo::SetAsChild(HWND,const CefRect &amp;)”: 无法将参数 2 从“RECT”转换为“const CefRect &amp;”</h2><p>出现点：qtcefwindow.cpp</p>\n<p>原因以及解决方案：void CefWindowInfo::SetAsChild(HWND parent, const CefRect &amp;windowBounds)，第二个参数类型由原来的windef.h中定义的RECT结构体，调整为<code>CefRect</code>类，即：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">-    RECT win_rect;</span></span><br><span class=\"line\">     QRect rect = this-&gt;geometry();</span><br><span class=\"line\"><span class=\"deletion\">-    win_rect.left = rect.left();</span></span><br><span class=\"line\"><span class=\"deletion\">-    win_rect.right = rect.right();</span></span><br><span class=\"line\"><span class=\"deletion\">-    win_rect.top = rect.top();</span></span><br><span class=\"line\"><span class=\"deletion\">-    win_rect.bottom = rect.bottom();</span></span><br><span class=\"line\"><span class=\"addition\">+// CEF引入CefRect，而不是windef.h中的RECT</span></span><br><span class=\"line\"><span class=\"addition\">+    CefRect win_rect(</span></span><br><span class=\"line\"><span class=\"addition\">+            rect.left(),</span></span><br><span class=\"line\"><span class=\"addition\">+            rect.top(),</span></span><br><span class=\"line\"><span class=\"addition\">+            rect.left() + rect.width() * devicePixelRatio(),</span></span><br><span class=\"line\"><span class=\"addition\">+            rect.top() + rect.height() * devicePixelRatio());</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"libcef-dll-wrapper-lib-libcef-dll-wrapper-obj-error-LNK2038-检测到“-ITERATOR-DEBUG-LEVEL”的不匹配项-值“0”不匹配值“2”-mocs-compilation-cpp-obj-中\"><a href=\"#libcef-dll-wrapper-lib-libcef-dll-wrapper-obj-error-LNK2038-检测到“-ITERATOR-DEBUG-LEVEL”的不匹配项-值“0”不匹配值“2”-mocs-compilation-cpp-obj-中\" class=\"headerlink\" title=\"libcef_dll_wrapper.lib(libcef_dll_wrapper.obj) : error LNK2038: 检测到“_ITERATOR_DEBUG_LEVEL”的不匹配项: 值“0”不匹配值“2”(mocs_compilation.cpp.obj 中)\"></a>libcef_dll_wrapper.lib(libcef_dll_wrapper.obj) : error LNK2038: 检测到“_ITERATOR_DEBUG_LEVEL”的不匹配项: 值“0”不匹配值“2”(mocs_compilation.cpp.obj 中)</h2><p>出现点：链接阶段错误</p>\n<p>原因以及解决方案：针对该问题，首先通过网上搜寻的博文了解到是：<code>当前工程是Debug版本，而引用的库文件时Release版本</code>。排查libcef_dll_wrapper.lib，确实使用的Debug版本。从报错了解到与<code>mocs_compilation.cpp.obj</code>的<code>_ITERATOR_DEBUG_LEVEL</code>不一致。但是，这个<code>mocs_compilation.cpp.obj</code>是通过咱们项目生成的，是QT的MetaObject元对象机制下，MOC参与代码生成、编译输出的，其自动生成的代码在<code>cmake-build-debug</code>目录下的<code>qt-cef_autogen</code>中：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-12/010-autogen-in-cmake.png\" alt=\"010-autogen-in-cmake\"></p>\n<p>该cpp编译单元编译后的产物在<code>项目根目录/cmake-build-debug/CMakeFiles/qt-cef.dir/qt-cef_autogen</code>下：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-12/020-autogen-obj-in-cmake.png\" alt=\"020-autogen-obj-in-cmake\"></p>\n<p>使用VS的工具（ <a href=\"https://docs.microsoft.com/zh-cn/visualstudio/ide/reference/command-prompt-powershell?view=vs-2022\">适用于开发人员的命令行 shell 和提示 - Visual Studio (Windows) | Microsoft Docs</a>）中的<strong>dumpbin.exe</strong>工具（<a href=\"https://docs.microsoft.com/zh-cn/cpp/build/reference/dumpbin-reference?view=msvc-170\">DUMPBIN 参考 | Microsoft Docs</a>），可以查看库文件的<code>_ITERATOR_DEBUG_LEVEL</code>值。操作方式为：</p>\n<ol>\n<li>找到VS开发者工具，方式有几种，主要有：1、<a href=\"https://docs.microsoft.com/zh-cn/visualstudio/ide/reference/command-prompt-powershell?view=vs-2022#start-from-windows-menu\">从 Windows 菜单中启动</a>；2、<a href=\"https://docs.microsoft.com/zh-cn/visualstudio/ide/reference/command-prompt-powershell?view=vs-2022#start-from-file-browser\">从文件菜单启动</a>；</li>\n<li>启动后进入命令行，执行命令：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dumpbin /directives <span class=\"string\">&quot;库文件路径&quot;</span></span><br></pre></td></tr></table></figure>\n<p>mocs_compilation.cpp.obj的_ITERATOR_DEBUG_LEVEL值</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-12/030-dumpbin-mocs-obj.png\" alt=\"030-dumpbin-mocs-obj\"></p>\n<p>libcef_dll_wrapper.lib中一些obj的_ITERATOR_DEBUG_LEVEL值：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-12/040-dumpbin-libcef_dll_wrapper.png\" alt=\"040-dumpbin-libcef_dll_wrapper\"></p>\n<p>可以看出，两份库代码确实是不一样的。由于libcef_dll_wrapper.lib我们已经完成了编译，这里我们不考虑重新编译该lib库，而是通过配置CMake，让生成的mocs_compilation.cpp.obj等obj的_ITERATOR_DEBUG_LEVEL值为0，来匹配libcef_dll_wrapper.lib。所以，解决方案就是在CMakeLists.txt中，添加配置（<a href=\"https://stackoverflow.com/questions/54246427/how-to-add-iterator-debug-level-to-cmake\">c++ - How to add _ITERATOR_DEBUG_LEVEL to CMake? - Stack Overflow</a>）：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 解决warning C4819，需要在ADD_EXECUTABLE前加上</span><br><span class=\"line\">ADD_COMPILE_OPTIONS(&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;)</span><br><span class=\"line\">ADD_COMPILE_OPTIONS(&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;)</span><br><span class=\"line\"><span class=\"addition\">+# 控制项目所有编译单元_ITERATOR_DEBUG_LEVEL的值，</span></span><br><span class=\"line\"><span class=\"addition\">+# 这里设置为和libcef_dll_wrapper.lib中的obj一致。</span></span><br><span class=\"line\"><span class=\"addition\">+ADD_COMPILE_DEFINITIONS($&lt;$&lt;CONFIG:Debug&gt;:_ITERATOR_DEBUG_LEVEL=0&gt;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 【QT】CMAKE_PREFIX_PATH 实际值为本地安装的QT中的对应编译环境的目录</span><br><span class=\"line\">SET(CMAKE_PREFIX_PATH &quot;D:\\\\Programs\\\\Qt\\\\Qt5.14.2\\\\5.14.2\\\\msvc2017_64&quot;)</span><br></pre></td></tr></table></figure>\n<p>不出意外，此时我们已经处理了所有的编译和链接过程中的问题。控制台会显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;[ Build | qt-cef | Debug ]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">D:\\Programs\\ToolBoxApp\\apps\\CLion\\ch-0\\222.3739.54\\bin\\cmake\\win\\bin\\cmake.exe --build D:\\Projects\\cpp-projects\\qt-projects\\qt-cef\\QtCefCMakeDemo\\cmake-build-debug --target qt-cef -j 12</span><br><span class=\"line\">[1&#x2F;8] Automatic MOC and UIC for target qt-cef</span><br><span class=\"line\">[2&#x2F;8] Building CXX object CMakeFiles\\qt-cef.dir\\qt-cef_autogen\\UVLADIE3JM\\qrc_qtcefwindow.cpp.obj</span><br><span class=\"line\">[3&#x2F;8] Building CXX object CMakeFiles\\qt-cef.dir\\src\\simple_app.cpp.obj</span><br><span class=\"line\">[4&#x2F;8] Building CXX object CMakeFiles\\qt-cef.dir\\src\\simple_handler.cpp.obj</span><br><span class=\"line\">[5&#x2F;8] Building CXX object CMakeFiles\\qt-cef.dir\\qt-cef_autogen\\mocs_compilation.cpp.obj</span><br><span class=\"line\">[6&#x2F;8] Building CXX object CMakeFiles\\qt-cef.dir\\src\\qtcefwindow.cpp.obj</span><br><span class=\"line\">[7&#x2F;8] Building CXX object CMakeFiles\\qt-cef.dir\\src\\main.cpp.obj</span><br><span class=\"line\">[8&#x2F;8] Linking CXX executable qt-cef.exe</span><br><span class=\"line\"></span><br><span class=\"line\">Build finished</span><br></pre></td></tr></table></figure>\n<p>但是在运行的过程中理论山还会出现两个问题：</p>\n<h2 id=\"Process-finished-with-exit-code-1073740791-0xC0000409\"><a href=\"#Process-finished-with-exit-code-1073740791-0xC0000409\" class=\"headerlink\" title=\"Process finished with exit code -1073740791 (0xC0000409)\"></a>Process finished with exit code -1073740791 (0xC0000409)</h2><p>出现这个问题的时候，使用CLion的Debug模式进行，会看到错误调用栈：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-12/050-debug-string-error.png\" alt=\"050-debug-string-error\"></p>\n<p>经过问题排查，主要原因点：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-12/060-string-error-detail.png\" alt=\"060-string-error-detail\"></p>\n<p>在qtcefwindow构造函数中调用<code>CefBrowserHost::CreateBrowser</code>API，会传入初始要打开的页面地址，然而QString.toStdString得到string有问题（后续排查具体原因）。解决方案就是直接使用std::string变量即可：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     // 以下是将 SimpleHandler 与窗体进行关联的代码</span><br><span class=\"line\">     CefWindowInfo cef_wnd_info;</span><br><span class=\"line\"><span class=\"deletion\">-    QString str_url = &quot;https://www.cnblogs.com/w4ngzhen&quot;;</span></span><br><span class=\"line\"><span class=\"addition\">+    std::string str_url = &quot;https://www.cnblogs.com/w4ngzhen&quot;;</span></span><br><span class=\"line\">     QRect rect = this-&gt;geometry();</span><br><span class=\"line\">     CefRect win_rect(</span><br><span class=\"line\">             rect.left(),</span><br><span class=\"line\">@@ -25,7 +25,7 @@ QtCefWindow::QtCefWindow(QWidget* parent)</span><br><span class=\"line\">     simple_handler_ = CefRefPtr&lt;SimpleHandler&gt;(new SimpleHandler());</span><br><span class=\"line\">     CefBrowserHost::CreateBrowser(cef_wnd_info,</span><br><span class=\"line\">         simple_handler_,</span><br><span class=\"line\"><span class=\"deletion\">-        str_url.toStdString(),</span></span><br><span class=\"line\"><span class=\"addition\">+        str_url,</span></span><br><span class=\"line\">         cef_browser_settings,</span><br><span class=\"line\">         nullptr,</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"“Invalid-COM-thread-model-change”-或-运行后异常退出报错Exception-0x80000003-encountered-at-address-0x7ffbc43e9f3c\"><a href=\"#“Invalid-COM-thread-model-change”-或-运行后异常退出报错Exception-0x80000003-encountered-at-address-0x7ffbc43e9f3c\" class=\"headerlink\" title=\"“Invalid COM thread model change” 或 运行后异常退出报错Exception 0x80000003 encountered at address 0x7ffbc43e9f3c\"></a>“Invalid COM thread model change” 或 运行后异常退出报错Exception 0x80000003 encountered at address 0x7ffbc43e9f3c</h2><p>解决掉上述问题以后，笔者的环境下还会出现两种类似的问题：</p>\n<ol>\n<li>“Invalid COM thread model change”（实际上有些同学机器上，这个问题先于上面的字符串问题）</li>\n<li>运行后异常退出报错Exception 0x80000003 encountered at address 0x7ffbc43e9f3c</li>\n</ol>\n<p>这两种情况都是一个解决方案。问题点在于，QT的事件循环在多个进程（浏览器进程、渲染进程）均被初始化。实际上只需要在浏览器进程即可。解决方案就是将main.cpp中的init_for_cef提取到最前：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">-    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);  // 解决高DPI下，界面比例问题</span></span><br><span class=\"line\"><span class=\"deletion\">-    QApplication a(argc, argv);</span></span><br><span class=\"line\"><span class=\"addition\">+    // 将init_qt_cef提取到QApplication初始化之前</span></span><br><span class=\"line\"><span class=\"addition\">+    // 对于CEF多进程架构模型</span></span><br><span class=\"line\"><span class=\"addition\">+    // 因为【渲染进程】启动后，init_qt_cef中执行的CefExecuteProcess会阻塞住，</span></span><br><span class=\"line\"><span class=\"addition\">+    // 如果在此之前启动了QT的事件循环，那么会导致QT出现异常</span></span><br><span class=\"line\"><span class=\"addition\">+    // 所以，我们将init_qt_cef提前到QApplication初始化之前，</span></span><br><span class=\"line\"><span class=\"addition\">+    // 保证无论是浏览器进程还是渲染进程启动，都会进入init_qt_cef，但渲染进程会在里面阻塞，</span></span><br><span class=\"line\"><span class=\"addition\">+    // 不会进入后续的QT应用初始化</span></span><br><span class=\"line\">     const int result = init_qt_cef(argc, argv);</span><br><span class=\"line\">     if (result &gt;= 0)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         return result;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"addition\">+    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);  // 解决高DPI下，界面比例问题</span></span><br><span class=\"line\"><span class=\"addition\">+    QApplication a(argc, argv);</span></span><br><span class=\"line\"><span class=\"addition\">+</span></span><br><span class=\"line\">     QtCefWindow w;</span><br><span class=\"line\">     w.show();</span><br><span class=\"line\">     a.exec();</span><br></pre></td></tr></table></figure>\n<p>对于CEF多进程架构模型，因为<strong>渲染进程</strong>启动后，init_qt_cef中执行的CefExecuteProcess会阻塞住，如果在此之前启动了QT的事件循环，那么会导致QT出现异常。 所以，我们将init_qt_cef提前到QApplication初始化之前，保证无论是<strong>浏览器进程</strong>还是<strong>渲染进程</strong>启动后，都会进入init_qt_cef，但渲染进程会在里面阻塞，不会进入后续的QT应用初始化。</p>\n<h1 id=\"效果演示与代码库\"><a href=\"#效果演示与代码库\" class=\"headerlink\" title=\"效果演示与代码库\"></a>效果演示与代码库</h1><p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-12/070-show.gif\" alt=\"070-show\"></p>\n<p>与本文相关的代码已经提交至Github，且按照整个文章的编写流程进行提交：</p>\n<p><a href=\"https://github.com/w4ngzhen/QtCefCmakeDemo\">w4ngzhen/QtCefCmakeDemo (github.com)</a></p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-09-12/080-git-commits.png\" alt=\"080-git-commits\"></p>\n","categories":[],"tags":["cef","qt","cmake"]},{"title":"TypeScript与Babel、webpack的关系以及IDE对TS的类型检查","url":"http://compilemind.com/2022/08/14/2022-08-14-TypeScript与Babel、webpack的关系以及IDE对TS的类型检查/","content":"<p>只要接触过ts的前端同学都能回答出ts是js超集，它具备静态类型分析，能够根据类型在静态代码的解析过程中对ts代码进行类型检查，从而在保证类型的一致性。那，现在让你对你的webpack项目（其实任意类型的项目都同理）加入ts，你知道怎么做吗？带着这个问题，我们由浅入深，逐步介绍<strong>TypeScript</strong>、<strong>Babel</strong>以及<strong>我们日常使用IDE进行ts文件类型检查</strong>的关系，让你今后面对基于ts的工程能够做到游刃有余。</p>\n<a id=\"more\"></a>\n<h1 id=\"TypeScript基本认识\"><a href=\"#TypeScript基本认识\" class=\"headerlink\" title=\"TypeScript基本认识\"></a>TypeScript基本认识</h1><p><strong>原则1：主流的浏览器的主流版本只认识js代码</strong></p>\n<p><strong>原则2：ts的代码一定会经过编译为js代码，才能运行在主流浏览器上</strong></p>\n<p>要编译ts代码，至少具备以下几个要素：</p>\n<ol>\n<li>ts源代码</li>\n<li>ts编译器</li>\n<li>ts编译器所需要的配置（默认配置也是配置）</li>\n</ol>\n<h1 id=\"编译TS的方式\"><a href=\"#编译TS的方式\" class=\"headerlink\" title=\"编译TS的方式\"></a>编译TS的方式</h1><p>目前主流的ts编译方案有2种，分别是官方tsc编译、babel+ts插件编译。</p>\n<h2 id=\"官方tsc编译器\"><a href=\"#官方tsc编译器\" class=\"headerlink\" title=\"官方tsc编译器\"></a>官方tsc编译器</h2><p>对于ts官方模式来说，ts编译器就是tsc（安装typescript就可以获得），而编译器所需的配置就是tsconfig.json配置文件形式或其他形式。ts源代码经过tsc的编译（Compile），就可以生成js代码，在tsc编译的过程中，需要<strong>编译配置</strong>来确定一些编译过程中要处理的内容。</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/010-ts-compile-flow.png\" alt=\"010-ts-compile-flow\"></p>\n<p>我们首先准备一个ts-demo，该demo中有如下的结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ts-demo</span><br><span class=\"line\"> |- packages.json</span><br><span class=\"line\"> |- tsconfig.json</span><br><span class=\"line\"> |- src</span><br><span class=\"line\">    |- index.ts</span><br></pre></td></tr></table></figure>\n<p>安装typescript</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D typescript</span><br></pre></td></tr></table></figure>\n<p>package.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;ts-demo&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;1.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;description&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;main&quot;</span>: <span class=\"string\">&quot;index.js&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;build-ts&quot;</span>: <span class=\"string\">&quot;tsc&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;author&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;license&quot;</span>: <span class=\"string\">&quot;MIT&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;devDependencies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;typescript&quot;</span>: <span class=\"string\">&quot;^4.7.4&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>tsconfig.js（对于这个简单的tsconfig，我不再赘述其配置的含义。）</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;module&quot;</span>: <span class=\"string\">&quot;commonjs&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDir&quot;</span>: <span class=\"string\">&quot;./src&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;outDir&quot;</span>: <span class=\"string\">&quot;./dist&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index.ts</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> User &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> userToString = <span class=\"function\">(<span class=\"params\">user: User</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;user.name&#125;</span>@<span class=\"subst\">$&#123;user.age&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;userToString, User&#125;;</span><br></pre></td></tr></table></figure>\n<p>此时，我们只需要运行<code>yarn build-ts</code>就可以将我们的index.ts编译为index.js：</p>\n<p>commonjs模块化方式产物：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.__esModule = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.userToString = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> userToString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>.concat(user.name, <span class=\"string\">&quot;@&quot;</span>).concat(user.age); &#125;;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.userToString = userToString;</span><br></pre></td></tr></table></figure>\n<p>可以看到，原本index.ts编译为index.js的产物，使用了commonjs模块化方案（tsconfig里面配置模块化方案是”commonjs”，编译后的代码可以看到”exports”的身影）；倘若我们将模块化方案改为ESM（ES模块化）的es：<code>&quot;module&quot;: &quot;es6&quot;</code>，编译后的产物依然是index.js，只不过内容采用了es6中的模块方案。</p>\n<p>es6模块化方式产物：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userToString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>.concat(user.name, <span class=\"string\">&quot;@&quot;</span>).concat(user.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;userToString&#125;;</span><br></pre></td></tr></table></figure>\n<p>说了这么多，只是想要告诉各位同学，<strong>ts无论有多么庞大的语法体系，多么强大的类型检查，最终的产物都是js</strong>。</p>\n<p>此外，ts中的模块化，不能和js中的模块化混为一谈。js中的模块化方案很多（es6、commonjs、umd等等），所以ts本身在编译过程中，需要指定一种js的模块化表达，才能编译为对应的代码。也就是说，在ts中的<code>import/export</code>，不能认为和es6的<code>import/export</code>是一样的，他们是完全不同的两个体系！只是语法上类似而已。</p>\n<h2 id=\"babel-ts插件\"><a href=\"#babel-ts插件\" class=\"headerlink\" title=\"babel+ts插件\"></a>babel+ts插件</h2><p>如前文所述</p>\n<blockquote>\n<p>ts源代码经过tsc的编译（Compile），就可以生成js代码，在tsc编译的过程中，需要编译配置来确定一些编译过程中要处理的内容。</p>\n</blockquote>\n<p>那么是不是说，编译器这块是不是有其他的代替呢？ts源码经过某种其他的编译器编译后，生成目标js代码。答案是肯定的：babel。</p>\n<p>我们准备一个ts-babel-demo：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ts-babel-demo</span><br><span class=\"line\"> |- packages.json</span><br><span class=\"line\"> |- .babelrc</span><br><span class=\"line\"> |- src</span><br><span class=\"line\">    |- index.ts</span><br></pre></td></tr></table></figure>\n<p>依赖添加：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D @babel/core @babel/cli</span><br><span class=\"line\">yarn add -D @babel/preset-env @babel/preset-typescript</span><br><span class=\"line\">yarn add -D @babel/plugin-proposal-class-properties @babel/plugin-proposal-object-rest-spread</span><br></pre></td></tr></table></figure>\n<p>package.json：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;ts-babel-demo&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;1.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;main&quot;</span>: <span class=\"string\">&quot;index.js&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;license&quot;</span>: <span class=\"string\">&quot;MIT&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;</span>: <span class=\"string\">&quot;babel src -d dist -x &#x27;.ts, .tsx&#x27;&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;devDependencies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/cli&quot;</span>: <span class=\"string\">&quot;^7.18.10&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/core&quot;</span>: <span class=\"string\">&quot;^7.18.10&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/plugin-proposal-class-properties&quot;</span>: <span class=\"string\">&quot;^7.18.6&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span>: <span class=\"string\">&quot;^7.18.9&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/preset-env&quot;</span>: <span class=\"string\">&quot;^7.18.10&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/preset-typescript&quot;</span>: <span class=\"string\">&quot;^7.18.6&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>.babelrc</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;presets&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/preset-env&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/preset-typescript&quot;</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/plugin-proposal-class-properties&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index.ts和ts-demo保持一致。</p>\n<p>完成基础的项目搭建以后，我们执行<code>yarn build</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&#x2F;Projects&#x2F;web-projects&#x2F;ts-babel-demo &gt; yarn build</span><br><span class=\"line\">yarn run v1.22.17</span><br><span class=\"line\">$ babel src -d dist -x &#39;.ts, .tsx&#39;</span><br><span class=\"line\">Successfully compiled 1 file with Babel (599ms).</span><br><span class=\"line\">Done in 4.05s.</span><br></pre></td></tr></table></figure>\n<p>可以看到项目dist目录下出现了编译好的js代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, <span class=\"string\">&quot;__esModule&quot;</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.userToString = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> userToString = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">userToString</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>.concat(user.name, <span class=\"string\">&quot;@&quot;</span>).concat(user.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exports</span>.userToString = userToString;</span><br></pre></td></tr></table></figure>\n<p>可以看到和使用tsc编译为commonjs效果是一样。</p>\n<p>回顾这个项目，其实按照我们之前的思路来梳理：</p>\n<ol>\n<li>ts源文件（src/index.ts）</li>\n<li>ts的编译器（babel）</li>\n<li>编译配置（.babelrc）</li>\n</ol>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/020-babel-compile-flow.png\" alt=\"020-babel-compile-flow\"></p>\n<p><strong>了解babel机制</strong></p>\n<p>如果对于babel不太熟悉，可能对上述的一堆依赖感到恐惧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D @babel&#x2F;core @babel&#x2F;cli</span><br><span class=\"line\">yarn add -D @babel&#x2F;preset-env @babel&#x2F;preset-typescript</span><br><span class=\"line\">yarn add -D @babel&#x2F;plugin-proposal-class-properties @babel&#x2F;plugin-proposal-object-rest-spread</span><br></pre></td></tr></table></figure>\n<p>这里如果读者有时间，我推荐这篇深入了解babel的文章：<a href=\"https://zhuanlan.zhihu.com/p/43249121\">一口（很长的）气了解 babel - 知乎 (zhihu.com)</a>。当然，如果这口气憋不住（哈哈），我做一个简单摘抄：</p>\n<blockquote>\n<p>babel 总共分为三个阶段：解析，转换，生成。</p>\n<p>babel 本身不具有任何转化功能，它把转化的功能都分解到一个个 plugin 里面。因此当我们不配置任何插件时，经过 babel 的代码和输入是相同的。</p>\n<p>插件总共分为两种：</p>\n<ul>\n<li>当我们添加 <strong>语法插件</strong> 之后，在解析这一步就使得 babel 能够解析更多的语法。(顺带一提，babel 内部使用的解析类库叫做 babylon，并非 babel 自行开发)</li>\n</ul>\n<p>举个简单的例子，当我们定义或者调用方法时，最后一个参数之后是不允许增加逗号的，如 <code>callFoo(param1, param2,)</code> 就是非法的。如果源码是这种写法，经过 babel 之后就会提示语法错误。</p>\n<p>但最近的 JS 提案中已经允许了这种新的写法(让代码 diff 更加清晰)。为了避免 babel 报错，就需要增加语法插件 <code>babel-plugin-syntax-trailing-function-commas</code></p>\n<ul>\n<li>当我们添加 <strong>转译插件</strong> 之后，在转换这一步把源码转换并输出。这也是我们使用 babel 最本质的需求。</li>\n</ul>\n<p>比起语法插件，转译插件其实更好理解，比如箭头函数 <code>(a) =&gt; a</code> 就会转化为 <code>function (a) &#123;return a&#125;</code>。完成这个工作的插件叫做 <code>babel-plugin-transform-es2015-arrow-functions</code>。</p>\n<p>同一类语法可能同时存在语法插件版本和转译插件版本。<strong>如果我们使用了转译插件，就不用再使用语法插件了。</strong></p>\n</blockquote>\n<p>简单来讲，使用babel就像如下流程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">源代码 &#x3D;babel&#x3D;&gt; 目标代码</span><br></pre></td></tr></table></figure>\n<p>如果没有使用任何插件，源代码和目标代码就没有任何差异。当我们引入各种插件的时候，就像如下流程一样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">源代码</span><br><span class=\"line\">|</span><br><span class=\"line\">进入babel</span><br><span class=\"line\">|</span><br><span class=\"line\">babel插件1处理代码：移除某些符号</span><br><span class=\"line\">|</span><br><span class=\"line\">babel插件2处理代码：将形如() &#x3D;&gt; &#123;&#125;的箭头函数，转换成function xxx() &#123;&#125;</span><br><span class=\"line\">|</span><br><span class=\"line\">目标代码</span><br></pre></td></tr></table></figure>\n<p>因为babel的插件处理的力度很细，我们代码的语法、语义内容规范有很多，如果我们要处理这些语法，可能需要配置一大堆的插件，所以babel提出，将一堆插件组合成一个preset（预置插件包），这样，我们只需要引入一个插件组合包，就能处理代码的各种语法、语义。</p>\n<p>所以，回到我们上述的那些@babel开头的npm包，再回首可能不会那么迷茫：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel&#x2F;core</span><br><span class=\"line\">@babel&#x2F;preset-env</span><br><span class=\"line\">@babel&#x2F;preset-typescript</span><br><span class=\"line\">@babel&#x2F;preset-react</span><br><span class=\"line\">@babel&#x2F;plugin-proposal-class-properties</span><br><span class=\"line\">@babel&#x2F;plugin-proposal-object-rest-spread</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>@babel/core</code>毋庸置疑，babel的核心模块，实现了上述的流程运转以及代码语法、语义分析的功能；</p>\n</li>\n<li><p><code>@babel/cli</code>则是我们可以在命令行使用babel命令；</p>\n</li>\n<li><p>plugin开头的就是插件，这里我们引入了两个：<code>@babel/plugin-proposal-class-properties</code>（<a href=\"https://babel.docschina.org/docs/en/babel-plugin-proposal-class-properties/\">允许类具有属性</a>）和<code>@babel/plugin-proposal-object-rest-spread</code>（<a href=\"https://babel.docschina.org/docs/en/7.0.0/babel-plugin-proposal-object-rest-spread/\">对象展开</a>）；</p>\n</li>\n<li><p>preset开头的就是预置组件包合集，其中<code>@babel/preset-env</code>表示使用了可以根据实际的浏览器运行环境，会选择相关的转义插件包，通过配置得知目标环境的特点只做必要的转换。如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)；<code>@babel/preset-typescript</code>会处理所有ts的代码的语法和语义规则，并转换为js代码。</p>\n</li>\n</ul>\n<p>关于babel编译ts，并不是所有的语法都支持，这里有一篇文章专门介绍了其中注意点：《TypeScript 和 Babel：美丽的结合》。</p>\n<h1 id=\"webpack项目级TS使用\"><a href=\"#webpack项目级TS使用\" class=\"headerlink\" title=\"webpack项目级TS使用\"></a>webpack项目级TS使用</h1><p>前面的内容，我们已经介绍了将ts编译为js的两种方式（tsc、babel），但仅仅是简单将一个index.ts编译为index.js。实际上，对于项目级别的ts项目，还有很多需要了解的。接下来基于一个webpack项目来逐步介绍如何基于前文的两种方式来使用ts。</p>\n<p>对于webpack来说，至少需要读者了解到webpack的基本机制：<a href=\"https://webpack.docschina.org/concepts/\">概念 | webpack 中文文档 (docschina.org)</a>。</p>\n<p>简单来讲，webpack运行从指定的entry文件开始，从顶层开始分析依赖的内容，依赖的内容可以是任何的内容（只要是import的或require了的），而loader可以专门来处理各种类型的文件。</p>\n<blockquote>\n<p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。<strong>loader</strong> 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 <a href=\"https://webpack.docschina.org/concepts/modules\">模块</a>，以供应用程序使用，以及被添加到依赖图中</p>\n</blockquote>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/030-webpack-base-flow.png\" alt=\"030-webpack-base-flow\"></p>\n<p>所以，当一个webpack项目是基于TS进行的时候，我们一定会有一个loader来处理ts（甚至是tsx）。当然，我们还是通过demo搭建来演示讲解。</p>\n<h2 id=\"ts-loader\"><a href=\"#ts-loader\" class=\"headerlink\" title=\"ts-loader\"></a>ts-loader</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir webpack-ts-loader-demo &amp;&amp; cd webpack-ts-loader-demo</span><br><span class=\"line\">yarn init</span><br><span class=\"line\">yarn add -D webpack webpack-cli</span><br><span class=\"line\">yarn add -D ts-loader</span><br></pre></td></tr></table></figure>\n<p><strong>package.json</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;webpack-ts-loader-demo&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;1.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;main&quot;</span>: <span class=\"string\">&quot;index.js&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;license&quot;</span>: <span class=\"string\">&quot;MIT&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;</span>: <span class=\"string\">&quot;webpack --config webpack.config.js&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;devDependencies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;ts-loader&quot;</span>: <span class=\"string\">&quot;^9.3.1&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;webpack&quot;</span>: <span class=\"string\">&quot;^5.74.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;webpack-cli&quot;</span>: <span class=\"string\">&quot;^4.10.0&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>webpack.config.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;resolve&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">&#x27;./src/index.ts&#x27;</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: resolve(__dirname, <span class=\"string\">&#x27;./dist&#x27;</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">&quot;index.js&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.ts/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">&quot;ts-loader&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>src/index.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> User &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> userToString = <span class=\"function\">(<span class=\"params\">user: User</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;user.name&#125;</span>@<span class=\"subst\">$&#123;user.age&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;userToString, User&#125;;</span><br></pre></td></tr></table></figure>\n<p>表面上，只需要上述三个文件，就可以编译ts文件，但是尝试运行<code>yarn build</code>会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module build failed (from .&#x2F;node_modules&#x2F;ts-loader&#x2F;index.js):</span><br><span class=\"line\">Error: Could not load TypeScript. Try installing with &#96;yarn add typescript&#96; or &#96;npm install typescript&#96;. If TypeScript is installed globally, try using &#96;yarn link typescript&#96; or &#96;npm link typescript&#96;.</span><br></pre></td></tr></table></figure>\n<p>通过报错很容易理解，我们没有安装typescript。为什么？<strong>因为ts-loader本身处理ts文件的时候，本质上还是调用的tsc，而tsc是typescript模块提供的</strong>。因此，我们只需要<code>yarn add -D typescript</code>即可（其实只需要开发依赖即可），但是紧接着又会有另外一个报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR in .&#x2F;src&#x2F;index.t</span><br><span class=\"line\">Module build failed (from .&#x2F;node_modules&#x2F;ts-loader&#x2F;index.js):</span><br><span class=\"line\">Error: error while parsing tsconfig.json</span><br></pre></td></tr></table></figure>\n<p>报错提醒我们，解析tsconfig的出错，不难理解，我们还没有配置tsconfig.json，因为tsc需要！所以，在我们项目中，加上tsconfig.json即可：</p>\n<p><strong>tsconfig.json</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;module&quot;</span>: <span class=\"string\">&quot;commonjs&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDir&quot;</span>: <span class=\"string\">&quot;./src&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;outDir&quot;</span>: <span class=\"string\">&quot;./dist&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置完成以后，我们再次编译，发现可以编译成功，并且在dist目录下会有对应的js代码。</p>\n<p>然而，事情到这里就结束了吗？一个中大型的项目，必然有模块的引入，假如现在我们添加了个utils.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> hello = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改index.ts的代码，引入该hello方法，并使用：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;hello&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./utils&quot;</span>; <span class=\"comment\">// 引入utils</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> User &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> userToString = <span class=\"function\">(<span class=\"params\">user: User</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;user.name&#125;</span>@<span class=\"subst\">$&#123;user.age&#125;</span><span class=\"subst\">$&#123;hello()&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;userToString, User&#125;;</span><br></pre></td></tr></table></figure>\n<p>再次运行<code>yarn build</code>，读者会发现还是会报错，但这一次的错误略有点出乎意料：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module not found: Error: Can&#39;t resolve &#39;.&#x2F;utils&#39; in &#39;&#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-ts-loader-demo&#x2F;src&#39;</span><br><span class=\"line\">resolve &#39;.&#x2F;utils&#39; in &#39;&#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-ts-loader-demo&#x2F;src&#39;</span><br></pre></td></tr></table></figure>\n<p>核心报错在于，webpack似乎无法找到utils这个模块。为什么呢？因为webpack默认是处理js代码的，如果你的代码中编写了<code>import xxx from &#39;xxx&#39;</code>，在没有明确指明这个模块的后缀的时候，webpack只会认为这个模块是以下几种：</p>\n<ol>\n<li>无后缀文件</li>\n<li>js文件</li>\n<li>json文件</li>\n<li>wasm文件</li>\n</ol>\n<p>所以，你会看到具体一点的报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve &#39;.&#x2F;utils&#39; in &#39;&#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-ts-loader-demo&#x2F;src&#39;</span><br><span class=\"line\">  using description file: &#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-ts-loader-demo&#x2F;package.json (relative path: .&#x2F;src)</span><br><span class=\"line\">    Field &#39;browser&#39; doesn&#39;t contain a valid alias configuration</span><br><span class=\"line\">    using description file: &#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-ts-loader-demo&#x2F;package.json (relative path: .&#x2F;src&#x2F;utils)</span><br><span class=\"line\">      no extension</span><br><span class=\"line\">        Field &#39;browser&#39; doesn&#39;t contain a valid alias configuration</span><br><span class=\"line\">        &#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-ts-loader-demo&#x2F;src&#x2F;utils doesn&#39;t exist</span><br><span class=\"line\">      .js</span><br><span class=\"line\">        Field &#39;browser&#39; doesn&#39;t contain a valid alias configuration</span><br><span class=\"line\">        &#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-ts-loader-demo&#x2F;src&#x2F;utils.js doesn&#39;t exist</span><br><span class=\"line\">      .json</span><br><span class=\"line\">        Field &#39;browser&#39; doesn&#39;t contain a valid alias configuration</span><br><span class=\"line\">        &#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-ts-loader-demo&#x2F;src&#x2F;utils.json doesn&#39;t exist</span><br><span class=\"line\">      .wasm</span><br><span class=\"line\">        Field &#39;browser&#39; doesn&#39;t contain a valid alias configuration</span><br><span class=\"line\">        &#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-ts-loader-demo&#x2F;src&#x2F;utils.wasm doesn&#39;t exist</span><br><span class=\"line\">      as directory</span><br></pre></td></tr></table></figure>\n<p>要想让webpack知道我们引入的utils是ts代码，方式为在webpack配置中，指明webpack默认处理的文件后缀：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;resolve&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... ...</span></span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// webpack 默认只处理js、jsx等js代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 为了防止在import其他ts代码的时候，出现</span></span><br><span class=\"line\">    <span class=\"comment\">// &quot; Can&#x27;t resolve &#x27;xxx&#x27; &quot;的错误，需要特别配置</span></span><br><span class=\"line\">    extensions: [<span class=\"string\">&#x27;.js&#x27;</span>, <span class=\"string\">&#x27;.jsx&#x27;</span>, <span class=\"string\">&#x27;.ts&#x27;</span>, <span class=\"string\">&#x27;.tsx&#x27;</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ... ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>完成配置以后，我们就能够正确编译具备模块导入的ts代码了。</p>\n<p>综合来看，在基于ts-loader的webpack项目的解析流程处理如下。</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/040-webpack-ts-loader-flow.png\" alt=\"040-webpack-ts-loader-flow\"></p>\n<p>回顾一下webpack，它默认处理模块化js代码，比如index.js引用了utils.js（模块引用方式可以是commonjs，也可以是esModule形式），那么webpack从入口的index.js出发，来处理依赖，并打包为一个js（暂不考虑js拆分）。</p>\n<p>对于wepack+ts-loader的ts项目体系主要是通过ts-loader内部调用typescript提供的tsc，将ts代码编译为js代码（编译后的js代码依然是js模块化的形式），所以这个过程是需要tsconfig参与；等到tsc将整个所有的ts代码均编译为js代码以后，再整体交给webpack进行依赖分析并打包（也就进入webpack的默认处理流程）。</p>\n<p>细心的读者会发现这个过程有一个问题：由于先经过tsc编译后的js，又再被webpack默认的js处理机制进行分析并编译打包，这个过程一方面经过了两次编译（ts-&gt;标准模块化js-&gt;webpack模块体系js），那么如果ts项目特别大，模块特别多的时候，这个两次编译的过程会特别漫长！</p>\n<h2 id=\"babel-loader\"><a href=\"#babel-loader\" class=\"headerlink\" title=\"babel-loader\"></a>babel-loader</h2><p>前面我们简单介绍了如何使用babel对一份ts进行编译，那么在webpack中，如何使用babel呢？有的同学可能会想到这样操作步骤：我先用babel对ts进行编译为js，然后再利用webpack对js进行打包，这样的做法是可以的，但细想不就和上面的ts-loader一样的情况了吗？</p>\n<p>只要开发过基于webpack的现代化前端项目的同学，或多或少都看到过babel-loader的身影，他是个什么东西呢？先说结论吧，babel-loader是webpack和babel（由@babel/core和一堆预置集preset、插件plugins组合）的桥梁。</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/050-webpack-babel-loader-flow.png\" alt=\"050-webpack-babel-loader-flow\"></p>\n<p>根据这个图，同学可能觉得这不是和ts-loader的架构很像吗？webpack启动，遇到入口ts，匹配到babel-loader，babel-loader交给babel处理，处理完毕，回到webpack打包。但是使用babel进行ts处理，比起ts-loader更加高效。而关于这块的说明，我更加推荐读者阅读这篇文章<a href=\"https://zhuanlan.zhihu.com/p/59614089\"> TypeScript 和 Babel：美丽的结合 - 知乎 (zhihu.com)</a>，简单来讲：</p>\n<blockquote>\n<p>警告！有一个震惊的消息，你可能想坐下来好好听下。</p>\n<p>Babel 如何处理 TypeScript 代码？<strong>它删除它</strong>。</p>\n<p>是的，它删除了所有 TypeScript，将其转换为“常规的” JavaScript，并继续以它自己的方式愉快处理。</p>\n<p>这听起来很荒谬，但这种方法有两个很大的优势。</p>\n<p>第一个优势：️⚡️<strong>闪电般快速</strong>⚡️。</p>\n<p>大多数 Typescript 开发人员在开发/监视模式下经历过编译时间长的问题。你正在编写代码，保存一个文件，然后…它来了…再然后…<strong>最后</strong>，你看到了你的变更。哎呀，错了一个字，修复，保存，然后…啊。它<strong>只是</strong>慢得令人烦恼并打消你的势头。</p>\n<p>很难去指责 TypeScript 编译器，它在做很多工作。它在扫描那些包括 <code>node_modules</code> 在内的类型定义文件（<code>*.d.ts</code>），并确保你的代码正确使用。这就是为什么许多人将 Typescript 类型检查分到一个单独的进程。然而，Babel + TypeScript 组合仍然提供更快的编译，这要归功于 Babel 的高级缓存和单文件发射架构。</p>\n</blockquote>\n<p>让我们来搭建一个项目来复习这一过程吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir webpack-babel-loader-demo &amp;&amp; cd webpack-babel-loader-demo</span><br><span class=\"line\">yarn init</span><br><span class=\"line\">yarn add -D webpack webpack-cli</span><br><span class=\"line\">yarn add -D babel-loader</span><br><span class=\"line\">yarn add -D @babel&#x2F;core</span><br><span class=\"line\">yarn add -D @babel&#x2F;preset-env @babel&#x2F;preset-typescript</span><br><span class=\"line\">yarn add -D @babel&#x2F;plugin-proposal-class-properties @babel&#x2F;plugin-proposal-object-rest-spread</span><br></pre></td></tr></table></figure>\n<p><strong>package.json</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;webpack-babel-loader-demo&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;1.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;main&quot;</span>: <span class=\"string\">&quot;index.js&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;license&quot;</span>: <span class=\"string\">&quot;MIT&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;</span>: <span class=\"string\">&quot;webpack --config webpack.config.js&quot;</span> </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;devDependencies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/core&quot;</span>: <span class=\"string\">&quot;^7.18.13&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/plugin-proposal-class-properties&quot;</span>: <span class=\"string\">&quot;^7.18.6&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span>: <span class=\"string\">&quot;^7.18.9&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/preset-env&quot;</span>: <span class=\"string\">&quot;^7.18.10&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;@babel/preset-typescript&quot;</span>: <span class=\"string\">&quot;^7.18.6&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;babel-loader&quot;</span>: <span class=\"string\">&quot;^8.2.5&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;webpack&quot;</span>: <span class=\"string\">&quot;^5.74.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;webpack-cli&quot;</span>: <span class=\"string\">&quot;^4.10.0&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>webpack.config.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;resolve&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">&#x27;./src/index.ts&#x27;</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: resolve(__dirname, <span class=\"string\">&#x27;./dist&#x27;</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">&quot;index.js&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// webpack 默认只处理js、jsx等js代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 为了防止在import其他ts代码的时候，出现</span></span><br><span class=\"line\">    <span class=\"comment\">// &quot; Can&#x27;t resolve &#x27;xxx&#x27; &quot;的错误，需要特别配置</span></span><br><span class=\"line\">    extensions: [<span class=\"string\">&#x27;.js&#x27;</span>, <span class=\"string\">&#x27;.jsx&#x27;</span>, <span class=\"string\">&#x27;.ts&#x27;</span>, <span class=\"string\">&#x27;.tsx&#x27;</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.ts/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">&quot;babel-loader&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>src/index.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;hello&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> User &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> userToString = <span class=\"function\">(<span class=\"params\">user: User</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;user.name&#125;</span>@<span class=\"subst\">$&#123;user.age&#125;</span><span class=\"subst\">$&#123;hello()&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;userToString, User&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>src/utils.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> hello = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成上述package.json、webpack.config.js、src源代码三个部分，我们可以开始运行<code>yarn build</code>，但实际上会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR in .&#x2F;src&#x2F;index.ts</span><br><span class=\"line\">Module build failed (from .&#x2F;node_modules&#x2F;babel-loader&#x2F;lib&#x2F;index.js):</span><br><span class=\"line\">SyntaxError: &#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-babel-loader-demo&#x2F;src&#x2F;index.ts: Unexpected reserved word &#39;interface&#39;. (1:0)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 1 | interface User &#123;</span><br><span class=\"line\">    | ^</span><br><span class=\"line\">  2 |     name: string;</span><br><span class=\"line\">  3 |     age: number;</span><br><span class=\"line\">  4 | &#125;</span><br><span class=\"line\">    at instantiate (&#x2F;Users&#x2F;w4ngzhen&#x2F;Projects&#x2F;web-projects&#x2F;webpack-babel-loader-demo&#x2F;node_modules&#x2F;@babel&#x2F;parser&#x2F;lib&#x2F;index.js:72:32)</span><br></pre></td></tr></table></figure>\n<p>出现了语法的错误，报错的主要原因在于没有把整个babel处理ts的链路打通。目前的链路是：webpack找到入口ts文件，匹配上babel-loader，babel-loader交给@babel/core，@babel/core处理ts。由于我们没有给@babel/core配置plugin、preset，所以导致了babel还是以默认的js角度来处理ts代码，所以有语法报错。此时，我们需要添加.babelrc文件来指明让babel加载处理ts代码的插件：</p>\n<p><strong>.babelrc</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;presets&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/preset-env&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/preset-typescript&quot;</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/plugin-proposal-class-properties&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成配置以后，我们再次运行<code>yarn build</code>，编译通过，但是在dist下的index.js却是空白的！</p>\n<h3 id=\"问题：babel-loader编译后，输出js内容空白\"><a href=\"#问题：babel-loader编译后，输出js内容空白\" class=\"headerlink\" title=\"问题：babel-loader编译后，输出js内容空白\"></a>问题：babel-loader编译后，输出js内容空白</h3><p>如果按照上述的配置以后，我们能够成功编译但是却发现，输出的js代码是空白的！原因在于：我们编写的js代码，是按照类库的模式进行编写（在indexjs中只有导出一些函数却没有实际的使用），且webpack打包的时候，没有指定js代码的编译为什么样子的库。</p>\n<p>假如我们在index中编写一段具有副作用的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;hello&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> User &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> userToString = <span class=\"function\">(<span class=\"params\">user: User</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;user.name&#125;</span>@<span class=\"subst\">$&#123;user.age&#125;</span><span class=\"subst\">$&#123;hello()&#125;</span>`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具备副作用：在id=app的元素上添加监听</span></span><br><span class=\"line\"><span class=\"built_in\">document</span></span><br><span class=\"line\">    .querySelector(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br><span class=\"line\">    .addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;userToString, User&#125;;</span><br></pre></td></tr></table></figure>\n<p>此时我们使用生产模式（mode: ‘production’）来编译，会发现dist/index.js的内容如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;#app&quot;</span>).addEventListener(<span class=\"string\">&quot;click&quot;</span>, (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>会发现只有副作用代码，但是userToString相关的代码完全被剔除了！这时候，可能有读者会说，我导出的代码有可能别人会使用，你凭什么要帮我剔除？其实，因为webpack默认是生成项目使用的js，也就是做打包操作，他的目的是生成当前项目需要的js。在我们这个示例中，在没有写副作用之前，webpack认为打包是没有意义的，因为只有导出方法，却没有使用。那么，如果让webpack知道，我们需要做一个类库呢？在webpack中配置library字段即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;resolve&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">&#x27;./src/index.ts&#x27;</span>,</span><br><span class=\"line\">  mode: <span class=\"string\">&#x27;production&#x27;</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... ...</span></span><br><span class=\"line\">    library: &#123; </span><br><span class=\"line\">      <span class=\"comment\">// 配置library字段的相关配置，这里我们配置为commonjs2</span></span><br><span class=\"line\">      <span class=\"comment\">// 至于这块配置的意义，读者需要自行学习～</span></span><br><span class=\"line\">      type: <span class=\"string\">&#x27;commonjs2&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ... ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"tsc与babel编译的差异\"><a href=\"#tsc与babel编译的差异\" class=\"headerlink\" title=\"tsc与babel编译的差异\"></a>tsc与babel编译的差异</h1><p>现在我们先编写一个简单<strong>错误代码</strong>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> User &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// user.myName并没有在User接口中提供</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> userToString = <span class=\"function\">(<span class=\"params\">user: User</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;user.myName&#125;</span>@<span class=\"subst\">$&#123;user.age&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;userToString, User&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们试图访问在User类型中不存在的myName字段。</p>\n<h2 id=\"ts-loader-1\"><a href=\"#ts-loader-1\" class=\"headerlink\" title=\"ts-loader\"></a>ts-loader</h2><p>前面我们提到了ts-loader内部调用的是tsc作为编译器，我们尝试运行基于ts-loader的webpack配置进行打包该模块，会发现报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">... ...</span><br><span class=\"line\">      TS2551: Property &#39;myName&#39; does not exist on type &#39;User&#39;. Did you mean &#39;name&#39;?</span><br><span class=\"line\">ts-loader-default_e3b0c44298fc1c14</span><br><span class=\"line\"></span><br><span class=\"line\">webpack 5.74.0 compiled with 1 error in 2665 ms</span><br><span class=\"line\">error Command failed with exit code 1.</span><br><span class=\"line\">info Visit https:&#x2F;&#x2F;yarnpkg.com&#x2F;en&#x2F;docs&#x2F;cli&#x2F;run for documentation about this command.</span><br></pre></td></tr></table></figure>\n<p>可以看得出来，tsc帮助我们提示了类型错误的地方，user这个类型并没有对应的myName字段。</p>\n<h2 id=\"babel-loader-1\"><a href=\"#babel-loader-1\" class=\"headerlink\" title=\"babel-loader\"></a>babel-loader</h2><p>我们切换一下到babel-loader对该ts文件进行编译，居然发现编译可以直接成功！并且，我们检查编译好的js代码，会发现这部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dist/index.js</span></span><br><span class=\"line\">(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ... ...</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> r = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意这个地方：依然在使用myName</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>.concat(e.myName, <span class=\"string\">&quot;@&quot;</span>).concat(e.age);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = o;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>编译好的js代码就在直接使用myName字段。为什么类型检查失效了？还记得我们前面提到的babel怎么处理ts的？</p>\n<blockquote>\n<p>Babel 如何处理 TypeScript 代码？<strong>它删除它</strong>。</p>\n<p>是的，它删除了所有 TypeScript，将其转换为“常规的” JavaScript，并继续以它自己的方式愉快处理。</p>\n</blockquote>\n<p>是的，babel并没有进行类型检查，而是将各种类型移除掉以达到快速完成编译的目的。那么问题来了，我们如何让babel进行类型判断呢？<strong>实际上，我们没有办法让babel进行类型判断，必须要借助另外的工具进行。</strong>那为什么我们的IDE却能够现实ts代码的错误呢？因为IDE帮助我们进行了类型判断。</p>\n<h1 id=\"主流IDE对TypeScript的类型检查\"><a href=\"#主流IDE对TypeScript的类型检查\" class=\"headerlink\" title=\"主流IDE对TypeScript的类型检查\"></a>主流IDE对TypeScript的类型检查</h1><p>不知道有没有细心的读者在使用IDEA的时候，发现一个ts项目的IDEA右下角展示了typescript：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/060-idea-ts-service.png\" alt=\"060-idea-ts-service\"></p>\n<p>VSCode也能看到类似：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/070-vscode-ts-service.png\" alt=\"070-vscode-ts-service\"></p>\n<p>在同一台电脑上，甚至发现IDEA和VSCode的typescript版本都还不一样（4.7.4和4.7.3）。这是怎么一回事呢？实际上，IDE检测到你所在的项目是一个ts项目的时候（或包含ts文件），就会自动的启动一个ts的检测服务，专门用于所在项目的ts类型检测。这个ts类型检测服务，是通过每个IDE默认情况下自带的typescript中的tsc进行类型检测。</p>\n<p>但是，我们可以全局安装（npm -g）或者是为每个项目单独安装typescript，然后就可以让IDE选择启动独立安装的typescript。比如，我们在本项目中，安装一个特定版本的ts（版本4.7.2）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D typescript@4.7.2</span><br></pre></td></tr></table></figure>\n<p>在IDEA中，设置 - Languages &amp; Frameworks - TypeScript中，就可以选择IDEA启动的4.7.2版本的TypeScript为我们项目提供类型检查（注意看选项中有一个Bundled的TS，版本是4.7.4，就是默认的）：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/080-idea-select-ts.png\" alt=\"080-idea-select-ts\"></p>\n<p>IDE之所以能够在对应的代码位置展示代码的类型错误，流程如下：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/090-ide-ts-service-flow.png\" alt=\"090-ide-ts-service-flow\"></p>\n<p>但是，ts类型检查也要有一定的依据。譬如，有些类型定义的文件从哪里查找，是否允许较新的语法等，这些配置依然是由tsconfig.json来提供的，但若未提供，则IDE会使用一份默认的配置。如果要进行类型检测的自定义配置，则需要提供tsconfig.json。</p>\n<p>还记得我们前面的ts-loader吗？在代码编译期，ts-loader调用tsc，tsc读取项目目录下的tsconfig.json配置。而咱们编写代码的时候，又让IDE的ts读取该tsconfig.json配置文件进行类型检查。</p>\n<p>对于ts-loader项目体系来说，ts代码编译和ts的类型检测如下：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/100-ts-loader-and-ide.png\" alt=\"100-ts-loader-and-ide\"></p>\n<p>然而，对于babel-loader项目体系就不像ts-loader那样了：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-14/110-babel-loader-and-ide.png\" alt=\"110-babel-loader-and-ide\"></p>\n<p>在babel-loader体系中，代码的编译只取决于babel部分的处理，根类型没有根本的关系，而类型检查使用到的tsconfig和tsc则只作用在类型检查的部分，根ts代码编译没有任何关系。</p>\n","categories":[],"tags":["ts","babel","webpack"]},{"title":"从零搭建react+ts组件库（二）less模块化与svg引入配置","url":"http://compilemind.com/2022/08/11/2022-08-11-从零搭建react+ts组件库（二）配置less模块话与svg/","content":"<p>在上一篇《从零搭建react+ts组件库（一）项目搭建与封装antd组件》介绍了使用webpack来搭建一个基于antd的组件库的基本框架，但是作为一个组件库，实际上还有很多的都还未引入，本篇将会补充less模块化以及svg引入的基本方式。</p>\n<a id=\"more\"></a>\n<p>本文所有修改的代码分支为chapter02位于<a href=\"https://github.com/w4ngzhen/r-ui\">w4ngzhen/r-ui (github.com)</a>仓库的<code>chapter02_less_and_svg</code>分支，该分支基于上一篇文章的<code>chapter01_init</code>分支而来（main分支总是显示最新的内容）。</p>\n<p>为了讲解如何进行less模块化配置以及如何引入svg作为组件库的一部分，我们设想这样一个需求：一个搜索输入框，左侧是一个svg的icon搜索图标，右侧是输入框。</p>\n<h1 id=\"组件规划\"><a href=\"#组件规划\" class=\"headerlink\" title=\"组件规划\"></a>组件规划</h1><p>首先考虑组件具备的属性，作为一个简单的搜索框，我们至少有3个属性：</p>\n<ol>\n<li>输入框初始默认值（defaultValue）</li>\n<li>占位提示信息（placeholder）</li>\n<li>输入改变事件（onChange）</li>\n</ol>\n<p>对于UI结构来说，我们可以使用一个div作为整体包裹，然后左侧是图标的区域（使用一个div），右侧是输入框（input）。</p>\n<p>综上，我们的初始代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">interface SearchInputProps &#123;</span><br><span class=\"line\">    defaultValue?: string;</span><br><span class=\"line\">    placeholder?: string;</span><br><span class=\"line\">    onChange?: (value: string, e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#x3D;&gt; void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const SearchInput: React.FC&lt;SearchInputProps&gt; &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;</span><br><span class=\"line\">        defaultValue,</span><br><span class=\"line\">        placeholder,</span><br><span class=\"line\">        onChange,</span><br><span class=\"line\">    &#125; &#x3D; props;</span><br><span class=\"line\"></span><br><span class=\"line\">    const inputOnChange: React.ChangeEventHandler&lt;HTMLInputElement&gt;</span><br><span class=\"line\">        &#x3D; (e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#x3D;&gt; &#123;</span><br><span class=\"line\">        if (onChange) &#123;</span><br><span class=\"line\">            onChange(e.target.value, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &#x2F;&#x2F; 包裹</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &#123;&#x2F;*存放icon*&#x2F;&#125;</span><br><span class=\"line\">            &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">            &#123;&#x2F;* 输入框*&#x2F;&#125;</span><br><span class=\"line\">            &lt;input defaultValue&#x3D;&#123;defaultValue&#125;</span><br><span class=\"line\">                   placeholder&#x3D;&#123;placeholder&#125;</span><br><span class=\"line\">                   onChange&#x3D;&#123;inputOnChange&#125;&gt;&lt;&#x2F;input&gt;</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"less样式模块化配置\"><a href=\"#less样式模块化配置\" class=\"headerlink\" title=\"less样式模块化配置\"></a>less样式模块化配置</h1><p>首先我们编写less样式文件，当然，对于该文件我们不赘述实现。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@input-size:</span> <span class=\"number\">32px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.centerAll</span>() &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.searchInputWrap</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"variable\">@input-size</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#f4f4f4</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.centerAll</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.searchInputIconBox</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"variable\">@input-size</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"variable\">@input-size</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: transparent;</span><br><span class=\"line\">    <span class=\"selector-class\">.centerAll</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.searchInput</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: calc(<span class=\"number\">100%</span> - <span class=\"variable\">@input-size</span>);</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: transparent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.searchInput</span><span class=\"selector-pseudo\">:focus</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>修改组件代码，改动如下：</p>\n<ol>\n<li>以模块化的方式引入less文件</li>\n</ol>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> import * as React from &quot;react&quot;;</span><br><span class=\"line\"><span class=\"addition\">+import styles from &#x27;./index.module.less&#x27;;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>针对每个元素配置其less样式，采用<code>styles.xxx</code>方式使用</li>\n</ol>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     return (</span><br><span class=\"line\">         // 包裹</span><br><span class=\"line\"><span class=\"deletion\">-        &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"addition\">+        &lt;div className=&#123;styles.searchInputWrap&#125;&gt;</span></span><br><span class=\"line\">             &#123;/*存放icon*/&#125;</span><br><span class=\"line\"><span class=\"deletion\">-            &lt;div&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"addition\">+            &lt;div className=&#123;styles.searchInputIconBox&#125;&gt;&lt;/div&gt;</span></span><br><span class=\"line\">             &#123;/* 输入框*/&#125;</span><br><span class=\"line\"><span class=\"deletion\">-            &lt;input defaultValue=&#123;defaultValue&#125;</span></span><br><span class=\"line\"><span class=\"addition\">+            &lt;input className=&#123;styles.searchInput&#125;</span></span><br><span class=\"line\"><span class=\"addition\">+                   defaultValue=&#123;defaultValue&#125;</span></span><br><span class=\"line\">                    placeholder=&#123;placeholder&#125;</span><br><span class=\"line\">                    onChange=&#123;inputOnChange&#125;&gt;&lt;/input&gt;</span><br><span class=\"line\">         &lt;/div&gt;</span><br><span class=\"line\">     )</span><br></pre></td></tr></table></figure>\n<p>webpack对于css-loader需要进行简单的配置：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">           &#123;</span><br><span class=\"line\">             loader: MiniCssExtractPlugin.loader,</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\"><span class=\"deletion\">-          &#x27;css-loader&#x27;,</span></span><br><span class=\"line\"><span class=\"addition\">+          &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+            loader: &quot;css-loader&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+            options: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+              modules: true</span></span><br><span class=\"line\"><span class=\"addition\">+            &#125;</span></span><br><span class=\"line\"><span class=\"addition\">+          &#125;,</span></span><br><span class=\"line\">           &#x27;less-loader&#x27;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对于该处的配置，详细可以查看关于css-loader的文档<a href=\"https://github.com/webpack-contrib/css-loader\">webpack-contrib/css-loader: CSS Loader (github.com)</a></p>\n<p>此时，如果有同学在使用IDEA会发现有编译报错。有同学会发现，我们的项目里面没有直接安装typescript，那么为什么IDEA能够检测到我们代码呢？实际上这是IDEA自带的ts在进行类型检测，<strong>仅仅是类型检查</strong>，实际上编译过程我们是调用的babel-loader+preset/typescript这条链路来完成的，所以并不影响编译后的内容。当然，为了能够进行正确的类型检查，我们在项目根目录下添加tsconfig.json：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;noEmit&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;esModuleInterop&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;jsx&quot;</span>: <span class=\"string\">&quot;react&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;include&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;src&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;./src/external.d.ts&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，<code>&quot;noEmit&quot;: true</code>表明由ts进行类型检查，但是不编译文件。include中的<code>./src/external.d.ts</code>中的内容如下：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// less模块声明</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">module</span> &#x27;*.<span class=\"keyword\">module</span>.less&#x27; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> content: &#123; [className: <span class=\"built_in\">string</span>]: <span class=\"built_in\">string</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> = content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，希望IDEA的内置ts读取tsconfig.json，并添加关于import<code>*.module.less</code>时候得到的模块的类型定义。这样，IDEA的ts类型检查在这句话的时候就不会报错了：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> styles <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./index.module.less&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>总结一下，想要在ts+babel-loader项目中使用样式模块化。</p>\n<p>在类型检查阶段，需要：</p>\n<ol>\n<li>单独配置tsconfig.json</li>\n<li>编写d.ts，并被tsconfig.json配置包含在类型定义查找的范围（inlcude）</li>\n</ol>\n<p>在编译阶段，需要只需要配置css-loader的module为true即可。</p>\n<p>这一块我会再写一篇文章来单独讲解webpack+ts+babel的方案。</p>\n<h2 id=\"效果演示\"><a href=\"#效果演示\" class=\"headerlink\" title=\"效果演示\"></a>效果演示</h2><p>编写样例html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>r-ui example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;r-ui.umd.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;r-ui.umd.css&quot;</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;example&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// window上存在rui，是因为我们将组件包导出为了umd包，取名为rui</span></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">const</span> button = React.createElement(rui.SearchInput, &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    placeholder: <span class=\"string\">&#x27;占位符&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">    defaultValue: <span class=\"string\">&#x27;hello, world&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">    onChange: <span class=\"function\">(<span class=\"params\">value, e</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(value, e)</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"javascript\">  ReactDOM.render(button, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example&#x27;</span>));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>编译r-ui后打开样例界面，可以看到如下效果：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-11/010-less-module.gif\" alt=\"010-less-module\"></p>\n<h1 id=\"svg引入配置\"><a href=\"#svg引入配置\" class=\"headerlink\" title=\"svg引入配置\"></a>svg引入配置</h1><p>实际上，react中想要使用svg有这很多种方式，像是直接编写react组件，并返回svg代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">const IconSearch &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;svg className&#x3D;&quot;icon&quot;</span><br><span class=\"line\">             viewBox&#x3D;&quot;0 0 1024 1024&quot; version&#x3D;&quot;1.1&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;</span><br><span class=\"line\">             p-id&#x3D;&quot;4136&quot; width&#x3D;&quot;25&quot; height&#x3D;&quot;25&quot;&gt;</span><br><span class=\"line\">            &lt;path</span><br><span class=\"line\">                d&#x3D;&quot;M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6c3.2 3.2 8.4 3.2 11.6 0l43.6-43.5c3.2-3.2 3.2-8.4 0-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z&quot;</span><br><span class=\"line\">                p-id&#x3D;&quot;4137&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class=\"line\">        &lt;&#x2F;svg&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式弊端在于，每次svg有修改的时候，都需要重新复制svg代码对代码文件进行修改，且很多svg的数据较为复杂，容易出错。</p>\n<h2 id=\"将svg作为react组件来使用\"><a href=\"#将svg作为react组件来使用\" class=\"headerlink\" title=\"将svg作为react组件来使用\"></a>将svg作为react组件来使用</h2><p>我们知道，对于webpack来说，可以将一切的东西都是为模块，对于任何import进来的，webpack都可以通过匹配的规则（rules）调用对应的loader来进行处理。</p>\n<p>那么，是否存在这样一种方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import IconSearch from &#39;path&#x2F;to&#x2F;search.svg&#39;</span><br><span class=\"line\">&#x2F;&#x2F; IconSearch是一个React组件，可以在其他组件中使用</span><br></pre></td></tr></table></figure>\n<p>个人最常使用的方案是<code>svgr/webpack</code>（<a href=\"https://react-svgr.com/docs/webpack/\">Webpack - SVGR (react-svgr.com)</a>）</p>\n<p>只需要三个步骤的配置：</p>\n<ol>\n<li>引入@svgr/webpack</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D @svgr&#x2F;webpack</span><br></pre></td></tr></table></figure>\n<ol>\n<li>配置webpack，处理svg</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.svg$/</span>,</span><br><span class=\"line\">  use: [<span class=\"string\">&#x27;@svgr/webpack&#x27;</span>],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>external.d.ts配置（配置理由和上述less配置一样，为了达到类型检查）</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// svg类型</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">module</span> &#x27;*.svg&#x27; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> content: React.FunctionComponent&lt;React.SVGAttributes&lt;React.ReactSVGElement&gt;&gt;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> content</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成配置以后，我们就可以通过import XXX from ‘path/to/xxx.svg’，来使用SVG组件了：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> import * as React from &quot;react&quot;;</span><br><span class=\"line\"> import styles from &#x27;./index.module.less&#x27;;</span><br><span class=\"line\"><span class=\"addition\">+import IconSearch from &quot;../../assets/svg/search.svg&quot;;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> interface SearchInputProps &#123;</span><br><span class=\"line\">     defaultValue?: string;</span><br><span class=\"line\">     // ... ...</span><br><span class=\"line\">         // 包裹</span><br><span class=\"line\">         &lt;div className=&#123;styles.searchInputWrap&#125;&gt;</span><br><span class=\"line\">             &#123;/*存放icon*/&#125;</span><br><span class=\"line\"><span class=\"deletion\">-            &lt;div className=&#123;styles.searchInputIconBox&#125;&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"addition\">+            &lt;div className=&#123;styles.searchInputIconBox&#125;&gt;</span></span><br><span class=\"line\"><span class=\"addition\">+                &lt;IconSearch width=&#123;18&#125; height=&#123;18&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"addition\">+            &lt;/div&gt;</span></span><br><span class=\"line\">             &#123;/* 输入框*/&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"效果演示-1\"><a href=\"#效果演示-1\" class=\"headerlink\" title=\"效果演示\"></a>效果演示</h2><p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-08-11/020-use-svg.png\" alt=\"020-use-svg\"></p>\n","categories":[],"tags":["react","ui"]},{"title":"《世嘉新人培训教材—游戏开发》2DGraphics1项目cmake构建","url":"http://compilemind.com/2022/07/22/2022-07-22-《世嘉新人培训教材—游戏开发》2DGraphics1项目cmake构建/","content":"<p>《世嘉新人培训教材—游戏开发》作为经典的游戏开发教程，提供了相关样例代码供我们进行开发使用。但是该样例是基于VS进行编写构建的，而本人日常喜欢CLion进行C/C++开发，于是准备使用cmake重新组织该书籍的样例项目：2DGraphics1中的NimotsuKunBox和drawPixels。当然，这个过程不仅是移植，也是对cmake组织项目一个深入的实践。</p>\n<a id=\"more\"></a>\n<h1 id=\"对现有样例项目的认识与构建\"><a href=\"#对现有样例项目的认识与构建\" class=\"headerlink\" title=\"对现有样例项目的认识与构建\"></a>对现有样例项目的认识与构建</h1><h2 id=\"样例代码结构\"><a href=\"#样例代码结构\" class=\"headerlink\" title=\"样例代码结构\"></a>样例代码结构</h2><p>在进行cmake迁移前，有必要对现有的VS体系的代码结构进行了解。</p>\n<h3 id=\"GameLib（样例根目录）\"><a href=\"#GameLib（样例根目录）\" class=\"headerlink\" title=\"GameLib（样例根目录）\"></a>GameLib（样例根目录）</h3><p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-07-22-sega-game-dev/010-root.png\" alt=\"010-root\"></p>\n<p>该目录下主要存放了：</p>\n<ol>\n<li><p><strong>各个样例会使用的工具静态库/头文件</strong>；</p>\n</li>\n<li><p><strong>src</strong>：样例源码；</p>\n</li>\n<li><p><strong>tools</strong>：工具二进制程序。</p>\n</li>\n</ol>\n<h3 id=\"GameLib-src目录\"><a href=\"#GameLib-src目录\" class=\"headerlink\" title=\"GameLib/src目录\"></a>GameLib/src目录</h3><p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-07-22-sega-game-dev/020-root-src.png\" alt=\"020-root-src\"></p>\n<p>该目录下主要存放：</p>\n<ol>\n<li><p><strong>各种数字+下划线开头的文件夹</strong>：书中使用到的各种样例工程；</p>\n</li>\n<li><p><strong>GameLibs文件夹</strong>：生成GameLib根目录中的静态库/头文件的源码。</p>\n</li>\n</ol>\n<h3 id=\"GameLib-src-GameLibs目录\"><a href=\"#GameLib-src-GameLibs目录\" class=\"headerlink\" title=\"GameLib/src/GameLibs目录\"></a>GameLib/src/GameLibs目录</h3><p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-07-22-sega-game-dev/030-root-src-GameLibs.png\" alt=\"030-root-src-GameLibs\"></p>\n<p>该目录主要存放：</p>\n<ol>\n<li><strong>GameLib根目录下各个被样例项目使用的静态库/头文件的源码</strong>；</li>\n<li><strong>Modules</strong>：其他静态库项目的依赖静态库。</li>\n</ol>\n<h2 id=\"使用VS构建样例项目静态库\"><a href=\"#使用VS构建样例项目静态库\" class=\"headerlink\" title=\"使用VS构建样例项目静态库\"></a>使用VS构建样例项目静态库</h2><p>在GameLib下，本书的译者已经帮我们编写了一个基本的指南：</p>\n<blockquote>\n<p>编译顺序<br>在系统环境变量中添加 GAME_LIB_DIR 值为源码工程的根目录<br>注意要重启visual studio</p>\n<p>①先编译类库的Modules<br>src\\GameLibs\\Modules\\Modules.sln</p>\n<p>②再编译各个小功能的类库<br>比如 src\\GameLibs\\2DActionGame\\GameLib.sln</p>\n<p>③最后编译游戏本身<br>比如 src\\01_FirstGame\\FirstGame.sln</p>\n<p>为什么要按照这样的顺序呢？请看下面这个例子<br>譬如对src\\02_2DGraphics1\\2DGraphics1.sln 来说，<br>首先用vs打开它，右键点击 drawPixels查看属性<br>在链接器 的附加库目录一栏可以看到  $(GAME_LIB_DIR)\\2DGraphics1\\lib;%(AdditionalLibraryDirectories)<br>这意味着它需要在2DGraphics1\\lib中查找某些类库，<br>具体要用什么类库呢？可以点击 链接器 -&gt; 输入 ，看到附加依赖项中有 GameLib_d.lib;%(AdditionalDependencies)</p>\n<p>如何才能生成这个 GameLib_d.lib呢?<br>打开 src\\GameLibs\\2DGraphics1\\GameLib.sln 编译即可<br>但是，通过右键Framework属性， 查看库管理器 的附加依赖项可以看到 Modules_d.lib<br>这就要求必须先编译好 Modules工程<br>于是打开 src\\GameLibs\\Modules\\Modules.sln 编译即可。</p>\n</blockquote>\n<p>这里有两个关键点需要牢记：</p>\n<ol>\n<li>需要配置环境变量<code>GAME_LIB_DIR</code>，原因在于后续即将编译的各个样例，都会使用<code>$(GAME_LIB_DIR)</code>然后找到对应的类库；</li>\n<li>编译有一个顺序：先核心静态库：Modules；然后各个样例需要的GameLib；最后是样例。</li>\n</ol>\n<h3 id=\"编译核心的Modules\"><a href=\"#编译核心的Modules\" class=\"headerlink\" title=\"编译核心的Modules\"></a>编译核心的Modules</h3><p>加载<code>$(GAME_LIB_DIR)\\src\\GameLibs\\Modules\\Modules.sln</code>进行构建</p>\n<p>使用vs编译后会生成<code>$(GAME_LIB_DIR)\\src\\GameLibs\\Modules\\lib\\Modules_d.lib</code>（<code>_d</code>代表Debug的静态库）</p>\n<h3 id=\"编译各独立样例需要的GameLib\"><a href=\"#编译各独立样例需要的GameLib\" class=\"headerlink\" title=\"编译各独立样例需要的GameLib\"></a>编译各独立样例需要的GameLib</h3><p>在本文中，我们的目标是构建2DGrphics1-NimotsuKunBox项目，所以我们加载2DGrphics1的GameLib：<code>$(GAME_LIB_DIR)\\src\\GameLibs\\2DGraphics1\\GameLib.sln</code>进行构建，通过配置也能看到的确需要<code>Modules_d.lib</code>：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-07-22-sega-game-dev/040-gamelib-use-modules.png\" alt=\"040-gamelib-use-modules\"></p>\n<p>该项目构建完成后，会生成：<code>$(GAME_LIB_DIR)\\2DGraphics1\\lib\\GameLib_d.lib</code>，并且会将<code>GameLib_d.lib</code>静态库以及相关头文件都复制到<code>$(GAME_LIB_DIR)\\2DGraphics1\\中</code>，：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(GAME_LIB_DIR)\\2DGraphics1\\</span><br><span class=\"line\">├─include</span><br><span class=\"line\">│  └─GameLib</span><br><span class=\"line\">│      │  Framework.h</span><br><span class=\"line\">│      │</span><br><span class=\"line\">│      └─Base</span><br><span class=\"line\">│          DebugStream.h</span><br><span class=\"line\">│</span><br><span class=\"line\">└─lib</span><br><span class=\"line\">        Framework_d.idb</span><br><span class=\"line\">        Framework_d.pdb</span><br><span class=\"line\">        GameLib_d.lib（lib库）</span><br><span class=\"line\">        GameLib_d.pdb</span><br><span class=\"line\">        Modules_d.pdb</span><br></pre></td></tr></table></figure>\n<p>目前为止，我们生成了如下的两静态库以及头文件：</p>\n<ol>\n<li><code>$(GAME_LIB_DIR)\\src\\GameLibs\\Modules\\lib\\Modules_d.lib</code></li>\n<li><code>$(GAME_LIB_DIR)\\2DGraphics1\\lib\\GameLib_d.lib</code></li>\n<li><code>$(GAME_LIB_DIR)\\2DGraphics1\\include（头文件）</code></li>\n</ol>\n<p><strong>当然，因为我们的<code>GameLib_d.lib</code>是使用<code>Modules_d.lib</code>进行构建的，已经将<code>Modules_d.lib</code>链接到了<code>GameLib_d.lib</code>内部了，所以接下来我们的cmake项目不再需要<code>Modules_d.lib</code>了。</strong></p>\n<h3 id=\"演示2DGraphics1-NimotsuKunBox和drawPixels项目\"><a href=\"#演示2DGraphics1-NimotsuKunBox和drawPixels项目\" class=\"headerlink\" title=\"演示2DGraphics1-NimotsuKunBox和drawPixels项目\"></a>演示2DGraphics1-NimotsuKunBox和drawPixels项目</h3><p>使用VS打开<code>$(GAME_LIB_DIR)\\src\\02_2DGraphics1\\2DGraphics1.sln&quot;</code>解决方案，该解决方案中有如下的5个样例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NimotsuKunBox</span><br><span class=\"line\">NimotsuKunBoxWithTermination</span><br><span class=\"line\">NimotsuKunTextOnly</span><br><span class=\"line\">NimotuKunDot</span><br><span class=\"line\">drawPixels</span><br></pre></td></tr></table></figure>\n<p>将NimotsuKunBox项目作为启动项目，然后运行可以看到如下的界面：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-07-22-sega-game-dev/050-NimotsuKunBox-show.png\" alt=\"050-NimotsuKunBox-show\"></p>\n<p>将drawPixels作为启动项，运行可看到如下效果：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-07-22-sega-game-dev/060-drawPixels-show.png\" alt=\"060-drawPixels-show\"></p>\n<p>接下来，我们将使用cmake来移植这两个项目。</p>\n<h1 id=\"使用cmake搭建2DGraphics1项目\"><a href=\"#使用cmake搭建2DGraphics1项目\" class=\"headerlink\" title=\"使用cmake搭建2DGraphics1项目\"></a>使用cmake搭建2DGraphics1项目</h1><p>在经过前戏后，我们终于编译出了2DGraphics1所需要的<code>GameLib_d.lib</code>静态库以及相关的头文件，并且，我们还构建了2DGraphics1样例解决方案中的NimotsuKunBox和drawPixels项目。接下来我们将创建一个cmake项目，移植该样例中的两个项目。</p>\n<h2 id=\"搭建初始项目\"><a href=\"#搭建初始项目\" class=\"headerlink\" title=\"搭建初始项目\"></a>搭建初始项目</h2><p>首先，我们建立一个文件夹2DGraphics1_cmake，在该文件夹中，我们再创建两个文件夹：NimotsuKunBox和：drawPixels，并且这两个文件夹中分别各自创建一个main.cpp文件和CMakeLists.txt，内容如下：</p>\n<p>2DGraphics1_cmake/NimotsuKunBox：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2DGraphics1_cmake/NimotsuKunBox/main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;hello, NimotsuKunBox&quot;</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class=\"number\">3.22</span>)</span><br><span class=\"line\"><span class=\"keyword\">PROJECT</span>(NimotsuKunBox)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_CXX_STANDARD <span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD_EXECUTABLE</span>(NimotsuKunBox main.cpp)</span><br></pre></td></tr></table></figure>\n<p>2DGraphics1_cmake/drawPixels：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2DGraphics1_cmake/drawPixels/main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;hello, drawPixels&quot;</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class=\"number\">3.22</span>)</span><br><span class=\"line\"><span class=\"keyword\">PROJECT</span>(drawPixels)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_CXX_STANDARD <span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD_EXECUTABLE</span>(drawPixels main.cpp)</span><br></pre></td></tr></table></figure>\n<p>接着，我们在2DGraphics1_cmake中创建一个CMakeLists.txt来统一管理NimotsuKunBox和drawPixels这两个cmake项目，内容如下：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class=\"number\">3.22</span>)</span><br><span class=\"line\"><span class=\"keyword\">PROJECT</span>(<span class=\"number\">2</span>DGraphics1_cmake)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_CXX_STANDARD <span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># cmake子项目，子项目的名称就是子目录下的CMakeLists.txt中的PROJECT一致的名称</span></span><br><span class=\"line\"><span class=\"keyword\">ADD_SUBDIRECTORY</span>(NimotsuKunBox)</span><br><span class=\"line\"><span class=\"keyword\">ADD_SUBDIRECTORY</span>(drawPixels)</span><br></pre></td></tr></table></figure>\n<p>于是，当前整体目录结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2DGraphics1_cmake</span><br><span class=\"line\">├─ CMakeLists.txt</span><br><span class=\"line\">├─ NimotsuKunBox</span><br><span class=\"line\">│    ├─ CMakeLists.txt</span><br><span class=\"line\">│    └─ main.cpp</span><br><span class=\"line\">└─ drawPixels</span><br><span class=\"line\">     ├─ CMakeLists.txt</span><br><span class=\"line\">     └─ main.cpp</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>cmake实践点：子项目管理</p>\n<p>父级CMakeLists.txt可以通过ADD_SUBDIRECTORY来添加子CMake项目。这里有一篇特别详细的博文<a href=\"https://www.cnblogs.com/juzaizai/p/15069693.html\">CMake基础 第13节 构建子项目 - 橘崽崽啊 - 博客园 (cnblogs.com)</a></p>\n</blockquote>\n<h2 id=\"头文件与静态库添加\"><a href=\"#头文件与静态库添加\" class=\"headerlink\" title=\"头文件与静态库添加\"></a>头文件与静态库添加</h2><p>在前面我们已经编译出了<code>GameLib_d.lib</code>，并且把头文件已经复制到了指定目录。现在，我们在项目根目录中创建一个<code>@lib</code>文件夹，专门放置静态库和头文件，目录状态如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2DGraphics1_cmake</span><br><span class=\"line\">├─ CMakeLists.txt</span><br><span class=\"line\">├─ NimotsuKunBox</span><br><span class=\"line\">│    └─ &#x2F;&#x2F; ... ...</span><br><span class=\"line\">├─ drawPixels</span><br><span class=\"line\">│    └─ &#x2F;&#x2F; ... ...</span><br><span class=\"line\">└─ @lib  &#x2F;&#x2F; &#x3D;&gt; 存放要使用的静态库和头文件</span><br><span class=\"line\">    ├─ include</span><br><span class=\"line\">    │    └─ GameLib</span><br><span class=\"line\">    │           ├─ Base</span><br><span class=\"line\">    │           │    └─ DebugStream.h</span><br><span class=\"line\">    │           └─ Framework.h</span><br><span class=\"line\">    └─ lib</span><br><span class=\"line\">           ├─ Framework_d.idb</span><br><span class=\"line\">           ├─ Framework_d.pdb</span><br><span class=\"line\">           ├─ GameLib_d.lib</span><br><span class=\"line\">           ├─ GameLib_d.pdb</span><br><span class=\"line\">           └─ Modules_d.pdb</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置NimotsuKunBox项目\"><a href=\"#配置NimotsuKunBox项目\" class=\"headerlink\" title=\"配置NimotsuKunBox项目\"></a>配置NimotsuKunBox项目</h2><p>为了让NimotsuKunBox项目中的能够使用到根目录下的静态库和头文件，我们需要配置NimotsuKunBox/CMakeLists.txt，添加头文件和静态库：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  SET(CMAKE_CXX_STANDARD 11)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"addition\">+ MESSAGE(&quot;Current CMakeLists.txt dir:\\n$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"addition\">+</span></span><br><span class=\"line\"><span class=\"addition\">+ # 配置头文件查找路径</span></span><br><span class=\"line\"><span class=\"addition\">+ INCLUDE_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../@lib/include)</span></span><br><span class=\"line\"><span class=\"addition\">+ # 配置链接库文件查找路径</span></span><br><span class=\"line\"><span class=\"addition\">+ LINK_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../@lib/lib)</span></span><br><span class=\"line\"><span class=\"addition\">+</span></span><br><span class=\"line\">  ADD_EXECUTABLE(NimotsuKunBox main.cpp)</span><br><span class=\"line\"><span class=\"addition\">+</span></span><br><span class=\"line\"><span class=\"addition\">+ # 实际链接</span></span><br><span class=\"line\"><span class=\"addition\">+ TARGET_LINK_LIBRARIES(NimotsuKunBox GameLib_d.lib)</span></span><br></pre></td></tr></table></figure>\n<p>之后，我们将在VS中能够运行的NimotsuKunBox项目代码拷贝到当前的main.cpp中，由于篇幅的关系，就不贴出代码本身了，给一个整体的修改：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-07-22-sega-game-dev/070-NimotsuKunBox-modified01.png\" alt=\"070-NimotsuKunBox-modified01\"></p>\n<h3 id=\"编译问题\"><a href=\"#编译问题\" class=\"headerlink\" title=\"编译问题\"></a>编译问题</h3><p>当我们尝试运行该项目的时候，发现至少有以下几个问题：</p>\n<p><strong>问题1：在CLion+msvc编译器下，编码字符报错：warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失。</strong></p>\n<p>该问题原因在于CLion中的文件是默认使用的UTF-8编码，而msvc在不指定的情况默认以当前代码页（936）编码方式读取文件（<em>代码页936（Codepage 936）是Microsoft的简体中文字符集标准，是东亚语文的四种双字节字符集（DBCS）之一。其最初版本和GB 2312一模一样，但在推出Windows 95时扩展成GBK</em>）。</p>\n<p>在CMake中想要给msvc指定文件编码方式，需要在CMakeLists.txt配置如下内容：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">... ...</span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_CXX_STANDARD <span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置编译器以指定编码读取代码源文件</span></span><br><span class=\"line\"><span class=\"keyword\">ADD_COMPILE_OPTIONS</span>(<span class=\"string\">&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">ADD_COMPILE_OPTIONS</span>(<span class=\"string\">&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">MESSAGE</span>(<span class=\"string\">&quot;Current CMakeLists.txt dir:\\n$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class=\"line\">... ...</span><br></pre></td></tr></table></figure>\n<p><strong>问题2：GameLib_d.lib(MemoryManager.obj) : error LNK2038: 检测到“RuntimeLibrary”的不匹配项: 值“MTd_StaticDebug”不匹配值“MDd_DynamicDebug”(main.cpp.obj 中)</strong></p>\n<p>这一类报错通常比较普遍，简单来讲就是：GameLib_d.lib这个库是一个静态库带Debug（MTd_StaticDebug），但是我们的项目链接步骤是以动态库的方式链接这些库文件。对于这个问题，有两种方式来解决，一种就是重新编译GameLib为一个dll（动态链接库）；另一种则是修改当前项目的链接方式为静态库链接。当然，简便起见，我们修改项目的链接形式为静态库链接形式：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ... ...</span><br><span class=\"line\"> SET(CMAKE_CXX_STANDARD 11)</span><br><span class=\"line\"> ADD_COMPILE_OPTIONS(&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;)</span><br><span class=\"line\"> ADD_COMPILE_OPTIONS(&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"addition\">+# 设置策略CMP0091为NEW，新策略</span></span><br><span class=\"line\"><span class=\"addition\">+if (POLICY CMP0091)</span></span><br><span class=\"line\"><span class=\"addition\">+    CMAKE_POLICY(SET CMP0091 NEW)</span></span><br><span class=\"line\"><span class=\"addition\">+endif (POLICY CMP0091)</span></span><br><span class=\"line\"><span class=\"addition\">+</span></span><br><span class=\"line\"> MESSAGE(&quot;Current CMakeLists.txt dir:\\n$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> LINK_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../@lib/lib)</span><br><span class=\"line\"> </span><br><span class=\"line\"> ADD_EXECUTABLE(NimotsuKunBox main.cpp)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"addition\">+# 设置MT/MTd</span></span><br><span class=\"line\"><span class=\"addition\">+SET_PROPERTY(</span></span><br><span class=\"line\"><span class=\"addition\">+        TARGET NimotsuKunBox</span></span><br><span class=\"line\"><span class=\"addition\">+        PROPERTY MSVC_RUNTIME_LIBRARY &quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;)</span></span><br><span class=\"line\"><span class=\"addition\">+</span></span><br><span class=\"line\"> # 实际链接</span><br><span class=\"line\"> TARGET_LINK_LIBRARIES(NimotsuKunBox GameLib_d.lib)</span><br></pre></td></tr></table></figure>\n<p>关于这块配置的细节，可以参考这篇文章：<a href=\"https://blog.csdn.net/Copperxcx/article/details/123084367\">CMake设置MSVC工程MT/MTd/MD/MDd_Copperxcx的博客-CSDN博客_cmake mt</a></p>\n<p><strong>问题3：error LNK2019: 无法解析的外部符号 _main，函数 “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ) 中引用了该符号</strong></p>\n<p>稍有C/C++开发经验的开发者看到这个报错其实心里还是有底的，应该是没有提供main函数作为函数的入口。但是对于我们的项目，细心的读者发现似乎样例代码中确实是没有提供main入口函数的。那么，为什么vs项目能够正确运行起来呢？观察vs中的项目属性—连接器—系统，会发现子系统（SubSystem）的值是：<code>/SUBSYSTEM:WINDOWS</code></p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-07-22-sega-game-dev/080-subsystem-windows.png\" alt=\"070-subsystem-windows\"></p>\n<p>在cmake项目中，我们可以按照如下的方式进行配置：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 设置MT/MTd</span><br><span class=\"line\">SET_PROPERTY(</span><br><span class=\"line\">        TARGET NimotsuKunBox</span><br><span class=\"line\">        PROPERTY MSVC_RUNTIME_LIBRARY &quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"addition\">+ # 配置 &quot;/SUBSYSTEM:WINDOWS&quot;</span></span><br><span class=\"line\"><span class=\"addition\">+ TARGET_LINK_OPTIONS(NimotsuKunBox PRIVATE &quot;/SUBSYSTEM:WINDOWS&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 实际链接</span><br><span class=\"line\">TARGET_LINK_LIBRARIES(NimotsuKunBox GameLib_d.lib)</span><br></pre></td></tr></table></figure>\n<p>实际上，配置成了<code>/SUBSYSTEM:WINDOWS</code>之后也是需要有一个入口函数的，<strong>这个入口函数其实是在Modules那个项目里面定义好了的</strong>，具体可以搜索Modules项目中的<code>int APIENTRY _tWinMain</code>函数实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> APIENTRY _tWinMain(HINSTANCE hInstance,</span><br><span class=\"line\">                     HINSTANCE hPrevInstance,</span><br><span class=\"line\">                     LPTSTR    lpCmdLine,</span><br><span class=\"line\">                     <span class=\"keyword\">int</span>       nCmdShow)</span><br></pre></td></tr></table></figure>\n<p>上述问题处理完成后，我们通过项目编译</p>\n<h2 id=\"配置drawPixels项目\"><a href=\"#配置drawPixels项目\" class=\"headerlink\" title=\"配置drawPixels项目\"></a>配置drawPixels项目</h2><p>实际上，配置drawPixels项目的CMakeLists.txt和NimotsuKunBox的CMake配置结构上没有区别，只是需要把相关的项目名字等换位drawPixels即可。最终运行的效果和之前的vs下是一致的~</p>\n<h1 id=\"附录：项目地址\"><a href=\"#附录：项目地址\" class=\"headerlink\" title=\"附录：项目地址\"></a>附录：项目地址</h1><p>本cmake移植的项目地址在：<a href=\"https://github.com/w4ngzhen/2DGraphics1_cmake\">w4ngzhen/2DGraphics1_cmake (github.com)</a></p>\n","categories":[],"tags":["game","sega"]},{"title":"从零搭建react+ts组件库（一）项目搭建与封装antd组件","url":"http://compilemind.com/2022/05/27/2022-05-27-从零搭建react+ts组件库（一）项目搭建与封装antd组件/","content":"<p>为什么会有这样一篇文章？因为网上的教程/示例只说了怎么做，没有系统详细的介绍引入这些依赖、为什么要这样配置，甚至有些文章还是错的！迫于技术洁癖，我希望更多的开发小伙伴能够真正的理解一个项目搭建各个方面的细节，做到面对对于工程出现的错误能够做到有把握。</p>\n<a id=\"more\"></a>\n<p>最近使用阿里低开引擎的时候，想要封装一套组件库作为物料给低开引擎引入。根据低开引擎的物料封层模式，我的诉求是做一套组件库，并且将该组件库以umd方式生成。当然，从零开始开发组件库也是一个比较耗时耗力的事情，所以我想到将antd组件封装，于是催生出了本篇文章。</p>\n<p><strong>在封装组件并生成umd代码过程中，踩了很多的坑，也更加系统的了解了babel。</strong></p>\n<h2 id=\"整体需求\"><a href=\"#整体需求\" class=\"headerlink\" title=\"整体需求\"></a>整体需求</h2><ol>\n<li><strong>react</strong>组件库，取名r-ui，能够导出<strong>r-ui.umd.js</strong>和<strong>r-ui.umd.css</strong>。</li>\n<li>代码使用<strong>typescript</strong>进行开发。</li>\n<li>样式使用<strong>less</strong>进行开发。</li>\n<li>引入antd组件库作为底层原子组件库，并且r-ui.umd.js和r-ui.umd.css包含antd组件代码和样式代码。</li>\n<li>依赖的react、react-dom模块以<strong>外部引用方式</strong>。</li>\n</ol>\n<h2 id=\"开发与打包工具选型\"><a href=\"#开发与打包工具选型\" class=\"headerlink\" title=\"开发与打包工具选型\"></a>开发与打包工具选型</h2><h3 id=\"使用webpack作为打包工具\"><a href=\"#使用webpack作为打包工具\" class=\"headerlink\" title=\"使用webpack作为打包工具\"></a>使用webpack作为打包工具</h3><p>老牌而又经典的打包工具，广泛的使用，丰富的插件生态以及各种易得的样例。</p>\n<h3 id=\"使用babel来处理typescript代码\"><a href=\"#使用babel来处理typescript代码\" class=\"headerlink\" title=\"使用babel来处理typescript代码\"></a>使用babel来处理typescript代码</h3><blockquote>\n<p>由于 TypeScript 和 Babel 团队官方合作了一年的项目：<a href=\"https://link.zhihu.com/?target=https%3A//babeljs.io/docs/en/babel-preset-typescript.html\">TypeScript plugin for Babel</a>（<code>@babel/preset-typescript</code>），<a href=\"https://link.zhihu.com/?target=https%3A//www.typescriptlang.org/\">TypeScript</a> 的使用变得比以往任何时候都容易。 —— 摘自《<a href=\"https://iamturns.com/typescript-babel/\">TypeScript With Babel: A Beautiful Marriage （TypeScript 和 Babel：美丽的结合）</a>》</p>\n</blockquote>\n<p>建议各位读者可以先阅读一下上面的文章（有中文翻译文章）。</p>\n<h3 id=\"使用less-loader、css-loader等处理样式代码\"><a href=\"#使用less-loader、css-loader等处理样式代码\" class=\"headerlink\" title=\"使用less-loader、css-loader等处理样式代码\"></a>使用less-loader、css-loader等处理样式代码</h3><h3 id=\"使用MiniCssExtractPlugin分离CSS\"><a href=\"#使用MiniCssExtractPlugin分离CSS\" class=\"headerlink\" title=\"使用MiniCssExtractPlugin分离CSS\"></a>使用MiniCssExtractPlugin分离CSS</h3><h2 id=\"项目搭建思路\"><a href=\"#项目搭建思路\" class=\"headerlink\" title=\"项目搭建思路\"></a>项目搭建思路</h2><h3 id=\"整体结构\"><a href=\"#整体结构\" class=\"headerlink\" title=\"整体结构\"></a>整体结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- r-ui</span><br><span class=\"line\">  |- src</span><br><span class=\"line\">     |- components</span><br><span class=\"line\">        |- button</span><br><span class=\"line\">           |- index.tsx</span><br><span class=\"line\">  |- index.tsx</span><br></pre></td></tr></table></figure>\n<h3 id=\"方案思路\"><a href=\"#方案思路\" class=\"headerlink\" title=\"方案思路\"></a>方案思路</h3><p>编写webpack.config.js配置文件，添加核心loader：</p>\n<ol>\n<li>babel-loader。接收ts文件，交给babel-core以及相关babel插件进行处理，得到js代码。</li>\n<li>less-loader。接收less样式文件，处理得到css样式代码。</li>\n<li>css-loader+MiniCssExtractPlugin.loader。接收css样式代码进行处理，并分离导出组件库样式文件。</li>\n</ol>\n<h2 id=\"项目搭建实施\"><a href=\"#项目搭建实施\" class=\"headerlink\" title=\"项目搭建实施\"></a>项目搭建实施</h2><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p><strong>初始化r-ui项目</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir r-ui &amp;&amp; cd r-ui &amp;&amp; npm init</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 配置项目基本信息（name、version......）</span></span><br></pre></td></tr></table></figure>\n<p><strong>初始化git仓库，添加gitignore文件（后续所有命令非特殊情况，均相对于项目根目录）</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> .gitignore文件内容请直接查看项目内文件</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 完成后，初始提交：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> git add . &amp;&amp; git commit -m <span class=\"string\">&quot;init&quot;</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>安装webpack（包管理器使用yarn）</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D webpack webpack-cli webpack-dev-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装webpack-dev-server是为后续构建样例页面做准备，前期可以不安装。</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/package.json b/package.json</span><br><span class=\"line\">index e01c1b1..53dd9a3 100644</span><br><span class=\"line\"><span class=\"comment\">--- a/package.json</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/package.json</span></span><br><span class=\"line\"><span class=\"meta\">@@ -8,5 +8,9 @@</span></span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   &quot;author&quot;: &quot;&quot;,</span><br><span class=\"line\">   &quot;license&quot;: &quot;MIT&quot;,</span><br><span class=\"line\"><span class=\"deletion\">-  &quot;devDependencies&quot;: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"addition\">+  &quot;devDependencies&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;webpack&quot;: &quot;^5.72.1&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;webpack-cli&quot;: &quot;^4.9.2&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;webpack-dev-server&quot;: &quot;^4.9.0&quot;</span></span><br><span class=\"line\"><span class=\"addition\">+  &#125;</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>项目根目录添加webpack.config.js并进行初始配置</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;resolve&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;path&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 组件库的起点入口</span></span><br><span class=\"line\">  entry: <span class=\"string\">&#x27;./src/index.tsx&#x27;</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">&quot;r-ui.umd.js&quot;</span>, <span class=\"comment\">// 打包后的文件名</span></span><br><span class=\"line\">    path: resolve(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>), <span class=\"comment\">// 打包后的文件目录：根目录/dist/</span></span><br><span class=\"line\">    library: <span class=\"string\">&#x27;rui&#x27;</span>, <span class=\"comment\">// 导出的UMD js会在window挂rui，即可以访问window.rui</span></span><br><span class=\"line\">    libraryTarget: <span class=\"string\">&#x27;umd&#x27;</span> <span class=\"comment\">// 导出库为UMD形式</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// webpack 默认只处理js、jsx等js代码</span></span><br><span class=\"line\">    extensions: [<span class=\"string\">&#x27;.js&#x27;</span>, <span class=\"string\">&#x27;.jsx&#x27;</span>, <span class=\"string\">&#x27;.ts&#x27;</span>, <span class=\"string\">&#x27;.tsx&#x27;</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  externals: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 模块</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 规则</span></span><br><span class=\"line\">    rules: []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Babel引入\"><a href=\"#Babel引入\" class=\"headerlink\" title=\"Babel引入\"></a>Babel引入</h3><h4 id=\"引入babel-loader以及相关babel库\"><a href=\"#引入babel-loader以及相关babel库\" class=\"headerlink\" title=\"引入babel-loader以及相关babel库\"></a>引入babel-loader以及相关babel库</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D babel-loader @babel/core @babel/preset-env @babel/preset-typescript @babel/preset-react @babel/plugin-proposal-class-properties @babel/plugin-proposal-object-rest-spread</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/package.json b/package.json</span><br><span class=\"line\">index 53dd9a3..33c32b6 100644</span><br><span class=\"line\"><span class=\"comment\">--- a/package.json</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/package.json</span></span><br><span class=\"line\"><span class=\"meta\">@@ -9,6 +9,13 @@</span></span><br><span class=\"line\">   &quot;author&quot;: &quot;&quot;,</span><br><span class=\"line\">   &quot;license&quot;: &quot;MIT&quot;,</span><br><span class=\"line\">   &quot;devDependencies&quot;: &#123;</span><br><span class=\"line\"><span class=\"addition\">+    &quot;@babel/core&quot;: &quot;^7.18.2&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.17.12&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;@babel/plugin-proposal-object-rest-spread&quot;: &quot;^7.18.0&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;@babel/preset-env&quot;: &quot;^7.18.2&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;@babel/preset-react&quot;: &quot;^7.17.12&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;@babel/preset-typescript&quot;: &quot;^7.17.12&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;babel-loader&quot;: &quot;^8.2.5&quot;,</span></span><br><span class=\"line\">     &quot;webpack&quot;: &quot;^5.72.1&quot;,</span><br><span class=\"line\">     &quot;webpack-cli&quot;: &quot;^4.9.2&quot;,</span><br><span class=\"line\">     &quot;webpack-dev-server&quot;: &quot;^4.9.0&quot;</span><br><span class=\"line\">(END)</span><br></pre></td></tr></table></figure>\n<h4 id=\"了解Babel\"><a href=\"#了解Babel\" class=\"headerlink\" title=\"了解Babel\"></a>了解Babel</h4><p>如果对于babel不太熟悉，可能对这一堆的依赖感到恐惧，这里如果读者有时间，我推荐这篇深入了解babel的文章：<a href=\"https://zhuanlan.zhihu.com/p/43249121\">一口（很长的）气了解 babel - 知乎 (zhihu.com)</a>。当然，如果这口气憋不住（哈哈），我做一个简单摘抄：</p>\n<blockquote>\n<p>babel 总共分为三个阶段：解析，转换，生成。</p>\n<p>babel 本身不具有任何转化功能，它把转化的功能都分解到一个个 plugin 里面。因此当我们不配置任何插件时，经过 babel 的代码和输入是相同的。</p>\n<p>插件总共分为两种：</p>\n<ul>\n<li>当我们添加 <strong>语法插件</strong> 之后，在解析这一步就使得 babel 能够解析更多的语法。(顺带一提，babel 内部使用的解析类库叫做 babylon，并非 babel 自行开发)</li>\n</ul>\n<p>举个简单的例子，当我们定义或者调用方法时，最后一个参数之后是不允许增加逗号的，如 <code>callFoo(param1, param2,)</code> 就是非法的。如果源码是这种写法，经过 babel 之后就会提示语法错误。</p>\n<p>但最近的 JS 提案中已经允许了这种新的写法(让代码 diff 更加清晰)。为了避免 babel 报错，就需要增加语法插件 <code>babel-plugin-syntax-trailing-function-commas</code></p>\n<ul>\n<li>当我们添加 <strong>转译插件</strong> 之后，在转换这一步把源码转换并输出。这也是我们使用 babel 最本质的需求。</li>\n</ul>\n<p>比起语法插件，转译插件其实更好理解，比如箭头函数 <code>(a) =&gt; a</code> 就会转化为 <code>function (a) &#123;return a&#125;</code>。完成这个工作的插件叫做 <code>babel-plugin-transform-es2015-arrow-functions</code>。</p>\n<p>同一类语法可能同时存在语法插件版本和转译插件版本。<strong>如果我们使用了转译插件，就不用再使用语法插件了。</strong></p>\n</blockquote>\n<p>简单来讲，使用babel就像如下流程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">源代码 &#x3D;babel&#x3D;&gt; 目标代码</span><br></pre></td></tr></table></figure>\n<p>如果没有使用任何插件，源代码和目标代码就没有任何差异。当我们引入各种插件的时候，就像如下流程一样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">源代码</span><br><span class=\"line\">|</span><br><span class=\"line\">进入babel</span><br><span class=\"line\">|</span><br><span class=\"line\">babel插件1处理代码：移除某些符号</span><br><span class=\"line\">|</span><br><span class=\"line\">babel插件2处理代码：将形如() &#x3D;&gt; &#123;&#125;的箭头函数，转换成function xxx() &#123;&#125;</span><br><span class=\"line\">|</span><br><span class=\"line\">目标代码</span><br></pre></td></tr></table></figure>\n<p>因为babel的插件处理的力度很细，我们代码的语法、语义内容规范有很多，如果我们要处理这些语法，可能需要配置一大堆的插件，所以babel提出，将一堆插件组合成一个preset（预置插件包），这样，我们只需要引入一个插件组合包，就能处理代码的各种语法、语义。</p>\n<p>所以，回到我们上述的那些@babel开头的npm包，再回首可能不会那么迷茫：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel&#x2F;core</span><br><span class=\"line\">@babel&#x2F;preset-env</span><br><span class=\"line\">@babel&#x2F;preset-typescript</span><br><span class=\"line\">@babel&#x2F;preset-react</span><br><span class=\"line\">@babel&#x2F;plugin-proposal-class-properties</span><br><span class=\"line\">@babel&#x2F;plugin-proposal-object-rest-spread</span><br></pre></td></tr></table></figure>\n<p><code>@babel/core</code>毋庸置疑，babel的核心模块，实现了上述的流程运转以及代码语法、语义分析的功能。</p>\n<p>以plugin开头的就是插件，这里我们引入了两个：<code>@babel/plugin-proposal-class-properties</code>（<a href=\"https://babel.docschina.org/docs/en/babel-plugin-proposal-class-properties/\">允许类具有属性</a>）和<code>@babel/plugin-proposal-object-rest-spread</code>（<a href=\"https://babel.docschina.org/docs/en/7.0.0/babel-plugin-proposal-object-rest-spread/\">对象展开</a>）。</p>\n<p>以preset开头的就是预置组件包合集，其中<code>@babel/preset-env</code>表示使用了可以根据实际的浏览器运行环境，会选择相关的转义插件包：</p>\n<blockquote>\n<p>env 的核心目的是通过配置得知目标环境的特点，然后只做必要的转换。</p>\n<p>如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&#123;</span><br><span class=\"line\"> &quot;presets&quot;: [</span><br><span class=\"line\">   [&quot;env&quot;, &#123;</span><br><span class=\"line\">     &quot;targets&quot;: &#123;</span><br><span class=\"line\">       &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari &gt;&#x3D; 7&quot;]</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;]</span><br><span class=\"line\"> ]</span><br><span class=\"line\">&gt;&#125;</span><br></pre></td></tr></table></figure>\n<p>如上配置将考虑所有浏览器的最新2个版本(safari大于等于7.0的版本)的特性，将必要的代码进行转换。而这些版本已有的功能就不进行转化了。</p>\n<p>—— 摘自《<a href=\"https://zhuanlan.zhihu.com/p/43249121\">一口（很长的）气了解 babel - 知乎 (zhihu.com)</a>》</p>\n</blockquote>\n<p><code>@babel/preset-typescript</code>会处理所有ts的代码的语法和语义规则，并转换为js代码；<code>@babel/preset-react</code></p>\n<p>故名思义，<strong>可以帮助处理使用React相关特性</strong>，例如JSX标签语法等。</p>\n<h4 id=\"webpack的基于babel-loader的处理流程\"><a href=\"#webpack的基于babel-loader的处理流程\" class=\"headerlink\" title=\"webpack的基于babel-loader的处理流程\"></a>webpack的基于babel-loader的处理流程</h4><p>讲了这么多，我们的打包工具webpack如何使用babel相关组件处理代码的呢？还记得我们安装过<strong>babel-loader</strong>吗？</p>\n<p>实际上，我们通过配置webpack.config.js，使用<strong>babel-loader</strong>建立起webpack处理代码与babel处理代码的连接：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/webpack.config.js b/webpack.config.js</span><br><span class=\"line\">index 8bfbb63..6767fd8 100644</span><br><span class=\"line\"><span class=\"comment\">--- a/webpack.config.js</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/webpack.config.js</span></span><br><span class=\"line\">@@ -17,6 +17,11 @@ module.exports = &#123;</span><br><span class=\"line\">   // 模块</span><br><span class=\"line\">   module: &#123;</span><br><span class=\"line\">     // 规则</span><br><span class=\"line\"><span class=\"deletion\">-    rules: []</span></span><br><span class=\"line\"><span class=\"addition\">+    rules: [</span></span><br><span class=\"line\"><span class=\"addition\">+      &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+        test: /\\.tsx?$/,</span></span><br><span class=\"line\"><span class=\"addition\">+        use: &#x27;babel-loader&#x27;,</span></span><br><span class=\"line\"><span class=\"addition\">+        exclude: /node_modules/</span></span><br><span class=\"line\"><span class=\"addition\">+      &#125;</span></span><br><span class=\"line\"><span class=\"addition\">+    ]</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">(END)</span><br></pre></td></tr></table></figure>\n<p>这一步的配置，就是让webpack遇到ts或tsx的时候，将这些代码交给babel-loader，babel-loader作为桥接把代码交给内部引用的@babel/core相关API进行处理，当然为了防止babel-loader去解析依赖库node_modules的内容，需要配置exclude。</p>\n<p>那么，@babel/core如何知道要使用我们安装的各种plugin插件和preset预置插件包的呢？通过<code>.babelrc文件</code>（注：实际上还有其他配置方式，但个人倾向于.babelrc）。这里，我们在项目根目录创建.babelrc文件，并添加一下内容：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;presets&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/preset-env&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/preset-typescript&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/preset-react&quot;</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/plugin-proposal-class-properties&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的配置不难理解，plugins字段存放要使用的插件，presets字段存放预置插件包名称，具体的配置可以查阅官方文档。</p>\n<p><strong>总结一下，配置babel可以按照如下思路进行：</strong></p>\n<ol>\n<li>xxx.ts(x)代码交给webpack打包；</li>\n<li>webpack遇到ts(x)结尾的代码文件，根据webpack.config.js配置，交给babel-loader；</li>\n<li>babel-loader交给@babel/core；</li>\n<li>@babel/core根据.babelrc配置交给相关的插件处理代码，转为js代码；</li>\n<li>webpack进行后续的打包操作。</li>\n</ol>\n<h3 id=\"引入React相关库（externals方式）\"><a href=\"#引入React相关库（externals方式）\" class=\"headerlink\" title=\"引入React相关库（externals方式）\"></a>引入React相关库（externals方式）</h3><p>还记得我们的需求吗？</p>\n<blockquote>\n<p>依赖的react、react-dom模块以<strong>外部引用方式</strong>。</p>\n</blockquote>\n<p>什么是外部引用方式？简单来讲，我希望react、react-dom等组件库的包，不会被打入到组件库中，而是在html中引入（<a href=\"https://17.reactjs.org/docs/add-react-to-a-website.html#step-2-add-the-script-tags\">Add React to a Website – React (reactjs.org)</a>）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">&lt;!-- ... other HTML ... --&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- Load React. --&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- <span class=\"doctag\">Note:</span> when deploying, replace &quot;development.js&quot; with &quot;production.min.js&quot;. --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span> <span class=\"attr\">crossorigin</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span> <span class=\"attr\">crossorigin</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 组件库JS --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;r-ui.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>要实现这样的效果，第一步是配置webapck.config.js：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/webpack.config.js b/webpack.config.js</span><br><span class=\"line\">index 6767fd8..54fc0e5 100644</span><br><span class=\"line\"><span class=\"comment\">--- a/webpack.config.js</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/webpack.config.js</span></span><br><span class=\"line\">@@ -13,7 +13,13 @@ module.exports = &#123;</span><br><span class=\"line\">     // webpack 默认只处理js、jsx等js代码</span><br><span class=\"line\">     extensions: [&#x27;.js&#x27;, &#x27;.jsx&#x27;, &#x27;.ts&#x27;, &#x27;.tsx&#x27;]</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\"><span class=\"deletion\">-  externals: &#123;&#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+  externals: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+    // 打包过程遇到以下依赖导入，不会打包对应库代码，而是调用window上的React和ReactDOM</span></span><br><span class=\"line\"><span class=\"addition\">+    // import React from &#x27;react&#x27;</span></span><br><span class=\"line\"><span class=\"addition\">+    // import ReactDOM from &#x27;react-dom&#x27;</span></span><br><span class=\"line\"><span class=\"addition\">+    &#x27;react&#x27;: &#x27;React&#x27;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &#x27;react-dom&#x27;: &#x27;ReactDOM&#x27;</span></span><br><span class=\"line\"><span class=\"addition\">+  &#125;,</span></span><br><span class=\"line\">   // 模块</span><br><span class=\"line\">   module: &#123;</span><br><span class=\"line\">     // 规则</span><br><span class=\"line\">(END)</span><br></pre></td></tr></table></figure>\n<p>第二部，在引入react相关库的时候，可以不用引入到dependencies运行时依赖，而只需要引入对应的类型定义到devDependencies开发依赖中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D @types/react@17.0.39 @types/react-dom@17.0.17</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/package.json b/package.json</span><br><span class=\"line\">index 33c32b6..bd17763 100644</span><br><span class=\"line\"><span class=\"comment\">--- a/package.json</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/package.json</span></span><br><span class=\"line\"><span class=\"meta\">@@ -15,6 +15,8 @@</span></span><br><span class=\"line\">     &quot;@babel/preset-env&quot;: &quot;^7.18.2&quot;,</span><br><span class=\"line\">     &quot;@babel/preset-react&quot;: &quot;^7.17.12&quot;,</span><br><span class=\"line\">     &quot;@babel/preset-typescript&quot;: &quot;^7.17.12&quot;,</span><br><span class=\"line\"><span class=\"addition\">+    &quot;@types/react&quot;: &quot;17.0.39&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;@types/react-dom&quot;: &quot;17.0.17&quot;,</span></span><br><span class=\"line\">     &quot;babel-loader&quot;: &quot;^8.2.5&quot;,</span><br><span class=\"line\">     &quot;webpack&quot;: &quot;^5.72.1&quot;,</span><br><span class=\"line\">     &quot;webpack-cli&quot;: &quot;^4.9.2&quot;,</span><br></pre></td></tr></table></figure>\n<p>至此，我们已经完成了处理<strong>基于TypeScript</strong>的<strong>React项目</strong>的webpack配置，此时我们的项目结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- r-ui</span><br><span class=\"line\">  |- .babelrc</span><br><span class=\"line\">  |- package.json</span><br><span class=\"line\">  |- webpack.config.js</span><br></pre></td></tr></table></figure>\n<h3 id=\"阶段演示1：基于TypeScript的React组件项目的webpack配置可行性\"><a href=\"#阶段演示1：基于TypeScript的React组件项目的webpack配置可行性\" class=\"headerlink\" title=\"阶段演示1：基于TypeScript的React组件项目的webpack配置可行性\"></a>阶段演示1：基于TypeScript的React组件项目的webpack配置可行性</h3><h4 id=\"编写组件代码\"><a href=\"#编写组件代码\" class=\"headerlink\" title=\"编写组件代码\"></a>编写组件代码</h4><p>新增src目录，在src目录下添加index.tsx（用于将所有的组件导出）</p>\n<p>src目录下添加components/button目录，并创建index.tsx文件。具体结构与目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- r-ui</span><br><span class=\"line\">  |- src&#x2F;components&#x2F;button&#x2F;index.tsx</span><br><span class=\"line\">  |- src&#x2F;index.tsx</span><br><span class=\"line\">  |- ... ...</span><br></pre></td></tr></table></figure>\n<p><strong>src/components/button/index.tsx</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &#39;react&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">interface ButtonProps &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const Button: React.FC&lt;ButtonProps&gt; &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class=\"line\">    const &#123;children, ...rest&#125; &#x3D; props;</span><br><span class=\"line\">    return &lt;button &#123;...rest&#125; &gt;&#123;children&#125;&lt;&#x2F;button&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Button;</span><br></pre></td></tr></table></figure>\n<p><strong>src/index.tsx</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123;default as Button&#125; from &#39;.&#x2F;components&#x2F;button&#39;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改package-json\"><a href=\"#修改package-json\" class=\"headerlink\" title=\"修改package.json\"></a>修改package.json</h4><p>添加webpack处理脚本</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/package.json b/package.json</span><br><span class=\"line\">index bd17763..01565ad 100644</span><br><span class=\"line\"><span class=\"comment\">--- a/package.json</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/package.json</span></span><br><span class=\"line\"><span class=\"meta\">@@ -4,6 +4,7 @@</span></span><br><span class=\"line\">   &quot;description&quot;: &quot;&quot;,</span><br><span class=\"line\">   &quot;main&quot;: &quot;index.js&quot;,</span><br><span class=\"line\">   &quot;scripts&quot;: &#123;</span><br><span class=\"line\"><span class=\"addition\">+    &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;,</span></span><br><span class=\"line\">     &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   &quot;author&quot;: &quot;&quot;,</span><br><span class=\"line\">(END)</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译打包组件库\"><a href=\"#编译打包组件库\" class=\"headerlink\" title=\"编译打包组件库\"></a>编译打包组件库</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn run build</span><br></pre></td></tr></table></figure>\n<p>打包完成后，在<strong>项目根目录/dist目录</strong>下，会生成一个r-ui.umd.js文件。</p>\n<h4 id=\"效果演示\"><a href=\"#效果演示\" class=\"headerlink\" title=\"效果演示\"></a>效果演示</h4><p>想要查看效果，可以在dist目录下添加如下的html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>r-ui example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"comment\">&lt;!-- 注意r-ui.umd.js的路径 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;r-ui.umd.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;example&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">const</span> onClick = <span class=\"function\">() =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    alert(<span class=\"string\">&#x27;hello&#x27;</span>);</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// window上存在rui，是因为我们将组件包导出为了umd包，取名为rui</span></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// 使用React原生方法创建Button的react组件实例</span></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// 等价于：</span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">  // <span class=\"tag\">&lt;<span class=\"name\">Button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onClick&#125;</span>&gt;</span>hello, world<span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">const</span> button = React.createElement(rui.Button, &#123;onClick&#125;, <span class=\"string\">&#x27;hello, world&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// 调用ReactDOM方法，将button组件实例挂载到example DOM节点上</span></span></span><br><span class=\"line\"><span class=\"javascript\">  ReactDOM.render(button, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example&#x27;</span>));</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- r-ui</span><br><span class=\"line\">  |- dist</span><br><span class=\"line\">     |- index.html</span><br><span class=\"line\">     |- r-ui.umd.js</span><br><span class=\"line\">  |- ... ...</span><br></pre></td></tr></table></figure>\n<p>此时，可以直接使用浏览器打开index.html查看效果：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-05-27-webpack-ts-react/010.gif\" alt=\"010\"></p>\n<h3 id=\"处理样式（less编译与css导出）\"><a href=\"#处理样式（less编译与css导出）\" class=\"headerlink\" title=\"处理样式（less编译与css导出）\"></a>处理样式（less编译与css导出）</h3><h4 id=\"依赖引入\"><a href=\"#依赖引入\" class=\"headerlink\" title=\"依赖引入\"></a>依赖引入</h4><p>根据上述内容，我们已经搭建了基础的项目结构，但是目前来说我们还需要处理我们的less样式，并且能够支持导出r-ui.umd.css样式文件。基于此考虑，我们需要引入：</p>\n<ol>\n<li>less-loader。处理less样式代码，转为css；</li>\n<li>less。由于less-loader内部是调用了less模块进行less代码编译，故还需要引入less（模式和babel-loader内部使用@babel/core一样）；</li>\n<li>css-loader。处理css样式代码，进行适当加工；</li>\n<li>mini-css-extract-plugin。MiniCssExtractPlugin的loader用于进一步处理css，并且该插件用于导出独立样式文件。</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D less-loader less css-loader mini-css-extract-plugin</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/package.json b/package.json</span><br><span class=\"line\">index 01565ad..3070d07 100644</span><br><span class=\"line\"><span class=\"comment\">--- a/package.json</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/package.json</span></span><br><span class=\"line\"><span class=\"meta\">@@ -19,6 +19,10 @@</span></span><br><span class=\"line\">     &quot;@types/react&quot;: &quot;17.0.39&quot;,</span><br><span class=\"line\">     &quot;@types/react-dom&quot;: &quot;17.0.17&quot;,</span><br><span class=\"line\">     &quot;babel-loader&quot;: &quot;^8.2.5&quot;,</span><br><span class=\"line\"><span class=\"addition\">+    &quot;css-loader&quot;: &quot;^6.7.1&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;less&quot;: &quot;^4.1.2&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;less-loader&quot;: &quot;^11.0.0&quot;,</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;mini-css-extract-plugin&quot;: &quot;^2.6.0&quot;,</span></span><br><span class=\"line\">     &quot;webpack&quot;: &quot;^5.72.1&quot;,</span><br><span class=\"line\">     &quot;webpack-cli&quot;: &quot;^4.9.2&quot;,</span><br><span class=\"line\">     &quot;webpack-dev-server&quot;: &quot;^4.9.0&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置webpack\"><a href=\"#配置webpack\" class=\"headerlink\" title=\"配置webpack\"></a>配置webpack</h4><p>根据上述依赖，我们可以知道需要less-loader、css-loader以及MiniCssExtractPlugin的内置loader来处理我们的样式代码。但是配置到webpack需要注意： webpack中的顺序是<strong>【从后向前】</strong>链式调用的，所以注意下面配置的代码中use数组的顺序：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/webpack.config.js b/webpack.config.js</span><br><span class=\"line\">index 54fc0e5..9db43b8 100644</span><br><span class=\"line\"><span class=\"comment\">--- a/webpack.config.js</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/webpack.config.js</span></span><br><span class=\"line\"><span class=\"meta\">@@ -1,5 +1,6 @@</span></span><br><span class=\"line\"> // webpack.config.js</span><br><span class=\"line\"> const &#123;resolve&#125; = require(&quot;path&quot;);</span><br><span class=\"line\"><span class=\"addition\">+const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);</span></span><br><span class=\"line\"> module.exports = &#123;</span><br><span class=\"line\">   // 组件库的起点入口</span><br><span class=\"line\">   entry: &#x27;./src/index.tsx&#x27;,</span><br><span class=\"line\">@@ -27,7 +28,28 @@ module.exports = &#123;</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">         test: /\\.tsx?$/,</span><br><span class=\"line\">         use: &#x27;babel-loader&#x27;,</span><br><span class=\"line\">         exclude: /node_modules/</span><br><span class=\"line\"><span class=\"addition\">+      &#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+      &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+        test: /\\.less$/,</span></span><br><span class=\"line\"><span class=\"addition\">+        use: [</span></span><br><span class=\"line\"><span class=\"addition\">+          // webpack中的顺序是【从后向前】链式调用的</span></span><br><span class=\"line\"><span class=\"addition\">+          // 所以对于less先交给less-loader处理，转为css</span></span><br><span class=\"line\"><span class=\"addition\">+          // 再交给css-loader</span></span><br><span class=\"line\"><span class=\"addition\">+          // 最后导出css（MiniCssExtractPlugin.loader）</span></span><br><span class=\"line\"><span class=\"addition\">+          // 所以注意loader的配置顺序</span></span><br><span class=\"line\"><span class=\"addition\">+          &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+            loader: MiniCssExtractPlugin.loader,</span></span><br><span class=\"line\"><span class=\"addition\">+          &#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+          &#x27;css-loader&#x27;,</span></span><br><span class=\"line\"><span class=\"addition\">+          &#x27;less-loader&#x27;</span></span><br><span class=\"line\"><span class=\"addition\">+        ]</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     ]</span><br><span class=\"line\"><span class=\"deletion\">-  &#125;</span></span><br><span class=\"line\"><span class=\"addition\">+  &#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+  plugins: [</span></span><br><span class=\"line\"><span class=\"addition\">+    // 插件用于最终的导出独立的css的工作</span></span><br><span class=\"line\"><span class=\"addition\">+    new MiniCssExtractPlugin(&#123;</span></span><br><span class=\"line\"><span class=\"addition\">+      filename: &#x27;r-ui.umd.css&#x27;</span></span><br><span class=\"line\"><span class=\"addition\">+    &#125;),</span></span><br><span class=\"line\"><span class=\"addition\">+  ]</span></span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"阶段演示2：less样式处理配置可行性\"><a href=\"#阶段演示2：less样式处理配置可行性\" class=\"headerlink\" title=\"阶段演示2：less样式处理配置可行性\"></a>阶段演示2：less样式处理配置可行性</h3><h4 id=\"编写样式代码\"><a href=\"#编写样式代码\" class=\"headerlink\" title=\"编写样式代码\"></a>编写样式代码</h4><p>新增<strong>src/components/button/index.less</strong></p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@color:</span> <span class=\"number\">#006fde</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.my-button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">@color</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改<strong>src/components/button/index.tsx</strong></p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> import * as React from &#x27;react&#x27;;</span><br><span class=\"line\"><span class=\"addition\">+// 引入less样式</span></span><br><span class=\"line\"><span class=\"addition\">+import &#x27;./index.less&#x27;;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> interface ButtonProps &#123;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> const Button: React.FC&lt;ButtonProps&gt; = (props) =&gt; &#123;</span><br><span class=\"line\">     const &#123;children, ...rest&#125; = props;</span><br><span class=\"line\"><span class=\"deletion\">-    return &lt;button &#123;...rest&#125; &gt;&#123;children&#125;&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"addition\">+    // 使用my-button样式</span></span><br><span class=\"line\"><span class=\"addition\">+    return &lt;button &#123;...rest&#125; className=&#x27;my-button&#x27;&gt;&#123;children&#125;&lt;/button&gt;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> export default Button;</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译组件库\"><a href=\"#编译组件库\" class=\"headerlink\" title=\"编译组件库\"></a>编译组件库</h4><p>再次打包组件库以后，dist目录下会额外生成文件：r-ui.umd.css。所以，我们需要在index.html中添加样式文件的引入：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;head&gt;</span><br><span class=\"line\">     &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">     &lt;title&gt;r-ui example&lt;/title&gt;</span><br><span class=\"line\">     &lt;script src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">     &lt;script src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">     &lt;script src=&quot;r-ui.umd.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"addition\">+    &lt;link href=&quot;r-ui.umd.css&quot; rel=&quot;stylesheet&quot;/&gt;</span></span><br><span class=\"line\"> &lt;/head&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"效果演示-1\"><a href=\"#效果演示-1\" class=\"headerlink\" title=\"效果演示\"></a>效果演示</h4><p>刷新页面后，可以看到按钮的文字颜色已经生效</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-05-27-webpack-ts-react/020.jpg\" alt=\"020\"></p>\n<h3 id=\"引入AntDesign\"><a href=\"#引入AntDesign\" class=\"headerlink\" title=\"引入AntDesign\"></a>引入AntDesign</h3><p>根据我们的需求，我们希望将antd组件代码引用到我们组件内部进行封装，所以需要以dependencies方式引入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add antd</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/package.json b/package.json</span><br><span class=\"line\">index 3070d07..09ca792 100644</span><br><span class=\"line\"><span class=\"comment\">--- a/package.json</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/package.json</span></span><br><span class=\"line\"><span class=\"meta\">@@ -26,5 +26,8 @@</span></span><br><span class=\"line\">     &quot;webpack&quot;: &quot;^5.72.1&quot;,</span><br><span class=\"line\">     &quot;webpack-cli&quot;: &quot;^4.9.2&quot;,</span><br><span class=\"line\">     &quot;webpack-dev-server&quot;: &quot;^4.9.0&quot;</span><br><span class=\"line\"><span class=\"addition\">+  &#125;,</span></span><br><span class=\"line\"><span class=\"addition\">+  &quot;dependencies&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+    &quot;antd&quot;: &quot;^4.20.6&quot;</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"引用antd的button样式\"><a href=\"#引用antd的button样式\" class=\"headerlink\" title=\"引用antd的button样式\"></a>引用antd的button样式</h4><p><strong>src/components/button/index.less</strong></p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">-@color: #006fde;</span></span><br><span class=\"line\"><span class=\"deletion\">-</span></span><br><span class=\"line\"><span class=\"deletion\">-.my-button &#123;</span></span><br><span class=\"line\"><span class=\"deletion\">-  color: @color;</span></span><br><span class=\"line\"><span class=\"deletion\">-&#125;</span></span><br><span class=\"line\"><span class=\"addition\">+@import &quot;~antd/lib/button/style/index.css&quot;;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"引用antd的button组件\"><a href=\"#引用antd的button组件\" class=\"headerlink\" title=\"引用antd的button组件\"></a>引用antd的button组件</h4><figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> import * as React from &#x27;react&#x27;;</span><br><span class=\"line\"><span class=\"addition\">+// 使用antd的Button和ButtonProps</span></span><br><span class=\"line\"><span class=\"addition\">+// 为了不和我们的Button冲突，需要改导出名</span></span><br><span class=\"line\"><span class=\"addition\">+import &#123;Button as AntdButton, ButtonProps as AntdButtonProps&#125; from &#x27;antd&#x27;;</span></span><br><span class=\"line\"> // 引入less样式</span><br><span class=\"line\"> import &#x27;./index.less&#x27;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"deletion\">-interface ButtonProps &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+interface ButtonProps extends AntdButtonProps &#123;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> const Button: React.FC&lt;ButtonProps&gt; = (props) =&gt; &#123;</span><br><span class=\"line\">     const &#123;children, ...rest&#125; = props;</span><br><span class=\"line\"><span class=\"deletion\">-    // 使用my-button样式</span></span><br><span class=\"line\"><span class=\"deletion\">-    return &lt;button &#123;...rest&#125; className=&#x27;my-button&#x27;&gt;&#123;children&#125;&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"addition\">+    // 使用AntdButton</span></span><br><span class=\"line\"><span class=\"addition\">+    return &lt;AntdButton &#123;...rest&#125;&gt;&#123;children&#125;&lt;/AntdButton&gt;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> export default Button;</span><br></pre></td></tr></table></figure>\n<h3 id=\"阶段演示3：antd组件引入可行性\"><a href=\"#阶段演示3：antd组件引入可行性\" class=\"headerlink\" title=\"阶段演示3：antd组件引入可行性\"></a>阶段演示3：antd组件引入可行性</h3><p>通过上述的代码修改以后，我们直接进行编译，然后检查效果即可：</p>\n<p><img src=\"https://src-1252109805.cos.ap-chengdu.myqcloud.com/images/post/2022-05-27-webpack-ts-react/030.gif\" alt=\"030\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>实际上，代码开发过程中，还有很多可以辅助开发的模块、流程，例如eslint检查，热更新等。但是那些内容不在本文的讨论范围。后续会出相关的文章再进一步进行介绍。</p>\n<p>本文所搭建的整个项目，我都按照文章一步一步进行了git提交，开发小伙伴可以边阅读文章边对照git提交一步一步来看。</p>\n<p>github地址：<a href=\"https://github.com/w4ngzhen/r-ui\">w4ngzhen/r-ui (github.com)</a></p>\n","categories":[],"tags":["react","ts"]},{"title":"阿里低代码引擎物料开发windows下路径问题临时处理","url":"http://compilemind.com/2022/04/22/2022-04-22-阿里低代码引擎物料开发windows下适配/","content":"<p>阿里低代码引擎物料开发windows下路径问题临时处理</p>\n<a id=\"more\"></a>\n<p>使用阿里低代码进行物料开发过程中，官方文档推荐使用macOS、Linux或者windows下的WSL，其原因在于<strong>物料开发脚手架</strong>在对开发组件进行物料相关内容打包的时候会将路径字符串写入到生成文件中，这个过程会使用<code>@alifd/build-plugin-lowcode</code>插件里面的脚本代码进行。而如果直接使用的windows开发，会发现生成过程会报类似如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(undefined) .&#x2F;.tmp&#x2F;view.js</span><br><span class=\"line\">Module not found: Can&#39;t resolve &#39;D:Projecsmy-materials&#39; 巴拉巴拉</span><br></pre></td></tr></table></figure>\n<p>仔细分析可以看出，在对应.tmp/view.js里面，路径写的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import xxx from &#39;D:\\Projects\\my-materials\\meta.js&#39;</span><br><span class=\"line\">&#x2F;&#x2F; 这个地方实际应该是：</span><br><span class=\"line\">import xxx from &#39;D:\\\\Projects\\\\my-mterials\\\\meta.js&#39;</span><br><span class=\"line\">&#x2F;&#x2F; 由于在JS，单个\\是转义符，所以D:\\Projects中的\\P实际上被转义了。</span><br></pre></td></tr></table></figure>\n<p>根据最新的@alifd/build-plugin-lowcode的0.3.0-beta.1，还是有同样的问。如果在windows下，通过path.join拿到路径本身没有问题，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path.join(&#39;A&#39;, &#39;B&#39;) &#x3D;&gt; &#39;D:\\A\\B&#39;</span><br></pre></td></tr></table></figure>\n<p>这个路径在程序使用上没有问题，但是生成.tmp里面的文件的时候，把路径字符串写入到文件后，文件中的文本实际上是一段转义字符串。所以需要在写入文件的时候，把对应的文本进行<code>\\</code>替换为<code>\\\\</code>。<br>我这边的处理方法是：<br>对@alifd/build-plugin-lowcode\\index.js进行改造，适配windows路径。<br>具体方案为：</p>\n<ol>\n<li>增加 const os = require(‘os’);</li>\n<li>在<code>function getEntry(rootDir, entryPath)</code>之前加一个方法normalizePathTextForWindows：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalizePathTextForWindows</span>(<span class=\"params\">pathText</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (os.platform() === <span class=\"string\">&#x27;win32&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pathText.replace(<span class=\"regexp\">/\\\\/g</span>, <span class=\"string\">&#x27;\\\\\\\\&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pathText;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修改getEntry和getScssEntry方法：<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getEntry(rootDir, entryPath, needNormalizeForWindows) &#123;</span><br><span class=\"line\">  if (entryPath &amp;&amp; fse.existsSync(path.resolve(rootDir, entryPath))) &#123;</span><br><span class=\"line\"><span class=\"deletion\">-    return path.resolve(rootDir, entryPath)</span></span><br><span class=\"line\"><span class=\"addition\">+    return needNormalizeForWindows ? normalizePathTextForWindows(path.resolve(rootDir, entryPath)) : path.resolve(rootDir, entryPath);</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  for (let i = 0; i &lt; defaultEntryPaths.length; i++) &#123;</span><br><span class=\"line\">    const p = path.resolve(rootDir, defaultEntryPaths[i]);</span><br><span class=\"line\">    if (fse.existsSync(p)) &#123;</span><br><span class=\"line\"><span class=\"deletion\">-      return p;</span></span><br><span class=\"line\"><span class=\"addition\">+      return needNormalizeForWindows ? normalizePathTextForWindows(p) : p;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#x27;&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getScssEntry(rootDir, needNormalizeForWindows) &#123;</span><br><span class=\"line\">  for (let i = 0; i &lt; defaultScssEntryPaths.length; i++) &#123;</span><br><span class=\"line\">    const p = path.resolve(rootDir, defaultScssEntryPaths[i]);</span><br><span class=\"line\">    if (fse.existsSync(p)) &#123;</span><br><span class=\"line\"><span class=\"deletion\">-      return p;</span></span><br><span class=\"line\"><span class=\"addition\">+      return needNormalizeForWindows ? normalizePathTextForWindows(p) : p</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#x27;&#x27;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>找到getEntry和getScssEntry调用点：<br>getEntry第一个调用点：<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  INIT_STATE = true;</span><br><span class=\"line\">  if (!PARSED_NPM_NAME) &#123;</span><br><span class=\"line\">    PARSED_NPM_NAME = parseNpmName(package.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"deletion\">-  const entry = getEntry(rootDir, entryPath);</span></span><br><span class=\"line\"><span class=\"addition\">+  const entry = getEntry(rootDir, entryPath, false); </span></span><br><span class=\"line\">// 这里要设置为false，因为下面使用entry的地方并不是要用路径字符串，所以不能normalize</span><br></pre></td></tr></table></figure>\ngetEntry的第二个调用点传true：<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    componentViewsExportStr = _componentViews</span><br><span class=\"line\">      .map((component) =&gt; &#123;</span><br><span class=\"line\">        return `const $&#123;component&#125; = getRealComponent($&#123;component&#125;Data, &#x27;$&#123;component&#125;&#x27;);\\nexport &#123; $&#123;component&#125; &#125;;`;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .join(&#x27;\\n&#x27;);</span><br><span class=\"line\"><span class=\"deletion\">-    componentViewsExportStr += `\\nexport &#123; default &#125; from &#x27;$&#123;getEntry(rootDir, entryPath)&#125;&#x27;;`;</span></span><br><span class=\"line\"><span class=\"addition\">+   componentViewsExportStr += `\\nexport &#123; default &#125; from &#x27;$&#123;getEntry(rootDir, entryPath, true)&#125;&#x27;;`;</span></span><br><span class=\"line\">    componentViewsImportStr = _componentViews</span><br><span class=\"line\">      .map((component) =&gt; &#123;</span><br><span class=\"line\">        const componentNameFolder = camel2KebabComponentName(component);</span><br><span class=\"line\">        const viewJsPath = path.resolve(rootDir, `$&#123;lowcodeDir&#125;/$&#123;componentNameFolder&#125;/view`);</span><br><span class=\"line\">        return `import * as $&#123;component&#125;Data from &#x27;$&#123;viewJsPath&#125;&#x27;`;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .join(&#x27;\\n&#x27;);</span><br></pre></td></tr></table></figure>\ngetEntry的第三个调用点和getScss的唯一调用点：<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"addition\">+  const scssEntry = getScssEntry(rootDir, true);</span></span><br><span class=\"line\"><span class=\"deletion\">-  const scssEntry = getScssEntry(rootDir);</span></span><br><span class=\"line\">  const viewPath = generateEntry(&#123;</span><br><span class=\"line\">    template: &#x27;view.js&#x27;,</span><br><span class=\"line\">    filename: &#x27;view.js&#x27;,</span><br><span class=\"line\">    rootDir,</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\"><span class=\"deletion\">-      entryPath: getEntry(rootDir, entryPath),</span></span><br><span class=\"line\"><span class=\"addition\">+      entryPath: getEntry(rootDir, entryPath, true),</span></span><br><span class=\"line\">      scssImport: scssEntry ? `import &#x27;$&#123;scssEntry&#125;&#x27;` : &#x27;&#x27;,</span><br><span class=\"line\">      componentViews,</span><br><span class=\"line\">      componentViewsExportStr,</span><br><span class=\"line\">      componentViewsImportStr,</span><br><span class=\"line\">      library,</span><br><span class=\"line\">      execCompile,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>相关讨论在：</p>\n<p><a href=\"https://github.com/alibaba/lowcode-engine/issues/301\">windows10 系统下 .tmp 目录内的meta.js 等文件中的路径转义符错误 · Issue #301 · alibaba/lowcode-engine (github.com)</a></p>\n<p>希望阿里可以花点时间修复吧～</p>\n","categories":[],"tags":["ali","lowcode"]},{"title":"画布就是一切（二） — 实现元素拖拉拽","url":"http://compilemind.com/2021/11/22/2021-11-22-画布就是一切（二） — 实现元素拖拉拽/","content":"<p>在《画布就是一切（一） — 基础入门》中，我们介绍了利用画布进行UI编程的基本模式，分析了如何实现鼠标悬浮在元素上，元素变色的功能。在本文中，我们依然利用画布编程的基本模式进行编程，但这一次我们将会提升一定的难度，实现元素拖拉拽的效果。</p>\n<a id=\"more\"></a>\n<p>使用过流程图或是图形绘制软件的同学都见到过这样的场景对于矩形拖拉拽的场景：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-22/010-rect-drag.gif\" alt=\"010-rect-drag\"></p>\n<p>本文将以上述的场景为需求，结合画布编程的基本模式来复现一个类似的效果。本文的代码已经提交至GitHub仓库，在<strong>仓库根目录/02_drag目录</strong>中。</p>\n<p><a href=\"https://github.com/w4ngzhen/canvas-is-everything/tree/main/02_drag\">canvas-is-everything/02_drag at main · w4ngzhen/canvas-is-everything (github.com)</a></p>\n<h1 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h1><p>我们首先分析这个场景下的状态有哪些。鼠标在矩形元素上按下后，鼠标可以拖动矩形元素，鼠标松开后，矩形不再跟随鼠标移动。那么对于UI来说，最基本的就是矩形的位置和大小，同时我们还需要一个状态来表示矩形元素是否被选中：</p>\n<ul>\n<li>矩形位置position</li>\n<li>矩形大小size</li>\n<li>矩形是否被选中selected</li>\n</ul>\n<h1 id=\"输入与更新\"><a href=\"#输入与更新\" class=\"headerlink\" title=\"输入与更新\"></a>输入与更新</h1><p>在这个场景中，更新点主要在于当鼠标点击在元素上时，矩形selected会修改为true；当鼠标移动的时候，只要<strong>有元素被选中且鼠标的左键处于点击</strong>的状态，那么就会修改矩形元素的position。而造成更新的原因就是鼠标的行为输入（点击以及移动）。</p>\n<h1 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h1><p>实际上，在该场景下，渲染是最简单的部分，根据上一篇文章的介绍，我们只需要canvas的context不断的画矩形即可。</p>\n<h1 id=\"流程梳理\"><a href=\"#流程梳理\" class=\"headerlink\" title=\"流程梳理\"></a>流程梳理</h1><p>让我们再次对流程进行梳理。初始情况下，鼠标在画布上移动进而产生移动事件。我们引入一个辅助变量<code>lastMousePosition</code>（默认值为null），来表示<strong>上一次</strong>鼠标移动事件的所在位置。在鼠标移动事件触发中，我们得到此刻鼠标的位置，并与上一次鼠标位置做向量差，进而得到位移差<code>offset</code>。对于<code>offset</code>我们将其应用在矩形的移动上。此外，当鼠标<strong>按下</strong>的时候，我们判断是否选中矩形，进而将矩形的selected置为true或false。当鼠标<strong>抬起</strong>的时候，我们直接设置矩形selected为false即可。</p>\n<h1 id=\"基础拖拽代码编写与分析\"><a href=\"#基础拖拽代码编写与分析\" class=\"headerlink\" title=\"基础拖拽代码编写与分析\"></a>基础拖拽代码编写与分析</h1><h2 id=\"1）工具方法\"><a href=\"#1）工具方法\" class=\"headerlink\" title=\"1）工具方法\"></a>1）工具方法</h2><p>定义常用的工具方法：</p>\n<ul>\n<li><p>获取鼠标在canvas上的位置。</p>\n</li>\n<li><p>检查某个点是否位于某个矩形中。</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1 定义常用工具方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> utils = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 工具方法：获取鼠标在画布上的position</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  getMousePositionInCanvas: <span class=\"function\">(<span class=\"params\">event, canvasEle</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 移动事件对象，从中解构clientX和clientY</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123;clientX, clientY&#125; = event;</span><br><span class=\"line\">    <span class=\"comment\">// 解构canvas的boundingClientRect中的left和top</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123;left, top&#125; = canvasEle.getBoundingClientRect();</span><br><span class=\"line\">    <span class=\"comment\">// 计算得到鼠标在canvas上的坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      x: clientX - left,</span><br><span class=\"line\">      y: clientY - top</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 工具方法：检查点point是否在矩形内</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  isPointInRect: <span class=\"function\">(<span class=\"params\">rect, point</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123;<span class=\"attr\">x</span>: rectX, <span class=\"attr\">y</span>: rectY, width, height&#125; = rect;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123;<span class=\"attr\">x</span>: pX, <span class=\"attr\">y</span>: pY&#125; = point;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (rectX &lt;= pX &amp;&amp; pX &lt;= rectX + width) &amp;&amp; (rectY &lt;= pY &amp;&amp; pY &lt;= rectY + height);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2）状态定义\"><a href=\"#2）状态定义\" class=\"headerlink\" title=\"2）状态定义\"></a>2）状态定义</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2 定义状态</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> rect = &#123;</span><br><span class=\"line\">  x: <span class=\"number\">10</span>,</span><br><span class=\"line\">  y: <span class=\"number\">10</span>,</span><br><span class=\"line\">  width: <span class=\"number\">80</span>,</span><br><span class=\"line\">  height: <span class=\"number\">60</span>,</span><br><span class=\"line\">  selected: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>根据前文，在矩形一般的属性上位置和大小上，我们还新增了属性<code>selected</code>，用于表示矩形是否被选中。</p>\n<h2 id=\"3）获取Canvas元素对象\"><a href=\"#3）获取Canvas元素对象\" class=\"headerlink\" title=\"3）获取Canvas元素对象\"></a>3）获取Canvas元素对象</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3 获取canvas元素，准备在步骤</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> canvasEle = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#myCanvas&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>调用API，获取Canvas元素对象，用于后续的事件监听。</p>\n<h2 id=\"4）鼠标按下事件\"><a href=\"#4）鼠标按下事件\" class=\"headerlink\" title=\"4）鼠标按下事件\"></a>4）鼠标按下事件</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4 鼠标按下事件</span></span><br><span class=\"line\">canvasEle.addEventListener(<span class=\"string\">&#x27;mousedown&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取鼠标按下时位置</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;x, y&#125; = utils.getMousePositionInCanvas(event, canvasEle);</span><br><span class=\"line\">  <span class=\"comment\">// 矩形是否被选中取决于点击时候的鼠标是否在矩形内部</span></span><br><span class=\"line\">  rect.selected = utils.isPointInRect(rect, &#123;x, y&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>获取当前鼠标按下的位置，并通过工具函数来判断是否需要将矩形选中（selected置为true/false）。</p>\n<h2 id=\"5）鼠标移动处理\"><a href=\"#5）鼠标移动处理\" class=\"headerlink\" title=\"5）鼠标移动处理\"></a>5）鼠标移动处理</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 5 鼠标移动处理</span></span><br><span class=\"line\"><span class=\"comment\">// 5.1 定义辅助变量，记录每一次移动的位置</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> mousePosition = <span class=\"literal\">null</span>;</span><br><span class=\"line\">canvasEle.addEventListener(<span class=\"string\">&#x27;mousemove&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.2 记录上一次的鼠标位置</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> lastMousePosition = mousePosition;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.3 更新当前鼠标位置</span></span><br><span class=\"line\">  mousePosition = utils.getMousePositionInCanvas(event, canvasEle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.4 判断是否鼠标左键点击且有矩形被选中</span></span><br><span class=\"line\">  <span class=\"comment\">// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> buttons = event.buttons;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(buttons === <span class=\"number\">1</span> &amp;&amp; rect.selected)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不满足则不处理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.5 获取鼠标偏移</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> offset;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lastMousePosition === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首次记录，偏移dx和dy为0</span></span><br><span class=\"line\">    offset = &#123;</span><br><span class=\"line\">      dx: <span class=\"number\">0</span>,</span><br><span class=\"line\">      dy: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 曾经已经记录了位置，则偏移则为当前位置和上一次位置做向量差</span></span><br><span class=\"line\">    offset = &#123;</span><br><span class=\"line\">      dx: mousePosition.x - lastMousePosition.x,</span><br><span class=\"line\">      dy: mousePosition.y - lastMousePosition.y</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.6 改动rect位置</span></span><br><span class=\"line\">  rect.x = rect.x + offset.dx;</span><br><span class=\"line\">  rect.y = rect.y + offset.dy;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这一部分的代码略长。但是逻辑并不难理解。</p>\n<p><strong>5.1 定义辅助变量<code>mousePosition</code>。</strong>使用该变量记录鼠标在每一次移动过程中的位置。</p>\n<p><strong>5.2 记录临时变量<code>lastMousePosition</code>。</strong>将上一次事件记录的<code>mousePosition</code>赋给该变量，用于后续进行偏移offset计算。</p>\n<p><strong>5.3 更新<code>mousePosition</code>。</strong></p>\n<p><strong>5.4 判断是否鼠标左键点击且有矩形被选中。</strong>在鼠标移动的过程中，我们是可以通过事件对象中的<code>button</code>或<code>buttons</code>属性的数值来判断当前鼠标的点击情况（<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\">MDN</a>）。当<code>buttons</code>或<code>button</code>为1的时候，表示移动的过程中<strong>鼠标左键</strong>是按下的状态。通过判断鼠标左键是否被按下来表示是否处于拖拽中，但是拖拽并不意味就选中了矩形在拖拽，还需要确定当前的矩形是否选中，所以需要（<code>buttons === 1</code>和<code>rect.selected === true</code>）两个条件共同决定。</p>\n<p><strong>5.5 获取鼠标偏移。</strong>这一部分需要解释一下什么是鼠标偏移（offset）。在鼠标移动的每时每刻都会有一个位置，我们利用<code>mousePosition</code>记录了该位置。然后利用<code>lastMousePosition</code>和<code>mousePosition</code>，我们将此刻的位置和上一次位置的x和y对应进行差（向量差），进而得到鼠标一小段的偏移量。但需要注意的是，如果是首次的移动事件，那么上一次的位置是<code>lastMousePosition</code>是null，那么我们认为这个偏移0。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-22/020-mouse-offset-desc.jpg\" alt=\"020-mouse-offset-desc\"></p>\n<p><strong>5.6 改动矩形位置。</strong>将鼠标偏移值应用到矩形的位置上，让矩形也位移对应的距离。</p>\n<p>在鼠标移动的处理中，我们完成了由鼠标移动offset作为输入，修改了被点中的矩形的位置。</p>\n<h2 id=\"6）鼠标按键抬起事件\"><a href=\"#6）鼠标按键抬起事件\" class=\"headerlink\" title=\"6）鼠标按键抬起事件\"></a>6）鼠标按键抬起事件</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 6 鼠标抬起事件</span></span><br><span class=\"line\">canvasEle.addEventListener(<span class=\"string\">&#x27;mouseup&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 鼠标抬起时，矩形就未被选中了</span></span><br><span class=\"line\">  rect.selected = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>鼠标按键的抬起后，我们认为不再需要对矩形进行推拽，所以将矩形的selected置为false。</p>\n<h2 id=\"7）渲染处理\"><a href=\"#7）渲染处理\" class=\"headerlink\" title=\"7）渲染处理\"></a>7）渲染处理</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 7 渲染</span></span><br><span class=\"line\"><span class=\"comment\">// 7.1 从Canvas元素上获取context</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ctx = canvasEle.getContext(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doRender</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  requestAnimationFrame(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 7.2 处理渲染</span></span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 先清空画布</span></span><br><span class=\"line\">      ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, canvasEle.width, canvasEle.height);</span><br><span class=\"line\">      <span class=\"comment\">// 暂存当前ctx的状态</span></span><br><span class=\"line\">      ctx.save();</span><br><span class=\"line\">      <span class=\"comment\">// 设置画笔颜色：黑色</span></span><br><span class=\"line\">      ctx.strokeStyle = rect.selected ? <span class=\"string\">&#x27;#F00&#x27;</span> : <span class=\"string\">&#x27;#000&#x27;</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 矩形所在位置画一个黑色框的矩形</span></span><br><span class=\"line\">      ctx.strokeRect(rect.x - <span class=\"number\">0.5</span>, rect.y - <span class=\"number\">0.5</span>, rect.width, rect.height);</span><br><span class=\"line\">      <span class=\"comment\">// 恢复ctx的状态</span></span><br><span class=\"line\">      ctx.restore();</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 7.3 递归调用</span></span><br><span class=\"line\">    doRender();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>渲染部分的代码，总的来说就是三个要点：</p>\n<ol>\n<li>获取Canvas元素的context对象。</li>\n<li>使用<code>requestAnimationFrame</code>API并构造递归结构来让浏览器调度渲染流程。</li>\n<li>在渲染流程编写画布操作的代码（清空、绘制）。</li>\n</ol>\n<h2 id=\"拖拽效果演示\"><a href=\"#拖拽效果演示\" class=\"headerlink\" title=\"拖拽效果演示\"></a>拖拽效果演示</h2><p>至此，我们已经实现了元素拖动的样例，效果如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-22/030-drag-show-case.gif\" alt=\"030-drag-show-case\"></p>\n<p>对于当前效果的完整代码在<strong>项目根目录/02_drag目录</strong>中，对应git提交为：<code>02_drag: 01_基础效果</code>。</p>\n<h1 id=\"效果提升\"><a href=\"#效果提升\" class=\"headerlink\" title=\"效果提升\"></a>效果提升</h1><p>对于上述效果，其实还是不完美的。因为当鼠标悬浮在矩形上的时候，并没有任何UI上的信息，点击的矩形进行拖拽的时候，鼠标指针也是普通的。于是我们优化代码，将鼠标悬浮的呈现的效果以及拖拽时候的鼠标指针效果做出来。</p>\n<p>我们设定，当鼠标悬浮在矩形上的时候，矩形会改变对应的颜色为带有50%透明的红色（<code>rgba(255, 0, 0, 0.5)</code>，并且鼠标的指针修改为<code>pointer</code>。那么首先需要给矩形加上我们在第一章中提到的属性<code>hover</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rect = &#123;</span><br><span class=\"line\">  x: <span class=\"number\">10</span>,</span><br><span class=\"line\">  y: <span class=\"number\">10</span>,</span><br><span class=\"line\">  width: <span class=\"number\">80</span>,</span><br><span class=\"line\">  height: <span class=\"number\">60</span>,</span><br><span class=\"line\">  selected: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// hover效果</span></span><br><span class=\"line\">  hover: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在渲染中，我们不再像上一节中进行简单的处理，而是需要对selected、hover以及一般状态都进行考虑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 7.2 处理渲染</span></span><br><span class=\"line\"> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 被点击选中：正红色，指针为 &#x27;move&#x27;</span></span><br><span class=\"line\">   <span class=\"comment\">// 悬浮：带50%透明的正红色，指针为 &#x27;pointer&#x27;</span></span><br><span class=\"line\">   <span class=\"comment\">// 普通下为黑色，指针为 &#x27;default&#x27;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (rect.selected) &#123;</span><br><span class=\"line\">     ctx.strokeStyle = <span class=\"string\">&#x27;#FF0000&#x27;</span>;</span><br><span class=\"line\">     canvasEle.style.cursor = <span class=\"string\">&#x27;move&#x27;</span>;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rect.hover) &#123;</span><br><span class=\"line\">     ctx.strokeStyle = <span class=\"string\">&#x27;rgba(255, 0, 0, 0.5)&#x27;</span>;</span><br><span class=\"line\">     canvasEle.style.cursor = <span class=\"string\">&#x27;pointer&#x27;</span>;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     ctx.strokeStyle = <span class=\"string\">&#x27;#000&#x27;</span>;</span><br><span class=\"line\">     canvasEle.style.cursor = <span class=\"string\">&#x27;default&#x27;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">     </span><br><span class=\"line\"> &#125;)();</span><br></pre></td></tr></table></figure>\n<p>接下来就是在鼠标移动事件中，修改hover：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvasEle.addEventListener(<span class=\"string\">&#x27;mousemove&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.2 记录上一次的鼠标位置</span></span><br><span class=\"line\">  <span class=\"comment\">// ... ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.3 更新当前鼠标位置</span></span><br><span class=\"line\">  mousePosition = utils.getMousePositionInCanvas(event, canvasEle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.3.1 判断鼠标是否悬浮在矩形</span></span><br><span class=\"line\">  rect.hover = utils.isPointInRect(rect, mousePosition);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.4 判断是否鼠标左键点击且有矩形被选中</span></span><br><span class=\"line\">  <span class=\"comment\">// ... ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"整体演示\"><a href=\"#整体演示\" class=\"headerlink\" title=\"整体演示\"></a>整体演示</h1><p>至此，我们丰富了我们的拖拽样例，结果如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-22/040-drag-show-case-perfect.gif\" alt=\"040-drag-show-case-perfect\"></p>\n<h1 id=\"代码仓库与说明\"><a href=\"#代码仓库与说明\" class=\"headerlink\" title=\"代码仓库与说明\"></a>代码仓库与说明</h1><p>本文所在的代码仓库地址为：</p>\n<p><a href=\"https://github.com/w4ngzhen/canvas-is-everything/tree/main/02_drag\">canvas-is-everything/02_drag at main · w4ngzhen/canvas-is-everything (github.com)</a></p>\n<p>两次提交：</p>\n<ol>\n<li>02<em>drag: 01</em>基础效果（优化前）</li>\n<li>02<em>drag: 02</em>悬浮与点击效果提升（优化后）</li>\n</ol>\n","categories":[],"tags":["h5","canvas"]},{"title":"画布就是一切（一）— 画布编程的基本模式","url":"http://compilemind.com/2021/11/11/2021-11-11-画布就是一切（一）— 画布编程的基本模式/","content":"<p>画布编程的基本模式</p>\n<a id=\"more\"></a>\n<h1 id=\"画布基本介绍\"><a href=\"#画布基本介绍\" class=\"headerlink\" title=\"画布基本介绍\"></a>画布基本介绍</h1><p>我开发过基于QT的客户端程序、基于C# WinForm客户端，开发过Java后端服务，此外，前端VUE和React我也开发过不少。对应我所开发过的东西，比起一行一行冰冷的代码，我更加迷恋哪些能够直观的，可视化的东西。还记得以前在开发C#的时候，接触过一个的C# WinForm库<strong>NetronGraphLib</strong>，这个库能够让我们轻松的构建属于自己的流程图绘制软件，让我们能够以拖拉拽的方式来构建图（下图就是NetronGraphLib库的官方示例应用Cobalt）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/010-NetronGraphLibShow.gif\" alt=\"010-NetronGraphLibShow\"></p>\n<p>当年看到这个库的时候，极大的震撼了作为开发菜鸟（现在也是= - =）的我。同时，这个库开源免费，他还有一个轻量级Light版本也是开源的。迫于对这种UI的迷恋，我从Light版入手，深入研究了它的实现原理。尽管是C#编写的一个库，但是它内在的实现原理以及思想确实很通用的，对于我来说都是有革新意义的，以至于这么多年以来，我都会时常回忆起这个库。</p>\n<p>这个库原理并不复杂，就是通过<strong>C# GDI+</strong>来进行图像的绘制。也许读者没有开发过C#，不知道所谓的GDI+是什么。简单来讲，很多开发语言都提供所谓的<strong>画布以及绘制能力</strong>（比如html5中的canvas标签，C#中的Graphics对象等）。在画布上，你能够通过相关绘图API来绘制各种各样的图形。上图的流程图中，你所看到的矩形、线段等等，都是通过画布提供的绘制功能来实现的。</p>\n<h1 id=\"简单绘制\"><a href=\"#简单绘制\" class=\"headerlink\" title=\"简单绘制\"></a>简单绘制</h1><p>以下的代码就是C# 对一个空白的窗体绘制一个红色矩形：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 窗体绘制事件，由WinForm窗体消息事件框架调用</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Form1_Paint</span>(<span class=\"params\"><span class=\"keyword\">object</span> sender, PaintEventArgs e</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 绘制事件中获取图形画布对象</span></span><br><span class=\"line\">    Graphics g = e.Graphics;</span><br><span class=\"line\">    <span class=\"comment\">// 调用API在当前窗体的 x = 10, y = 10 位置绘制一个</span></span><br><span class=\"line\">    <span class=\"comment\">// width = 200, height = 150 的矩形</span></span><br><span class=\"line\">    g.DrawRectangle(<span class=\"keyword\">new</span> Pen(Color.Red), <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">200</span>, <span class=\"number\">150</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显示的效果如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/020-winfrom-draw.jpg\" alt=\"020-winfrom-draw\"></p>\n<p>以下的代码就是HTML5 Canvas 上获取Context对象，利用Context对象的API来绘制一个矩形：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myCanvas&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">style</span>=<span class=\"string\">&quot;border: 1px solid black;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">width</span>=<span class=\"string\">&quot;200&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">height</span>=<span class=\"string\">&quot;200&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 获取画布的上下文</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">let</span> ctx = </span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;myCanvas&#x27;</span>).getContext(<span class=\"string\">&#x27;2d&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 设置绘制的画笔颜色</span></span></span><br><span class=\"line\"><span class=\"javascript\">        ctx.strokeStyle = <span class=\"string\">&#x27;#FF0000&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 描边一个矩形</span></span></span><br><span class=\"line\">        ctx.strokeRect(10, 10, 100, 80);</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>实现的效果如下（黑色边框是为了便于看到画布的边界加上的）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/030-html-draw.jpg\" alt=\"030-html-draw\"></p>\n<p>为了方便后续的实现，以及适应目前的Web前端化，我们使用html 5 的canvas来进行代码编写、演示。</p>\n<h1 id=\"画布编程的基本模式\"><a href=\"#画布编程的基本模式\" class=\"headerlink\" title=\"画布编程的基本模式\"></a>画布编程的基本模式</h1><p>为了讲解画布编程的基本模式，接下来我们将以<strong>鼠标悬浮矩形，矩形边框变色场景</strong>为例来进行讲解。对于一个矩形，默认的情况下显示黑色边框，当鼠标悬浮在矩形上的时候，矩形的边框能够显示为红色，就像下图一样：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/050-rect-hover-show.gif\" alt=\"050-rect-hover-show\"></p>\n<p>那么如何实现这个功能呢？</p>\n<p>要回答这个问题，我们首先要明白一组基本概念：<strong>输入（input）</strong>—<strong>更新（update）</strong>—<strong>渲染（render）</strong>，而这几个操作，都会围绕<strong>状态（status）</strong>进行：</p>\n<ol>\n<li><strong>输入</strong>会触发<strong>更新</strong></li>\n<li><strong>更新</strong>会修改<strong>状态</strong></li>\n<li><strong>渲染</strong>读取最新的<strong>状态</strong>进行图像映射</li>\n</ol>\n<p>事实上，<strong>渲染</strong>和<strong>输入、更新</strong>是解耦的，它们之间只会通过<strong>状态</strong>来建立关联：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/040-input-update-render.jpg\" alt=\"040-input-update-render\"></p>\n<h2 id=\"状态整理与提炼\"><a href=\"#状态整理与提炼\" class=\"headerlink\" title=\"状态整理与提炼\"></a>状态整理与提炼</h2><p>将上述的概念应用到悬浮变色这个场景，我们首先需要整理并提炼有哪些状态。</p>\n<p><strong>整理状态</strong>最直接的方式，就是看所实现的效果需要哪些UI元素。悬浮变色的场景下，需要的东西很简单：</p>\n<ol>\n<li>矩形位置</li>\n<li>矩形大小</li>\n<li>矩形边框颜色</li>\n</ol>\n<p>整理完成以后，我们还需要进行<strong>提炼</strong>。有的读者可能会说，上述整理的东西已经足够了，还需要提炼什么呢？事实上<strong>提炼的过程是通用化的过程，是划清状态与渲染界限的过程</strong>。对于1、2来说，无需过多讨论，它们是核心渲染基础，再简单的图像渲染，都离不开position和size这两个核心的元素。</p>\n<p>但对于矩形边框颜色是不是状态，则需要探讨。在我看来，应该<strong>属于渲染</strong>的范畴，<strong>不属于状态</strong>的范畴。为什么这么来理解呢？因为颜色变化的根本原因是鼠标悬浮，鼠标是否悬浮在矩形上，是矩形的<strong>固有属性</strong>，在正常的情况下，鼠标和矩形发生交互，必然有是否悬浮这一情形；但是悬浮的颜色却不是固有属性，在这个场景中，指定了悬浮的颜色是红色，但是换一个场景，可能又需要蓝色。<em>“流水线的颜色，铁打悬浮”。</em></p>\n<p>经过上述的讨论，我们得到这个画布的状态：一个包含位置与大小，以及标识是否被鼠标悬浮的标志。在JS中，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rect = &#123;</span><br><span class=\"line\">    x: <span class=\"number\">10</span>,</span><br><span class=\"line\">    y: <span class=\"number\">10</span>,</span><br><span class=\"line\">    width: <span class=\"number\">80</span>,</span><br><span class=\"line\">    height: <span class=\"number\">60</span>,</span><br><span class=\"line\">    hovered: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"输入与更新\"><a href=\"#输入与更新\" class=\"headerlink\" title=\"输入与更新\"></a>输入与更新</h2><h3 id=\"找到更新点\"><a href=\"#找到更新点\" class=\"headerlink\" title=\"找到更新点\"></a>找到更新点</h3><p>完成对状态的整理提炼后，我们需要知道哪些部分是对状态的更新操作。在这个场景中，只要鼠标坐标在矩形区域内，那么我们就会修改矩形的hover为true，否则为false。用伪代码进行描述：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(鼠标在矩形区域内) &#123;</span><br><span class=\"line\">    rect.hover = <span class=\"literal\">true</span>; <span class=\"comment\">// 更新状态</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    rect.hover = <span class=\"literal\">false</span>; <span class=\"comment\">// 更新状态</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，我们接下来需要需要考虑“鼠标在矩形区域内”这个条件成立与否。在canvas中，我们需要知道如下的几个数据：矩形的位置、矩形的大小以及鼠标在canvas中的位置，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/060-position-1.jpg\" alt=\"060-position-1\"></p>\n<p>只要满足如下的条件，我们就认为鼠标在矩形内，于是就会发生状态的更新：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(x &lt;&#x3D; xInCanvas &amp;&amp; xInCanvas &lt;&#x3D; x + width) </span><br><span class=\"line\">&amp;&amp; </span><br><span class=\"line\">(y &lt;&#x3D; yInCanvas &amp;&amp; yInCanvas &lt;&#x3D; y + height)</span><br></pre></td></tr></table></figure>\n<h3 id=\"找到输入点\"><a href=\"#找到输入点\" class=\"headerlink\" title=\"找到输入点\"></a>找到输入点</h3><p>更新是如何触发的呢？我们现在知道，矩形的位置与大小是已有的值。那么鼠标在canvas中的x、y怎么获得呢？事实上，我们可以给canvas添加<strong>鼠标移动事件（mousemove）</strong>，从移动事件中获取鼠标位置。当事件被触发时，我们可以获取鼠标相对于 viewport（<a href=\"https://www.seoptimer.com/blog/viewport/\">什么是viewport？</a>）的坐标（<code>event.clientX</code>和<code>event.clientY</code>，这两个值并不是直接就是鼠标在canvas中的位置）。 同时，我们可以通过 <strong>canvas.getBoundingClientRect()</strong> 来获取 canvas 相对于 viewport 的坐标（<code>top, left</code>），这样我们就可以计算出鼠标在 canvas 中的坐标。</p>\n<p><em>注意：下图的canvas.left可能产生误导，canvas没有left，是通过调用canvas的getBoundingClientRect，获取一个boundingClientRect，再获取这个rect的left。</em></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/070-position-2.jpg\" alt=\"070-position-2\"></p>\n<p>为了后续的代码编写，我们准备一个index.html：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Hover Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myCanvas&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">style</span>=<span class=\"string\">&quot;border: 1px solid black&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">width</span>=<span class=\"string\">&quot;450&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">height</span>=<span class=\"string\">&quot;200&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 同级目录下的index.js --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;index.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>同级目录下的index.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同级目录的index.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> canvasEle = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#myCanvas&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">canvasEle.addEventListener(<span class=\"string\">&#x27;mousemove&#x27;</span>, <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 移动事件对象，从中解构clientX和clientY</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;clientX, clientY&#125; = ev;</span><br><span class=\"line\">  <span class=\"comment\">// 解构canvas的boundingClientRect中的left和top</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;left, top&#125; = canvasEle.getBoundingClientRect();</span><br><span class=\"line\">  <span class=\"comment\">// 计算得到鼠标在canvas上的坐标</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mousePositionInCanvas = &#123;</span><br><span class=\"line\">    x: clientX - left,</span><br><span class=\"line\">    y: clientY - top</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mousePositionInCanvas);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>用浏览器打开<code>index.html</code>，在控制台就能看到坐标输出：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/080-show-mouse-position.gif\" alt=\"080-show-mouse-position\"></p>\n<p>PS：实际上在对canvas有不同的缩放、CSS样式的加持下，坐标的计算会更加复杂，本文只是简单的获取鼠标在canvas中的坐标，不做过多的讨论，想要深入了解可以看这篇大佬的文章：<a href=\"https://www.cnblogs.com/wangqh8975/p/12706513.html\">获取鼠标在 canvas 中的位置 - 一根破棍子 - 博客园 (cnblogs.com)</a>。</p>\n<h3 id=\"整合输入以及状态更新\"><a href=\"#整合输入以及状态更新\" class=\"headerlink\" title=\"整合输入以及状态更新\"></a>整合输入以及状态更新</h3><p>综合上述的讨论，我们整合目前的信息，有如下的JS代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义状态</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> rect = &#123;</span><br><span class=\"line\">  x: <span class=\"number\">10</span>,</span><br><span class=\"line\">  y: <span class=\"number\">10</span>,</span><br><span class=\"line\">  width: <span class=\"number\">80</span>,</span><br><span class=\"line\">  height: <span class=\"number\">60</span>,</span><br><span class=\"line\">  hover: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取canvas元素</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> canvasEle = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#myCanvas&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听鼠标移动</span></span><br><span class=\"line\">canvasEle.addEventListener(<span class=\"string\">&#x27;mousemove&#x27;</span>, <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 移动事件对象，从中解构clientX和clientY</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;clientX, clientY&#125; = ev;</span><br><span class=\"line\">  <span class=\"comment\">// 解构canvas的boundingClientRect中的left和top</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;left, top&#125; = canvasEle.getBoundingClientRect();</span><br><span class=\"line\">  <span class=\"comment\">// 计算得到鼠标在canvas上的坐标</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mousePositionInCanvas = &#123;</span><br><span class=\"line\">    x: clientX - left,</span><br><span class=\"line\">    y: clientY - top</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// console.log(mousePositionInCanvas);</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断条件进行更新</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> inRect = </span><br><span class=\"line\">    (rect.x &lt;= mousePositionInCanvas.x &amp;&amp; mousePositionInCanvas.x &lt;= rect.x + rect.width)</span><br><span class=\"line\">    &amp;&amp; (rect.y &lt;= mousePositionInCanvas.y &amp;&amp; mousePositionInCanvas.y &lt;= rect.y + rect.height)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;mouse in rect: &#x27;</span> + inRect);</span><br><span class=\"line\">  rect.hover = inRect; <span class=\"comment\">// 状态修改</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h2><p>在上一节，我们已经实现了这样的效果：鼠标不断在canvas上进行移动，移动的过程中，鼠标在矩形外部移动的时候，控制台会不断的输出文本：<code>mouse in rect: false</code>，而当鼠标一旦进入了矩形内部，控制台则会输出：<code>mouse in rect: true</code>。那么如何将rect的布尔属性hover，转换为我们能够看到的UI图像呢？通过canvas的CanvasRenderingContext2D类实例的相关API来进行绘制即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// canvasEle来源见上面的代码</span></span><br><span class=\"line\"><span class=\"comment\">// 从Canvas元素上获取CanvasRenderingContext2D类实例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ctx = canvasEle.getContext(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置画笔颜色：黑色</span></span><br><span class=\"line\">ctx.strokeStyle = <span class=\"string\">&#x27;#000&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 矩形所在位置画一个黑色框的矩形</span></span><br><span class=\"line\">ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);</span><br></pre></td></tr></table></figure>\n<p>对于strokeStyle，根据我们的需求，我们需要判断rect的hover属性来决定实际的颜色是红色还是黑色：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ctx.strokeStyle = &#x27;#000&#x27;; 改写为：</span></span><br><span class=\"line\">ctx.strokeStyle = rect.hover ? <span class=\"string\">&#x27;#F00&#x27;</span> : <span class=\"string\">&#x27;#000&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>为了后续调用的方便，我们将绘制操作封装为一个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 画布渲染矩形的工具函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">ctx</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">rect</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawRect</span>(<span class=\"params\">ctx, rect</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 暂存当前ctx的状态</span></span><br><span class=\"line\">  ctx.save();</span><br><span class=\"line\">  <span class=\"comment\">// 设置画笔颜色：黑色</span></span><br><span class=\"line\">  ctx.strokeStyle = rect.hover ? <span class=\"string\">&#x27;#F00&#x27;</span> : <span class=\"string\">&#x27;#000&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 矩形所在位置画一个黑色框的矩形</span></span><br><span class=\"line\">  ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);</span><br><span class=\"line\">  <span class=\"comment\">// 恢复ctx的状态</span></span><br><span class=\"line\">  ctx.restore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个方法中，ctx调用了save和restore。关于这两个方法含义以及使用方式，请参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/save\">CanvasRenderingContext2D.save() - Web API 接口参考 | MDN (mozilla.org)</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/restore\">CanvasRenderingContext2D.restore() - Web API 接口参考 | MDN (mozilla.org)</a></li>\n</ul>\n<p>完成方法封装以后，我们需要该方法的调用点，一个最直接的方式就是在鼠标移动事件处理的内部进行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听鼠标移动</span></span><br><span class=\"line\">canvasEle.addEventListener(<span class=\"string\">&#x27;mousemove&#x27;</span>, <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 状态更新的代码</span></span><br><span class=\"line\">  <span class=\"comment\">// ......</span></span><br><span class=\"line\">  <span class=\"comment\">// 触发移动时，就进行渲染</span></span><br><span class=\"line\">  drawRect(ctx, rect);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>编写好代码以后，目前的index.js的整体内容如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义状态</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> rect = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取canvas元素</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> canvasEle = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#myCanvas&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从Canvas元素上获取context</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ctx = canvasEle.getContext(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 画布渲染矩形的工具函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawRect</span>(<span class=\"params\">ctx, rect</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听鼠标移动</span></span><br><span class=\"line\">canvasEle.addEventListener(<span class=\"string\">&#x27;mousemove&#x27;</span>, <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/090-first-hover-show.gif\" alt=\"090-first-hover-show\"></p>\n<h3 id=\"渲染的时机\"><a href=\"#渲染的时机\" class=\"headerlink\" title=\"渲染的时机\"></a>渲染的时机</h3><p>细心的读者发现了这个演示中的问题：将鼠标从canvas的外部移动进入，在初始的情况下，canvas中并没有矩形显示，只有在鼠标移动进入canvas以后才显示。原因也很容易解释：在触发mousemove事件后，渲染（drawRect调用）才开始。</p>\n<p>要解决上述问题，我们需要明确一点：<strong>一般情况下，图像渲染应该和任何的输入事件独立开来，输入事件应只作用于更新。</strong>也就是说，上面的（drawRect）调用，不应该和mousemove事件相关联，而是应该在一套独立的循环中去做：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/100-render-cycle.jpg\" alt=\"100-render-cycle\"></p>\n<p>那么，在JS中，我们可以有哪些循环调用方法的方式来完成我们图像的渲染呢？在我的认知中，主要有以下几种：</p>\n<p><strong>while类循环，包括for等循环控制语句类</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\trender();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>弊端：极易造成CPU高占用的卡死问题</p>\n<p><strong>setInterval</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> interval = <span class=\"number\">1000</span> / <span class=\"number\">60</span>; <span class=\"comment\">// 每1秒大约60次</span></span><br><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\trender();</span><br><span class=\"line\">&#125;, interval);</span><br></pre></td></tr></table></figure>\n<p>弊端：当render()的调用超过interval间隔的时候，会发生调用丢失的问题；此外，无论canvas是否需要渲染，都会进行调用渲染。</p>\n<p><strong>setTimeout</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> interval = <span class=\"number\">1000</span> / <span class=\"number\">60</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doRendert</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        doRender(); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">    &#125;, interval)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>弊端：同上，无论canvas是否需要渲染，都会调用，造成资源浪费。</p>\n<p><strong>requestAnimationFrame</strong></p>\n<p>关于这个API的基本使用以及原理，请参考这篇大神的详解：<a href=\"https://juejin.cn/post/6844903761102536718\">你知道的requestAnimationFrame - 掘金 (juejin.cn)</a>。</p>\n<p>简单来讲，requestAnimationFrame(callbackFunc)，这个API调用的时候，只是告诉浏览器，我在请求一个操作，这个操作是在动画帧渲染发生的时候进行的，至于什么时候发生的动画帧渲染交由浏览器底层完成，但通常，这个值是60FPS。所以，我们的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doRender</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  requestAnimationFrame(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    drawRect(ctx, rect);</span><br><span class=\"line\">    doRender(); <span class=\"comment\">// 递归</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"必要的画布清空\"><a href=\"#必要的画布清空\" class=\"headerlink\" title=\"必要的画布清空\"></a>必要的画布清空</h3><p>目前为止这份代码还有一个问题：我们一直在不断循环调用drawRect方法在指定位置绘制矩形，但是我们从来没有清空过画布，也就是说我们不断在一个位置画着矩形。在本例中，这问题凸显的效果看出不出，但是试想如果我们在输入更新的时候，修改了矩形的x或y值，就会发现画布上会有多个矩形图像了（因为上一个位置的矩形已经被“画”在画布上了）。所以，我们需要在开始进行图像绘制的时候，进行清空：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doRender</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  requestAnimationFrame(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先清空画布</span></span><br><span class=\"line\">    ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, canvasEle.width, canvasEle.height);</span><br><span class=\"line\">    <span class=\"comment\">// 绘制矩形</span></span><br><span class=\"line\">    drawRect(ctx, rect);</span><br><span class=\"line\">    <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">    doRender(); <span class=\"comment\">// 递归</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"1px线条模糊\"><a href=\"#1px线条模糊\" class=\"headerlink\" title=\"1px线条模糊\"></a>1px线条模糊</h3><p>目前为止这份代码<strong>还还</strong>有一个问题：默认的情况下，我们的线条宽度为1px。但实际上，我们画布上的显示的确实一个<strong>模糊的</strong>看起来<strong>比1px更加宽</strong>的线条：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/110-dim-line.jpg\" alt=\"110-dim-line\"></p>\n<p>这个问题产生的原因读者可以自行网上搜索。这里直接给出解决方案就是，在线宽1px的情况下，线条的坐标需要向左或者向右移动0.5像素，所以对于之前的drawRect中，绘制的时候将x和y进行0.5像素移动：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawRect</span>(<span class=\"params\">ctx, rect</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 矩形所在位置画一个黑色框的矩形，移位0.5像素</span></span><br><span class=\"line\">  ctx.strokeRect(rect.x - <span class=\"number\">0.5</span>, rect.y - <span class=\"number\">0.5</span>, rect.width, rect.height);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改之后，效果如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/120-new-line.jpg\" alt=\"\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>画布编程的模式：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-11-11-canvas/130-pattern-arch.jpg\" alt=\"130-pattern-arch\"></p>\n<h2 id=\"悬浮变色代码\"><a href=\"#悬浮变色代码\" class=\"headerlink\" title=\"悬浮变色代码\"></a>悬浮变色代码</h2><h3 id=\"index-html\"><a href=\"#index-html\" class=\"headerlink\" title=\"index.html\"></a>index.html</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Hover Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myCanvas&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">style</span>=<span class=\"string\">&quot;border: 1px solid black&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">width</span>=<span class=\"string\">&quot;450&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">height</span>=<span class=\"string\">&quot;200&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;index.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"index-js\"><a href=\"#index-js\" class=\"headerlink\" title=\"index.js\"></a>index.js</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义状态</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> rect = &#123;</span><br><span class=\"line\">  x: <span class=\"number\">10</span>,</span><br><span class=\"line\">  y: <span class=\"number\">10</span>,</span><br><span class=\"line\">  width: <span class=\"number\">80</span>,</span><br><span class=\"line\">  height: <span class=\"number\">60</span>,</span><br><span class=\"line\">  hover: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取canvas元素</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> canvasEle = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#myCanvas&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 从Canvas元素上获取context</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ctx = canvasEle.getContext(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 画布渲染矩形的工具函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">ctx</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">rect</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawRect</span>(<span class=\"params\">ctx, rect</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 暂存当前ctx的状态</span></span><br><span class=\"line\">  ctx.save();</span><br><span class=\"line\">  <span class=\"comment\">// 设置画笔颜色：黑色</span></span><br><span class=\"line\">  ctx.strokeStyle = rect.hover ? <span class=\"string\">&#x27;#F00&#x27;</span> : <span class=\"string\">&#x27;#000&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 矩形所在位置画一个黑色框的矩形</span></span><br><span class=\"line\">  ctx.strokeRect(rect.x - <span class=\"number\">0.5</span>, rect.y - <span class=\"number\">0.5</span>, rect.width, rect.height);</span><br><span class=\"line\">  <span class=\"comment\">// 恢复ctx的状态</span></span><br><span class=\"line\">  ctx.restore();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听鼠标移动</span></span><br><span class=\"line\">canvasEle.addEventListener(<span class=\"string\">&#x27;mousemove&#x27;</span>, <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 移动事件对象，从中解构clientX和clientY</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;clientX, clientY&#125; = ev;</span><br><span class=\"line\">  <span class=\"comment\">// 解构canvas的boundingClientRect中的left和top</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;left, top&#125; = canvasEle.getBoundingClientRect();</span><br><span class=\"line\">  <span class=\"comment\">// 计算得到鼠标在canvas上的坐标</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mousePositionInCanvas = &#123;</span><br><span class=\"line\">    x: clientX - left,</span><br><span class=\"line\">    y: clientY - top</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// console.log(mousePositionInCanvas);</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断条件进行更新</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> inRect =</span><br><span class=\"line\">    (rect.x &lt;= mousePositionInCanvas.x &amp;&amp; mousePositionInCanvas.x &lt;= rect.x + rect.width)</span><br><span class=\"line\">    &amp;&amp; (rect.y &lt;= mousePositionInCanvas.y &amp;&amp; mousePositionInCanvas.y &lt;= rect.y + rect.height);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;mouse in rect: &#x27;</span> + inRect);</span><br><span class=\"line\">  rect.hover = inRect;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doRender</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  requestAnimationFrame(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先清空画布</span></span><br><span class=\"line\">    ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, canvasEle.width, canvasEle.height);</span><br><span class=\"line\">    <span class=\"comment\">// 绘制矩形</span></span><br><span class=\"line\">    drawRect(ctx, rect);</span><br><span class=\"line\">    <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">    doRender(); <span class=\"comment\">// 递归</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h3><p><a href=\"https://github.com/w4ngzhen/canvas-is-everything\">w4ngzhen/canvas-is-everything (github.com)</a></p>\n<p><strong>01_hover</strong></p>\n","categories":[],"tags":["canvas"]},{"title":"IDEA Web渲染插件开发（二）— 自定义JsDialog","url":"http://compilemind.com/2021/10/06/2021-10-06-IDEA Web渲染插件开发（二）— 自定义JsDialog/","content":"<p>《IDEA Web渲染插件开发（一）》中，我们了解到了如何编写一款用于显示网页的插件，所需要的核心知识点就是<strong>IDEA插件开发</strong>和<strong>JCEF</strong>，在本文中，我们将继续插件的开发，为该插件的JS Dialog显示进行自定义处理。</p>\n<a id=\"more\"></a>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在开发之前，我们首先要了解下什么是JS Dialog。有过Web页面开发经历的开发者都或多或少使用过这样一个JS的API：<code>alert(&#39;this is a message&#39;)</code>，当JS页面执行这段脚本的时候，在浏览器上会有类似于如下的显示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/010-show-js-alert.gif\" alt=\"\"></p>\n<p>同样，当我们使用<code>confirm(&#39;ok?&#39;)</code>的时候，会显示如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/020-show-js-confirm.gif\" alt=\"\"></p>\n<p>以及，使用<code>prompt(input your name: &#39;)</code>，有如下的显示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/030-show-js-prompt.gif\" alt=\"\"></p>\n<p>这些弹框一般来说都是原生的窗体，例如，当我们在之前的《IDEA Web渲染插件开发（一）》中的Web渲染插件来打开上面的Demo网页的时候，效果如下：</p>\n<p><strong>alert</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/040-show-js-alert-in-jcef.gif\" alt=\"\"></p>\n<p><strong>confirm</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/050-show-js-confirm-in-jcef.gif\" alt=\"\"></p>\n<p><strong>prompt</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/060-show-js-prompt-in-jcef.gif\" alt=\"\"></p>\n<p>可以看到，原生窗体显得不是那么好看。那么，我们能不能自定义这个原生窗体呢？答案是肯定的，接下来就要用到<strong>JCEF</strong>里面一个Handler CefJSDialogHandler（<a href=\"https://github.com/chromiumembedded/java-cef/blob/master/java/org/cef/handler/CefJSDialogHandler.java\">java-cef/CefJSDialogHandler</a>）。</p>\n<h1 id=\"CefJSDialogHandler\"><a href=\"#CefJSDialogHandler\" class=\"headerlink\" title=\"CefJSDialogHandler\"></a>CefJSDialogHandler</h1><p>对于该Handler，官方注释为：</p>\n<blockquote>\n<p>Implement this interface to handle events related to JavaScript dialogs. The methods of this class will be called on the UI thread.</p>\n<p>实现此接口以处理与JavaScript对话框相关的事件。将在UI线程上调用此类的方法。</p>\n</blockquote>\n<p>对于该Handler，里面有一个核心的接口方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Called to run a JavaScript dialog. Set suppress_message to true and</span></span><br><span class=\"line\"><span class=\"comment\"> * return false to suppress the message (suppressing messages is preferable</span></span><br><span class=\"line\"><span class=\"comment\"> * to immediately executing the callback as this is used to detect presumably</span></span><br><span class=\"line\"><span class=\"comment\"> * malicious behavior like spamming alert messages in onbeforeunload). Set</span></span><br><span class=\"line\"><span class=\"comment\"> * suppress_message to false and return false to use the default</span></span><br><span class=\"line\"><span class=\"comment\"> * implementation (the default implementation will show one modal dialog at a</span></span><br><span class=\"line\"><span class=\"comment\"> * time and suppress any additional dialog requests until the displayed dialog</span></span><br><span class=\"line\"><span class=\"comment\"> * is dismissed). Return true if the application will use a custom dialog or</span></span><br><span class=\"line\"><span class=\"comment\"> * if the callback has been executed immediately. Custom dialogs may be either</span></span><br><span class=\"line\"><span class=\"comment\"> * modal or modeless. If a custom dialog is used the application must execute</span></span><br><span class=\"line\"><span class=\"comment\"> * callback once the custom dialog is dismissed.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> browser The corresponding browser.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> origin_url The originating url.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dialog_type the dialog type.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> message_text the text to be displayed.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> default_prompt_text value will be specified for prompt dialogs only.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> callback execute callback once the custom dialog is dismissed.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> suppress_message set to true to suppress displaying the message.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> false to use the default dialog implementation. Return true if the</span></span><br><span class=\"line\"><span class=\"comment\"> * application will use a custom dialog.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onJSDialog</span><span class=\"params\">(CefBrowser browser, String origin_url, JSDialogType dialog_type,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String message_text, String default_prompt_text, CefJSDialogCallback callback,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        BoolRef suppress_message)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>注释翻译如下：</p>\n<blockquote>\n<p>在调用一个JS的Dialog的时候会调用该方法。设置<code>suppress_message</code>为<code>true</code>并使该方法返回<code>false</code>来抑制这个消息（抑制消息比立即执行回调更可取，因为它用于检测可能的恶意行为，如onbeforeunload中的垃圾邮件警报消息）。设置<code>suppress_message</code>为<code>false</code>并且返回<code>false</code>来使用默认的实现（默认的实现将会立刻展示一个模态对话框并抑制任何额外的对话框请求直到当前展示的对话框已经销毁）。如果应用程序想要使用一个自定义的对话框或是回调callback已经立刻被执行了，则返回<code>true</code>。自定义的对话框可以是模态或是非模态的。如果使用了一个自定义的对话框，那么一旦自定义对话框销毁后，应用程序需要立即执行回调。</p>\n</blockquote>\n<p>首先，我们编写类JsDialogHandler，实现该接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.compilemind.demo.handler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.cef.browser.CefBrowser;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.cef.callback.CefJSDialogCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.cef.handler.CefJSDialogHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.cef.misc.BoolRef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.cef.handler.CefJSDialogHandler.JSDialogType.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsDialogHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">CefJSDialogHandler</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onJSDialog</span><span class=\"params\">(CefBrowser browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              java.lang.String origin_url,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              CefJSDialogHandler.JSDialogType dialog_type,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              java.lang.String message_text,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              java.lang.String default_prompt_text,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              CefJSDialogCallback callback,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              BoolRef suppress_message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 具体内容见下文</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onBeforeUnloadDialog</span><span class=\"params\">(CefBrowser cefBrowser, String s, <span class=\"keyword\">boolean</span> b, CefJSDialogCallback cefJSDialogCallback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResetDialogState</span><span class=\"params\">(CefBrowser cefBrowser)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDialogClosed</span><span class=\"params\">(CefBrowser cefBrowser)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>除了<code>onJSDialog</code>方法，其他的我们暂时不关心，使用默认的处理。对于<code>onJSDialog</code>的方法，我们编写如下的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onJSDialog</span><span class=\"params\">(CefBrowser browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          java.lang.String origin_url,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          CefJSDialogHandler.JSDialogType dialog_type,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          java.lang.String message_text,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          java.lang.String default_prompt_text,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          CefJSDialogCallback callback,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BoolRef suppress_message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不抑制消息</span></span><br><span class=\"line\">    suppress_message.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dialog_type == JSDIALOGTYPE_ALERT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// alert 对话框</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dialog_type == JSDIALOGTYPE_CONFIRM) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// confirm 对话框</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dialog_type == JSDIALOGTYPE_PROMPT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// prompt 对话框</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 默认处理，不过理论不会进入这一步</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回true，表明自行处理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们向CefBrowser进行注册（MyWebToolWindowContent类的构造函数中）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 JBCefBrowser</span></span><br><span class=\"line\">JBCefBrowser jbCefBrowser = <span class=\"keyword\">new</span> JBCefBrowser();</span><br><span class=\"line\"><span class=\"comment\">// 注册我们的Handler</span></span><br><span class=\"line\">jbCefBrowser.getJBCefClient()</span><br><span class=\"line\">        .addJSDialogHandler(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> JsDialogHandler(),</span><br><span class=\"line\">                jbCefBrowser.getCefBrowser());</span><br><span class=\"line\"><span class=\"comment\">// 将 JBCefBrowser 的UI控件设置到Panel中</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.content.add(jbCefBrowser.getComponent(), BorderLayout.CENTER);</span><br></pre></td></tr></table></figure>\n<p>至此，我们已经在该方法中对js的对话框类型进行了区分。接下来，就需要我们针对不同的对话框类型，展示不同的UI，那么需要我们了解如何在IDEA插件中弹出对话框。</p>\n<h1 id=\"IDEA插件对话框\"><a href=\"#IDEA插件对话框\" class=\"headerlink\" title=\"IDEA插件对话框\"></a>IDEA插件对话框</h1><h2 id=\"DialogWrapper\"><a href=\"#DialogWrapper\" class=\"headerlink\" title=\"DialogWrapper\"></a>DialogWrapper</h2><p>DialogWrapper是IntelliJ下的所有对话框的基类，他并不是一个实际的UI控件，而是一个抽象类，在调用其show方法的时候，由IntelliJ框架进行展示。</p>\n<p><a href=\"https://plugins.jetbrains.com/docs/intellij/dialog-wrapper.html\">Dialogs | IntelliJ Platform Plugin SDK (jetbrains.com)</a></p>\n<p>我们需要做的就是编写一个类来继承该Wrapper。</p>\n<h2 id=\"AlertDialog\"><a href=\"#AlertDialog\" class=\"headerlink\" title=\"AlertDialog\"></a>AlertDialog</h2><p>为了实现JS中的alert效果，我们首先编写AlertDialog：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.intellij.openapi.ui.DialogWrapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jetbrains.annotations.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.swing.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlertDialog</span> <span class=\"keyword\">extends</span> <span class=\"title\">DialogWrapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String content;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AlertDialog</span><span class=\"params\">(String title, String content)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        setTitle(title);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content = content;</span><br><span class=\"line\">        <span class=\"comment\">// init方法需要在所有的值设置到位的时候才进行调用</span></span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">JComponent <span class=\"title\">createCenterPanel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JLabel(<span class=\"keyword\">this</span>.content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个Dialog的实现非常的简单，通过构造函数传入对话框的title和content。其中，title在构造函数执行的时候，就通过<code>DialogWrapper.setTitle(string)</code>完成设置；content赋值给AlertDialog的私有变量content，之后调用<code>DialogWrapper.init()</code>方法进行初始化。</p>\n<p><strong>这里需要特别说明的是</strong>，init方法最好放在Dialog的私有变量赋值保存完成后才进行，因为init方法内部就会调用下面重写的<code>createCenterPanel</code>方法。<strong>如果没有这样做</strong>，而是先<code>init()</code>，再进行<code>this.content = content</code>赋值，那么初始化的时候流程就是：</p>\n<ol>\n<li>设置title。</li>\n<li>调用init()。</li>\n<li>Init()内部调用<code>createCenterPanel()</code>。</li>\n<li>createCenterPanel返回一个空白的JLabel，因为此时<code>this.content</code>还是null。</li>\n<li>进行<code>this.content = content</code>赋值操作。</li>\n</ol>\n<p>最终弹出的对话框效果就是没有任何的内容，本人在这里也是踩了坑。</p>\n<p>AlertDialog编写完成后，我们可以在需要的地方编写如下的代码进行弹框展示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> AlertDialog(<span class=\"string\">&quot;注意&quot;</span>, <span class=\"string\">&quot;这是一个弹出框&quot;</span>).show();</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isOk = <span class=\"keyword\">new</span> AlertDialog(<span class=\"string\">&quot;注意&quot;</span>, <span class=\"string\">&quot;这是一个弹出框&quot;</span>).showAndGet();</span><br></pre></td></tr></table></figure>\n<p>于是，我们在之前的JSDialogHandler.onJSDialog中处理<code>dialog_type == JSDIALOGTYPE_ALERT</code>的场景：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onJSDialog</span><span class=\"params\">(CefBrowser browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          java.lang.String origin_url,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          CefJSDialogHandler.JSDialogType dialog_type,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          java.lang.String message_text,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          java.lang.String default_prompt_text,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          CefJSDialogCallback callback,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BoolRef suppress_message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不抑制消息</span></span><br><span class=\"line\">    suppress_message.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dialog_type == JSDIALOGTYPE_ALERT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// alert 对话框</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> AlertDialog(<span class=\"string\">&quot;注意&quot;</span>, message_text).show();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"问题处理\"><a href=\"#问题处理\" class=\"headerlink\" title=\"问题处理\"></a>问题处理</h3><p>调试插件，当JS执行alert的时候，发现依然还是原生窗体。经过排查还会发现，<strong>问题情况</strong>如下：</p>\n<ul>\n<li>JS的alert依然是原生窗体。</li>\n<li>onJSDialog方法也进入了（可以使用断点或是控制台输出确认）。</li>\n<li>控制台有异常：<code>Exception in thread &quot;AWT-AppKit&quot;</code>。</li>\n</ul>\n<p>对于控制台的异常，详细如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;AWT-AppKit&quot; com.intellij.openapi.diagnostic.RuntimeExceptionWithAttachments: EventQueue.isDispatchThread()&#x3D;false Toolkit.getEventQueue()&#x3D;com.intellij.ide.IdeEventQueue@fa771e7</span><br></pre></td></tr></table></figure>\n<p>对于EventQueue关键字的异常，有过GUI开发的读者应该很容易联想到应该是窗体事件消息机制的问题。</p>\n<p>简单来说，<strong>窗体GUI的线程一般都是独立的</strong>，在这个线程中，会启动一个GUI事件队列循环，外部GUI输入（点击、拖动等等）会不断产生GUI事件对象，并按照一定的顺序进入事件循环队列，事件循环框架不断处理队列中的事件。对GUI的操作，比如修改窗体某个控件的文本或是想要对一个窗体进行模态显示，都需要在窗体GUI主线程进行，否则就会出现GUI的处理异常。</p>\n<p>对于这类情况<strong>最常见问题场景</strong>就是：在窗体中点击一个按钮，点击后会单开一个线程异步加载大数据，加载完成后显示在窗体上。如果直接在加载大数据的线程中调用<code>Form.setBigData()</code>（假如有这样一个设置文本的方法），一般来说就会出现异常：<strong>在非GUI线程中尝试修改GUI的相关值</strong>。在Java AWT中解决的方式，调用<code>EventQueue.invokeLater(() -&gt; &#123; // do something&#125; )</code>（异步）或是<code>EventQueue.invokeAndWait(() -&gt; &#123; // do something&#125; )</code>（同步）。调用之后，<code>do something</code>就会被事件框架送入GUI线程执行了。</p>\n<p>现在，我们回到一开始的问题，我们重新修改代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (dialog_type == JSDIALOGTYPE_ALERT) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// alert 对话框</span></span><br><span class=\"line\">    EventQueue.invokeLater(() -&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> AlertDialog(<span class=\"string\">&quot;注意&quot;</span>, message_text).show();</span><br><span class=\"line\">      callback.Continue(<span class=\"keyword\">true</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们对代码进行断点确认线程，在onJSDialog执行的时候，所运行的线程是：<code>AWT-AppKit</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/070-onJSDialog-thread.jpg\" alt=\"\"></p>\n<p>而EventQueue.invokeLater中所运行的线程是：<code>AWT-EventQueue-0</code>，这个线程就是IDEA插件中的GUI线程。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/080-EventQueueInvokeLater-thread.jpg\" alt=\"\"></p>\n<p>修改线程处理后，让我们再次调用alert：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/090-new-not-perfect-alert-dialog.gif\" alt=\"\"></p>\n<p>可以看到对话框已经显示为了使用IDEA插件下的dialog形式，但是这个dialog还不完全正确，一般的alert对话框，只会有一个确认按钮，而IDEA下的dialog默认是Cancel+OK的按钮组合。</p>\n<h3 id=\"Dialog按钮自定义（重写createActions）\"><a href=\"#Dialog按钮自定义（重写createActions）\" class=\"headerlink\" title=\"Dialog按钮自定义（重写createActions）\"></a>Dialog按钮自定义（重写createActions）</h3><p>IDEA插件的DialogWrapper默认情况下是Cancel+OK的按钮组合。那么如何自定义我们的按钮呢？可行的一种方式就是重写createActions。这个方法需要我们返回实现<code>javax.swing.Action</code>接口的实例的数组，当然，IDEA插件也有对应的Wrapper：DialogWrapperAction。我们编写我们自己的OkAction：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OkAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">DialogWrapperAction</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OkAction</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">&quot;确定&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doAction</span><span class=\"params\">(ActionEvent e)</span> </span>&#123;</span><br><span class=\"line\">        close(OK_EXIT_CODE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>务必注意，DialogWrapperAction的实现子类，必须是DialogWrapper的内部类，否则无法查看。</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/100-ok-action-in-alert.jpg\" alt=\"\"></p>\n<p>重新运行，查看AlertDialog的效果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/110-new-perfect-alert-dialog.gif\" alt=\"\"></p>\n<p>接下来，我们需要编写ConfirmDialog，来处理JS中的confirm。</p>\n<h2 id=\"ConfirmDialog\"><a href=\"#ConfirmDialog\" class=\"headerlink\" title=\"ConfirmDialog\"></a>ConfirmDialog</h2><p>由于confirm天生需要取消和确定按钮，所以我们可以直接使用默认的DialogWrapper，不用重写Action的返回：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.intellij.openapi.ui.DialogWrapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jetbrains.annotations.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.swing.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfirmDialog</span> <span class=\"keyword\">extends</span> <span class=\"title\">DialogWrapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String content;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConfirmDialog</span><span class=\"params\">(String title, String content)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        setTitle(title);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content = content;</span><br><span class=\"line\">        <span class=\"comment\">// init方法需要在所有的值设置到位的时候才进行调用</span></span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">JComponent <span class=\"title\">createCenterPanel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JLabel(<span class=\"keyword\">this</span>.content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在Handler中，我们对<code>JSDIALOGTYPE_CONFIRM</code>分支进行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (dialog_type == JSDIALOGTYPE_CONFIRM) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// confirm 对话框</span></span><br><span class=\"line\">    EventQueue.invokeLater(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isOk = <span class=\"keyword\">new</span> ConfirmDialog(<span class=\"string\">&quot;注意&quot;</span>, message_text).showAndGet();</span><br><span class=\"line\">        callback.Continue(isOk, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这点和AlertDialog的差别在于，需要调用<code>showAndGet</code>方法获取用户的点击是cancel还是ok的结果，使用callback返回给JS，才能使得JS的confirm调用获得正确的返回。下面是效果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/120-new-confirm-dialog.gif\" alt=\"\"></p>\n<h2 id=\"PromptDialog\"><a href=\"#PromptDialog\" class=\"headerlink\" title=\"PromptDialog\"></a>PromptDialog</h2><p>对于PromptDialog，在对话框的界面，需要两个元素：<strong>文本提示</strong>和<strong>文本输入</strong>。同时，在对话框点击结束后，还需要获取用户的输入，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PromptDialog</span> <span class=\"keyword\">extends</span> <span class=\"title\">DialogWrapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 显示信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String content;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 文本输入框</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> JTextField jTextField;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PromptDialog</span><span class=\"params\">(String title, String content)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.jTextField = <span class=\"keyword\">new</span> JTextField(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content = content;</span><br><span class=\"line\"></span><br><span class=\"line\">        setTitle(title);</span><br><span class=\"line\">        <span class=\"comment\">// init方法需要在所有的值设置到位的时候才进行调用</span></span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">JComponent <span class=\"title\">createCenterPanel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2行1列的结构</span></span><br><span class=\"line\">        JPanel jPanel = <span class=\"keyword\">new</span> JPanel(<span class=\"keyword\">new</span> GridLayout(<span class=\"number\">2</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">        jPanel.add(<span class=\"keyword\">new</span> JLabel(<span class=\"keyword\">this</span>.content));</span><br><span class=\"line\">        jPanel.add(<span class=\"keyword\">this</span>.jTextField);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jPanel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getText</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jTextField.getText();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个类中，我们定义了一个私有字段<code>JTextField</code>，之所以需要在类中持有该引用，是因为我们定义一个方法<code>getText</code>，以便在对话框结束时，可以通过调用<code>PromptDialog.getText</code>来获取用户输入。</p>\n<p>编写完成后，我们在onJSDialog中对prompt类型的对话框进行处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (dialog_type == JSDIALOGTYPE_PROMPT) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// prompt 对话框</span></span><br><span class=\"line\">    EventQueue.invokeLater(() -&gt; &#123;</span><br><span class=\"line\">        PromptDialog promptDialog = <span class=\"keyword\">new</span> PromptDialog(<span class=\"string\">&quot;注意&quot;</span>, message_text);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isOk = promptDialog.showAndGet();</span><br><span class=\"line\">        String text = promptDialog.getText();</span><br><span class=\"line\">        callback.Continue(isOk, text);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和之前不太一样的是，这里需要在showAndGet之后，调用getText来获取用户输入，并在<code>callback.Continue(isOk, text)方法中</code>传入用户的数据数据。最终效果如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-10-06-intelliJ-plugin-dev-2/130-new-prompt-dialog.gif\" alt=\"\"></p>\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><p><a href=\"https://github.com/w4ngzhen/intellij-jcef-plugin\">w4ngzhen/intellij-jcef-plugin (github.com)</a></p>\n<p>本次相关代码提交：<a href=\"https://github.com/w4ngzhen/intellij-jcef-plugin/commit/7df78f33845db89f46e33663967f9c5780cb5dca\">support JsDialog</a></p>\n","categories":[],"tags":["IDEA","Plugins"]},{"title":"程序员微机课系列—我的nodejs多版本管理方法","url":"http://compilemind.com/2021/08/18/2021-08-18-程序员微机课系列-我的nodejs环境配置与使用/","content":"<p>nodejs的多版本配置对于我来说一直都是一个较为头疼的事情。本人的开发工作会涉及electron以及前端，对于工作中使用的npm包（点名node-sqlite3和node-sass）在某些情况下，会使用node-gyp进行原生C/C++模块的编译，此时，nodejs的版本就尤为重要，但是本人又不太愿意使用nvm进行管理，所以总结了一套nodejs多版本管理的指南。</p>\n<a id=\"more\"></a>\n<h1 id=\"非安装二进制包下载\"><a href=\"#非安装二进制包下载\" class=\"headerlink\" title=\"非安装二进制包下载\"></a>非安装二进制包下载</h1><p>为了实现基本的多版本，nodejs二进制包我们都下载非安装版本，而不是安装版：</p>\n<p>下载地址：<a href=\"https://nodejs.org/en/download/\">Download | Node.js (nodejs.org)</a></p>\n<ul>\n<li>node-v12.22.5-win-x64.zip</li>\n<li>node-v14.17.5-win-x64.zip</li>\n</ul>\n<h1 id=\"本地目录配置\"><a href=\"#本地目录配置\" class=\"headerlink\" title=\"本地目录配置\"></a>本地目录配置</h1><p>下载好后，我们选取一个我们经常安装软件的目录，譬如在本人的机器上，我使用<code>D:\\Programes\\</code>来存放我所有的软件。在软件存放目录下创建名为nodejs的文件夹，并且将上述的两个版本的nodejs都按照其版本名称解压：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\Programs\\nodejs</span><br><span class=\"line\">    |-- node-v12.22.5-win-x64</span><br><span class=\"line\">        |-- node.exe</span><br><span class=\"line\">        |-- ...</span><br><span class=\"line\">    |-- node-v14.17.5-win-x64</span><br><span class=\"line\">        |-- node.exe</span><br><span class=\"line\">        |-- ...</span><br></pre></td></tr></table></figure>\n<p>接下来，我们在nodejs文件夹中创建一个文件夹：<code>global_and_cache_files</code>，并在其中创建子目录：</p>\n<ul>\n<li>global_modules：存放node的全局包</li>\n<li>cache_modules：存放npm使用过程的缓存文件</li>\n</ul>\n<p>至此，我们有如下的目录结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\Programs\\nodejs</span><br><span class=\"line\">    |-- node-v12.22.5-win-x64</span><br><span class=\"line\">        |-- ...</span><br><span class=\"line\">    |-- node-v14.17.5-win-x64</span><br><span class=\"line\">        |-- ..</span><br><span class=\"line\">    |-- global_and_cache_files</span><br><span class=\"line\">        |-- global_modules</span><br><span class=\"line\">        |-- cache_modules</span><br></pre></td></tr></table></figure>\n<h1 id=\"npmrc\"><a href=\"#npmrc\" class=\"headerlink\" title=\"npmrc\"></a>npmrc</h1><p>接下来是老生常谈的npmrc配置（用户目录/.npmrc文件）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 国内阿里镜像</span><br><span class=\"line\">registry&#x3D;https:&#x2F;&#x2F;r.npm.taobao.org&#x2F;</span><br><span class=\"line\"># 设置全局包的存放路径（注意此处的路径和上面创建的路径一致）</span><br><span class=\"line\">prefix&#x3D;D:\\Programs\\nodejs\\global_and_cache_files\\global_modules</span><br><span class=\"line\"># 缓存路径（和上面创建的路径一致）</span><br><span class=\"line\">cache&#x3D;D:\\Programs\\nodejs\\global_and_cache_files\\cache_modules</span><br></pre></td></tr></table></figure>\n<h1 id=\"环境变量设置\"><a href=\"#环境变量设置\" class=\"headerlink\" title=\"环境变量设置\"></a>环境变量设置</h1><p>对于环境变量，最基本的就是将node.exe添加到环境变量中：</p>\n<p>这里我分了两步：</p>\n<ol>\n<li>设置<code>NODE_JS_HOME</code>环境变量为上面的某一版本nodejs的路径：<code>D:\\Programs\\nodejs\\node-v14.17.5-win-x64</code></li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-08-18-my-node-env/010-set_NODE_JS_HOME.jpg\" alt=\"\"></p>\n<ol>\n<li>将<code>NODE_JS_HOME</code>环境变量加到Path中。此外，为了之后能够在命令行中使用全局安装的npm包，我们也把对应的全局包安装路径设置到环境变量中：<code>D:\\Programs\\nodejs\\node_global_modules</code></li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-08-18-my-node-env/020-set_env_path.jpg\" alt=\"\"></p>\n<h1 id=\"切换环境\"><a href=\"#切换环境\" class=\"headerlink\" title=\"切换环境\"></a>切换环境</h1><p>在上述的配置下，环境的切换也比较方便。只需要修改对应的<code>NODE_JS_HOME</code>指向的不同版本nodejs的安装路径即可。</p>\n<h2 id=\"环境切换注意点\"><a href=\"#环境切换注意点\" class=\"headerlink\" title=\"环境切换注意点\"></a>环境切换注意点</h2><p>由于缓存和全局安装的npm包会和安装时候的nodejs版本关联，在切换环境后请对全局包进行重新的安装工作。</p>\n<h1 id=\"其他的管理方案\"><a href=\"#其他的管理方案\" class=\"headerlink\" title=\"其他的管理方案\"></a>其他的管理方案</h1><p>实际上，nodejs多版本管理方案还有，只不过这些都需要安装额外的东西，个人不是很喜欢。</p>\n<p><a href=\"https://github.com/coreybutler/nvm-windows\">NVM-Windows</a></p>\n<p><a href=\"https://github.com/nullivex/nodist\">nodist</a></p>\n","categories":[],"tags":["软件"]},{"title":"极简SpringBoot指南-Chapter00-学习SpringBoot前的基本知识","url":"http://compilemind.com/2021/08/10/2021-08-10-极简SpringBoot指南-chapter00-学习SpringBoot前的基本知识/","content":"<h2 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n<h1 id=\"Chapter00-学习SpringBoot前的基本知识\"><a href=\"#Chapter00-学习SpringBoot前的基本知识\" class=\"headerlink\" title=\"Chapter00 学习SpringBoot前的基本知识\"></a>Chapter00 学习SpringBoot前的基本知识</h1><a id=\"more\"></a>\n<h2 id=\"一-反射\"><a href=\"#一-反射\" class=\"headerlink\" title=\"一 反射\"></a>一 反射</h2><p>在Java中，我们可以通过反射（Reflection）来获取任何类的类型信息，其中最值得关注的就是Class类。通过Class类，我们拿到任意对象的相关上下文。</p>\n<p>例如，我们有一个User类，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;User 无参构造函数&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;User 有参构造函数：name = %s, age = %d%n&quot;</span>, name, age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 忽略一堆的getter、setter</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下的代码中，我们可以获取类上的声明的字段和各种方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;User&gt; userClass = User.class;</span><br><span class=\"line\">System.out.println(userClass.getCanonicalName());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 显示声明的字段</span></span><br><span class=\"line\">Field[] fields = userClass.getDeclaredFields();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;该类包含了如下的字段：&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Field field : fields) &#123;</span><br><span class=\"line\">    System.out.println(field);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 显示声明的方法</span></span><br><span class=\"line\">Method[] methods = userClass.getDeclaredMethods();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;该类包含了如下的方法：&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">    System.out.println(method);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，我们同样可以拿到构造函数，并通过反射的方式进行实例创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3. 展示类上的构造函数对象</span></span><br><span class=\"line\">Constructor&lt;?&gt;[] constructors = userClass.getConstructors();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;找到构造函数：&quot;</span> + constructor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 通过无参构造函数创建实例</span></span><br><span class=\"line\">Constructor&lt;?&gt; constructor = userClass.getConstructor();</span><br><span class=\"line\">Object user1 = constructor.newInstance();</span><br><span class=\"line\">System.out.println(user1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 通过有参构造函数创建实例</span></span><br><span class=\"line\"><span class=\"comment\">// 注意有参构造函数获取时，传入了参数的class对象</span></span><br><span class=\"line\"><span class=\"comment\">// 以及在newInstance的时候，需要传入实际的值</span></span><br><span class=\"line\">Constructor&lt;?&gt; constructor1 = userClass.getConstructor(String.class, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">Object user2 = constructor1.newInstance(<span class=\"string\">&quot;Mr.Hello&quot;</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">System.out.println(user2);</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，我们使用代码符号的方式获取的对应类的Class对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;User&gt; userClass = User.class;</span><br></pre></td></tr></table></figure>\n<p>这种情况下，我们必须能拿到User的符号。但更多的情况下，我们并没有类符号，反射允许我们通过类型的名称来进行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; userClass = Class.forName(<span class=\"string\">&quot;com.compilemind.guide.chapter00.manual.User&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>此外，我们还可以拿到类上的注解。首先我们定义一个注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span> <span class=\"comment\">// 放在类型上</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span> <span class=\"comment\">// 运行时保留</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> UserInfo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后给User上添加这个注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UserInfo(name = &quot;annotationName&quot;, age = 99)</span> <span class=\"comment\">// 使用注解</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;User 有参构造函数：name = %s, age = %d%n&quot;</span>, name, age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用反射，我们可以获取注解，并通过注解的方式，创建我们的User对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 获取Class类对象</span></span><br><span class=\"line\">Class&lt;?&gt; userClass = Class.forName(</span><br><span class=\"line\"><span class=\"string\">&quot;com.compilemind.guide.chapter00.manual.User&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 获取类上的 @UserInfo 注解</span></span><br><span class=\"line\">UserInfo userInfo = userClass.getAnnotation(UserInfo.class);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (userInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">System.out.println(userClass.getCanonicalName() + <span class=\"string\">&quot;不包含注解&quot;</span> + UserInfo.class + &quot;，终止创建&quot;);</span><br><span class=\"line\"><span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 获取注解信息</span></span><br><span class=\"line\">String name = userInfo.name();</span><br><span class=\"line\"><span class=\"keyword\">int</span> age = userInfo.age();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 通过有参构造函数，结合注解上的上下文，创建实例</span></span><br><span class=\"line\">Object user = userClass.getConstructor(String.class, <span class=\"keyword\">int</span>.class).newInstance(name, age);</span><br><span class=\"line\">System.out.println(user);</span><br></pre></td></tr></table></figure>\n<p>该部分可以在chapter00.manual包下查看源码。</p>\n<h2 id=\"二-Spring”构造”对象\"><a href=\"#二-Spring”构造”对象\" class=\"headerlink\" title=\"二 Spring”构造”对象\"></a>二 Spring”构造”对象</h2><p>可能读者会疑惑，为什么<code>1.反射</code>和<code>2.Spring&quot;构造&quot;对象</code>会放在一起，实际上Spring的对象构造的底层就是使用反射进行的。接下来，让我们看看Spring中，如何”构造”一个对象。</p>\n<p>编写一个新的示例UserEx：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">// 使用注解，标记该类为一个组件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserEx</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserEx</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;UserEx 无参构造函数&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个UserEx中，我们在类上添加了注解<code>@Component</code>，标记该类为一个<strong>组件</strong>。然后创建一个新的类：<code>IocApp</code>，编写如下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &quot;<span class=\"doctag\">@SpringBootApplication</span>&quot; 标记是一个SpringBoot应用</span></span><br><span class=\"line\"><span class=\"comment\"> * 启动后，SpringBoot框架会去扫描当前包以及子包下（默认情况）的所有具有<span class=\"doctag\">@Component</span>标记的类，</span></span><br><span class=\"line\"><span class=\"comment\"> * 并通过反射的方式创建这个类的实例，存放在Spring的Bean容器中。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span> <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IocApp</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 启动</span></span><br><span class=\"line\">        ConfigurableApplicationContext context =</span><br><span class=\"line\">                SpringApplication.run(IocApp.class, args);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 类符号获取</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通过类符号获取Bean&quot;</span>);</span><br><span class=\"line\">        UserEx userEx = context.getBean(UserEx.class);</span><br><span class=\"line\">        System.out.println(userEx);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 通过Bean的名称获取</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通过类符号获取Bean&quot;</span>);</span><br><span class=\"line\">        UserEx userEx2 = (UserEx) context.getBean(<span class=\"string\">&quot;userEx&quot;</span>);</span><br><span class=\"line\">        System.out.println(userEx2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，在有main函数的类上，添加<code>@SpringBootApplication</code>，标记是一个<strong>SpringBoot</strong>应用。</p>\n<p>接着，我们在main函数中调用<code>SpringApplication.run(IocApp.class, args);</code>来启动这个SpringBoot应用。启动后，SpringBoot框架会去扫描当前包以及子包下（默认情况）的所有具有<code>@Component</code>标记的类，并通过反射的方式创建这个类的实例，存放在Spring的<strong>Bean</strong>容器中。</p>\n<p>最后，我们通过调用<code>ConfigurableApplicationContext.getBean</code>来获取实例并进行打印。在这里，我们使用了两种方式来获取Bean：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传入类符号.class</span></span><br><span class=\"line\">&lt;T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\"><span class=\"comment\">// 传入Bean的名称</span></span><br><span class=\"line\"><span class=\"function\">Object <span class=\"title\">getBean</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure>\n<p>这里简单提一下，Bean的name是有一定的规则。默认情况下，是类名称的小驼峰形式，这里UserEx对应的名称就是userEx；但是我们通过设置注解的name字段：<code>@Component(&quot;myUserEx&quot;)</code>，能够自定义在Bean在容器中的名称。</p>\n<p>看到这里，让我们再次回顾第一节反射中的操作：我们在<code>User</code>类上添加注解<code>@UserInfo</code>，然后通过反射，获取注解的信息，并创建User实例。</p>\n<p>那么现在，各位读者能否将第二节上述的内容，和反射中的操作关联起来呢？如果你能够大致理解我现在讲的含义，那么恭喜你，对于Spring进行对象构建的内部原理你已经有了一个简单的认识。</p>\n<h3 id=\"2-1-IOC控制反转\"><a href=\"#2-1-IOC控制反转\" class=\"headerlink\" title=\"2.1.IOC控制反转\"></a>2.1.IOC控制反转</h3><p>细心的读者已经发现了，在上一节中，我们创建了包含启动代码的类：<code>IocApp</code>。没错，此IOC就是这一节要讲的IOC（Inversion of Control），控制反转。</p>\n<blockquote>\n<p>　　传统的创建对象的方法是直接通过 <strong>new 关键字</strong>，而 spring 则是通过 IOC 容器来创建对象，也就是说我们将创建对象的控制权交给了 IOC 容器。我们可以用一句话来概括 IOC：</p>\n<p>　　<strong>IOC 让程序员不在关注怎么去创建对象，而是关注与对象创建之后的操作，把对象的创建、初始化、销毁等工作交给spring容器来做。</strong></p>\n</blockquote>\n<p>具体结合前面的例子来说，对于UserEx类，<strong>在没有IOC思想的介入下</strong>，我们创建这个UserEx类通常会这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UserEx userEx &#x3D; new UserEx();</span><br><span class=\"line\">&#x2F;&#x2F; ... 使用该实例</span><br></pre></td></tr></table></figure>\n<p>而在Spring IOC框架下，我们做了如下的工作：</p>\n<ol>\n<li>编写UserEx类，标注<code>@Component</code>；</li>\n<li>初始化容器：<code>SpringApplication.run(...)</code>；</li>\n<li>从容器中获取：<code>UserEx userEx = context.getBean(UserEx.class);</code></li>\n</ol>\n<p>看到这里，你也许会想没有IOC的模式下，我只要一行代码，而现在使用了Spring的IOC，多了这么多的配置和操作。难道不是更加的麻烦了吗？对于这个例子，的确是这样的，但是仔细一想，随着项目的体积逐渐增大，越来越多的类实例需要被创建，难道那个时候我们还要如此繁杂的通过new创建一大堆实例吗？另外，IOC容器帮我们做的事情，还远远不止控制反转这一项，依赖注入（dependence injection）也是一个重要的能力。</p>\n<h3 id=\"2-2-DI依赖注入\"><a href=\"#2-2-DI依赖注入\" class=\"headerlink\" title=\"2.2.DI依赖注入\"></a>2.2.DI依赖注入</h3><p>说到依赖注入，我们首先需要明确，在代码中什么是依赖。从互联网上有这样一段对于依赖的定义，我觉得很好：</p>\n<blockquote>\n<p>每个软件，都是由很多“组件”构成的。这里的“组件”是指广义的组件 —— 组成部件，它可能是函数，可能是类，可能是包，也可能是微服务。软件的架构，就是组件以及组件之间的关系。而这些组件之间的关系，就是（广义的）依赖关系。</p>\n</blockquote>\n<p>从狭义来讲，我们定义一个类GameEx，这GameEx包含前文的UserEx，我们就可以认为GameEx依赖UserEx：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GameEx</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserEx userEx; <span class=\"comment\">// GameEx依赖UserEx</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserEx</span><span class=\"params\">(UserEx userEx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userEx = userEx;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;调用setUserEx&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 打印GameEx的UserEx</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printUserEx</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.userEx == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;无用户&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">this</span>.userEx);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述GameEx类中，拥有一个UserEx类型的字段userEx。同时，包含一个名为<code>printUserEx</code>的方法，用以打印UserEx实例。为了<strong>避免</strong>得到输出<code>&quot;无用户&quot;</code>，我们需要在调用该方法前，设置UserEx的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码</span></span><br><span class=\"line\">UserEx userEx = ...; <span class=\"comment\">// 1.通过某种方式，获得的UserEx的实例</span></span><br><span class=\"line\">GameEx gameEx = ...; <span class=\"comment\">// 2.通过某种方式，获得的GameEx的实例</span></span><br><span class=\"line\">gameEx.setUserEx(userEx); <span class=\"comment\">// 3.调用setter方法将UserEx实例设置到GameEx中</span></span><br><span class=\"line\">gameEx.printUserEx(); <span class=\"comment\">// 4.输出: UserEx@xxxx</span></span><br></pre></td></tr></table></figure>\n<p>在上面伪代码的第3步中，我们通过代码的方式手动调用setter函数。这个过程，本质上来讲，<strong>就是我们在控制着依赖</strong>：因为我们明白GameEx的功能依赖于UserEx，所以为了达到预期的目的，我们需要手动进行代码编写，处理这样的依赖。</p>\n<p>让我们再看上述伪代码的中的第1、2步：得到UserEx和GameEx实例。在第2节中，我们已经学会了如何使用Spring的IOC容器创建对象，所以对于GameEx类，我们同样可以增加注解<code>@Component</code>，将GameEx标记为Bean，让Spring的IOC容器管理起来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GameEx</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 其他代码忽略 ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们在IocApp中实现上述的伪代码效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span> <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IocApp</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 启动</span></span><br><span class=\"line\">        ConfigurableApplicationContext context =</span><br><span class=\"line\">                SpringApplication.run(IocApp.class, args);</span><br><span class=\"line\">        manualDependencySet(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 第2.2节伪代码实现：手动进行依赖设置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">manualDependencySet</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">        UserEx userEx = context.getBean(UserEx.class); // <span class=\"number\">1.</span></span><br><span class=\"line\">        GameEx gameEx = context.getBean(GameEx.class); // <span class=\"number\">2.</span></span><br><span class=\"line\">        gameEx.setUserEx(userEx); <span class=\"comment\">// 3.</span></span><br><span class=\"line\">        gameEx.printUserEx(); <span class=\"comment\">// 4.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进行执行后，我们可以从控制台中观察到相关输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UserEx 无参构造函数</span><br><span class=\"line\">&#x2F;&#x2F; 其他log信息</span><br><span class=\"line\">调用setUserEx</span><br><span class=\"line\">com.compilemind.guide.chapter00.spring.UserEx@5300f14a</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，我们手动进行了依赖的管理，那么Spring的IOC容器是否可以帮助我们去管理依赖吗？答案是肯定的。我们只需要在需要注入依赖字段的setter方法上（后面会介绍其他的方式），加上<code>@Autowired</code>注解即可实现这样的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GameEx</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserEx userEx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">// 使用注解 @Autowired，表明希望IOC容器为我们注入这个UserEx的实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserEx</span><span class=\"params\">(UserEx userEx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userEx = userEx;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;调用setUserEx&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 忽略其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，我们不再需要分别从IOC容器中获取UserEx和GameEx来手动设置依赖，因为SpringIOC容器已经帮助我们完成了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span> <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IocApp</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 启动</span></span><br><span class=\"line\">        ConfigurableApplicationContext context =</span><br><span class=\"line\">                SpringApplication.run(IocApp.class, args);</span><br><span class=\"line\">        dependencyInject(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 不再需要手工设置了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dependencyInject</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">        GameEx gameEx = context.getBean(GameEx.class);</span><br><span class=\"line\">        gameEx.printUserEx();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后的输出与上面手动设置依赖是相同。</p>\n<h2 id=\"本章总结\"><a href=\"#本章总结\" class=\"headerlink\" title=\"本章总结\"></a>本章总结</h2><p>在本章中，我们了解了Java中关于反射的一些基础知识，了解了如何通过反射而不是new的形式创建对象。在此基础上，我们介绍了Spring IOC容器，让大家明白了Spring IOC底层的基本原理。最后，我们介绍了IOC控制反转以及DI依赖注入的概念，并用Spring框架演示了这些概念。在下一章，我们将介绍使用SpringIOC容器来创建Bean的几种方式。</p>\n<h2 id=\"仓库地址-1\"><a href=\"#仓库地址-1\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n","categories":[],"tags":["Java","SpringBoot"]},{"title":"极简SpringBoot指南-Chapter02-Spring依赖注入的方式","url":"http://compilemind.com/2021/08/10/2021-08-10-极简SpringBoot指南-chapter02-Spring依赖注入的方式/","content":"<h2 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n<h1 id=\"Chapter02-Spring依赖注入的方式\"><a href=\"#Chapter02-Spring依赖注入的方式\" class=\"headerlink\" title=\"Chapter02-Spring依赖注入的方式\"></a>Chapter02-Spring依赖注入的方式</h1><a id=\"more\"></a>\n<p>我们在<strong>Chapter00—2.2节依赖注入</strong>已经介绍了Spring的对象依赖注入的方式，在那个例子中，我们使用了字段的setter方法对字段进行了注入。在本章中，我们将介绍对象依赖注入的另外的方式，并提到一些关于依赖注入的注意点。</p>\n<p>大致来说，依赖注入分为三种：</p>\n<ol>\n<li>属性setter方法注入</li>\n<li>字段注入</li>\n<li>构造函数注入</li>\n</ol>\n<p>为了 接下来的示例做准备，我们按照如下的代码结构顺序编写：</p>\n<ol>\n<li>编写类Pen，表示一个笔类Pen</li>\n<li>编写类Box，表示一个用于装Pen的盒子类Box</li>\n<li>编写相关配置注入的代码</li>\n<li>使用Spring验证代码注入</li>\n</ol>\n<p>OK，首先编写类Pen做准备：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pen</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Pen 无参构造函数&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于该类，我们使用<code>@Component</code>将其标记为Bean（PS：这里为了本章的主题，我们就不使用上一章的配置类和XML来声明了）。</p>\n<h2 id=\"一-属性setter方法注入\"><a href=\"#一-属性setter方法注入\" class=\"headerlink\" title=\"一 属性setter方法注入\"></a>一 属性setter方法注入</h2><p>编写类BoxA类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoxA</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Pen pen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 我们在属性setter方法上，使用@Autowire注解</span></span><br><span class=\"line\">    <span class=\"comment\">// 目的是希望Spring容器框架能够让帮助我们注入该属性</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPen</span><span class=\"params\">(Pen pen)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pen = pen;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;setter函数注入：&quot;</span> + pen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printPen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(pen == <span class=\"keyword\">null</span> ? <span class=\"string\">&quot;BoxA没有Pen&quot;</span> : <span class=\"string\">&quot;BoxA有Pen：&quot;</span> + pen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于该BoxA类，我们同样使用<code>@Component</code>标记为了Bean。此外，我们为其添加了Pen类型的字段pen，并编写了setter方法。在该方法上，我们添加了<code>@Autowired</code>注解，表明我们希望类型为Pen的属性pen能够由Spring为我们注入进来。</p>\n<p>那么现在有一个问题，这个Pen的实例，是怎么来的呢？不难思考出来，就是我们一开头准备的<code>@Component Pen</code>。</p>\n<p>接下来编写验证代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chapter02App</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ConfigurableApplicationContext context =</span><br><span class=\"line\">                SpringApplication.run(Chapter02App.class, args);</span><br><span class=\"line\">        <span class=\"comment\">// 我们只获取了BoxA的实例</span></span><br><span class=\"line\">        Object boxA = context.getBean(<span class=\"string\">&quot;boxA&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (boxA <span class=\"keyword\">instanceof</span> BoxA) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;BoxA实例：&quot;</span> + box);</span><br><span class=\"line\">            ((BoxA) boxA).printPen(); <span class=\"comment\">// 却能够正确打印Pen实例</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-构造函数注入\"><a href=\"#二-构造函数注入\" class=\"headerlink\" title=\"二 构造函数注入\"></a>二 构造函数注入</h2><p>编写BoxB类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoxB</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Pen pen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在构造函数上添加@Autowired注解，并且构造函数入参有Pen</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BoxB</span><span class=\"params\">(Pen pen)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pen = pen;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;BoxB 有参构造函数，注入Pen实例：&quot;</span> + pen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printPen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(pen == <span class=\"keyword\">null</span> ? <span class=\"string\">&quot;BoxB没有Pen&quot;</span> : <span class=\"string\">&quot;BoxB有Pen：&quot;</span> + pen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于该类，我们同样拥有Pen类型字段pen，但和setter方法注入不同的是，我们没有编写setter方法，而是显式编写了BoxB的构造函数，并且构造函数的入参就是Pen类的实例，然后在该构造函数上也同样添加了注解<code>@Autowired</code>。其意图其实和setter方法注入相同，都是希望Spring框架能够帮我们进行依赖注入。</p>\n<p>对于验证的代码，我们只需要稍微修改以下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chapter02App</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ConfigurableApplicationContext context =</span><br><span class=\"line\">                SpringApplication.run(Chapter02App.class, args);</span><br><span class=\"line\">        <span class=\"comment\">// 我们只获取了BoxB的实例</span></span><br><span class=\"line\">        Object boxB = context.getBean(<span class=\"string\">&quot;boxB&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (boxB <span class=\"keyword\">instanceof</span> BoxB) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;BoxB实例：&quot;</span> + boxB);</span><br><span class=\"line\">            ((BoxB) boxB).printPen(); <span class=\"comment\">// BoxB 能够正确打印Pen实例</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-字段注入\"><a href=\"#三-字段注入\" class=\"headerlink\" title=\"三 字段注入\"></a>三 字段注入</h2><p>对于字段注入来说，就更简单了，BoxC：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoxC</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Pen pen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printPen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(pen == <span class=\"keyword\">null</span> ? <span class=\"string\">&quot;BoxC没有Pen&quot;</span> : <span class=\"string\">&quot;BoxC有Pen：&quot;</span> + pen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>没有构造函数，没有setter方法，只有<del>无尽的怒火</del>字段，然后字段上添加<code>@Autowired</code>注解。验证代码同上，不再赘述。</p>\n<p>字段注入比起另外的两种两种方式简单的多，可能绝大多数的项目都会用这个字段，但本人将<strong>字段注入</strong>放在了第三个来讲，还是希望说一下字段注入的问题点。使用IDEA同学可能已经看到了，IDEA会提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field injection is not recommended </span><br><span class=\"line\">不推荐使用字段注入</span><br></pre></td></tr></table></figure>\n<p>字段注入这么方便，为什么说不推荐呢？主要有以下几点：</p>\n<ol>\n<li>基于字段的依赖注入在声明为final的字段上不起作用。</li>\n<li>会与SpringIOC容器框架紧密耦合。因为private字段的原因，想要编写单元测试，就必须依赖Spring测试框架，否则你无法手动注入（除了使用反射，但是那样不久太麻烦了吗？）。</li>\n</ol>\n<p>字段注入的问题还有其他的问题，可以自行搜索：Spring不推荐字段注入。</p>\n<p>当然，如果一个项目自始自终都是在Spring框架中运行，也没有所谓的需要脱离Spring框架的地方，字段注入也并非不可。</p>\n<h2 id=\"扩展阅读：依赖注入的注意点\"><a href=\"#扩展阅读：依赖注入的注意点\" class=\"headerlink\" title=\"扩展阅读：依赖注入的注意点\"></a>扩展阅读：依赖注入的注意点</h2><p>我们在上文已经提到了三种依赖注入的方式。那么读者有没有想过依赖注入需要注意什么呢？</p>\n<p>编写类TestA、TestB：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TestA类</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestA</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字段注入</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestB testB;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printTestB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;printTestB: &quot;</span> + <span class=\"keyword\">this</span>.testB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// TestB类</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestB</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestA testA;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printTestA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;printTestA: &quot;</span> + <span class=\"keyword\">this</span>.testA);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意TestA类与TestB类相互以字段注入的方式注入到了另一个类中。接着我们编写测试代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chapter01CycleTestApp</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ConfigurableApplicationContext context =</span><br><span class=\"line\">                SpringApplication.run(Chapter01CycleTestApp.class, args);</span><br><span class=\"line\">        TestA testA = context.getBean(TestA.class);</span><br><span class=\"line\">        TestB testB = context.getBean(TestB.class);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;从容器中获取的TestA实例：&quot;</span> + testA);</span><br><span class=\"line\">        testA.printTestB();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;从容器中获取的TestB实例：&quot;</span> + testB);</span><br><span class=\"line\">        testB.printTestA();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么，测试代码能够正常运行呢？思考一下，我们似乎陷入了循环依赖的场景了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Spring容器创建TestA实例 -&gt; 发现需要注入TestB实例 -&gt; 创建TestB实例 -&gt; 发现需要注入实例TestA -&gt; 创建TestA实例 -&gt; ... </span><br></pre></td></tr></table></figure>\n<p>似乎陷入了一直循环的情景。可是实际运行的时候，却正确输出了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">从容器中获取的TestA实例：TestA@4248ed58</span><br><span class=\"line\">printTestB: TestB@712ca57b</span><br><span class=\"line\">从容器中获取的TestB实例：TestB@712ca57b</span><br><span class=\"line\">printTestA: TestA@4248ed58</span><br><span class=\"line\"></span><br><span class=\"line\">PS: 为了简洁的显示，我删去了包名</span><br></pre></td></tr></table></figure>\n<p>为什么会这样呢？实际上，Spring在初始化Bean的时候，并不是傻乎乎的按照上述的逻辑进行的，而是按照如下的大致流程：</p>\n<ol>\n<li>准备创建TestA实例</li>\n<li>发现TestA依赖TestB</li>\n<li>查找TestB实例未果</li>\n<li>先继续创建TestA实例，但是<strong>内部会标记该类实际还未注入依赖</strong></li>\n<li>准备创建TestB实例</li>\n<li>发现TestB实例依赖TestA实例</li>\n<li>查找TestA实例成功（只不过目前还没注入依赖而已），注入</li>\n<li>扫描所有还未完全完成初始化的Bean，发现TestA还未注入依赖TestB</li>\n<li>再次检查发现TestB已经有了，将其注入到TestA中</li>\n</ol>\n<p>当然，这里只是简单的梳理一个流程，在Spring内部是很复杂的。</p>\n<p>那么现在再来思考另外一个相互依赖注入的情况：构造函数注入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TestA 构造函数注入</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestA</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字段注入</span></span><br><span class=\"line\"><span class=\"comment\">//    @Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestB testB;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestA</span><span class=\"params\">(TestB testB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.testB = testB;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printTestB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;printTestB: &quot;</span> + <span class=\"keyword\">this</span>.testB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// TestB构造函数注入</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestB</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    @Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestA testA;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数注入</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestB</span><span class=\"params\">(TestA testA)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.testA = testA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printTestA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;printTestA: &quot;</span> + <span class=\"keyword\">this</span>.testA);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>现在我们通过构造函数注入，执行测试代码看看会发生什么：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The dependencies of some of the beans in the application context form a cycle:</span><br><span class=\"line\"></span><br><span class=\"line\">┌─────┐</span><br><span class=\"line\">|  testA defined in file [xxx\\chapter02\\cycle\\TestA.class]</span><br><span class=\"line\">↑     ↓</span><br><span class=\"line\">|  testB defined in file [xxx\\chapter02\\cycle\\TestB.class]</span><br><span class=\"line\">└─────┘</span><br></pre></td></tr></table></figure>\n<p>”当前应用程序中某些beans出现了循环依赖“。至于原因，请搜索关键词：<code>Spring构造函数注入与setter注入</code></p>\n<h2 id=\"本章小结\"><a href=\"#本章小结\" class=\"headerlink\" title=\"本章小结\"></a>本章小结</h2><p>在本章中，我们了解了Spring依赖注入的三种方式，并提到了循环依赖在不同注入方式下的区别。</p>\n<p>至此，关于学习SpringBoot前的需要有的知识我们算是完成了一个简单的介绍的，接下来的文章将会基于SpringBoot框架，构建我们的Web服务。</p>\n<h2 id=\"仓库地址-1\"><a href=\"#仓库地址-1\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n","categories":[],"tags":["Java","SpringBoot"]},{"title":"极简SpringBoot指南-Chapter01-如何用Spring框架声明Bean","url":"http://compilemind.com/2021/08/10/2021-08-10-极简SpringBoot指南-chapter01-如何用Spring框架声明Bean/","content":"<h2 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n<h1 id=\"Chapter01-如何用Spring框架声明Bean\"><a href=\"#Chapter01-如何用Spring框架声明Bean\" class=\"headerlink\" title=\"Chapter01-如何用Spring框架声明Bean\"></a>Chapter01-如何用Spring框架声明Bean</h1><a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在上一章中，我们已经掌握了Spring最基本的使用方式：</p>\n<ol>\n<li>通过使用<code>@Component</code>注解标记我们的类作为一个Bean组件。</li>\n<li>使用Spring上下文对象从IOC容器中拿到Bean组件。</li>\n</ol>\n<p>在这一章中，我们将进一步学习使用Spring框架声明Bean的三种方式：</p>\n<ol>\n<li><code>@Component</code>注解</li>\n<li>XML配置声明</li>\n<li>Java类配置声明（<code>@Configuration</code>）</li>\n</ol>\n<p><em>PS：Spring声明Bean的方式不止这三种，请自行搜索了解：Spring声明Bean的方式。</em></p>\n<h2 id=\"一-使用-Component注解\"><a href=\"#一-使用-Component注解\" class=\"headerlink\" title=\"一 使用@Component注解\"></a>一 使用<code>@Component</code>注解</h2><p><code>@Component</code>注解我们已经很熟悉了，这里还是需要简单提一下。创建类Apple：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用注解 @Component 标记，并且我们还自定义了Bean的名称</span></span><br><span class=\"line\"><span class=\"meta\">@Component(&quot;myApple&quot;)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Apple</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Apple 无参构造函数&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取并打印：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chapter01App</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ConfigurableApplicationContext context =</span><br><span class=\"line\">                SpringApplication.run(Chapter01App.class, args);</span><br><span class=\"line\">        <span class=\"comment\">// 注意BeanName我们填写的&quot;myApple&quot;，和 @Component(&quot;myApple&quot;) 对应</span></span><br><span class=\"line\">        Object myApple = context.getBean(<span class=\"string\">&quot;myApple&quot;</span>);</span><br><span class=\"line\">        System.out.println(myApple);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-Java类配置声明\"><a href=\"#二-Java类配置声明\" class=\"headerlink\" title=\"二 Java类配置声明\"></a>二 Java类配置声明</h2><p>Java类配置声明是指，我们使用某个Java作为Spring的配置，通过Java代码本身来定义Bean。这样做的好处我们后文会提到。</p>\n<p>首先编写我们的Bean类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Banana类，不需要使用任何注解</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Banana</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Banana</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Banana 无参构造函数&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们编写一个<strong>配置类</strong>，其特征是在类上有注解<code>@Configuration</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span> <span class=\"comment\">// 添加注解表明是一个Spring配置类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chapter01Configuration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span> <span class=\"comment\">// 使用&#x27;@Bean&#x27;在方法上，表明我们声明了一个Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Banana <span class=\"title\">myBanana</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 方法名即为Bean的名称</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;进入Banana Bean创建函数&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Banana();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，我们在启动类上添加注入，表明扫描该配置类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;@Import&#x27; 注解用于指定我们需要的配置类</span></span><br><span class=\"line\"><span class=\"comment\">// 默认情况下，会自动扫描当前启动类所在包及其子包的Configuration，</span></span><br><span class=\"line\"><span class=\"comment\">// 所以不需要特别指定，这里主要是演示</span></span><br><span class=\"line\"><span class=\"meta\">@Import(Chapter01Configuration.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chapter01App</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ConfigurableApplicationContext context =</span><br><span class=\"line\">                SpringApplication.run(Chapter01App.class, args);</span><br><span class=\"line\">        Object myBanana = context.getBean(<span class=\"string\">&quot;myBanana&quot;</span>);</span><br><span class=\"line\">        System.out.println(myBanana);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，各位读者可能会比较绕，这里再整理以下思路。</p>\n<p>首先，我们创建了一个普普通通的Java类Banana，对于这个类，我们没有用到任何有关Spring框架的东西。</p>\n<p>其次，我们创建了一个配置类Chapter01Configuration，通过类名我们知道，Spring对于配置类的名称没有任何的限制，只要是合法的都行。这个类与Spring框架唯一的联系就是使用了注解<code>@Configuration</code>，意味着我们标记了这个类为一个Spring的配置类。</p>\n<p>那么配置类能干什么呢？就是我们第三步的操作：我们在配置类中编写了一个方法<code>public Banana myBanana();</code>，并且在其方法上使用了注解<code>@Bean</code>，通过该注解，表明我们定义了一个Bean，这个Bean的名称就是方法名”myBanana”，这个Bean的类型就是Banana。</p>\n<h2 id=\"三-XML配置声明Bean（选读）\"><a href=\"#三-XML配置声明Bean（选读）\" class=\"headerlink\" title=\"三 XML配置声明Bean（选读）\"></a>三 XML配置声明Bean（选读）</h2><p>还记得上面的我们通过注解的形式来声明我们的Bean吗？实际上，初期的Spring的IOC容器的初始化，是通过配置文件进行的，尽管如今Spring以及SpringBoot项目绝大多数情况都使用的是<strong>注解方式</strong>以及<strong>Java类配置</strong>，但是使用XML的配置方式，我也希望大家能够了解。</p>\n<p>首先，我们依然创建一个普通的Java类Coconut：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Coconut</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义字段：重量，可以通过下面的getter和setter获取和设置该值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Coconut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Coconut 无参构造函数&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWeight</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这个类可以看到，我们没有使用任何的有关Spring相关的注解（尤其是<code>@Component</code>注解），但是注意，这个类我们稍微添加了些内容，增加了一个字段weight，用于记录Coconut的重量。那么接下来，Spring的IOC容器，如何初始化我们的Coconut实例呢？只需两步：</p>\n<ol>\n<li>创建一个xml文件，在xml文件中，使用Spring框架约定的格式定义Bean</li>\n<li>在启动类上，指定Spring框架加载该xml</li>\n</ol>\n<p><strong>首先我们看步骤1，创建xml文件。</strong>在<code>项目目录/src/main/resources</code>目录下，创建任意自定义的名称的XML文件，为了便于我们识别，本人创建的是：<code>chapter01_03_use_xml_beans.xml</code>，初始内容下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>PS：使用IDEA的时候，可以在相关文件夹上<code>右键 — New — XML Configuration File — Spring Config</code>来快速创建具有初始内容的xml。</em></p>\n<p>可以看到xml初始内容的根节点<code>&lt;beans&gt;</code>就可以猜测到我们可以在其中添加子节点<code>&lt;bean&gt;</code>。OK，我们来定义我们的bean：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义了一个Bean，名称是myCoconut --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;myCoconut&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.compilemind.guide.chapter01._03_use_xml.Coconut&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 对于Coconut的weight属性，我们设置它的初始值100 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;weight&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其实，通过xml，我认为不需要赘述什么。我们首先使用节点<code>&lt;bean&gt;</code>来定义我们的Bean，指明了他的name，以及他是由哪个类来创建的。并且，我们还在其子节点<code>&lt;propertiy&gt;</code>定义了Coconut的weight的初始值。</p>\n<p>现在，我们已经通过xml，配置好了我们的Bean。怎么让Spring框架识别并初始化我们的Bean呢？很简单，只需要使用<code>@ImportResource</code>来配置我们要加载的xml是哪个即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;@ImportResource&#x27; 注解用于加载我们指定的xml配置</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource(&quot;classpath:chapter01_03_use_xml_beans.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chapter01App</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ConfigurableApplicationContext context =</span><br><span class=\"line\">                SpringApplication.run(Chapter01App.class, args);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\tObject myCoconut = context.getBean(<span class=\"string\">&quot;myCoconut&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (myCoconut <span class=\"keyword\">instanceof</span> Coconut) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> weight = ((Coconut) myCoconut).getWeight();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Coconut重量是：&quot;</span> + weight);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>PS：对于<code>classpath:xxx</code>的知识点，请自行了解，搜索关键字：<code>Spring classpath</code>。</em></p>\n<h2 id=\"仓库地址-1\"><a href=\"#仓库地址-1\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n","categories":[],"tags":["Java","SpringBoot"]},{"title":"极简SpringBoot指南-Chapter04-基于SpringBoot的书籍管理Web服务","url":"http://compilemind.com/2021/08/10/2021-08-10-极简SpringBoot指南-chapter04-基于SpringBoot的书籍管理Web服务/","content":"<h2 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n<h1 id=\"Chapter04-基于SpringBoot的书籍管理Web服务\"><a href=\"#Chapter04-基于SpringBoot的书籍管理Web服务\" class=\"headerlink\" title=\"Chapter04-基于SpringBoot的书籍管理Web服务\"></a>Chapter04-基于SpringBoot的书籍管理Web服务</h1><a id=\"more\"></a>\n<p>从本章开始，我们将会基于SpringBoot框架，来编写一块书籍管理的应用。为了契合我们的简单教程原则，项目不会出现复杂的结构，只会有一个通用的结构。</p>\n<h2 id=\"初始结构\"><a href=\"#初始结构\" class=\"headerlink\" title=\"初始结构\"></a>初始结构</h2><p>我们项目的初始结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base-package</span><br><span class=\"line\">    |-- controller</span><br><span class=\"line\">        |-- BookController.class</span><br><span class=\"line\">    |-- model</span><br><span class=\"line\">        |-- Book.class</span><br><span class=\"line\">    BookManagementSystemApp.class</span><br></pre></td></tr></table></figure>\n<h2 id=\"Book类\"><a href=\"#Book类\" class=\"headerlink\" title=\"Book类\"></a>Book类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 书籍ID</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 书籍名称</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 书籍价格</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> price;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPrice</span><span class=\"params\">(<span class=\"keyword\">double</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"BookController类\"><a href=\"#BookController类\" class=\"headerlink\" title=\"BookController类\"></a>BookController类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;books&quot;)</span> <span class=\"comment\">// url：&quot;books&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Book&gt; bookList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     * 内部进行bookList初始化操作，便于下面的测试</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BookController</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bookList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(count);</span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>; idx &lt; count; idx++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\">            book.setId(Integer.toString(idx));</span><br><span class=\"line\">            book.setName(<span class=\"string\">&quot;book@&quot;</span> + idx);</span><br><span class=\"line\">            book.setPrice(random.nextInt(<span class=\"number\">100</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.bookList.add(book);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * GET /books</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回所有的书籍信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Book&gt; <span class=\"title\">getBookList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bookList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * GET /books/&#123;id&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据书籍ID，得到对应的书籍信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> id 书籍ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 书籍</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Book <span class=\"title\">getBookById</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class=\"line\">        Optional&lt;Book&gt; first = <span class=\"keyword\">this</span>.bookList</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .filter(b -&gt; b.getId().equals(id))</span><br><span class=\"line\">                .findFirst();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first.orElse(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * POST /books</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加书籍信息</span></span><br><span class=\"line\"><span class=\"comment\">     * 需要注意的是，入参Book需要添加注解<span class=\"doctag\">@RequestBody</span>，才能通过HTTP JSON形式传入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> book 希望新增的书籍信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> Book book)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (book == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;请求数据book为空，未进行添加&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 服务端生成ID</span></span><br><span class=\"line\">        String nextId = Integer.toString(<span class=\"keyword\">this</span>.bookList.size());</span><br><span class=\"line\">        book.setId(nextId);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bookList.add(book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * PUT /books/&#123;id&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * 更新指定ID书籍的信息，</span></span><br><span class=\"line\"><span class=\"comment\">     * 需要注意的是，入参Book需要添加注解<span class=\"doctag\">@RequestBody</span>，才能通过HTTP JSON形式传入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> id 希望更新的书籍信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> book 希望更新的书籍信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateBook</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> String id, <span class=\"meta\">@RequestBody</span> Book book)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (book == <span class=\"keyword\">null</span> || id == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;请求数据book为空或指定书籍id为空，终止更新&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Optional&lt;Book&gt; first = <span class=\"keyword\">this</span>.bookList</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .filter(b -&gt; b.getId().equals(id))</span><br><span class=\"line\">                .findFirst();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.isPresent()) &#123;</span><br><span class=\"line\">            Book exist = first.get();</span><br><span class=\"line\">            exist.setName(book.getName());</span><br><span class=\"line\">            exist.setPrice(book.getPrice());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * DELETE /books/&#123;id&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据书籍ID删除对应的书籍信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> id 待删除的书籍ID</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteBook</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id == <span class=\"keyword\">null</span> || id.trim().equals(<span class=\"string\">&quot;&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Optional&lt;Book&gt; existBook = <span class=\"keyword\">this</span>.bookList</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .filter(b -&gt; b.getId().equals(id))</span><br><span class=\"line\">                .findFirst();</span><br><span class=\"line\">        existBook.ifPresent(<span class=\"keyword\">this</span>.bookList::remove);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于该Controller，我们添加了如下的5个API：</p>\n<ul>\n<li>获取所有的书籍信息（GET /books）</li>\n<li>获取指定ID的书籍信息（GET /books/{id}）</li>\n<li>增加书籍信息（POST /books）</li>\n<li>更新书籍信息（PUT /books/{id}）</li>\n<li>删除指定ID书籍信息（DELETE /books/{id}）</li>\n</ul>\n<p>对于URL的定义形式，我们采用了REST ful规范：<a href=\"http://www.restfulapi.nl/\"><a href=\"https://restfulapi.cn/\">RESTful API 一种流行的 API 设计风格</a></a>。</p>\n<h2 id=\"Web应用启动\"><a href=\"#Web应用启动\" class=\"headerlink\" title=\"Web应用启动\"></a>Web应用启动</h2><p>最后，我们编写一个启动类启动我们的书籍管理Web服务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookManagementSystemApp</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(BookManagementSystemApp.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"功能验证\"><a href=\"#功能验证\" class=\"headerlink\" title=\"功能验证\"></a>功能验证</h2><p>通过postman等HTTP API工具，我们可以轻松的验证我们的API的正确性。本人也把该处的postman调用文件导出存放在了项目/guide/postman/目录下，同学可以用postman导入使用。</p>\n<h2 id=\"仓库地址-1\"><a href=\"#仓库地址-1\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n","categories":[],"tags":["Java","SpringBoot"]},{"title":"极简SpringBoot指南-Chapter03-基于SpringBoot的Web服务","url":"http://compilemind.com/2021/08/10/2021-08-10-极简SpringBoot指南-chapter03-基于SpringBoot的Web服务/","content":"<h2 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n<h1 id=\"Chapter03-基于SpringBoot的Web服务\"><a href=\"#Chapter03-基于SpringBoot的Web服务\" class=\"headerlink\" title=\"Chapter03-基于SpringBoot的Web服务\"></a>Chapter03-基于SpringBoot的Web服务</h1><a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>终于，我们的教程来到了SpringBoot核心功能的介绍。对于本章，各位读者至少具备以下的知识：</p>\n<ol>\n<li>maven的使用</li>\n<li>HTTP</li>\n</ol>\n<h2 id=\"SpringBoot的maven配置介绍\"><a href=\"#SpringBoot的maven配置介绍\" class=\"headerlink\" title=\"SpringBoot的maven配置介绍\"></a>SpringBoot的maven配置介绍</h2><p>对于一个<strong>简单的maven结构</strong>的项目来说，以下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;basedir&#125;</span><br><span class=\"line\">    |-- pom.xml</span><br><span class=\"line\">    |-- src</span><br><span class=\"line\">        |-- main</span><br><span class=\"line\">            |-- java</span><br><span class=\"line\">                || com.xxx.xxx 项目源码</span><br><span class=\"line\">            |-- resources</span><br><span class=\"line\">                || 项目配置文件 .xml等</span><br><span class=\"line\">        |-- test</span><br><span class=\"line\">            |-- java</span><br><span class=\"line\">            |-- resources</span><br></pre></td></tr></table></figure>\n<p>在我们前面的教程中，我们都是在编写着代码，从未关注过maven的pom.xml究竟是如何配置的，因为项目脚手架已经配置完成了，也许有细心的同学已经看过了pom.xml文件的内容了：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- ... 省略了当前项目本身信息的配置，如有需要，请读者查看源码 --&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 当前pom的父级 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.5.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">relativePath</span>/&gt;</span> <span class=\"comment\">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- springboot框架web功能starter --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- springboot框架的测试依赖starter --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 构建流程使用SpringBoot的maven插件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对于一个普通的maven项目，其实核心的就是<code>dependencies节点-dependency节点</code>了。通过<code>dependency</code>节点，我们可以GAV坐标（Group-Artifact-Version）引入不同的库jar包，便于我们的项目使用这些库。</p>\n<p>那么为什么在上面的pom出现了一个parent节点呢？实际上，pom允许所谓的继承：我们可以把一堆的pom依赖和配置，放到一个公共的pom里面，然后各个项目通过parent节点去引用这个公共的pom文件。由于SpringBoot并不是一个单一的jar包构成的框架，它的内部其实依赖了下面的核心库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring-core</span><br><span class=\"line\">spring-beans</span><br><span class=\"line\">spring-context</span><br><span class=\"line\">...还有很多</span><br></pre></td></tr></table></figure>\n<p>如果手动一项又一项编写dependency来使用Spring框架，不仅仅容易遗漏，而且十分不方便进行这些依赖库的版本管理。基于此，SpringBoot官方提供了父级pom：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.5.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span> <span class=\"comment\">&lt;!-- 2021/08/09最新 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">relativePath</span>/&gt;</span> <span class=\"comment\">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>那么再看我们的pom文件中，还依赖了<code>spring-boot-starter-web</code>，这又是什么呢？难道有一个jar包叫做<code>spring-boot-starter-web</code>吗？其实不然。我们上面提到了parent POM，但是Spring框架下的依赖包特别多，并且有些包是核心的包，有些包则是在某些功能需要的情况下才依赖的包。如果一股脑的全部通过parent引入会让你的项目依赖十分臃肿，所以Spring官方再次按照包的功能进行了一定的组合，形成了所谓的starter，如果你只是想做web API的服务开发，用<code>spring-boot-starter-web</code>就可以了，要是需要使用AOP（面向切面编程，作切面开发），加上<code>spring-boot-starter-aop</code>依赖即可。</p>\n<h2 id=\"一个简单的Controller\"><a href=\"#一个简单的Controller\" class=\"headerlink\" title=\"一个简单的Controller\"></a>一个简单的Controller</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用注解 @RestController，表明当前类是一个基于REST 规范的HTTP API Controller</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span> </span><br><span class=\"line\"><span class=\"comment\">// @RequestMapping 注解放在Controller上，用于标记 HTTP url的路径入口，</span></span><br><span class=\"line\"><span class=\"comment\">// 例如 http://localhost:8080/hello/xxx 才会进入当前Controller</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;hello&quot;)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// @RequestMapping 注解放在Controller的里面的方法上，</span></span><br><span class=\"line\">    <span class=\"comment\">// 将会与Controller上的RequestMapping组合成：&quot;/hello/say&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// method用于指示通过何种HTTP方法访问</span></span><br><span class=\"line\">    <span class=\"comment\">// 在程序启动后，我们可以使用GET方法访问：http://localhost:8080/hello/say</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = &quot;say&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello, world&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写启动类，启动我们的SpringBoot程序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chapter03App</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Chapter03App.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动成功后，通过HTTP访问：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;localhost:8080&#x2F;hello&#x2F;say</span><br><span class=\"line\"># 输出：hello, world</span><br></pre></td></tr></table></figure>\n<h2 id=\"关于Controller需要注意的点\"><a href=\"#关于Controller需要注意的点\" class=\"headerlink\" title=\"关于Controller需要注意的点\"></a>关于Controller需要注意的点</h2><p>上面的例子中，我们使用注解<code>@RestController</code>来标记了我们的Controller类，会有初学者使用<code>@Controller</code>来标记Controller，让我们改成它试试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span> <span class=\"comment\">// 改成使用 @Controller注解，其他不变，再次访问，看看有什么问题</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;hello&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloController</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启启动应用后再次访问对应地址。如果是在浏览器中，你会看到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Whitelabel Error Page</span><br><span class=\"line\">This application has no explicit mapping for &#x2F;error, so you are seeing this as a fallback.</span><br><span class=\"line\"></span><br><span class=\"line\">Mon Aug 09 10:16:59 CST 2021</span><br><span class=\"line\">There was an unexpected error (type&#x3D;Not Found, status&#x3D;404).</span><br></pre></td></tr></table></figure>\n<p><code>type=Not Found, status=404</code>，404！为什么会这样呢？</p>\n<ol>\n<li>如果使用<code>@Controller</code>标记，那么将使用SpringMVC架构（自行了解），如果对应的方法返回的是字符串，则这个字符串表明需要查找对应的视图（View）名称，并将对应的视图通过视图解析器（InternalResourceViewResolver）解析修改为前端web页面。</li>\n<li>如果使用<code>@RestController</code>注解Controller，则Controller中的方法无法返回jsp页面，或者html，配置的视图解析器不起作用，返回的内容就是return里的内容。</li>\n</ol>\n<p>针对情况1，解决方法就是在方法的返回上加上注解：<code>@ResponseBody</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ResponseBody</span> <span class=\"comment\">// 如果当前Controller被@Controller注解，又想返回字符串或其他原始数据</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(value = &quot;say&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello, world&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Controller如何被加载的？\"><a href=\"#Controller如何被加载的？\" class=\"headerlink\" title=\"Controller如何被加载的？\"></a>Controller如何被加载的？</h2><p>在之前的文章，我们已经介绍了SpringBoot是如何初始化Bean并且将其放在IOC容器的。我们提到了三种方式：1、<code>@Component</code>；2、Java配置类；3、XML配置。对于第2、3点，好像目前我们的样例中并没有做手动配置的事情。那么是不是我们的Controller已经被<code>@Component</code>标记了呢？</p>\n<p>查看@RestController的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Controller</span> <span class=\"comment\">// 原来你RestController也是一个Controller注解啊！</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span> <span class=\"comment\">// 并且，已经添加了@ResponseBody</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RestController &#123;</span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(</span></span><br><span class=\"line\"><span class=\"meta\">        annotation = Controller.class</span></span><br><span class=\"line\"><span class=\"meta\">    )</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@RestController</code>其实组合了<code>@Controller</code>和<code>@ResponseBody</code>两个注解了。我们再看看<code>@Controller</code>的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">// 原来你Controller注解也组合了Component注解</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Controller &#123;</span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(</span></span><br><span class=\"line\"><span class=\"meta\">        annotation = Component.class</span></span><br><span class=\"line\"><span class=\"meta\">    )</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原来<code>@Controller</code>也已经组合了<code>@Component</code>注解啊，难怪我们的定义的Controller能被加载。</p>\n<h2 id=\"Controller如何处理HTTP请求的？\"><a href=\"#Controller如何处理HTTP请求的？\" class=\"headerlink\" title=\"Controller如何处理HTTP请求的？\"></a>Controller如何处理HTTP请求的？</h2><p>要回答这个问题，需要你有一定的关于Java Tomcat Web容器的知识。本系列主要是对SpringBoot的快速入门，不便于讲的过细。简单一点就是：</p>\n<ol>\n<li>Tomcat是一个用Java编写的Web容器，可以接受HTTP请求。</li>\n<li>SpringBoot内置了Tomcat容器，并且对于HTTP请求，转到了内部处理</li>\n<li>对于这些HTTP请求，根据请求的路径等上下文，匹配Bean容器中的Controller进行处理</li>\n</ol>\n<h2 id=\"仓库地址-1\"><a href=\"#仓库地址-1\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n","categories":[],"tags":["Java","SpringBoot"]},{"title":"极简SpringBoot指南-Chapter05-SpringBoot中的AOP面向切面编程简介","url":"http://compilemind.com/2021/08/10/2021-08-10-极简SpringBoot指南-chapter05-SpringBoot中的AOP面向切面编程简介/","content":"<h2 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n<h1 id=\"Chapter05-SpringBoot中的AOP面向切面编程简介\"><a href=\"#Chapter05-SpringBoot中的AOP面向切面编程简介\" class=\"headerlink\" title=\"Chapter05-SpringBoot中的AOP面向切面编程简介\"></a>Chapter05-SpringBoot中的AOP面向切面编程简介</h1><a id=\"more\"></a>\n<p>在上一章中，我们编写了一款基于SpringBoot的书籍信息管理Web应用，实现了对书籍信息的增删查改操作。现在，我们有了一个新的需求：为了方便后台服务监管我们的Web服务的请求耗时，我们需要增强一下对我们的Web应用，希望对每个请求都能够打印一下处理耗时。</p>\n<h2 id=\"基本方式\"><a href=\"#基本方式\" class=\"headerlink\" title=\"基本方式\"></a>基本方式</h2><p>为了实现这样的需求，我们首先以<strong>获取指定ID的书籍信息</strong>这个API为例，开始进行编程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Book <span class=\"title\">getBookById</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为了更加明显，我模拟了一个耗时</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Optional&lt;Book&gt; first = <span class=\"keyword\">this</span>.bookList</span><br><span class=\"line\">            .stream()</span><br><span class=\"line\">            .filter(b -&gt; b.getId().equals(id))</span><br><span class=\"line\">            .findFirst();</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;处理耗时：%d ms %n&quot;</span>, (System.currentTimeMillis() - currentTimeMillis));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first.orElse(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了模拟一个耗时，我在请求处理的时候对当前处理线程sleep500ms。然后使用对应postman进行请求调用，调用后查看控制台打印：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">处理耗时：513 ms </span><br></pre></td></tr></table></figure>\n<p>效果还行，但是现在需要对所有的调用都进行日志记录呢？有的同学可能会说，直接开写，一个一个加。牛！此外，我今天的需求是耗时打印，我以后可能需要耗时上传进行预警了，再后来我还希望统计各个API的调用接口，似乎我们愈来愈无法控制这些需求了。每变更一个需求，都需要我们去对每个API进行修改。</p>\n<p>还好，我们还有一大杀器：AOP。</p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>AOP全称<code>Aspect Oriented Programming</code>意为面向切面编程，也叫做面向方法编程，是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">流程起点</span><br><span class=\"line\"> |</span><br><span class=\"line\"> |</span><br><span class=\"line\">---&gt; 切入点1</span><br><span class=\"line\"> |</span><br><span class=\"line\"> |</span><br><span class=\"line\">---&gt; 切入点2</span><br><span class=\"line\"> |</span><br><span class=\"line\"> V</span><br><span class=\"line\">流程终点</span><br></pre></td></tr></table></figure>\n<p>上图的流程中，我们可以在任何希望的时候<strong>切入</strong>处理。其好处的就是是的业务逻辑各个部分之间的耦合度降低，提高程序的可重用性。我们可以在完全不侵入业务逻辑代码的情况下就完成各个阶段的切入处理。</p>\n<h3 id=\"核心术语\"><a href=\"#核心术语\" class=\"headerlink\" title=\"核心术语\"></a>核心术语</h3><h4 id=\"连接点（JoinPoint）\"><a href=\"#连接点（JoinPoint）\" class=\"headerlink\" title=\"连接点（JoinPoint）\"></a>连接点（JoinPoint）</h4><p>连接点是在应用执行过程中能够插入切面（Aspect）的一个点。这些点可以是调用方法时、甚至修改一个字段时。它是一个虚拟的概念，例如坐地铁的时候，每一个站都可以下车，那么这每一个站都是一个连接点。假如一个对象中有多个方法，那么这个每一个方法就是一个连接点。</p>\n<h4 id=\"切入点（Pointcut）\"><a href=\"#切入点（Pointcut）\" class=\"headerlink\" title=\"切入点（Pointcut）\"></a>切入点（Pointcut）</h4><p>切入点是一些特殊的连接点，是具体附加通知的地方。例如坐地铁的时候，具体在某个站下车，那这个站就是切入点。</p>\n<h4 id=\"通知（Advice）\"><a href=\"#通知（Advice）\" class=\"headerlink\" title=\"通知（Advice）\"></a>通知（Advice）</h4><p>在某个特定的Pointcut切点上需要的执行的动作，如日志记录，权限校验等具体要应用切入点的代码。</p>\n<p>五种通知类型：</p>\n<ul>\n<li>环绕通知：<strong>@Around</strong></li>\n<li>前置通知：<strong>@Before</strong></li>\n<li>返回通知：<strong>@After</strong></li>\n<li>正常返回通知：<strong>@AfterReturning</strong></li>\n<li>异常返回通知：<strong>@AfterThrowing</strong></li>\n</ul>\n<h4 id=\"切面（Aspect）\"><a href=\"#切面（Aspect）\" class=\"headerlink\" title=\"切面（Aspect）\"></a>切面（Aspect）</h4><p>切面是<strong>通知</strong>和<strong>切入点</strong>的结合，通知规定了在什么时机干什么事，切入点规定了在什么地方。如“在8点钟在天府广场站下车“ 就是一个切面：时间8点，动作下车就是一个通知；西站就是一个切入点。</p>\n<p>对于概念术语还是很抽象，我们直接编写一个切面吧。编写切面之前，首先需要引入相关的依赖。因为切面相关的模块是可选模块，我们在pom中添加如下的依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 其他依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>完成依赖导入后，我们编写一个切面类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 定义一个日志切面</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">// 切面不是Bean，需要添加注解</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(LogAspect.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义切点表明要通知的地方</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里使用了pointcut expression表达式，具体语法请自行搜索</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里解释为包 com.compilemind.guide包以及子包的所有类的所有公共方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* com.compilemind.guide..*.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">webLog</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指代上面的切点：webLog，并且是调用前执行</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class=\"line\">        ServletRequestAttributes requestAttributes =</span><br><span class=\"line\">                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestAttributes == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        HttpServletRequest request = requestAttributes.getRequest();</span><br><span class=\"line\">        LOGGER.info(<span class=\"string\">&quot;发生请求：&quot;</span> + request.getRequestURI());</span><br><span class=\"line\">        LOGGER.info(<span class=\"string\">&quot;调用方法：&quot;</span> + joinPoint.getSignature());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 一个关于对应切点的环绕执行的处理</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// 调用参数</span></span><br><span class=\"line\">        Object[] invokeArgs = joinPoint.getArgs();</span><br><span class=\"line\">        <span class=\"comment\">// 返回数据</span></span><br><span class=\"line\">        Object returnObj;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 执行对应的方法，得到结果</span></span><br><span class=\"line\">            returnObj = joinPoint.proceed(invokeArgs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">&quot;统计某方法执行耗时环绕通知出错&quot;</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LOGGER.info(<span class=\"string\">&quot;处理耗时：&#123;&#125; ms&quot;</span>, System.currentTimeMillis() - currentTimeMillis);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> returnObj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个切面由以下几个部分组成：</p>\n<ol>\n<li>在类上使用<code>@Aspect</code>注解标记为切面，使用<code>@Component</code>注解标记为组件，由Spring管理；</li>\n<li>编写方法<code>webLog</code>，并在其方法上添加注解<code>@Pointcut</code>，并按照规则填写切点的位置；</li>\n<li>分别编写由<code>@Before</code>和<code>@Around</code>注解标记的方法，用以处理对应的切点位置<strong>处理前</strong>和<strong>整个环绕</strong>的处理代码。</li>\n</ol>\n<p>最后，让我们再次启动程序，进行相关的API调用，可以看到输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2021-08-09 16:42:46.494  INFO 18528 --- [nio-8080-exec-2] c.c.guide.chapter04_05.aspect.LogAspect  : 发生请求：&#x2F;books&#x2F;1</span><br><span class=\"line\">2021-08-09 16:42:46.495  INFO 18528 --- [nio-8080-exec-2] c.c.guide.chapter04_05.aspect.LogAspect  : 调用方法：Book com.compilemind.guide.chapter04_05.controller.BookController.getBookById(String)</span><br><span class=\"line\">处理耗时：502 ms </span><br><span class=\"line\">2021-08-09 16:42:47.004  INFO 18528 --- [nio-8080-exec-2] c.c.guide.chapter04_05.aspect.LogAspect  : 处理耗时：510 ms</span><br></pre></td></tr></table></figure>\n<h2 id=\"仓库地址-1\"><a href=\"#仓库地址-1\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h2><p><a href=\"https://github.com/w4ngzhen/springboot-simple-guide\">w4ngzhen/springboot-simple-guide: This is a project that guides SpringBoot users to get started quickly through a series of examples (github.com)</a></p>\n","categories":[],"tags":["Java","SpringBoot"]},{"title":"IDEA Web渲染插件开发（一）— 使用JCEF","url":"http://compilemind.com/2021/07/16/2021-07-06-IDEA Web渲染插件开发（一）— 使用JCEF/","content":"<p>目前网上已经有了很多关于IDEA（IntelliJ平台）的插件开发教程了，本人觉得简书上这位作者<a href=\"https://www.jianshu.com/u/3adf83c26b4e\">秋水畏寒 </a>的关于插件开发的文章很不错，在我进行插件开发的过程中指导了我很多。但是综合下来看，在IDEA上加载网页的插件的教程还不是特别多，官方文档也不是那么的完整。本系列将会从这个角度出发，探讨如何编写加载Web页面的插件。</p>\n<a id=\"more\"></a>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>为什么会有想到开发处理Web网页的插件呢？实际上因为在IDEA中，我们可以打开markdown文件，并且IDEA具有markdown实时渲染的能力：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/010-idea-md-show.jpg\" alt=\"\"></p>\n<p>因为之前，本人使用过JCEF进行开发。看到这个渲染，心里大概猜测，应该用了浏览器内核。打开任务管理器：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/020-idea-use-jcef.jpg\" alt=\"\"></p>\n<p>果然，熟悉的JCEF。然后进入JetBrains的官网，在插件开发的文档中找到了：<a href=\"https://plugins.jetbrains.com/docs/intellij/jcef.html\">JCEF - Java Chromium Embedded Framework | IntelliJ Platform Plugin SDK (jetbrains.com)</a>。</p>\n<p>那么，接下来我们从零开始，编写一款属于自己的插件，这款插件能够加载Web页面。</p>\n<h1 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h1><ul>\n<li>JDK 11</li>\n<li>Gradle</li>\n<li>良好的网络环境</li>\n</ul>\n<p>我们先创建一个IntelliJ Platform Plugin，名为：intellij-jcef-plugin</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/030-create-plugin-proj-1.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/040-create-plugin-proj-2.jpg\" alt=\"\"></p>\n<p>然后进行这个Gradle项目的配置工作，完成整个项目搭建。本项目会在最后提交到github供读者下载。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/050-proj-arch.jpg\" alt=\"\"></p>\n<h1 id=\"代码编写\"><a href=\"#代码编写\" class=\"headerlink\" title=\"代码编写\"></a>代码编写</h1><p>首先说明我们的目的，就是希望能够类似于gradle、maven插件一样，能够在IDEA的侧边有一个显示我们Web页面的地方：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/060-display-like-gradle-page.jpg\" alt=\"\"></p>\n<p>通过阅读官方的文档我们可以知道，我们需要编写的是ToolWindow（<a href=\"https://plugins.jetbrains.com/docs/intellij/tool-windows.html\">Tool Windows | IntelliJ Platform Plugin SDK (jetbrains.com)</a>）这样一个页面窗体。</p>\n<h2 id=\"基础ToolWindow开发\"><a href=\"#基础ToolWindow开发\" class=\"headerlink\" title=\"基础ToolWindow开发\"></a>基础ToolWindow开发</h2><p>在开发之前，我们需要明确一点，尽管这一节的标题写着”空白ToolWindow开发”，似乎在暗示我们，接下来我们会开发一个所谓的ToolWindow的实现类。实际上，ToolWindow是插件框架本身提供的，我们只需要做的是创建UI组件（例如JPanel），然后调用ToolWindow实例通过相关的API帮我们把UI组件设置到ToolWindow内部，具体的步骤如下：</p>\n<h3 id=\"实现ToolWindowFactory\"><a href=\"#实现ToolWindowFactory\" class=\"headerlink\" title=\"实现ToolWindowFactory\"></a>实现ToolWindowFactory</h3><p>创建一个ToolWindowFactory的实现类，这里我们取名MyToolWindowFactory，然后重写<code>createToolWindowContent</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyToolWindowFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ToolWindowFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createToolWindowContent</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"meta\">@NotNull</span> Project project,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"meta\">@NotNull</span> ToolWindow toolWindow)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此处方法将会在点击ToolWindow的时候触发</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取ContentManager</span></span><br><span class=\"line\">        ContentManager contentManager = toolWindow.getContentManager();</span><br><span class=\"line\">        Content labelContent =</span><br><span class=\"line\">                contentManager.getFactory() <span class=\"comment\">// 内容管理器获取工厂类</span></span><br><span class=\"line\">                        .createContent( <span class=\"comment\">// 创建Content（组件类实例、显示名称、是否可以锁定）</span></span><br><span class=\"line\">                                <span class=\"keyword\">new</span> JLabel(<span class=\"string\">&quot;hello, world&quot;</span>),</span><br><span class=\"line\">                                <span class=\"string\">&quot;MyTab&quot;</span>,</span><br><span class=\"line\">                                <span class=\"keyword\">false</span></span><br><span class=\"line\">                        );</span><br><span class=\"line\">        <span class=\"comment\">// 利用ContentManager添加Content</span></span><br><span class=\"line\">        contentManager.addContent(labelContent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在重写的<code>createToolWindowContent</code>方法中，插件框架会为我们传入两个对象：Project以及ToolWindow对象。其中，Project对象是当前项目的内容抽象，而ToolWindow这个对象就是插件框架本身内部构造的，抽象了我们需求所说的，点击侧边栏时候弹出的页面。</p>\n<p>在该方法实现中，主要有以下步骤：</p>\n<ol>\n<li>使用ContentFactory（ContentManager.getFactory()获取）的<code>createContent</code>API创建Content对象。这个创建时候，需要swing组件对象（JPanel、JLabel等等）。</li>\n<li>使用ContentManager的<code>addContent</code>API添加步骤1的Content对象。</li>\n</ol>\n<h3 id=\"注册插件\"><a href=\"#注册插件\" class=\"headerlink\" title=\"注册插件\"></a>注册插件</h3><p>接下来，我们将我们实现的MyToolWindowFactory通过<code>plugin.xml</code>进行注册，<code>alt+enter</code>，IDEA帮助我们快速完成填写xml配置到<code>plugin.xml</code>中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/070-register-toolwindow.jpg\" alt=\"\"></p>\n<p>进行上述操作后，IDEA自动为我们在plugin.xml文件的<code>extensions节点</code>中，添加了<code>toolWindow节点</code>的内容，但是我们还需要填写必备的属性<code>id</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- plugin.xml文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">extensions</span> <span class=\"attr\">defaultExtensionNs</span>=<span class=\"string\">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- Add your extensions here --&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- id是必须的属性，我们进行添加 --&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- anchor锚点非必须，但是为了像Gradle插件一样默认显示在右边，我们设置为right --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">toolWindow</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myToolWindowFactory&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">anchor</span>=<span class=\"string\">&quot;right&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">factoryClass</span>=<span class=\"string\">&quot;com.compilemind.demo.ui.MyToolWindowFactory&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">extensions</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"解决调试环境问题\"><a href=\"#解决调试环境问题\" class=\"headerlink\" title=\"解决调试环境问题\"></a>解决调试环境问题</h3><p>目前为止，我们实现了ToolWindowFactory以及将我们的实现类注册到plugin.xml中。现在，我们先什么内容都不编写，开始调试我们的插件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/080-begin-debug.jpg\" alt=\"\"></p>\n<p>不过开始调试后，会有很多的情况发生，这里我做了一些遇到的问题的总结。</p>\n<h4 id=\"Gradle乱码\"><a href=\"#Gradle乱码\" class=\"headerlink\" title=\"Gradle乱码\"></a>Gradle乱码</h4><p>此时进行Debug调试，在我的机器上会出现乱码：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/090-debug-but-encode-error.jpg\" alt=\"\"></p>\n<p>解决方案为，在build.gradle中添加如下的语句：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks.withType(JavaCompile) &#123;</span><br><span class=\"line\">    options.encoding = <span class=\"string\">&quot;UTF-8&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Gradle报错不知道这样的主机（Unknown-host）\"><a href=\"#Gradle报错不知道这样的主机（Unknown-host）\" class=\"headerlink\" title=\"Gradle报错不知道这样的主机（Unknown host）\"></a>Gradle报错不知道这样的主机（Unknown host）</h4><p>如果出现了类似于<code>Unknown host &#39;xxxxx.cloudfront.net&#39;. You may need to adjust the proxy settings in Gradle.</code>这样的报错，一般是当前网络的连通问题，导致无法下载cloudfront.net一些jar文件。此时挂代理是最好的办法。</p>\n<h4 id=\"rumIde：Download-JCEF\"><a href=\"#rumIde：Download-JCEF\" class=\"headerlink\" title=\"rumIde：Download JCEF\"></a>rumIde：Download JCEF</h4><p>如果使用调试模式，intellij插件开发的Gradle插件会下载jcef的运行时，这个过程会比较漫长，目前解决办法是使用好的网络等待下载：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/100-downloading-jcef.jpg\" alt=\"\"></p>\n<p>在本人机器上，第一次调试的时候主要就是遇到上面的三种情况。</p>\n<h3 id=\"验证基础ToolWindow\"><a href=\"#验证基础ToolWindow\" class=\"headerlink\" title=\"验证基础ToolWindow\"></a>验证基础ToolWindow</h3><p>解决完上述的几个问题之后，界面弹出了我们的调试下的社区版的IDEA（ideaIC），并且，查看Plugins页签，会发现我们编写的插件已经被这个ideaIC安装了：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/110-first-run-ideaIC-with-my-plugin.jpg\" alt=\"\"></p>\n<p>我们使用这个IDEA创建一个简单的空项目，然后可以看到右侧有我们提供的ToolWindow：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/120-first-display-my-toolwindow.jpg\" alt=\"\"></p>\n<p>可以看到，此时的ToolWindow中的内容显示为我们上面设置的<code>new JLabel(&quot;hello, world&quot;)</code>，该ToolWindow上方有我们设置的”My Tab”标题。截至目前的代码，包含在这个github上这个提交：</p>\n<p><a href=\"https://github.com/w4ngzhen/intellij-jcef-plugin/commit/bf2ca8eb71c36a46077d222b031439537d8015cd\">simple ToolWindow Content · w4ngzhen/intellij-jcef-plugin@bf2ca8e (github.com)</a></p>\n<h2 id=\"Web页面ToolWindow开发\"><a href=\"#Web页面ToolWindow开发\" class=\"headerlink\" title=\"Web页面ToolWindow开发\"></a>Web页面ToolWindow开发</h2><p>通过上面一些系列的环境搭建，以及ToolWindow开发练习，我们已经了解了如何开发一款用于IDEA侧边栏展示内容的插件。当然，我们一开始的需求是要在ToolWindow中展示网页，并且也知道了，JetBrains已经将JCEF引入到了IntelliJ插件平台。接下来，我们使用JCef以及JBCef相关API创建一个用于展示Web的UI组件，再通过上述的方式，添加到ToolWindow。</p>\n<h3 id=\"创建MyWebToolWindowContent\"><a href=\"#创建MyWebToolWindowContent\" class=\"headerlink\" title=\"创建MyWebToolWindowContent\"></a>创建MyWebToolWindowContent</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.compilemind.demo.ui;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.intellij.ui.jcef.JBCefApp;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.intellij.ui.jcef.JBCefBrowser;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.swing.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWebToolWindowContent</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> JPanel content;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyWebToolWindowContent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content = <span class=\"keyword\">new</span> JPanel(<span class=\"keyword\">new</span> BorderLayout());</span><br><span class=\"line\">        <span class=\"comment\">// 判断所处的IDEA环境是否支持JCEF</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!JBCefApp.isSupported()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.content.add(<span class=\"keyword\">new</span> JLabel(<span class=\"string\">&quot;当前环境不支持JCEF&quot;</span>, SwingConstants.CENTER));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 JBCefBrowser</span></span><br><span class=\"line\">        JBCefBrowser jbCefBrowser = <span class=\"keyword\">new</span> JBCefBrowser();</span><br><span class=\"line\">        <span class=\"comment\">// 将 JBCefBrowser 的UI控件设置到Panel中</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content.add(jbCefBrowser.getComponent(), BorderLayout.CENTER);</span><br><span class=\"line\">        <span class=\"comment\">// 加载URL</span></span><br><span class=\"line\">        jbCefBrowser.loadURL(<span class=\"string\">&quot;https://cnblogs.com/w4ngzhen&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回创建的JPanel</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> JPanel</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JPanel <span class=\"title\">getContent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改MyToolWindowFactory\"><a href=\"#修改MyToolWindowFactory\" class=\"headerlink\" title=\"修改MyToolWindowFactory\"></a>修改MyToolWindowFactory</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/130-modify-factory.jpg\" alt=\"\"></p>\n<p>这里，我们将创建<code>MyWebToolWindowContent</code>实例，然后返回其Panel，按同样的方式设置到ToolWindow中。</p>\n<h3 id=\"验证Web渲染ToolWindow\"><a href=\"#验证Web渲染ToolWindow\" class=\"headerlink\" title=\"验证Web渲染ToolWindow\"></a>验证Web渲染ToolWindow</h3><p>上述代码完成开发后，我们再次运行Debug模式，可以看到此时的界面显示了相关的网页：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-16-intelliJ-plugin-dev-1/140-display-toolwindow-with-web-page.jpg\" alt=\"\"></p>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><p>本次代码本人放在了Github上，地址为：<a href=\"https://github.com/w4ngzhen/intellij-jcef-plugin\">w4ngzhen/intellij-jcef-plugin (github.com)</a>。</p>\n<p>上面<strong>基础ToolWindow开发</strong>以及<strong>web页面ToolWindow开发</strong>两节的内容，按如下提交对应：</p>\n<p>基础ToolWindow开发 ：<a href=\"https://github.com/w4ngzhen/intellij-jcef-plugin/commit/bf2ca8eb71c36a46077d222b031439537d8015cd\">simple ToolWindow Content · w4ngzhen/intellij-jcef-plugin@bf2ca8e (github.com)</a></p>\n<p>web页面ToolWindow开发：<a href=\"https://github.com/w4ngzhen/intellij-jcef-plugin/commit/45604d374eaead417b16df2ade1b5d6700e291f3\">web ToolWindow Content · w4ngzhen/intellij-jcef-plugin@45604d3 (github.com)</a></p>\n","categories":[],"tags":["jcef","idea plugin"]},{"title":"使用CEF（四）— 在QT中集成CEF（1）基本集成","url":"http://compilemind.com/2021/07/04/2021-07-04-使用CEF（四）— 在QT中集成CEF（1）基本集成/","content":"<p>QT作为C++下著名的跨平台软件开发框架，实现了一套代码可以在所有的操作系统、平台和屏幕类型上部署。我们前几篇文章讲解了如何构建一款基于CEF的简单的样例，但这些样例的GUI都是使用的原生的或者是控件功能不强大的CEF视图框架。本文将会重新开始，使用VS2019编写一款基于QT的并嵌入原生窗体的文章。</p>\n<a id=\"more\"></a>\n<h1 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h1><p>在本文中，我没有使用QtCreator进行项目搭建的工作，而是使用VS配合QT VS Tools类来完成项目的环境。在本文，假设你已经安装了QT，并且了解QT的相关知识。</p>\n<h2 id=\"安装Qt-VS-Tools插件\"><a href=\"#安装Qt-VS-Tools插件\" class=\"headerlink\" title=\"安装Qt VS Tools插件\"></a>安装Qt VS Tools插件</h2><p>在VS中，我们通过在扩展（Extension）搜索对应的QT插件，完成安装工作，安装完成后，需要重启VS。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/010-install-qt-extension.jpg\" alt=\"010-install-qt-extension\"></p>\n<h2 id=\"配置Qt环境\"><a href=\"#配置Qt环境\" class=\"headerlink\" title=\"配置Qt环境\"></a>配置Qt环境</h2><p>找到<code>Extensions - Qt VS Tools - Options</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/020-qt-extension-options.jpg\" alt=\"020-qt-extension-options\"></p>\n<p>找到<code>Qt - Versions</code>，进行QT - VS编译的配置：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/030-config-qt-options.jpg\" alt=\"030-config-qt-options\"></p>\n<h2 id=\"Qt项目创建\"><a href=\"#Qt项目创建\" class=\"headerlink\" title=\"Qt项目创建\"></a>Qt项目创建</h2><p>在经过配置以后，此时使用VS进行项目创建的时候，会发现创建的向导页面会出现Qt的相关项目模板：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/040-create-qt-project.jpg\" alt=\"040-create-qt-project\"></p>\n<p>接下来创建一个名为QtCefDemo的样例，此时会弹出Qt的创建向导：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/050-popup-qt-create-guide.jpg\" alt=\"050-popup-qt-create-guide\"></p>\n<p>然后，Qt会自动帮我们配置好Debug和Release：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/060-config-debug-and-release.jpg\" alt=\"060-config-debug-and-release\"></p>\n<p>最后，我们再调整下项目的文件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/070-final-qt-prop-config.jpg\" alt=\"070-final-qt-prop-config\"></p>\n<p>点击<code>Finish</code>，我么就得到了如下的在VS IDE下的QT项目大致结构：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/080-vs-qt-proj.jpg\" alt=\"080-vs-qt-proj\"></p>\n<p>当我们运行该项目以后，就可以看到目前的一个简单的QT窗体：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/090-empty-window.jpg\" alt=\"090-empty-window\"></p>\n<p>当然，本文的目的不仅仅是创建一个Qt窗体那样的简单，还需要进行CEF的简单集成。所以，接下来我们继续配置CEF的环境。</p>\n<h2 id=\"配置CEF环境\"><a href=\"#配置CEF环境\" class=\"headerlink\" title=\"配置CEF环境\"></a>配置CEF环境</h2><p>在前一篇文章，我们已经了解如何编译<code>libcef_dll_wrapper</code>这个库，所以，本文假设你已经编译出了libcef_dll_wrapper.lib（Debug和Release版本，并且对应版本的程序集类型分别是：MDd和MD）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/100-libcef_dll_wrapper_debug_and_MDd.jpg\" alt=\"100-libcef_dll_wrapper_debug_and_MDd\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/110-libcef_dll_wrapper_release_and_MD.jpg\" alt=\"110-libcef_dll_wrapper_release_and_MD\"></p>\n<p>接下来，我们需要在我们的解决方案下，创建对应的文件夹，用来存放CEF在编译和运行时会使用到的头文件、库文件以及资源文件。</p>\n<h3 id=\"拷贝头文件以及资源文件\"><a href=\"#拷贝头文件以及资源文件\" class=\"headerlink\" title=\"拷贝头文件以及资源文件\"></a>拷贝头文件以及资源文件</h3><p>首先，我们在解决方案同级目录下创建一个名为<code>CefFiles</code>的文件夹，将cef文件中的Release和Include拷贝进来：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/120-copy-include-and-Resouces-files.jpg\" alt=\"120-copy-include-and-Resouces-files\"></p>\n<h3 id=\"拷贝二进制库文件\"><a href=\"#拷贝二进制库文件\" class=\"headerlink\" title=\"拷贝二进制库文件\"></a>拷贝二进制库文件</h3><p>接下来，我们在CefFiles文件夹中创建一个<code>bin</code>目录，用于存放libcef.lib相关文件以及ibcef_dll_wrapper.lib库文件，但需要注意的是，我们需要按照Debug和Release进行分类：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/130-copy-libcef_lib-files.jpg\" alt=\"130-copy-libcef_lib-files\"></p>\n<p>对于拷贝libcef_dll_wrapper.lib文件，我们也拷贝到对应的bin/版本目录下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/140-copy-libcef_dll_wrapper-to-bin_Debug.jpg\" alt=\"140-copy-libcef_dll_wrapper-to-bin_Debug\"></p>\n<p>Release的同理：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/150-copy-libcef_dll_wrapper-to-bin_Release.jpg\" alt=\"150-copy-libcef_dll_wrapper-to-bin_Release\"></p>\n<p>此时，我们的CefFiles文件结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CefFiles</span><br><span class=\"line\">├─bin</span><br><span class=\"line\">│  ├─Debug</span><br><span class=\"line\">│  │  │  ...</span><br><span class=\"line\">│  │  │  libcef.dll</span><br><span class=\"line\">│  │  │  libcef.lib</span><br><span class=\"line\">│  │  │  libcef_dll_wrapper.lib</span><br><span class=\"line\">│  │  │  ...</span><br><span class=\"line\">│  │  │</span><br><span class=\"line\">│  │  └─swiftshader</span><br><span class=\"line\">│  │          ...</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─Release</span><br><span class=\"line\">│      │  ...</span><br><span class=\"line\">│      │  libcef.dll</span><br><span class=\"line\">│      │  libcef.lib</span><br><span class=\"line\">│      │  libcef_dll_wrapper.lib</span><br><span class=\"line\">│      │  ...</span><br><span class=\"line\">│      │  </span><br><span class=\"line\">│      └─swiftshader</span><br><span class=\"line\">│              ...</span><br><span class=\"line\">│</span><br><span class=\"line\">├─include</span><br><span class=\"line\">│  各种.h头文件</span><br><span class=\"line\">│  ...</span><br><span class=\"line\">└─Resources</span><br><span class=\"line\">    │  cef.pak</span><br><span class=\"line\">    │  ..</span><br><span class=\"line\">    └─locales</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            zh-CN.pak</span><br><span class=\"line\">            zh-TW.pak</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写manifest文件\"><a href=\"#编写manifest文件\" class=\"headerlink\" title=\"编写manifest文件\"></a>编写manifest文件</h3><p>在Windows上使用CEF的时候，需要配置将manifest文件打入exe可执行程序中，这个manifest文件我们直接手工创建，在<strong>项目目录</strong>下创建一个名为<code>app.manifest</code>的文件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/155-create-manifest-file.jpg\" alt=\"155-create-manifest-file\"></p>\n<p>内容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">assembly</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span> <span class=\"attr\">manifestVersion</span>=<span class=\"string\">&quot;1.0&quot;</span>&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">compatibility</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;urn:schemas-microsoft-com:compatibility.v1&quot;</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span>&gt;</span> </span><br><span class=\"line\">      <span class=\"comment\">&lt;!--The ID below indicates application support for Windows 8.1 --&gt;</span>  </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">supportedOS</span> <span class=\"attr\">Id</span>=<span class=\"string\">&quot;&#123;1f676c76-80e1-4239-95bb-83d0f6d0da78&#125;&quot;</span>/&gt;</span>  </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 10.0 --&gt;</span>  </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">supportedOS</span> <span class=\"attr\">Id</span>=<span class=\"string\">&quot;&#123;8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a&#125;&quot;</span>/&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">compatibility</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"配置VS中的头文件以及库文件的加载地址\"><a href=\"#配置VS中的头文件以及库文件的加载地址\" class=\"headerlink\" title=\"配置VS中的头文件以及库文件的加载地址\"></a>配置VS中的头文件以及库文件的加载地址</h3><p>首先是配置头文件include的目录：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/160-config-Debug-and-Release-include-dir.jpg\" alt=\"160-config-Debug-and-Release-include-dir\"></p>\n<p>由于头文件不存在Debug和Release的差别，所以Release相同配置，不再赘述。</p>\n<p>接下来是配置链接库的文件路径，由于Debug和Release下，库文件内容存在不同，所以需要分别配置，但我们看可以使用<code>$(Configuration)宏</code>来完成根据环境自动配置。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/170-config-Debug-link-lib.jpg\" alt=\"170-config-Debug-link-lib\"></p>\n<p>在Release下，只需要同样的配置，但是会自动定位。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/180-config-Release-link-lib.jpg\" alt=\"180-config-Release-link-lib\"></p>\n<h3 id=\"配置manifest文件\"><a href=\"#配置manifest文件\" class=\"headerlink\" title=\"配置manifest文件\"></a>配置manifest文件</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/190-config-Debug-and-Release-manifest.jpg\" alt=\"190-config-Debug-and-Release-manifest\"></p>\n<p>当然，由于manifest文件不涉及Debug还是Release，所以配置一致即可。</p>\n<p>至此，我们的使用VS作为IDE，基于QT的框架的，集成CEF的环境完全搭建完成了，在文章的末尾，我会附上在环境搭建完成下的初始状态的项目。</p>\n<h1 id=\"集成CEF的编码\"><a href=\"#集成CEF的编码\" class=\"headerlink\" title=\"集成CEF的编码\"></a>集成CEF的编码</h1><p>在CEF编码的时候，我们直接将cefsimple中的相关代码迁移到我们的项目中，但是会进行一定的删改。</p>\n<h2 id=\"编写simple-handler\"><a href=\"#编写simple-handler\" class=\"headerlink\" title=\"编写simple_handler\"></a>编写simple_handler</h2><h3 id=\"simple-handler-h\"><a href=\"#simple-handler-h\" class=\"headerlink\" title=\"simple_handler.h\"></a>simple_handler.h</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_client.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleHandler</span> :</span> <span class=\"keyword\">public</span> CefClient,</span><br><span class=\"line\">                      <span class=\"keyword\">public</span> CefLifeSpanHandler,</span><br><span class=\"line\">                      <span class=\"keyword\">public</span> CefLoadHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">SimpleHandler</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    ~SimpleHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Provide access to the single global instance of this object.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> SimpleHandler* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefLifeSpanHandler&gt; <span class=\"title\">GetLifeSpanHandler</span><span class=\"params\">()</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefLoadHandler&gt; <span class=\"title\">GetLoadHandler</span><span class=\"params\">()</span> OVERRIDE </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CefLifeSpanHandler methods:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnAfterCreated</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span> OVERRIDE</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">DoClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span> OVERRIDE</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnBeforeClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span> OVERRIDE</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CefLoadHandler methods:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnLoadError</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             CefRefPtr&lt;CefFrame&gt; frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             ErrorCode errorCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             <span class=\"keyword\">const</span> CefString&amp; errorText,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             <span class=\"keyword\">const</span> CefString&amp; failedUrl)</span> OVERRIDE</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Request that all existing browser windows close.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CloseAllBrowsers</span><span class=\"params\">(<span class=\"keyword\">bool</span> force_close)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsClosing</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> is_closing_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// List of existing browser windows. Only accessed on the CEF UI thread.</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;CefRefPtr&lt;CefBrowser&gt;&gt; BrowserList;</span><br><span class=\"line\">    BrowserList browser_list_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> is_closing_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Include the default reference counting implementation.</span></span><br><span class=\"line\">IMPLEMENT_REFCOUNTING(SimpleHandler);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"simple-handler-cpp\"><a href=\"#simple-handler-cpp\" class=\"headerlink\" title=\"simple_handler.cpp\"></a>simple_handler.cpp</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights</span></span><br><span class=\"line\"><span class=\"comment\">// reserved. Use of this source code is governed by a BSD-style license that</span></span><br><span class=\"line\"><span class=\"comment\">// can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_handler.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/base/cef_bind.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_app.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_parser.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/views/cef_browser_view.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/views/cef_window.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/wrapper/cef_closure_task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/wrapper/cef_helpers.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SimpleHandler* g_instance = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns a data: URI with the specified contents.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">GetDataURI</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; data, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; mime_type)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;data:&quot;</span> + mime_type + <span class=\"string\">&quot;;base64,&quot;</span> +</span><br><span class=\"line\">            CefURIEncode(CefBase64Encode(data.data(), data.<span class=\"built_in\">size</span>()), <span class=\"literal\">false</span>)</span><br><span class=\"line\">            .ToString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace</span></span><br><span class=\"line\"></span><br><span class=\"line\">SimpleHandler::SimpleHandler(): is_closing_(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DCHECK(!g_instance);</span><br><span class=\"line\">    g_instance = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SimpleHandler::~SimpleHandler()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    g_instance = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// static</span></span><br><span class=\"line\"><span class=\"function\">SimpleHandler* <span class=\"title\">SimpleHandler::GetInstance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g_instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleHandler::OnAfterCreated</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Add to the list of existing browsers.</span></span><br><span class=\"line\">    browser_list_.push_back(browser);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SimpleHandler::DoClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Closing the main window requires special handling. See the DoClose()</span></span><br><span class=\"line\">    <span class=\"comment\">// documentation in the CEF header for a detailed destription of this</span></span><br><span class=\"line\">    <span class=\"comment\">// process.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (browser_list_.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set a flag to indicate that the window close should be allowed.</span></span><br><span class=\"line\">        is_closing_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allow the close. For windowed browsers this will result in the OS close</span></span><br><span class=\"line\">    <span class=\"comment\">// event being sent.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleHandler::OnBeforeClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Remove from the list of existing browsers.</span></span><br><span class=\"line\">    BrowserList::iterator <span class=\"built_in\">bit</span> = browser_list_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; <span class=\"built_in\">bit</span> != browser_list_.<span class=\"built_in\">end</span>(); ++<span class=\"built_in\">bit</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((*<span class=\"built_in\">bit</span>)-&gt;IsSame(browser))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            browser_list_.erase(<span class=\"built_in\">bit</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (browser_list_.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// All browser windows have closed. Quit the application message loop.</span></span><br><span class=\"line\">        CefQuitMessageLoop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleHandler::OnLoadError</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    CefRefPtr&lt;CefFrame&gt; frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    ErrorCode errorCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> CefString&amp; errorText,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> CefString&amp; failedUrl)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t display an error for downloaded files.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (errorCode == ERR_ABORTED)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Display a load error message using a data: URI.</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">    ss &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;&lt;body bgcolor=\\&quot;white\\&quot;&gt;&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&lt;h2&gt;Failed to load URL &quot;</span></span><br><span class=\"line\">        &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>(failedUrl) &lt;&lt; <span class=\"string\">&quot; with error &quot;</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>(errorText)</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot; (&quot;</span> &lt;&lt; errorCode &lt;&lt; <span class=\"string\">&quot;).&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    frame-&gt;LoadURL(GetDataURI(ss.str(), <span class=\"string\">&quot;text/html&quot;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleHandler::CloseAllBrowsers</span><span class=\"params\">(<span class=\"keyword\">bool</span> force_close)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!CefCurrentlyOn(TID_UI))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Execute on the UI thread.</span></span><br><span class=\"line\">        CefPostTask(TID_UI, base::Bind(&amp;SimpleHandler::CloseAllBrowsers, <span class=\"keyword\">this</span>,</span><br><span class=\"line\">            force_close));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (browser_list_.empty())</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    BrowserList::const_iterator it = browser_list_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; it != browser_list_.<span class=\"built_in\">end</span>(); ++it)</span><br><span class=\"line\">        (*it)-&gt;GetHost()-&gt;CloseBrowser(force_close);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"编写simple-app\"><a href=\"#编写simple-app\" class=\"headerlink\" title=\"编写simple_app\"></a>编写simple_app</h2><h3 id=\"simple-app-h\"><a href=\"#simple-app-h\" class=\"headerlink\" title=\"simple_app.h\"></a>simple_app.h</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"comment\">// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights</span></span><br><span class=\"line\"><span class=\"comment\">// reserved. Use of this source code is governed by a BSD-style license that</span></span><br><span class=\"line\"><span class=\"comment\">// can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_app.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implement application-level callbacks for the browser process.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleApp</span> :</span> <span class=\"keyword\">public</span> CefApp, <span class=\"keyword\">public</span> CefBrowserProcessHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    SimpleApp();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CefApp methods:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefBrowserProcessHandler&gt; <span class=\"title\">GetBrowserProcessHandler</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CefBrowserProcessHandler methods:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnContextInitialized</span><span class=\"params\">()</span> OVERRIDE</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Include the default reference counting implementation.</span></span><br><span class=\"line\">IMPLEMENT_REFCOUNTING(SimpleApp);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"simple-app-cpp\"><a href=\"#simple-app-cpp\" class=\"headerlink\" title=\"simple_app.cpp\"></a>simple_app.cpp</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights</span></span><br><span class=\"line\"><span class=\"comment\">// reserved. Use of this source code is governed by a BSD-style license that</span></span><br><span class=\"line\"><span class=\"comment\">// can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_app.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/views/cef_window.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/wrapper/cef_helpers.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_handler.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">SimpleApp::SimpleApp()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleApp::OnContextInitialized</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"编写入口代码处理函数集成CEF\"><a href=\"#编写入口代码处理函数集成CEF\" class=\"headerlink\" title=\"编写入口代码处理函数集成CEF\"></a>编写入口代码处理函数集成CEF</h2><h3 id=\"main-cpp\"><a href=\"#main-cpp\" class=\"headerlink\" title=\"main.cpp\"></a>main.cpp</h3><p>对于入口函数，目前只是进行QT相关代码的编写，我们还需要对CEF进行初始化操作，对于该文件整体如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cef_app.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;qtcefwindow.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdafx.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QtWidgets/QApplication&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_app.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化QT以及CEF相关</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_qt_cef</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> HINSTANCE h_instance = <span class=\"keyword\">static_cast</span>&lt;HINSTANCE&gt;(GetModuleHandle(<span class=\"literal\">nullptr</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> CefMainArgs <span class=\"title\">main_args</span><span class=\"params\">(h_instance)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> CefRefPtr&lt;SimpleApp&gt; <span class=\"title\">app</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleApp)</span></span>; <span class=\"comment\">//CefApp实现，用于处理进程相关的回调。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> exit_code = CefExecuteProcess(main_args, app.<span class=\"built_in\">get</span>(), <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exit_code &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> exit_code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置配置</span></span><br><span class=\"line\">    CefSettings settings;</span><br><span class=\"line\">    settings.multi_threaded_message_loop = <span class=\"literal\">true</span>; <span class=\"comment\">//多线程消息循环</span></span><br><span class=\"line\">    settings.log_severity = LOGSEVERITY_DISABLE; <span class=\"comment\">//日志</span></span><br><span class=\"line\">    settings.no_sandbox = <span class=\"literal\">true</span>; <span class=\"comment\">//沙盒</span></span><br><span class=\"line\"></span><br><span class=\"line\">    CefInitialize(main_args, settings, app, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling); <span class=\"comment\">// 解决高DPI下，界面比例问题</span></span><br><span class=\"line\">    <span class=\"function\">QApplication <span class=\"title\">a</span><span class=\"params\">(argc, argv)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> result = init_qt_cef(argc, argv);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    QtCefWindow w;</span><br><span class=\"line\">    w.show();</span><br><span class=\"line\">    a.exec();</span><br><span class=\"line\"></span><br><span class=\"line\">    CefShutdown(); <span class=\"comment\">// 关闭CEF，释放资源</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改qtcefwindow窗体代码\"><a href=\"#修改qtcefwindow窗体代码\" class=\"headerlink\" title=\"修改qtcefwindow窗体代码\"></a>修改qtcefwindow窗体代码</h2><h3 id=\"qtcefwindow-h\"><a href=\"#qtcefwindow-h\" class=\"headerlink\" title=\"qtcefwindow.h\"></a>qtcefwindow.h</h3><p>为窗体添加私有成员：<code>CefRefPtr&lt;SimpleHandler&gt;</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_handler.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;ui_qtcefwindow.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QtCefWindow</span> :</span> <span class=\"keyword\">public</span> QMainWindow</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    QtCefWindow(QWidget *parent = Q_NULLPTR);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Ui::QtCefWindowClass ui;</span><br><span class=\"line\">    CefRefPtr&lt;SimpleHandler&gt; simple_handler_; <span class=\"comment\">// 这里是新增的CefRefPtr&lt;SimpleHandler&gt;成员</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"qtcefwindow-cpp\"><a href=\"#qtcefwindow-cpp\" class=\"headerlink\" title=\"qtcefwindow.cpp\"></a>qtcefwindow.cpp</h3><p>在构造函数中，处理关联qtcefwindow和SimpleHandler：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;qtcefwindow.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cef_request_context.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_handler.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdafx.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">QtCefWindow::QtCefWindow(QWidget *parent)</span><br><span class=\"line\">    : QMainWindow(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ui.setupUi(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 以下是将 SimpleHandler 与窗体进行关联的代码</span></span><br><span class=\"line\">    CefWindowInfo cef_wnd_info;</span><br><span class=\"line\">    QString str_url = <span class=\"string\">&quot;https://www.cnblogs.com/w4ngzhen&quot;</span>;</span><br><span class=\"line\">    RECT win_rect;</span><br><span class=\"line\">    QRect <span class=\"built_in\">rect</span> = <span class=\"keyword\">this</span>-&gt;geometry();</span><br><span class=\"line\">    win_rect.left = <span class=\"built_in\">rect</span>.left();</span><br><span class=\"line\">    win_rect.right = <span class=\"built_in\">rect</span>.right();</span><br><span class=\"line\">    win_rect.top = <span class=\"built_in\">rect</span>.top();</span><br><span class=\"line\">    win_rect.bottom = <span class=\"built_in\">rect</span>.bottom();</span><br><span class=\"line\"></span><br><span class=\"line\">    cef_wnd_info.SetAsChild((HWND)<span class=\"keyword\">this</span>-&gt;winId(), win_rect); <span class=\"comment\">//将cef界面嵌入qt界面中</span></span><br><span class=\"line\">    CefBrowserSettings cef_browser_settings;</span><br><span class=\"line\">    simple_handler_ = CefRefPtr&lt;SimpleHandler&gt;(<span class=\"keyword\">new</span> SimpleHandler());</span><br><span class=\"line\">    CefBrowserHost::CreateBrowser(cef_wnd_info,</span><br><span class=\"line\">        simple_handler_,</span><br><span class=\"line\">        str_url.toStdString(),</span><br><span class=\"line\">        cef_browser_settings,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        CefRequestContext::GetGlobalContext());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"运行代码\"><a href=\"#运行代码\" class=\"headerlink\" title=\"运行代码\"></a>运行代码</h1><p>终于，项目搭建完成以后，我们走到了最后一步，看看我们在Qt中集成CEF的效果吧。</p>\n<p>运行程序，会发现报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------------------------</span><br><span class=\"line\">QtCefDemo.exe - 系统错误</span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">由于找不到 libcef.dll，无法继续执行代码。重新安装程序可能会解决此问题。 </span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">确定   </span><br><span class=\"line\">---------------------------</span><br></pre></td></tr></table></figure>\n<p>对于这个问题，其实我们就是缺少运行时候的相关库文件，这里我们暂时先手动进行拷贝工作，以Debug环境为例，我们将资源文件拷贝到输出目录中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/200-copy-resources-files.jpg\" alt=\"200-copy-resources-files\"></p>\n<p>然后将<code>CefFiles\\bin\\Debug</code>中所有的文件拷贝到输出目录中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/210-copy-cef-libs.jpg\" alt=\"210-copy-cef-libs\"></p>\n<p>当然，我们可以通过配置自动化脚本的方式，让IDE帮助我们拷贝这些文件，但本文不讨论这个问题。在手动拷贝了文件以后，我们再次尝试运行。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/220-run-and-display.jpg\" alt=\"220-run-and-display\"></p>\n<p>终于，我们看到了我们想要的页面，不过似乎渲染显示还有点问题，不过在本文我们暂且不讨论。在后续，我会单独写一篇文章，来谈一谈使用CEF以及QT集成CEF的过程中会遇到的各种问题以及解决方案。</p>\n<h1 id=\"附录：源码以及相关文件\"><a href=\"#附录：源码以及相关文件\" class=\"headerlink\" title=\"附录：源码以及相关文件\"></a>附录：源码以及相关文件</h1><p>本文所涉及的项目源码在：<a href=\"https://github.com/w4ngzhen/QtCefDemo\">w4ngzhen/QtCefDemo (github.com)</a></p>\n<p>其中，会有两个提交：</p>\n<ol>\n<li>project init</li>\n<li>integrate CEF code</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-07-04-use-cef-4/230-git-commit-desc.jpg\" alt=\"230-git-commit-desc\"></p>\n<p>读者可以自行创建分支，回退到指定的提交查看对应状态的代码。</p>\n<p>此外，本Demo还需要我们创建的CefFiles文件夹以及其中的文件。由于Github对于大文件的处理不太方便。本人将其上传到了网盘，读者只需要从网盘下载CefFiles.zip文件，并将其解压到解决方案同级目录即可。</p>\n<p>网盘地址：链接：<a href=\"https://pan.baidu.com/s/1BylLcETsFAJ5-TnmzpRxeA\">https://pan.baidu.com/s/1BylLcETsFAJ5-TnmzpRxeA</a><br>提取码：bydn</p>\n","categories":[],"tags":["cef","qt"]},{"title":"node-gyp项目命名BUG","url":"http://compilemind.com/2021/06/25/2021-06-25-node-gyp项目命名BUG/","content":"<p>当我们编写node原生模块的时候，免不了对node-gyp项目进行命名，在node-gyp进行build的时候，会跟binding.gyp配置文件中的target_name生成对应的原生模块。但是，如果target_name填写不规范，会触发编译问题。</p>\n<a id=\"more\"></a>\n<h1 id=\"问题与解决\"><a href=\"#问题与解决\" class=\"headerlink\" title=\"问题与解决\"></a>问题与解决</h1><p>本人发现，当target_name使用了短中线的时候（”-“），会导致编译过程中触发编译问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error C2143: 语法错误: 缺少“;”(在“-”的前面) </span><br></pre></td></tr></table></figure>\n<p>使用下划线命名以及各种驼峰命名不会出现此问题。出现问题的点为文件最后使用宏的时候：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br></pre></td></tr></table></figure>\n<p>解决方案，target_name名称不使用中横线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_name: &quot;the-demo&quot; &#x3D;&gt; target_name: &quot;theDemo&quot;</span><br><span class=\"line\">或</span><br><span class=\"line\">target_name: &quot;the-demo&quot; &#x3D;&gt; target_name: &quot;the_demo&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><p>接下来的问题分析，需要一定的C/C++知识。</p>\n<h2 id=\"编写样例\"><a href=\"#编写样例\" class=\"headerlink\" title=\"编写样例\"></a>编写样例</h2><p>这里不再赘述样例，直接使用这篇文章建立一个demo：<a href=\"https://zhuanlan.zhihu.com/p/383948462\">使用node-gyp编写简单的node原生模块 - 知乎 (zhihu.com)</a>，或是<a href=\"https://www.cnblogs.com/w4ngzhen/p/14931367.html\">使用node-gyp编写简单的node原生模块 - w4ngzhen - 博客园 (cnblogs.com)</a>。</p>\n<p>Demo编写完成后，我们修改其中的target_name，使其带有中横线（”-“）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;hello-world&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello_world.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改为该target_name后，我们进行<code>node-gyp configure &amp;&amp; node-gyp build</code>，会发现编译器报错：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/compile-error.jpg\" alt=\"\"></p>\n<h2 id=\"使用IDE分析\"><a href=\"#使用IDE分析\" class=\"headerlink\" title=\"使用IDE分析\"></a>使用IDE分析</h2><p>我们曾经讲过，node-gyp实际上只是构建工具，他会根据各个操作平台，生成对应平台的项目。在Windows上，它最终会帮你生成一个解决方案。查看项目目录下，我们就能看到一个build文件夹，这个文件夹下面会有解决方案：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/node-gyp-build-sln.jpg\" alt=\"\"></p>\n<p>我们使用VS打开，开始进行分析：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/demo-sln-in-vs.jpg\" alt=\"\"></p>\n<p>通过IDE的智能提示，我们看到在下面的宏使用报错了：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/compile-err-in-vs.jpg\" alt=\"\"></p>\n<p>通常，对于宏报错，我们需要的第一步是进行宏展开，查看到底是什么导致了编译错误的。在VS中，我们进行进行如下的配置，让编译器首先生成宏展开的源码：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/gen-i-file.jpg\" alt=\"\"></p>\n<p>然后，我们重新进行编译，可以看到在对应的生成目录下，产生了一个<code>.i</code>后缀的文件。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/i-file-generated.jpg\" alt=\"\"></p>\n<p>这个宏展开后的源码文件，可以更见方便的便于我们分析。我们直接定位到这个文件的最下方，可以看到我们已经经过宏展开的代码：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/i-file-content.jpg\" alt=\"\"></p>\n<p>我们67404这行宏展开的代码拷贝到VS对应宏使用的地方，通过IDE来更加智能的检查这段有何问题：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/replace-macro-to-code.jpg\" alt=\"\"></p>\n<p>因为改行很长，这里我进行一下格式化代码的操作：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/macro-unfold-error-point.jpg\" alt=\"\"></p>\n<p>可以看到，宏展开里面模块名为”hello-world”，在上图指出的部分，被分割为了”hello - world”，而分割开来后，导致了语法错误。如果target_name使用的”hello_world”，则不会有这个问题：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-node-gyp-target-name-bug/macro-unfold-with-underline.jpg\" alt=\"\"></p>\n<p>实际上被<code>&quot;-&quot;</code>分割，是因为在宏展开的时候，作为了函数名的一部分，而函数名标识符是不能有<code>&quot;-&quot;</code>的。这里举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NAME hello-world</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TEST_MACRO(fn) static void fn(void);</span></span><br><span class=\"line\"></span><br><span class=\"line\">TEST_MACRO(NAME) <span class=\"comment\">// 报错，因为最终展开后：static void hello-world(void);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>C语言规定，标识符只能由字母（A~Z, a~z）、数字（0~9）和下划线（_）组成，并且第一个字符必须是字母或下划线，不能是数字。</p>\n</blockquote>\n<p>所以这就是为什么target_name使用有中横线的名称会报错了。</p>\n","categories":[],"tags":["node-gyp","C/C++"]},{"title":"使用node-gyp编写简单的node原生模块","url":"http://compilemind.com/2021/06/25/2021-06-25-编写一个简单的node原生模块/","content":"<p>通过样例，让我们了解如何编写一个node的原生模块。当然，这篇文章还有一个目的，是为了方便以后编写关于node-gyp的文章，搭建初始环境。</p>\n<a id=\"more\"></a>\n<h1 id=\"基于node-addon-api\"><a href=\"#基于node-addon-api\" class=\"headerlink\" title=\"基于node-addon-api\"></a>基于node-addon-api</h1><p>基于node-addon-api的nodejs插件，使用的是node的头文件：<code>#include &lt;node.h&gt;</code>。</p>\n<p><strong>hello_world.cc</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;node.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Method</span><span class=\"params\">(<span class=\"keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class=\"line\">  v8::Isolate* isolate = args.GetIsolate();</span><br><span class=\"line\">  args.GetReturnValue().Set(v8::String::NewFromUtf8(</span><br><span class=\"line\">      isolate, <span class=\"string\">&quot;world&quot;</span>).ToLocalChecked());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Initialize</span><span class=\"params\">(v8::Local&lt;v8::Object&gt; exports)</span> </span>&#123;</span><br><span class=\"line\">  NODE_SET_METHOD(exports, <span class=\"string\">&quot;hello&quot;</span>, Method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br></pre></td></tr></table></figure>\n<p><strong>binding.gyp</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;hello_world&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello_world.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>index.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binding = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./build/Release/hello_world&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binding.hello());</span><br></pre></td></tr></table></figure>\n<p><strong>package.json</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...  </span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build&quot;: &quot;node-gyp configure &amp;&amp; node-gyp build&quot;,</span><br><span class=\"line\">    &quot;run:demo&quot;: &quot;node index.js&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><strong>整体结构</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-06-25-simple-node-gyp-demo/node-addon-simple-demo-proj-arch.jpg\" alt=\"\"></p>\n<p>按照如下命令依次运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run build</span></span><br><span class=\"line\">// 使用node-gyp配置并构建</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run run:demo</span></span><br><span class=\"line\">// 运行Demo</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\Projects\\node-addon-demo&gt;npm run run:demo</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; node-addon-demo@1.0.0 run:demo</span><br><span class=\"line\">&gt; node index.js</span><br><span class=\"line\"></span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n<p>附上GitHub地址：<a href=\"https://github.com/w4ngzhen/node-addon-demo\">w4ngzhen/node-addon-demo (github.com)</a>，方便以后快速完成环境搭建。</p>\n","categories":[],"tags":["node-gyp"]},{"title":"从源码分析node-gyp指定node库文件下载地址","url":"http://compilemind.com/2021/05/12/2021-05-12-从源码分析node-gyp指定node库文件下载地址/","content":"<p>当我们安装node的C/C++原生模块时，涉及到使用node-gyp对C/C++原生模块的编译工作（configure、build）。这个过程，需要nodejs的<strong>头文件</strong>以及<strong>静态库</strong>参与（后续称库文件）对C/C++项目编译和链接。库文件从哪里下载，会有一定逻辑进行处理，本文将从源码入手进行分析。</p>\n<a id=\"more\"></a>\n<h1 id=\"编写简单的原生模块\"><a href=\"#编写简单的原生模块\" class=\"headerlink\" title=\"编写简单的原生模块\"></a>编写简单的原生模块</h1><p>为了方便进行分析，我们首先创建一个原生模块（关于如何编写原生模块的细节不再本文讨论）。</p>\n<p><strong>hello_world.cc</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;node.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Method</span><span class=\"params\">(<span class=\"keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class=\"line\">  v8::Isolate* isolate = args.GetIsolate();</span><br><span class=\"line\">  args.GetReturnValue().Set(v8::String::NewFromUtf8(</span><br><span class=\"line\">      isolate, <span class=\"string\">&quot;world&quot;</span>).ToLocalChecked());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Initialize</span><span class=\"params\">(v8::Local&lt;v8::Object&gt; exports)</span> </span>&#123;</span><br><span class=\"line\">  NODE_SET_METHOD(exports, <span class=\"string\">&quot;hello&quot;</span>, Method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br></pre></td></tr></table></figure>\n<p><strong>binding.gyp</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;hello_world&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello_world.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>index.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binding = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./build/Release/hello_world&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(binding.hello());</span><br></pre></td></tr></table></figure>\n<p><strong>package.json</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...  </span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build&quot;: &quot;node-gyp configure &amp;&amp; node-gyp build&quot;,</span><br><span class=\"line\">    &quot;run:demo&quot;: &quot;node index.js&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><strong>整体结构</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/node-addon-simple-demo-proj-arch.jpg\" alt=\"\"></p>\n<p>按照如下命令依次运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run build</span></span><br><span class=\"line\">// 使用node-gyp配置并构建</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run run:demo</span></span><br><span class=\"line\">// 运行Demo</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\Projects\\node-addon-demo&gt;npm run run:demo</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; node-addon-demo@1.0.0 run:demo</span><br><span class=\"line\">&gt; node index.js</span><br><span class=\"line\"></span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n<h1 id=\"从源码分析node-gyp下载库文件的路径\"><a href=\"#从源码分析node-gyp下载库文件的路径\" class=\"headerlink\" title=\"从源码分析node-gyp下载库文件的路径\"></a>从源码分析node-gyp下载库文件的路径</h1><p>首先要直接给出一个结论，库文件并不是每次都要从网络上下载，库文件下载后会缓存在本地一个目录，在Windows上为<code>C:\\Users\\用户\\AppData\\Local\\node-gyp\\Cache</code>中，并按照nodejs的版本进行存储：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/node-headers-cache-dir.jpg\" alt=\"\"></p>\n<p><em>本人电脑安装的node版本为14.15.0，且曾经已经缓存了对应的库文件。</em></p>\n<p>为了便于分析，我们首先删除该缓存文件，并且在原有的npm命令加上<code>--verbose</code>，输出更加详细的日志：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run build --verbose</span><br></pre></td></tr></table></figure>\n<p>于是，我们可以从众多的输出中，看到一个关键信息：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/show-official-dist-url.jpg\" alt=\"\"></p>\n<p>从日志中可以看出，node-gyp在构建过程中，会创建缓存目录，然后从指定URL下载指定版本的headers文件。</p>\n<p>我们利用GrepWin（一款Windows下超好用的文本内容搜索工具，<a href=\"https://tools.stefankueng.com/grepWin.html\">官网</a>），在node-gyp目录中搜索<code>created nodedir</code>这个关键词，因为可以看到<code>gyp http GET</code>上面出现了这个关键词。那么现在有一个新的问题，node-gyp目录在哪儿？其实，从上面的日志往上查看，能够找到：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/where-is-node-gyp.jpg\" alt=\"\"></p>\n<p>这里是调用的我们全局安装的npm依赖的node-gyp，于是我们定位到node-gyp所在目录进行搜索：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/search-create-nodedir.jpg\" alt=\"\"></p>\n<p>进入该文件，我们找到：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/create-nodedir-and-download.jpg\" alt=\"\"></p>\n<p>找到关键词搜索后，继续往后续代码查阅，能够看到一个<code>download</code>函数的调用，入参最后一位是url，此时已经是成型的url，所以接下来我们需要确定，<code>release.tarballUrl</code>这个值，究竟是什么时候确定的。</p>\n<h2 id=\"tarballUrl如何得到\"><a href=\"#tarballUrl如何得到\" class=\"headerlink\" title=\"tarballUrl如何得到\"></a>tarballUrl如何得到</h2><p>继续向上翻阅代码，能够在入口处看到这个release是如何生成的：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/get-the-release.jpg\" alt=\"\"></p>\n<p>进入代码后，能够找到一段核心的构建：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/distUrl-make-flow.jpg\" alt=\"\"></p>\n<p>通过上述代码流程，我们总结出来，tarballUrl的baseUrl取决于是否存在overrideDistUrl，若存在，则直接使用；否则使用默认URL：<code>https://nodejs.org/dist</code>。</p>\n<p>再查看<code>overrideDistUrl</code>的传入点：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/overrideDistUrl.jpg\" alt=\"\"></p>\n<p>也就是说，gyp对象的opts属性存在<code>dist-url</code>或<code>disturl</code>时，就会使用该值作为库文件下载的baseUrl。</p>\n<h2 id=\"如何构建gyp-opts\"><a href=\"#如何构建gyp-opts\" class=\"headerlink\" title=\"如何构建gyp.opts\"></a>如何构建gyp.opts</h2><p>首先检查该函数的调用点：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/where-use-processRelease.jpg\" alt=\"\"></p>\n<p>发现configure和install.js都使用了该函数，且都是入口处进行的调用的：</p>\n<p><strong>configure.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configure</span> (<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> python</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buildDir = path.resolve(<span class=\"string\">&#x27;build&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> configNames = [<span class=\"string\">&#x27;config.gypi&#x27;</span>, <span class=\"string\">&#x27;common.gypi&#x27;</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> configs = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nodeDir</span><br><span class=\"line\">  <span class=\"keyword\">var</span> release = processRelease(argv, gyp, process.version, process.release)</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = configure</span><br></pre></td></tr></table></figure>\n<p><strong>install.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">fs, gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> release = processRelease(argv, gyp, process.version, process.release)</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> install(fs, gyp, argv, callback)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到confiigure.js和install.js都作为函数形式导出，也就是说，gyp这个对象是在这两个模块在被导入并以函数形式调用时被传入的。那么接下来我们需要看这两个模块在何处使用的。</p>\n<p>在上文我们查看当前执行的node-gyp目录的时候，我们就看到过：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gyp verb cli [</span><br><span class=\"line\">gyp verb cli   &#39;D:\\\\Programs\\\\nodejs\\\\node.exe&#39;,</span><br><span class=\"line\">gyp verb cli   &#39;D:\\\\Programs\\\\nodejs\\\\global_modules\\\\node_modules\\\\npm\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js&#39;,</span><br><span class=\"line\">gyp verb cli   &#39;configure&#39;</span><br><span class=\"line\">gyp verb cli ]</span><br></pre></td></tr></table></figure>\n<p>入口函数是：<code>node-gyp根目录/bin/node-gyp.js</code>。所以，我们将node-gyp以项目的形式添加到IDEA中，尝试以相同的形式调用这些命令，通过开启DEBUG模式，来一探究竟。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/debug-node-gyp-portal.jpg\" alt=\"\"></p>\n<p>在<code>bin/node-gyp.js</code>中的最下方进行了一个名为<code>run</code>的函数调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bin/node-gyp.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// 还有很多省略的代码......</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// start running the given commands!</span></span><br><span class=\"line\">run()</span><br></pre></td></tr></table></figure>\n<p>根据注释可以，<code>run()</code>执行所提供的命令。翻阅该函数：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/the-run-func.jpg\" alt=\"\"></p>\n<p>总体分为两步：</p>\n<ol>\n<li>从对象prog的todo这个数组中取出首个command命令对象，不存在判定为所有命令执行完成。</li>\n<li>从对象prog的命令数组（commands）中找到对应命令名称（command.name），通过代码可知，该命令实际上对应一个函数。传入参数（command.args）完成该函数的调用。</li>\n</ol>\n<p>那么这个prog是什么呢？通过向上阅读代码，可以知道来自于上层目录提供的模块：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/what-is-gyp.jpg\" alt=\"\"></p>\n<p>而上层所指代的模块是通过package.json的<code>main</code>字段可知是<code>lib/node-gyp.js</code>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根目录下的package.json</span></span><br><span class=\"line\">&quot;main&quot;: &quot;./lib/node-gyp.js&quot;,</span><br></pre></td></tr></table></figure>\n<p>进入该文件的gyp函数，返回的是类Gyp的实例，而Gyp实例的构造过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/Gyp-constructor-and-commands.jpg\" alt=\"\"></p>\n<ol>\n<li>使用self变量指代Gyp实例，并创建devDir和commands字段。</li>\n<li>遍历上方的commands字符串数组，给self（也就是Gyp实例）的commands属性中，逐步添加对应命令名称的函数，函数的实现是：require和command同名的js模块，这些模块又本身是以函数形式导出的，最终是调用对应模块函数。举例说明：当遍历到command为<code>configure</code>的时候，就是如下的形式：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.commands[<span class=\"string\">&#x27;configure&#x27;</span>] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  log.verbose(<span class=\"string\">&#x27;command&#x27;</span>, <span class=\"string\">&#x27;configure&#x27;</span>, argv)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./configure&#x27;</span>)(self, argv, callback)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在进行<code>node-gyp configure</code>时的调用栈就如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行node-gyp configure:</span><br><span class=\"line\">=&gt; run()</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">=&gt; gyp.commands[<span class=\"string\">&#x27;configure&#x27;</span>](argv, cb);</span><br><span class=\"line\">=&gt; <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./configure&#x27;</span>)(self, argv, cb); <span class=\"comment\">// self就是Gyp实例</span></span><br></pre></td></tr></table></figure>\n<p>前文我们已经知道了configure.js这个模块导出的就是一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// configure.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configure</span> (<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> python</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buildDir = path.resolve(<span class=\"string\">&#x27;build&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> configNames = [<span class=\"string\">&#x27;config.gypi&#x27;</span>, <span class=\"string\">&#x27;common.gypi&#x27;</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> configs = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nodeDir</span><br><span class=\"line\">  <span class=\"comment\">// 这个gyp，就是入参gyp，也就是上面的gyp实例</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> release = processRelease(argv, gyp, process.version, process.release)</span><br><span class=\"line\">  ... ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">... ...</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = configure</span><br></pre></td></tr></table></figure>\n<p>所以，我们终于知道<code>processRelease</code>的入参的gyp，就是上面的gyp实例。那么gyp实例中的opts属性，是哪儿来的呢？使用IDEA的Debug进行断点调式，调试<code>bin/node-gyp.js</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/before-handle-opts.jpg\" alt=\"\"></p>\n<p>可以看到，在执行<code>parseArgv</code>这个函数前，gyp实例里面还不存在opts属性，而执行后，又在使用opts属性的devdir。也就是说，<code>parseArgv</code>这个函数一定构建了opts，接下来我们重点分析这个函数。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/parseArgv-portal.jpg\" alt=\"\"></p>\n<p>入口的argv就是我们的运行时入参：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dev&quot;: &quot;node .&#x2F;bin&#x2F;node-gyp.js configure&quot;</span><br></pre></td></tr></table></figure>\n<p>首先会经过<code>nopt</code>函数，看样子，是对命令行参数以及短命令的处理：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/opts-build-1.jpg\" alt=\"\"></p>\n<p>然后是该函数其他的部分：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/opts-build-2-handle-argv-and-env.jpg\" alt=\"\"></p>\n<p>主要分为两个部分：</p>\n<ol>\n<li>对argv的解析</li>\n<li>对环境变量的解析</li>\n</ol>\n<p>对argv的解析不涉及设置opts属性，我们重点看对环境变量的解析：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// support for inheriting config env variables from npm</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> npmConfigPrefix = <span class=\"string\">&#x27;npm_config_&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(process.env).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name.indexOf(npmConfigPrefix) !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> val = process.env[name]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name === npmConfigPrefix + <span class=\"string\">&#x27;loglevel&#x27;</span>) &#123;</span><br><span class=\"line\">    log.level = val</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add the user-defined options to the config</span></span><br><span class=\"line\">    name = name.substring(npmConfigPrefix.length)</span><br><span class=\"line\">    <span class=\"comment\">// gyp@741b7f1 enters an infinite loop when it encounters</span></span><br><span class=\"line\">    <span class=\"comment\">// zero-length options so ensure those don&#x27;t get through.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.opts[name] = val</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"built_in\">this</span>)</span><br></pre></td></tr></table></figure>\n<p>处理流程为：</p>\n<ol>\n<li>判断环境变量的名称（name），如果<strong>不是</strong>以<code>npm_config_</code>开头，则跳过该次处理，否则进入下一步。</li>\n<li>如果变量名是<code>npm_config_loglevel</code>（npm的日志等级变量），则使用该日志等级作为node-gyp在使用npm时候的日志变量（这是对日志等级的特殊处理）。</li>\n<li>否则（一般处理），截断该变量的名，例如<code>name = &#39;npm_config_my_key&#39;</code>，则得到<code>my_key</code>，设置到opts中：<code>opts[&#39;my_key&#39;] = 变量值</code>。</li>\n</ol>\n<p>至此，我们已经知道了，opts属性的值来源于上述的解析。</p>\n<p>那么，回到我们一开始的目的，我们知道了要实现从指定的地方下载node的库文件，只要opts里面存在<code>dist-url</code>或是<code>disturl</code>即可。有些读者可能会说，那这样就行了呀：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/custom-url-by-set-dist-url.jpg\" alt=\"\"></p>\n<p>实际上，并不行：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/just-has-dist_url.jpg\" alt=\"\"></p>\n<p>解析结束后，会发现，gyp.opts中是不存在<code>dist-url</code>字段的，只有<code>dist_url</code>。这一切的缘由，都是因为，npm在处理环境变量的时候，会将<code>-</code>替换为下划线<code>_</code>（<a href=\"https://docs.npmjs.com/cli/v7/using-npm/config#environment-variables\">config | npm Docs (npmjs.com)</a>）。</p>\n<p>好在，node-gyp还能够处理opts中的<code>disturl</code>字段。所以我们只需要在使用npm来使用node-gyp的时候，加入参数<code>--disturl</code>。现在，让我们回到我们一开始的node-addon-demo，添加设置变量的参数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;build&quot;: &quot;node-gyp configure &amp;&amp; node-gyp build&quot;,</span><br><span class=\"line\">  &quot;build:custom&quot;: &quot;npm run build --verbose --disturl=this_is_my_custom_url&quot;,</span><br><span class=\"line\">  &quot;run:demo&quot;: &quot;node index.js&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>上述<code>build:custom</code>就是我们新加的配置，通过运行，果然，加载的是我们制定的url：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gyp verb created nodedir C:\\Users\\w4ngzhen\\AppData\\Local\\node-gyp\\Cache\\14.15.0</span><br><span class=\"line\">&#x2F;&#x2F; 这里报错忽略，因为使用的是一个无效的url: &#39;this_is_my_custom_url&#39;</span><br><span class=\"line\">&#x2F;&#x2F; 主要是为了验证确实是改变了</span><br><span class=\"line\">gyp http GET this_is_my_custom_url&#x2F;v14.15.0&#x2F;node-v14.15.0-headers.tar.gz</span><br><span class=\"line\">gyp WARN install got an error, rolling back install</span><br><span class=\"line\">gyp verb command remove [ &#39;14.15.0&#39; ]</span><br></pre></td></tr></table></figure>\n<h2 id=\"node-gyp的直接使用和npm使用的区别\"><a href=\"#node-gyp的直接使用和npm使用的区别\" class=\"headerlink\" title=\"node-gyp的直接使用和npm使用的区别\"></a>node-gyp的直接使用和npm使用的区别</h2><p>那么，有的细心的读者可能会说，明明这里通过npm使用的时候会转为下划线，那在node-gyp的官方github，说是可以使用<code>dist-url</code>这个参数呢？。</p>\n<p><a href=\"https://github.com/nodejs/node-gyp\">nodejs/node-gyp: Node.js native addon build tool (github.com)</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-05-12-node-gyp-dist-url/official-dist-url.jpg\" alt=\"\"></p>\n<p>实际上，官方文档给出的参数，需要你直接使用node-gyp方式进行设置，也就是说，—dist-url这个参数必须紧跟node-gyp的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node-gyp configure --dist-url&#x3D;xxx</span><br></pre></td></tr></table></figure>\n<p>像是上面的<code>npm run $&#123;使用node-gyp的脚本名&#125; --dist-url=xxx</code>，这个dist-url是作为npm的参数来被识别，而非node-gyp。所以，对于demo，我们还可以如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;build&quot;: &quot;node-gyp configure --dist-url=this_is_my_custom_url &amp;&amp; node-gyp build --dist-url=this_is_my_custom_url&quot;,</span><br><span class=\"line\">  &quot;build:custom&quot;: &quot;npm run build --verbose&quot;,</span><br><span class=\"line\">  &quot;run:demo&quot;: &quot;node index.js&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>注意，这一次，我把<code>--dist-url</code>是放在和node-gyp命令的参数的。但是，我们知道有些npm包，内部就直接使用node-gyp进行配置编译的操作，这个过程没法通过<code>--dist-url</code>紧跟<code>node-gyp</code>命令方式，所以只能在例如<code>.npmrc</code>文件中配置兼容的不会被下划线处理的<code>disturl</code>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>要想让node-gyp下载node库文件的时候，能够走指定的镜像，可以通过配置<code>--dist-url</code>或是<code>--disturl</code>的方式，但配置<code>dist-url</code>形式参数只能是参数紧跟<code>node-gyp</code>的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node-gyp configure --dist-url&#x3D;xxx</span><br></pre></td></tr></table></figure>\n<p>而<strong>不能</strong>是如下的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 你的package.json scripts字段</span><br><span class=\"line\">&quot;build&quot;: &quot;node-gyp configure&quot;</span><br><span class=\"line\">&#x2F;&#x2F; 然后在命令行调用</span><br><span class=\"line\">npm run build --dist-url&#x3D;xxx &#x2F;&#x2F; </span><br></pre></td></tr></table></figure>\n<p>因为此时<code>--dist-url</code>参数是npm的参数，且会被处理为<code>npm_config_dist_url</code>下划线形式，进而在gyp.opts只有dist_url属性。</p>\n<p>所以，最安全的方式是使用disturl参数：</p>\n<p>情况1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node-gyp configure --disturl&#x3D;xxx</span><br></pre></td></tr></table></figure>\n<p>情况2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 你的package.json scripts字段</span><br><span class=\"line\">&quot;build&quot;: &quot;node-gyp configure&quot;</span><br><span class=\"line\">&#x2F;&#x2F; 然后在命令行调用</span><br><span class=\"line\">npm run build --disturl&#x3D;xxx</span><br></pre></td></tr></table></figure>\n<p>情况1下，disturl是作为node-gyp的参数进行解析，能够被设置到opts中。</p>\n<p>情况2，disturl是作为npm的参数被加入到npm环境变量：<code>npm_config_disturl</code>，此时，node-gyp解析process.env的时候，也能解析到<code>disturl</code>进而设置到opts。</p>\n","categories":[],"tags":["node-gyp"]},{"title":"electron-builder进行DEBUG输出的正确方式","url":"http://compilemind.com/2021/04/18/2021-04-18-electron-builder进行DEBUG输出的正确方式/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>使用Electron进行打包通常会用到electron-builder或者electron-packager两种工具。在使用electron-builder的时候，由于对机制的不熟悉，我们在打包过程中常常遇到很多环境错误，但最终只是一些简单的错误信息，难以排查问题。本文将介绍electron-builder进行DEBUG输出的正确方式来帮助排查打包过程中的各种问题。</p>\n<a id=\"more\"></a>\n<h1 id=\"本地node与electron内部的node\"><a href=\"#本地node与electron内部的node\" class=\"headerlink\" title=\"本地node与electron内部的node\"></a>本地node与electron内部的node</h1><p>在对Electron进行打包的时候，需要对当前Electron项目中使用到的node原生C/C++模块进行额外的平台编译，这个过程被称为<code>rebuild</code>。有这样的一个步骤，是因为electron在运行主进程脚本的时候，是跑在了electron内部的一个nodejs环境的，electron内部的nodejs与开发机器上的nodejs并不一定是相同的。为了验证这一论点，我们进行如下的一个测试，来分别打印本地机器安装的node的版本和electon内部的node版本：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/test-show-version1.png\" alt=\"\"></p>\n<p>接下来是electron主进程脚本的node版本显示（main.js）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/test-show-version2.png\" alt=\"\"></p>\n<p>接下来是分别运行<code>npm run show-local-node-version</code>和<code>npm run start</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/show-local-and-inner-version.png\" alt=\"\"></p>\n<p>可以看到输出确实和我们的理解是一致的，版本为11.2.0的electron内部的node版本呢是12，而我们本地机器上的node是14。这也侧面说明了为什么一般的electron应用程序会很大，因为一份electron应用程序，就有一个node的运行时。</p>\n<h1 id=\"electron-builder调试输出正确方式\"><a href=\"#electron-builder调试输出正确方式\" class=\"headerlink\" title=\"electron-builder调试输出正确方式\"></a>electron-builder调试输出正确方式</h1><p>electron-builder进行打包的时候，会建议你在此之前使用<code>electron-builder install-app-deps</code>的命令。该命令的作用就是针对即将打包的electron程序对应的node版本进行原生模块的编译工作，以达到模块运行时匹配。实际上，<code>install-app-deps</code>内部依然使用了<code>node-gyp</code>相关知识，关于这一块的知识，读者可以翻阅我之前的文章《node-pre-gyp以及node-gyp的源码简单解析（以安装sqlite3为例）》来了解，这里不再赘述。本文着重介绍electron-builder如何进行debug打印，好知道打包的过程中发生了什么。</p>\n<ol>\n<li>首先我们准备在项目中，安装一个需要根据平台原生编译的npm包：<code>images</code>。</li>\n<li>然后在package.json中的scripts中添加一段脚本：<code>&quot;installappdeps&quot;: &quot;electron-builder install-app-deps&quot;</code></li>\n<li>最后调用命令<code>npm rum installappdeps</code>执行该脚本</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/images-install-and-run-install-app-deps.png\" alt=\"\"></p>\n<h2 id=\"DEBUG环境变量\"><a href=\"#DEBUG环境变量\" class=\"headerlink\" title=\"DEBUG环境变量\"></a>DEBUG环境变量</h2><p>在<a href=\"https://www.electron.build/#debug\">官方文档</a>中指出了，你可以设置环境变量的方式来方便输出：</p>\n<p>Set the <code>DEBUG</code> environment variable to debug what electron-builder is doing:</p>\n<p>设置<code>DEBUG</code>环境变量值为字符串<code>electron-builder</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEBUG=electron-builder</span><br></pre></td></tr></table></figure>\n<p><code>FPM_DEBUG</code> 环境变量，将会显示更多关于构建Linux平台程序的细节（除了snap和appimage）。</p>\n<ul>\n<li><strong>cmd（Windows CMD）</strong></li>\n</ul>\n<p>On <a href=\"https://github.com/visionmedia/debug#windows-command-prompt-notes\">Windows</a> the environment variable is set using the set command：</p>\n<p>在Windows CMD设置环境变量可以使用如下命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> DEBUG=electron-builder</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>PowerShell</strong></li>\n</ul>\n<p>PowerShell uses different syntax to set environment variables：</p>\n<p>PowerShell使用不同的语法来设置环境变量：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$env:DEBUG</span>=electron<span class=\"literal\">-builder</span></span><br></pre></td></tr></table></figure>\n<p>在我们的机器上，我们同样设置该环境变量，然后执行：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/install-app-deps-with-DEBUG.png\" alt=\"\"></p>\n<p>发现输出了大量的关于electron-builder的DEBUG打印，为我们了解<code>electron-builder install-app-deps</code>提供了更多的信息。</p>\n<h2 id=\"verbose参数\"><a href=\"#verbose参数\" class=\"headerlink\" title=\"verbose参数\"></a>verbose参数</h2><p>然而，有的时候光是设置上述<code>DEBUG</code>环境变量还不够，因为electron-builder内部在进行rebuild操作的时候，还会以子进程方式调用<code>node-gyp</code>等工具，这些工具可不会查看上面的环境变量来输出调试信息的。我们需要在electron-builder调用node-gyp的时候，还能够打印这些工具的调试信息。熟悉node的读者可能会说，那我使用<code>electron-builder</code>的时候，传入<code>--verbose</code>怎么样？就像如下的方式：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;installappdeps&quot;: &quot;electron-builder install-app-deps --verbose&quot;</span><br></pre></td></tr></table></figure>\n<p>不幸的是，虽然<code>--verbose</code>能被node-gyp识别，无法被electron-builder识别，。当你直接这么调用的时候，会出错：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/electron-cannot-recognise-verbose.png\" alt=\"\"></p>\n<p>那么要如何解决这个问题呢？正确的做法是编写两个<code>scripts</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;scripts&quot;: &#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">   &quot;installappdeps&quot;: &quot;electron-builder install-app-deps&quot;,</span><br><span class=\"line\">   &quot;installappdeps-with-verbose&quot;: &quot;npm run installappdeps --verbose&quot;</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure>\n<p>然后在想要进行verbose打印的时候，执行<code>npm rum installappdeps-with-verbose</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-04-18-electron-builder/after-use-two-scripts-output.png\" alt=\"\"></p>\n<p>可以看到，在install-app-deps的DEBUG打印前，我们还看到node给出的一些额外信息。</p>\n","categories":[],"tags":["electron","electron-builder"]},{"title":"使用CEF（三）— 从CEF官方Demo源码入手解析CEF架构与CefApp、CefClient对象","url":"http://compilemind.com/2021/03/31/2021-03-31-使用CEF（三）— 从CEF官方Demo源码入手解析CEF架构与CefApp、CefClient对象/","content":"<p>在上文《使用CEF（2）— 基于VS2019编写一个简单CEF样例》中，我们介绍了如何编写一个CEF的样例，在文章中提供了一些代码清单，在这些代码清单中提到了一些CEF的定义的类，例如<code>CefApp</code>、<code>CefClient</code>等等。它们具体有什么作用，和CEF的进程架构有什么关系呢？本文将逐一进行介绍。</p>\n<a id=\"more\"></a>\n<h1 id=\"CEF的进程架构\"><a href=\"#CEF的进程架构\" class=\"headerlink\" title=\"CEF的进程架构\"></a>CEF的进程架构</h1><blockquote>\n<p>CEF3 runs using multiple processes. The main process which handles window creation, painting and network access is called the “browser” process. This is generally the same process as the host application and the majority of the application logic will run in the browser process. Blink rendering and JavaScript execution occur in a separate “render” process. Some application logic, such as JavaScript bindings and DOM access, will also run in the render process. The default <a href=\"http://www.chromium.org/developers/design-documents/process-models\">process model</a> will spawn a new render process for each unique origin (scheme + domain). Other processes will be spawned as needed, such as “plugin” processes to handle <a href=\"http://www.chromium.org/developers/design-documents/plugin-architecture\">plugins</a> like Flash and “gpu” processes to handle <a href=\"http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome\">accelerated compositing</a>.</p>\n</blockquote>\n<p>CEF3使用多个进程运行。处理窗口创建、绘制和网络访问的主要进程称为<strong>浏览器进程</strong>。这通常与宿主应用程序的进程相同，大多数应用程序的逻辑将在浏览器进程中运行。使用Blink引擎渲染HTML和JavaScript执行在单独的<strong>渲染进程</strong>中发生。一些应用程序逻辑（如JavaScript绑定和DOM访问）也将在渲染进程中运行。默认进程模型将为每个唯一源地址（scheme+domain）运行一个新的渲染进程。其他进程将根据需要生成，例如处理Flash等插件的<strong>插件进程</strong>和处理加速合成的<strong>GPU进程</strong>。综合上述文档，我们整理一下：</p>\n<p>浏览器进程（Browser Process）：</p>\n<ul>\n<li>窗口创建、绘制</li>\n<li>网络访问</li>\n<li>……</li>\n</ul>\n<p>渲染进程（Renderer Process）：</p>\n<ul>\n<li><p>通过Blink引擎渲染HTML</p>\n</li>\n<li><p>JavaScript执行（V8引擎）</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<p>需要注意的是，<strong>浏览器进程</strong>中会进行窗口绘制，并不是指绘制HTML内容，而是承载网页内容的那个窗体壳，同样<strong>渲染进程</strong>也不是用来创建窗体的进程。接下来，本人将以官方CefSimple Demo源码入手，逐步介绍Cef的概念。</p>\n<p>本来本人想要使用上一文中的编写的simple-cef进行源码解析，但是为了让本文相对的独立，所以还是决定使用官方的Demo：cefsimple进行源码解析。尽管和simple-cef项目的内容差别不大。需要注意的是一下的源码在解析的时候，会进行适当的删改，读者最好对照源码进行阅读更佳。<strong>PS：源码中显示<code>......</code>表明示例代码有所删除。</strong></p>\n<h2 id=\"cefsimple-win-cc\"><a href=\"#cefsimple-win-cc\" class=\"headerlink\" title=\"cefsimple_win.cc\"></a>cefsimple_win.cc</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// Entry point function for all processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> APIENTRY <span class=\"title\">wWinMain</span><span class=\"params\">(HINSTANCE hInstance,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      HINSTANCE hPrevInstance,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      LPTSTR lpCmdLine,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">int</span> nCmdShow)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// CEF applications have multiple sub-processes (render, plugin, GPU, etc)</span></span><br><span class=\"line\">  <span class=\"comment\">// that share the same executable. This function checks the command-line and,</span></span><br><span class=\"line\">  <span class=\"comment\">// if this is a sub-process, executes the appropriate logic.</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> exit_code = CefExecuteProcess(main_args, <span class=\"literal\">nullptr</span>, sandbox_info);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exit_code &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// The sub-process has completed so return here.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> exit_code;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// SimpleApp implements application-level callbacks for the browser process.</span></span><br><span class=\"line\">  <span class=\"comment\">// It will create the first browser instance in OnContextInitialized() after</span></span><br><span class=\"line\">  <span class=\"comment\">// CEF has initialized.</span></span><br><span class=\"line\">  <span class=\"function\">CefRefPtr&lt;SimpleApp&gt; <span class=\"title\">app</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleApp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Initialize CEF.</span></span><br><span class=\"line\">  CefInitialize(main_args, settings, app.<span class=\"built_in\">get</span>(), sandbox_info);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Run the CEF message loop. This will block until CefQuitMessageLoop() is</span></span><br><span class=\"line\">  <span class=\"comment\">// called.</span></span><br><span class=\"line\">  CefRunMessageLoop();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Shut down CEF.</span></span><br><span class=\"line\">  CefShutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>首先第一个重要点是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">// CEF applications have multiple sub-processes (render, plugin, GPU, etc)</span></span><br><span class=\"line\">   <span class=\"comment\">// that share the same executable. This function checks the command-line and,</span></span><br><span class=\"line\">   <span class=\"comment\">// if this is a sub-process, executes the appropriate logic.    </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> exit_code = CefExecuteProcess(main_args, <span class=\"literal\">nullptr</span>, sandbox_info);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (exit_code &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// The sub-process has completed so return here.</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> exit_code;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码看起来有点奇怪，对于英文的翻译如下：</p>\n<blockquote>\n<p>CEF应用程序会创建多个子进程（渲染render，插件plugin，GPU处理，等等）但是会共用一个可执行程序。以下的函数会检查命令行并且，如果确认是一个子进程，那么会执行相关的逻辑。</p>\n</blockquote>\n<p>然后，我们查看该函数：<code>CefExecuteProcess</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// This function should be called from the application entry point function to</span></span><br><span class=\"line\"><span class=\"comment\">// execute a secondary process. It can be used to run secondary processes from</span></span><br><span class=\"line\"><span class=\"comment\">// the browser client executable (default behavior) or from a separate</span></span><br><span class=\"line\"><span class=\"comment\">// executable specified by the CefSettings.browser_subprocess_path value. If</span></span><br><span class=\"line\"><span class=\"comment\">// called for the browser process (identified by no &quot;type&quot; command-line value)</span></span><br><span class=\"line\"><span class=\"comment\">// it will return immediately with a value of -1. If called for a recognized</span></span><br><span class=\"line\"><span class=\"comment\">// secondary process it will block until the process should exit and then return</span></span><br><span class=\"line\"><span class=\"comment\">// the process exit code. The |application| parameter may be empty. The</span></span><br><span class=\"line\"><span class=\"comment\">// |windows_sandbox_info| parameter is only used on Windows and may be NULL (see</span></span><br><span class=\"line\"><span class=\"comment\">// cef_sandbox_win.h for details).</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/*--cef(api_hash_check,optional_param=application,</span></span><br><span class=\"line\"><span class=\"comment\">        optional_param=windows_sandbox_info)--*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CefExecuteProcess</span><span class=\"params\">(<span class=\"keyword\">const</span> CefMainArgs&amp; args,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      CefRefPtr&lt;CefApp&gt; application,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">void</span>* windows_sandbox_info)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>翻译：</p>\n<blockquote>\n<p>该函数应当在应用程序的入口函数处被调用，用以执行一个子进程。它可以用于执行一个可执行程序来启动一个子进程，该可执行程序可以是当前的浏览器客户端可执行程序（默认行为）或是通过设置CefSettings.browser_subprocess_path指定路径的可执行程序。如果被调用用于浏览器进程（在启动命令行中没有”type”参数），该函数会立刻返回<code>-1</code>。如果被调用时识别为子进程，该函数将会阻塞直到子进程退出并且返回子进程退出的返回码。<code>application</code>参数可以为空（null）。<code>windows_sandbox_info</code>参数只能在Windows上使用或设置为NULL（详见cef_sandbox_win.h）</p>\n</blockquote>\n<p>从这段话我们不难推断出，CEF在以多进程架构下启动的时候，会多次启动自身可执行程序。启动的时候，会通过命令行参数传入某些标识，由<code>CefExecuteProcess</code>内部进行判断。如果是主进程，则该函数立刻返回-1，程序会继续执行下去，那么后续继续运行的代码全部都运行在主进程中；如果是子进程（渲染进程等），那么该函数会阻塞住，直到子进程结束后，该函数会返回一个大于等于0的值，并在main函数直接返回，进而退出。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/CefExecuteProcess-flow.jpg\" alt=\"\"></p>\n<p>对CefExecuteProcess分析就到这里，细节可以阅读<a href=\"https://bitbucket.org/chromiumembedded/cef/wiki/GeneralUsage.md#markdown-header-entry-point-function\">官方文档</a>，我们继续后续的代码分析：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SimpleApp implements application-level callbacks for the browser process.</span></span><br><span class=\"line\"><span class=\"comment\">// It will create the first browser instance in OnContextInitialized() after</span></span><br><span class=\"line\"><span class=\"comment\">// CEF has initialized.</span></span><br><span class=\"line\"><span class=\"function\">CefRefPtr&lt;SimpleApp&gt; <span class=\"title\">app</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleApp)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>注释翻译如下</p>\n<blockquote>\n<p>SimpleApp实现了对于浏览器进程在应用级别的回调。该实例CEF初始化后（initialized），在OnContextInitialized中会创建第一个browser实例</p>\n</blockquote>\n<p>查看SimpleApp的声明，发现该类继承了CefApp：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SimpleApp : public CefApp, public CefBrowserProcessHandler &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">  SimpleApp();</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是，我们迎来了第一个重要的类：CefApp。</p>\n<h2 id=\"CefApp\"><a href=\"#CefApp\" class=\"headerlink\" title=\"CefApp\"></a>CefApp</h2><p>CefApp在官方文档中，就写了一句话介绍：</p>\n<blockquote>\n<p>The <a href=\"http://magpcss.org/ceforum/apidocs3/projects/(default\">CefApp</a>/CefApp.html) interface provides access to process-specific callbacks.</p>\n<p>CefApp接口提供了指定进程的回调访问。</p>\n</blockquote>\n<p>本人一开始看到CefApp时，想到上面提到的CEF的多进程架构，结合后文还会提到的CefClient，以为所谓CefApp就是指浏览器进程，CefClient就对应其他的进程（一个App对应多个Client，多么的自然的理解），<strong>然而这样错误的理解</strong>，让本人在阅读代码的时候走了很大的弯路。</p>\n<p>首先，我们看一下CefApp的头文件声明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CefApp</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> CefBaseRefCounted &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnBeforeCommandLineProcessing</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">const</span> CefString&amp; process_type,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CefRefPtr&lt;CefCommandLine&gt; command_line)</span> </span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnRegisterCustomSchemes</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CefRawPtr&lt;CefSchemeRegistrar&gt; registrar)</span> </span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefResourceBundleHandler&gt; <span class=\"title\">GetResourceBundleHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefBrowserProcessHandler&gt; <span class=\"title\">GetBrowserProcessHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefRenderProcessHandler&gt; <span class=\"title\">GetRenderProcessHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>先看其中有两个本文讨论的重点方法：<code>GetBrowserProcessHandler</code>、<code>GetRenderProcessHandler</code>。它们的文档注释如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// Return the handler for functionality specific to the browser process. This</span></span><br><span class=\"line\"><span class=\"comment\">// method is called on multiple threads in the browser process.</span></span><br><span class=\"line\"><span class=\"comment\">// 返回浏览器进程特定功能的处理程序。在浏览器进程中的多个线程上调用此方法。</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefBrowserProcessHandler&gt; <span class=\"title\">GetBrowserProcessHandler</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">///</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// Return the handler for functionality specific to the render process. This</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// method is called on the render process main thread.</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 返回渲染进程特定功能的处理程序。在渲染进程中的主线程上调用此方法。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">///</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefRenderProcessHandler&gt; <span class=\"title\">GetRenderProcessHandler</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>读者看到这些注释可能会疑问：为什么注释中一会儿说在浏览器进程中一会儿又说在渲染进程中？难道这个类的实例还会在多个进程中使用吗？对也不对。这个类的实例确实会在浏览器进程和渲染进程中使用，但是我们又知道，两个进程之间的资源是不共享的，包括类实例，所以在浏览器进程运行的过程中，会使用到CefApp的某个实例化对象，而在渲染进程的运行过程中，又会使用到CefApp另一个实例化对象，它们都是CefApp子类的实例，但一定不是同一个实例对象。</p>\n<p>我们可以这样理解：一个CefApp对应了一个进程，而一个进程可以是浏览器进程（Browser Process），可以是渲染进程（Renderer Process）。因此，CefApp提供了GetBrowserProcessHandler和GetRendererProcessHandler来分别在相关进程中获取对应的handler。</p>\n<p>这两个方法的实现由我们来决定，即我们可以通过编程方式来返回handler，<strong>但这两个方法不会由我们客户端代码进行调用</strong>，而是CEF在运行过程中，由CEF在某个时刻来回调这两个方法。所以，这里虽然写了两个GetXXXProcessHandler，但在<strong>浏览器进程</strong>和<strong>渲染进程</strong>中只会<strong>分别</strong>调用GetBrowserProcessHandler和GetRendererProcessHandler。</p>\n<p>按照程序运行的角度讲，当浏览器进程运行的时候，CEF框架就会在某个时候调用CefApp::GetBrowserProcessHandler获得由我们定义的BrowserProcessHandler实例，这个实例会在适当的时候调用它提供的一些方法（后文介绍有哪些方法）；当渲染进程运行的时候，CEF框架就会在某个时候调用CefApp::GetRendererProcessHandler得到我们定义的RendererProcessHandler实例，然后在适当的时候调用RenererProcessHandler中的一些方法（后文介绍有哪些方法）。</p>\n<p>在cefsimple的示例代码中只有一个SimpleApp是继承的CefApp，这个类还继承了CefBrowserHandler，表明自身是同时也是CefBrowserHandler，这样实现的<code>GetBrowserProcessHandler</code>就返回自身。那么CEF是如何将我们的CefApp实例关联到CEF运行中的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SimpleApp implements application-level callbacks for the browser process.</span></span><br><span class=\"line\"><span class=\"comment\">// It will create the first browser instance in OnContextInitialized() after</span></span><br><span class=\"line\"><span class=\"comment\">// CEF has initialized.</span></span><br><span class=\"line\"><span class=\"function\">CefRefPtr&lt;SimpleApp&gt; <span class=\"title\">app</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleApp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initialize CEF.</span></span><br><span class=\"line\">CefInitialize(main_args, settings, app.<span class=\"built_in\">get</span>(), sandbox_info);</span><br></pre></td></tr></table></figure>\n<p>注意CefInitialize中的<code>app.get()</code>参数，就是将我们的CefApp关联到CEF的运行中的。那么，有些读者会有疑问，在示例代码中，只看到我们创建的SimpleApp类继承了CefApp，并通过<code>GetBrowserProcessHandler</code>返回自身来表明是一个浏览器进程的回调实例，并没有看到体现渲染进程的代码呢？确实，cefsimple作为helloworld级别的代码，没有体现这一点。在cefclient示例代码中（更高阶的CEF示例，也更复杂），你会看到：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cefclient-app-browser.jpg\" alt=\"\"></p>\n<p>上图是浏览器进程CefApp子类ClientAppBrowser（这里的”Client“是cefclient示例代码的“client”，请勿和下文的CefClient类混淆）。</p>\n<p>同时你还能找到一个CefApp子类ClientAppRenderer：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cefclient-app-renderer.jpg\" alt=\"\"></p>\n<p>你甚至还能找到一个名为ClientAppOther的CefApp子类：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cefclient-app-other.jpg\" alt=\"\"></p>\n<p>那么它们在哪儿被使用到呢？</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/where-use-CefApp.jpg\" alt=\"\"></p>\n<p>看到这里，我相信绝大多数的读者应该能够理解我所说的CefApp代表的是一个进程的抽象了。这块的大体流程是，通过一个工具函数<code>GetProcessType</code>从命令行中解析<code>--type=xxx</code>（浏览器进程没有这个命令参数）来判断进程的类型，然后实例化对应的CefApp子类，最后通过<code>CefExecuteProcess</code>来运行进程。</p>\n<p>在介绍了CefApp的基本概念以后，我们可以继续分析<code>SimpleApp</code>。</p>\n<p>通过上文，我们知道SimpleApp是CefApp子类，并且通过只会在浏览器进程中，会使用到该类的实例，因为实现了接口<code>CefBrowserProcessHandler</code>，并且有如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CefApp methods:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefBrowserProcessHandler&gt; <span class=\"title\">GetBrowserProcessHandler</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    OVERRIDE </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在CEF中，作为<code>CefBrowserProcessHandler</code>，有哪些回调可以供我们定制呢？下面是头文件声明，并且我也写了下概要注释：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CefBrowserProcessHandler</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> CefBaseRefCounted &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Cookie处理定制化</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetCookieableSchemes</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;CefString&gt;&amp; schemes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    <span class=\"keyword\">bool</span>&amp; include_defaults)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在CEF上下文初始化后，在浏览器进程UI线程中进行调用。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnContextInitialized</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可定制化处理子进程启动时的命令行参数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnBeforeChildProcessLaunch</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CefRefPtr&lt;CefCommandLine&gt; command_line)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 打印处理</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefPrintHandler&gt; <span class=\"title\">GetPrintHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义消息循环的时候，消息循环的频率</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnScheduleMessagePumpWork</span><span class=\"params\">(int64 delay_ms)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取默认的CefClient</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefClient&gt; <span class=\"title\">GetDefaultClient</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过阅读该Handler的头文件以及每个函数的调用说明，我们继续阅读在<code>SimpleApp::OnContextInitialized</code>这个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleApp::OnContextInitialized</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">  CefRefPtr&lt;CefCommandLine&gt; command_line =</span><br><span class=\"line\">      CefCommandLine::GetGlobalCommandLine();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> enable_chrome_runtime =</span><br><span class=\"line\">      command_line-&gt;HasSwitch(<span class=\"string\">&quot;enable-chrome-runtime&quot;</span>); <span class=\"comment\">// 是否启用chrome运行时</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(OS_WIN) || defined(OS_LINUX)</span></span><br><span class=\"line\">    <span class=\"comment\">// Create the browser using the Views framework if &quot;--use-views&quot; is specified</span></span><br><span class=\"line\">    <span class=\"comment\">// via the command-line. Otherwise, create the browser using the native</span></span><br><span class=\"line\">    <span class=\"comment\">// platform framework. The Views framework is currently only supported on</span></span><br><span class=\"line\">    <span class=\"comment\">// Windows and Linux.</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果命令行中指定了&quot;--use-views&quot;，那么使用CEF自己的视图框架（Views framework）</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则使用操作系统原生API。视图框架目前只支持Windows和Linux。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views = command_line-&gt;HasSwitch(<span class=\"string\">&quot;use-views&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// SimpleHandler implements browser-level callbacks.</span></span><br><span class=\"line\">  <span class=\"function\">CefRefPtr&lt;SimpleHandler&gt; <span class=\"title\">handler</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleHandler(use_views))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Specify CEF browser settings here.</span></span><br><span class=\"line\">  CefBrowserSettings browser_settings;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> url;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Check if a &quot;--url=&quot; value was provided via the command-line. If so, use</span></span><br><span class=\"line\">  <span class=\"comment\">// that instead of the default URL.</span></span><br><span class=\"line\">  url = command_line-&gt;GetSwitchValue(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (url.empty())</span><br><span class=\"line\">    url = <span class=\"string\">&quot;http://www.google.com&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (use_views &amp;&amp; !enable_chrome_runtime) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the BrowserView.</span></span><br><span class=\"line\">    CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(</span><br><span class=\"line\">        handler, url, browser_settings, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> SimpleBrowserViewDelegate());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Create the Window. It will show itself after creation.</span></span><br><span class=\"line\">    CefWindow::CreateTopLevelWindow(<span class=\"keyword\">new</span> SimpleWindowDelegate(browser_view));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Information used when creating the native window.</span></span><br><span class=\"line\">    CefWindowInfo window_info;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(OS_WIN)</span></span><br><span class=\"line\">    <span class=\"comment\">// On Windows we need to specify certain flags that will be passed to</span></span><br><span class=\"line\">    <span class=\"comment\">// CreateWindowEx().</span></span><br><span class=\"line\">    window_info.SetAsPopup(<span class=\"literal\">NULL</span>, <span class=\"string\">&quot;cefsimple&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Create the first browser window.</span></span><br><span class=\"line\">    CefBrowserHost::CreateBrowser(window_info, handler, url, browser_settings,</span><br><span class=\"line\">                                  <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这段代码，我整理了如下流程，方便读者对照阅读：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cef-SimpleApp-OnContextInitialized.jpg\" alt=\"\"></p>\n<p>在这个流程中，最关键的3个部分被我用红色标记出来：</p>\n<ol>\n<li>SimpleHandler（CefClient子类）；</li>\n<li>使用CEF的窗体视图框架创建CefBrowserView和CefWindow；</li>\n<li>使用操作系统原生API构建窗体。</li>\n</ol>\n<p>整个过程中会创建CefClient的子类实例，然后通过CEF提供的API来将CefClient和窗体结合在一起。</p>\n<p><strong>对于使用CEF自己的视图框架，有如下的步骤：</strong></p>\n<ol>\n<li>首先是调用CefBrowserView::CreateBrowserView得到CefBrowserView实例，这个过程会把CefClient实例和View对象通过API绑定。</li>\n<li>调用CefWindow::CreateTopLevelWindow，传入CefBrowserView实例来创建窗体。</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cef-use-CEF-Views.jpg\" alt=\"\"></p>\n<p><strong>对于使用操作系统原生API创建浏览器窗体，主要是如下步骤：</strong></p>\n<ol>\n<li>使用CefWindowInfo设置窗体句柄</li>\n<li>调用CefBrowserHost::CreateBrowser将对应窗体句柄的窗体和CefClient绑定起来</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/cef-use-OS-native-Views.jpg\" alt=\"\"></p>\n<p>当然，上述两个窗体的创建过程涉及到CEF的窗体模块，我们不在这里细说，但是两个流程都离不开一个重要的类：CefClient，它具体是什么呢？接下来，我们将对CefClient进行介绍，并对SimpleHandler这个类（CefClient子类）进行一定的源码分析。</p>\n<h2 id=\"CefClient\"><a href=\"#CefClient\" class=\"headerlink\" title=\"CefClient\"></a>CefClient</h2><p>在官方的文档，描述了CefClien的概念：</p>\n<blockquote>\n<p>The <a href=\"http://magpcss.org/ceforum/apidocs3/projects/(default\">CefClient</a>/CefClient.html) interface provides access to browser-instance-specific callbacks. A single CefClient instance can be shared among any number of browsers. Important callbacks include:</p>\n<p>CefClient接口提供对特定于浏览器实例的回调的访问。一个CefClient实例可以在任意数量的浏览器之间共享。重要的回调包括：</p>\n<ul>\n<li>Handlers for things like browser life span, context menus, dialogs, display notifications, drag events, focus events, keyboard events and more. The majority of handlers are optional. See the documentation in cef_client.h for the side effects, if any, of not implementing a specific handler.</li>\n<li>所有的Handler，例如浏览器的生命周期，上下文菜单，对话框，显示通知，拖动事件，焦点事件，键盘事件等。大多数处理程序是可选的。请参阅cef_client.h中的文档，以了解不实施特定处理程序的副作用（如果有）。</li>\n<li><strong>OnProcessMessageReceived</strong> which is called when an IPC message is received from the render process. See the “Inter-Process Communication” section for more information.</li>\n<li>从渲染过程中接收到IPC消息时调用的OnProcessMessageReceived。有关更多信息，请参见“进程间通信”部分。</li>\n</ul>\n</blockquote>\n<p>首先需要解释一下什么什么是特定浏览器实例，实际上，指的是以下过程产生的浏览器实例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(</span><br><span class=\"line\">        handler, url, browser_settings, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> SimpleBrowserViewDelegate());</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">    CefBrowserHost::CreateBrowser(window_info, handler, url, browser_settings,</span><br><span class=\"line\">                                  <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br></pre></td></tr></table></figure>\n<p>通过上述两种方式创建的浏览器实例，是一个概念上的实例，并不是指你能看得到的浏览器的窗口，窗口只是浏览器实例的宿主而已。而浏览器中发生的事件，例如：生命周期的变化，对话框等，都只会通过CefClient中返回的各种类型Handler以及这些Handler接口实例提供的方法回调。</p>\n<p>下面时CefClient的声明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CefClient</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> CefBaseRefCounted &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefAudioHandler&gt; <span class=\"title\">GetAudioHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefContextMenuHandler&gt; <span class=\"title\">GetContextMenuHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDialogHandler&gt; <span class=\"title\">GetDialogHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDisplayHandler&gt; <span class=\"title\">GetDisplayHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDownloadHandler&gt; <span class=\"title\">GetDownloadHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDragHandler&gt; <span class=\"title\">GetDragHandler</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...... 还有很多的Handler</span></span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个CefClient提供了很多<code>GetXXXHandler</code>方法，这些方法会在合适的时候，被CEF调用以得到对应的Handler，然后再调用返回的Handler中的方法。例如，HTML页面中的Title发生变化的时候，就会调用<code>CefClient::CefDisplayHandler()</code>得到一个CefDisplayHandler实例，然后再调用其中的<code>CefDisplayHandler::OnTitleChange</code>，而这些过程不是我们调用的，而是CEF框架完成的。只是具体的实现有我们客户端代码编写。</p>\n<p>那么现在思考一下，为什么会有这个CefClient呢？在本人看来主要是如下的理由：</p>\n<p>在CefClient中各种回调的事件，本质上发生的地方是渲染进程。因为每当一个浏览器实例（不是浏览器进程）创建的时候，会有一个对应的渲染进程创建（也可能由于配置，而共用一个，这里先认为默认多个一对一）。渲染进程中发生的各种V8事件、下载事件，显示事件等触发后，会通过<strong>进程间通讯</strong>给到浏览器进程，然后在浏览器进程中找到与之相关的CefClient，然后从CefClient中找到对应的Handler，回调Handler对应的方法。</p>\n<p>也就是说，将在渲染进程发生的事件，用在浏览器进程中的CefClient一定的抽象映射，而不是直接在浏览器进程处理器中进行，因为一个浏览器进程可能会创建多个渲染进程，让CefClient作为中间层避免耦合。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-31-use-cef-3/CefClientAndRenderer.jpg\" alt=\"\"></p>\n<p>当然，文档也为我们指出，CefClient实例与浏览器实例可以不是一一对应的，多个浏览器实例可以共享一个CefClient，如此一来我们也可以总结关于CefClient的一点：<strong>非必要情况，不要编写具有状态的CefClient</strong>。</p>\n<p>至此，我们通过对Demo源码入手，对CefApp和CefClient已经有了一个整体的认识，读者可以阅读官方文档来更加深入的了解：<a href=\"https://bitbucket.org/chromiumembedded/cef/wiki/GeneralUsage.md#markdown-header-application-structure\">官方文档</a>。</p>\n","categories":[],"tags":["CEF"]},{"title":"Windows下node-gyp查找VS安装路径简单解析","url":"http://compilemind.com/2021/03/27/2021-03-27-Windows下node-gyp查找VS安装路径简单解析/","content":"<p>node-gyp的作用我已经不想赘述了，这里给一个我之前文章的链接：<a href=\"https://www.cnblogs.com/w4ngzhen/p/14086497.html\">cnblogs看这里</a>，<a href=\"https://zhuanlan.zhihu.com/p/330468774\">知乎看这里</a>。本文主要从源码入手，介绍node-gyp查找VisualStudio的过程</p>\n<a id=\"more\"></a>\n<p>为了方便我们研究node-gyp的源码，我们随意创建一个node项目，然后我们npm install node-gyp，安装node-gyp这个包来开始我们源码探索之路吧。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E:\\Projects\\node<span class=\"literal\">-gyp</span><span class=\"literal\">-demo</span>&gt; npm init</span><br><span class=\"line\">...</span><br><span class=\"line\">package name: (gyp<span class=\"literal\">-demo</span>)</span><br><span class=\"line\">version: (<span class=\"number\">1.0</span>.<span class=\"number\">0</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install node-gyp@latest // 安装最新的node-gyp</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在项目/node_modules/node-gyp中，已经有了我们需要的node-gyp的js脚本代码：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/gyp-lib-dir-position.jpg\" alt=\"\"></p>\n<p>那么，我们应该怎么入手呢？这里需要再次提到node-gyp的处理过程，主要分为两个步骤：</p>\n<ol>\n<li>configure</li>\n</ol>\n<p>gyp首先根据C/C++源码目录下的binding.gyp文件+操作系统（Windows、macOS以及Linux）+编译构建工具（Windows下的VS，macOS以及Linux下的make）来决定生成什么样的项目结构（Windows下的sln以及vcxproj、macOS以及Linux下的make项目）这一步是<em>configure</em>配置过程，不会进行源码的编译，仅仅是生成能够作为对应平台下对应编译工具输入的项目结构。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/node-gyp-configure-flow.jpg\" alt=\"\"></p>\n<ol>\n<li>build</li>\n</ol>\n<p>生成项目结构以后，执行build过程调用对应的编译工具完成编译任务。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/node-gyp-build-flow.jpg\" alt=\"\"></p>\n<p>所以，我们首先查看lib/configure.js文件，试着从源码中探索一下。进入configure.js，一下就可以看到我们期望的东西（图片顶部显示了js代码位置）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/gyp-configure-portal-code.jpg\" alt=\"\"></p>\n<p>如果当前进程平台是<code>win32</code>（Windows操作系统标识），则会引入模块<code>find-visualstudio</code>。暂时停止阅读configure.js的代码，直接上我们的主角：<code>find-visualstudio.js</code></p>\n<h2 id=\"find-visualstudio-js\"><a href=\"#find-visualstudio-js\" class=\"headerlink\" title=\"find-visualstudio.js\"></a>find-visualstudio.js</h2><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/visualStudioFinder-class-def.jpg\" alt=\"\"></p>\n<p>在该文件中定义了一个名为<code>VisualStudioFinder</code>的类，查找的过程就是执行创建该类的一个实例，并调用实例的一个名为<code>findVisualStudio</code>的方法。该方法被定义在该类的原型里：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/method-the-findVisualStudio.png\" alt=\"\"></p>\n<p>对于该函数来说，主要分为了三个步骤：</p>\n<ol>\n<li>对于参数msvs_version的处理</li>\n<li>对于环境变量VSINSTALLDIR的处理</li>\n<li>查找各个版本的VS</li>\n</ol>\n<p>对于步骤1和2，我们暂时不进行解析，主要解析步骤3。因为绝大多数开发者就卡在这个步骤，导致安装需要原生编译的node模块失败。对于步骤3来说，我们不难看出处理的过程是优先查找本地的vs2017以及更高的版本，然后是vs2015，最后是vs2013，所以开发者Windows机器上没有安装VS或者是不在源码中支持的范围都一定会报错，提示VS找不到。我们首先解析<code>findVisualStudio2017OrNewer</code>这个函数，然后解析<code>findVisualStudio2015</code>和<code>findVisualStudio2013</code>，对于后两个，实际上最终都是相同的逻辑，后面会提到。</p>\n<h3 id=\"findVisualStudio2017OrNewer\"><a href=\"#findVisualStudio2017OrNewer\" class=\"headerlink\" title=\"findVisualStudio2017OrNewer\"></a>findVisualStudio2017OrNewer</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/func-findVisualStudio2017OrNewer.png\" alt=\"\"></p>\n<p>该函数的签名表示，这个函数是通过调用PowerShell脚本来获取关于VS2017或是更高版本VS的安装信息。</p>\n<p>那么这段代码的运行情况到底如何呢？我们将该段代码单独拿出来，并将<code>Find-VisualStudio.cs</code>拷贝到运行目录下来Debug它。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/mock-findVisualStudio2017OrNewer.png\" alt=\"\"></p>\n<p>上图中，我模拟了node-gyp中查询VS2017以上版本的函数，通过Debug方式断点调试：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/use-powershell.jpg\" alt=\"\"></p>\n<p><code>ps</code>变量值为：<code>C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe</code>，即为Windows下对应的最初版本的PowerShell。cs文件不再赘述，我们也不对CSharp代码解读了。代码的最后就是执行弄得的chile_process模块中的<code>execFile</code>函数，通过传入可执行程序的完整路径已经执行参数，完成外部程序调用。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/execFile-stdout.jpg\" alt=\"\"></p>\n<p>而在这一步当中，如果执行出现了异常就会导致node-gyp的执行过程出现异常，进而导致需要原生编译的模块无法完成安装等。为了方便开发人员进行在Windows上查找VS2017以及以上版本，我把这段代码和CSharp代码提取出来，放在了<a href=\"https://github.com/w4ngzhen/node-gyp-find-vs-check\">github仓库（w4ngzhen/node-gyp-find-vs-check）</a>，读者如果出现了问题，可以直接下载脚本和CSharp代码进行环境的确认。</p>\n<p>当然，有些读者的机器还是VS2015或者VS2013等版本，我们继续分析。</p>\n<h3 id=\"findVisualStudio2015-2013\"><a href=\"#findVisualStudio2015-2013\" class=\"headerlink\" title=\"findVisualStudio2015/2013\"></a>findVisualStudio2015/2013</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/method-findVs2015Or2013.jpg\" alt=\"\"></p>\n<p>通过源码可以知道，最终都调用了方法：<code>findOldVS</code>，并且还知道，nodejs的主版本大于等于9时，根本不会查找VS了。接下来我们查看方法<code>findOldVs</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-27-node-gyp/method-findOldVS.jpg\" alt=\"\"></p>\n<p>对于该段代码，其实一点也不难理解，就是根据注册表上对应的键去查找的VS的安装路径（PS：好像又学习到了VS的安装路径可以从注册表里面查看呢！）对于该段代码，本人不提供demo代码帮助查询了。有兴趣的读者可以自己提取代码，模拟调用。</p>\n","categories":[],"tags":["node-gyp"]},{"title":"Windows下的程序及热键监视神器——Spy++","url":"http://compilemind.com/2021/03/09/2021-03-09-Windows下的程序及热键监视神器——Spy++/","content":"<h1 id=\"Windows下的程序及热键监视神器——Spy\"><a href=\"#Windows下的程序及热键监视神器——Spy\" class=\"headerlink\" title=\"Windows下的程序及热键监视神器——Spy++\"></a>Windows下的程序及热键监视神器——Spy++</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在使用Windows的时候，偶尔会发现某些应用程序的热键不生效了；又或是桌面弹出了弹框却并不知道这个弹框来自何处。例如，本人最近使用Vim的时候，发现创建分屏后，无法使用<code>ctrl+w</code>快捷键完成切屏操作，一开始以为是Vim配置出现了问题，后来发现就连Edge浏览器的<code>ctrl+w</code>关闭页面都无法完成，仔细一想才觉得是热键被占用了，这时候就要祭出Windows下一款简单的神器Spy++。</p>\n<a id=\"more\"></a>\n<h2 id=\"如何获取Spy\"><a href=\"#如何获取Spy\" class=\"headerlink\" title=\"如何获取Spy++\"></a>如何获取Spy++</h2><h3 id=\"Visual-Studio\"><a href=\"#Visual-Studio\" class=\"headerlink\" title=\"Visual Studio\"></a>Visual Studio</h3><p>如果你下载过VS2019（其他版本应该同理），那么你可以在<code>VS的安装目录/Common7/Tools/</code>中找到一个名叫<code>spyxx.exe</code>以及<code>spyxx_amd64.exe</code>，如果你的机器是64位版本最好使用后者（PS：spyxx中的xx即为倒着的加号++）。</p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/visualstudio/debugger/spy-increment-help?view=vs-2019\">Spy++ 帮助 - Visual Studio | Microsoft Docs</a></p>\n<h3 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h3><p>当然，如果你没有安装VS或是其他版本的VS没有spy++，已经有热心开发者把不同版本的spy++上传到了仓库。</p>\n<p><a href=\"https://github.com/westoncampbell/SpyPlusPlus\">GitHub - westoncampbell/SpyPlusPlus: Microsoft Spy++</a></p>\n<p>你只需要clone仓库下载即可。</p>\n<h3 id=\"本人提供度盘\"><a href=\"#本人提供度盘\" class=\"headerlink\" title=\"本人提供度盘\"></a>本人提供度盘</h3><p>如果你是一位普通的Windows使用者，对上面的方式都不怎么会，本人已经将VS2019中的spy++传到了度盘，下载即可使用。</p>\n<p>链接：<a href=\"https://pan.baidu.com/s/1CwLPltBelCJVtbyFQObA0w\">https://pan.baidu.com/s/1CwLPltBelCJVtbyFQObA0w</a><br>提取码：cdn7 </p>\n<h2 id=\"如何使用Spy\"><a href=\"#如何使用Spy\" class=\"headerlink\" title=\"如何使用Spy++\"></a>如何使用Spy++</h2><h3 id=\"热键占用检测\"><a href=\"#热键占用检测\" class=\"headerlink\" title=\"热键占用检测\"></a>热键占用检测</h3><p>Spy++能够对当前的热键占用进行检测并给出占用该热键的应用程序。具体做法如下：</p>\n<p>1、打开Spy++，选择<strong>日志消息（log message）</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/log-message.jpg\" alt=\"\"></p>\n<p>2、选择<strong>All Windows in System</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/set-all-windows-in-system.jpg\" alt=\"\"></p>\n<p>这一步的目的是保证拦截到当前Windows系统中的所有窗体的有关消息</p>\n<p>3、进入message页签，筛选热键消息</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/filter-message.jpg\" alt=\"\"></p>\n<p>4、保存配置后，会看到界面有一个空白窗口，然后按下快捷键，会发现窗口中会出现对应的热键消息</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/message.gif\" alt=\"\"></p>\n<p>本例中，本人使用了<code>alt+space</code>快捷键呼出了uTools（另一款本人特别喜欢的工具）。通过Spy++监听到了快捷键的按下。我们可以右键该条消息，查看Properties检查该热键是由哪个程序捕获的：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/prop1.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/prop2.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/prop3.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/prop4.jpg\" alt=\"\"></p>\n<h3 id=\"窗体所属程序检测\"><a href=\"#窗体所属程序检测\" class=\"headerlink\" title=\"窗体所属程序检测\"></a>窗体所属程序检测</h3><p>除了上述Spy++能够监听Windows下的事件消息外，它还能获取Windows下任意窗口的句柄信息，进而获取到该窗口所属的应用程序。</p>\n<p>1、Spy菜单中选择<code>Find Window</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/find-window.jpg\" alt=\"\"></p>\n<p>2、拖动FinderTool到你想要识别的窗口上，松开它。剩下的请看下面的gif。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-03-09-spyxx/how-to-find-window.gif\" alt=\"\"></p>\n","categories":[],"tags":["Windows"]},{"title":"iframe、SameSite与CEF","url":"http://compilemind.com/2021/03/08/2021-03-08-iframe、SameSite与CEF/","content":"<h1 id=\"iframe、SameSite与CEF\"><a href=\"#iframe、SameSite与CEF\" class=\"headerlink\" title=\"iframe、SameSite与CEF\"></a>iframe、SameSite与CEF</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>本人使用CEF（或是Chrome）来加载开发的前端页面，其中使用iframe嵌入了第三方页面，在第三方页面中需要发送cookie到后端，然而加载会报错，第三方页面后端无法接受到Cookie。</p>\n<a id=\"more\"></a>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>由于CEF（Chrome内核）的安全策略，在51版本以前、80版本以后，绝大多数情况下是禁止嵌入的iframe提交Cookie的（下文会列出哪些禁止），所以需要浏览器配置策略来允许iframe提交Cookie，这个策略就是SameSite。</p>\n<p>SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。<br>SameSite 可以有下面三种值：</p>\n<ul>\n<li><strong>Strict</strong>（严格的）。仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</li>\n<li><strong>Lax</strong>（松懈的）。允许部分第三方请求携带 Cookie。</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">请求类型</th>\n<th style=\"text-align:center\">示例</th>\n<th style=\"text-align:right\">正常情况</th>\n<th style=\"text-align:left\">Lax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">链接</td>\n<td style=\"text-align:center\"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">发送 Cookie</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">预加载</td>\n<td style=\"text-align:center\"><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">发送 Cookie</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GET 表单</td>\n<td style=\"text-align:center\"><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">发送 Cookie</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">POST 表单</td>\n<td style=\"text-align:center\"><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">不发送</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iframe</td>\n<td style=\"text-align:center\"><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">不发送</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AJAX</td>\n<td style=\"text-align:center\"><code>$.get(&quot;...&quot;)</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">不发送</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Image</td>\n<td style=\"text-align:center\"><code>&lt;img src=&quot;...&quot;&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td style=\"text-align:left\">不发送</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><strong>None</strong>（无）。无论是否跨站都会发送 Cookie。</li>\n</ul>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"Chrome（或是基于Chromium的Edge）\"><a href=\"#Chrome（或是基于Chromium的Edge）\" class=\"headerlink\" title=\"Chrome（或是基于Chromium的Edge）\"></a>Chrome（或是基于Chromium的Edge）</h3><p>在基于Chrome中，可以进入如下的页面进行配置：</p>\n<ul>\n<li>地址栏输入：<code>chrome://flags/</code>（Edge中会自动转为<code>edge://</code>）</li>\n<li>找到<code>SameSite by default cookies</code>和<code>Cookies without SameSite must be secure</code></li>\n<li>将上面两项设置为 <code>Disable</code></li>\n</ul>\n<h3 id=\"CEF\"><a href=\"#CEF\" class=\"headerlink\" title=\"CEF\"></a>CEF</h3><p>上面的方法很通用，不过，对于CEF项目来说，并没有这个页面供我们配置。我们可以通过命令行形式传入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cef-app.exe（你的cef应用程序） --disable-features&#x3D;SameSiteByDefaultCookies</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html\">http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>\n","categories":[],"tags":["CEF"]},{"title":"Linux下Electron loadURL报错 ERR_FAILED Not allowed to load local resource","url":"http://compilemind.com/2021/02/24/2021-02-24-Linux下Electron loadURL报错 ERR_FAILED Not allowed to load local resource/","content":"<h1 id=\"Linux下Electron-loadURL报错-ERR-FAILED-2-Not-allowed-to-load-local-resource\"><a href=\"#Linux下Electron-loadURL报错-ERR-FAILED-2-Not-allowed-to-load-local-resource\" class=\"headerlink\" title=\"Linux下Electron loadURL报错 ERR_FAILED(-2) Not allowed to load local resource\"></a>Linux下Electron loadURL报错 ERR_FAILED(-2) Not allowed to load local resource</h1><p>Linux Electron打包后页面无法加载，报错：Not allowed to load local resource</p>\n<a id=\"more\"></a>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>使用electron-vue的时候，窗体创建后加载页面使用的是<code>loadURL</code>函数，并且传入的参数形如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`file://<span class=\"subst\">$&#123;__dirname&#125;</span>/index.html`</span></span><br></pre></td></tr></table></figure>\n<p>PS：在<strong>electron-vue</strong>中，编译打包后的<code>__dirname</code>是<code>asar所在绝对地址/dist/electron/</code>。</p>\n<p>编译打包后的Electron程序启动时候，发现在调用loadURL的时候会出现：ERR_FAILED(-2) 。</p>\n<p>遂临时启动DevTool窗口查看控制台输出，发现类似如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Not allowed to load local resource: file:&#x2F;&#x2F;XXXXXX&#x2F;app.asar&#x2F;dir1&#x2F;dir2&#x2F;index.html</span><br></pre></td></tr></table></figure>\n<h2 id=\"原因及方案\"><a href=\"#原因及方案\" class=\"headerlink\" title=\"原因及方案\"></a>原因及方案</h2><h3 id=\"1、文件并不存在于你的asar包中\"><a href=\"#1、文件并不存在于你的asar包中\" class=\"headerlink\" title=\"1、文件并不存在于你的asar包中\"></a>1、文件并不存在于你的asar包中</h3><p>处理方式：</p>\n<ol>\n<li>全局安装<code>npm install -g asar</code></li>\n<li>通过asar解压app.asar包，检查上述提到的file路径中是否存在你的index.html。</li>\n</ol>\n<h3 id=\"2、尝试禁用窗体参数中的webSercurity\"><a href=\"#2、尝试禁用窗体参数中的webSercurity\" class=\"headerlink\" title=\"2、尝试禁用窗体参数中的webSercurity\"></a>2、尝试禁用窗体参数中的<code>webSercurity</code></h3><p>处理方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  webPreferences: &#123;</span><br><span class=\"line\">    webSecurity: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、检查webpack配置中的-dirname，防止webpack处理’mock’\"><a href=\"#3、检查webpack配置中的-dirname，防止webpack处理’mock’\" class=\"headerlink\" title=\"3、检查webpack配置中的__dirname，防止webpack处理’mock’\"></a>3、检查webpack配置中的__dirname，防止webpack处理’mock’</h3><p>这一点主要是当上述<code>Not alloed to load local resource</code>提到的路径明显不正确时候，可以检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; webpack配置文件中的node节点，当打包的时候需要防止webpack处理</span><br><span class=\"line\">node: &#123;</span><br><span class=\"line\">  __dirname: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>webpack配置文件中的node节点，当打包的时候需要防止webpack处理<code>__dirname</code>，如果你使用了electron-vue脚手架应该不需要关心，因为你会看到如下的内容，已经帮你处理了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node: &#123;</span><br><span class=\"line\">  __dirname: process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;,</span><br><span class=\"line\">  __filename: process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、使用loadFile而不是loadURL\"><a href=\"#4、使用loadFile而不是loadURL\" class=\"headerlink\" title=\"4、使用loadFile而不是loadURL\"></a>4、使用loadFile而不是loadURL</h3><p>使用loadFile接口来加载本地的路径，loadFile(‘path/to/index.html’)，这个路径是以app.asar根路径为base的。例如，loadFile(‘dir_path1/dir_path2/index.html’)，那么你的index.html在app.asar是如下的结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.asar</span><br><span class=\"line\">|-dir_path1</span><br><span class=\"line\">  |-dir_path2</span><br><span class=\"line\">    |-index.html</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["electron"]},{"title":"从源码解析Electron的安装为什么这么慢","url":"http://compilemind.com/2021/02/01/2021-02-01-从源码解析Electron的安装为什么这么慢/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Electron作为一款跨平台的桌面应用端解决方案已经风靡全球。作为开发者，我们几乎不用关心与操作系统的交互，直接通过Web前端技术与Electron提供的API就可以完成桌面应用端的开发。</p>\n<p>然而，为什么国内使用Electron的踩坑文章数不胜数，主要原因是Electron为了支持跨平台，为不同的操作系统平台进行了适配，将chromium内核与node集成到了一起，屏蔽了底层操作系统的细节，所以在不同的平台上有着不同的二进制基座。在开发的过程中，我们必须要下载对应的平台的基座，才能正常开发。也就是说，我们<code>npm install electron -D</code>的时候，一定是下载了Electron的二进制基座的。那么这个下载的过程在哪里？为什么速度这么慢呢？本文将通过Electron的安装源码一一说明。</p>\n<a id=\"more\"></a>\n<h1 id=\"安装Electron\"><a href=\"#安装Electron\" class=\"headerlink\" title=\"安装Electron\"></a>安装Electron</h1><p>在安装之前，我们先模拟一下没有配置任何关于Electron二进制镜像的npm配置文件，在<code>~/.npmrc</code>里面，只有一些默认的配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ~&#x2F;.npmrc文件</span><br><span class=\"line\">registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class=\"line\">prefix&#x3D;D:\\Programs\\nodejs\\global_modules</span><br><span class=\"line\">cache&#x3D;D:\\Programs\\nodejs\\cache_modules</span><br><span class=\"line\">python&#x3D;D:\\Programs\\Python39\\python.exe</span><br></pre></td></tr></table></figure>\n<p>然后，创建一个名为<code>electron-install-example</code>的文件夹作为本此测试的Demo项目目录，并在<strong>进入</strong>该目录后执行<code>npm init</code>初始化node项目。</p>\n<p>最后，使用命令行安装Electron：<code>npm install electron -D</code>。在短暂的npm包安装后，我们会发现会卡在一个地方：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/electron-postinstall.jpg\" alt=\"\"></p>\n<p>这时候，很多开发者就会开始在网络上搜索：’安装Electron卡住’，并且也很容易得到解决方案：</p>\n<blockquote>\n<p>在<code>~/.npmrc</code>文件中，单独设置Electron的镜像<code>electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot;</code></p>\n</blockquote>\n<p>于是我们按照搜来的解决方案重新配置我们的<code>.npmrc</code>文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ~&#x2F;.npmrc文件</span><br><span class=\"line\">registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class=\"line\">prefix&#x3D;D:\\Programs\\nodejs\\global_modules</span><br><span class=\"line\">cache&#x3D;D:\\Programs\\nodejs\\cache_modules</span><br><span class=\"line\">python&#x3D;D:\\Programs\\Python39\\python.exe</span><br><span class=\"line\"># 单独设置Electron的镜像</span><br><span class=\"line\">electron_mirror&#x3D;&quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;electron&#x2F;&quot; </span><br></pre></td></tr></table></figure>\n<p>设置完成后，重新进行<code>npm install</code>，发现能够很快完成下载并继续开发。通过本文，我们深入细节，看看为什么Electron设置了单独的镜像后，就能够正常且快速完成下载安装。</p>\n<h1 id=\"深入下载细节\"><a href=\"#深入下载细节\" class=\"headerlink\" title=\"深入下载细节\"></a>深入下载细节</h1><p>进入<code>项目根目录下/node_modules/electron/</code>（后续除特殊情况外，提到的目录路径都是统一相对于项目根目录）目录中，查看package.json文件中的<strong>scripts</strong>脚本节点：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/electron-pkgjson.jpg\" alt=\"\"></p>\n<p>了解npm的朋友们知道，<code>postinstall</code>中的脚本会在npm包完成安装后执行。</p>\n<p>也就是说，<code>npm install -D electron</code>完成以后，会在<code>node_modules/electron</code>目录中立刻执行<code>node install.js</code>。所以，我们进一步查看install.js文件，看看它到底执行了什么。核心代码如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/download-electron-code.jpg\" alt=\"\"></p>\n<p>代码特别容易理解：在没有缓存文件的时候，会使用<code>@electron/get</code>提供的<code>downloadArtifact</code>函数，进行Electron二进制制品的下载。</p>\n<p>于是，我们又将目标转移到<code>@electron/get</code>。这是个什么东西呢？查询官方仓库：<a href=\"https://github.com/electron/get\">官方仓库</a>，就能够大概知道该工具的功能了：提供一定的参数来向远端下载文件。</p>\n<p>找到<code>@electron/get</code>的模块入口<code>node_modules/@electron/get/dist/cjs/index.js</code>，也很容易从中找到<code>downloadArtifact</code>的函数定义：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/where-is-downloadArtifact.jpg\" alt=\"\"></p>\n<p>该函数的文档：下载Electron发行制品，并且返回下载后的制品的绝对路径。而函数内部主要流程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/func-flow.jpg\" alt=\"\"></p>\n<ul>\n<li><p>解析要下载的制品对应的操作系统和平台。例如是Windows还是Linux，架构是x86还是AMD64。</p>\n</li>\n<li><p>解析要下载的制品的版本。</p>\n</li>\n<li><p>解析要下载的制品的具体文件名。例如要下载Windows下的64位的Electron制品，那么默认文件名称是：<code>electron-v11.0.2-win32-x64.zip</code></p>\n</li>\n<li><p>解析要下载的制品所在的远端URL是多少（与本文相关的重点）。</p>\n</li>\n<li>处理本地缓存。</li>\n</ul>\n<p>本文主要解析下载以及从本地缓存制品两个环节。</p>\n<h2 id=\"远端下载的URL\"><a href=\"#远端下载的URL\" class=\"headerlink\" title=\"远端下载的URL\"></a>远端下载的URL</h2><p>从上面的源码图中，我们会看到远端的URL来自于<code>artifact_utils_1.getArtifactRemoteURL(artifactDetails)</code>这个的返回，而该函数在<code>@electron/get/dist/cjs/artifact-utils.js</code>中进行定义：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/getArtifactRemoteURL.jpg\" alt=\"\"></p>\n<p>该函数的定义也不难，主要流程如下：解析得到<code>base</code>变量，解析得到<code>path</code>变量，解析得到<code>file</code>变量，组合为<code>$&#123;base&#125;$&#123;path&#125;/$&#123;file&#125;</code>。当然，你也可以在<code>mirrorOptions</code>中定义<code>resolveAssetURL</code>函数来返回自定义的地址。</p>\n<p>在上面的处理流程中，能够看到一个频繁出现的函数：<code>mirroVar</code>。该函数也在该文件中定义，其函数定义如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mirrorVar</span>(<span class=\"params\">name, options, defaultValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Convert camelCase to camel_case for env var reading</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> lowerName = name.replace(<span class=\"regexp\">/([a-z])([A-Z])/g</span>, <span class=\"function\">(<span class=\"params\">_, a, b</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;a&#125;</span>_<span class=\"subst\">$&#123;b&#125;</span>`</span>).toLowerCase();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (process.env[<span class=\"string\">`NPM_CONFIG_ELECTRON_<span class=\"subst\">$&#123;lowerName.toUpperCase()&#125;</span>`</span>] ||</span><br><span class=\"line\">        process.env[<span class=\"string\">`npm_config_electron_<span class=\"subst\">$&#123;lowerName&#125;</span>`</span>] ||</span><br><span class=\"line\">        process.env[<span class=\"string\">`npm_package_config_electron_<span class=\"subst\">$&#123;lowerName&#125;</span>`</span>] ||</span><br><span class=\"line\">        process.env[<span class=\"string\">`ELECTRON_<span class=\"subst\">$&#123;lowerName.toUpperCase()&#125;</span>`</span>] ||</span><br><span class=\"line\">        options[name] ||</span><br><span class=\"line\">        defaultValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数主要返回参数<code>name</code>相关的变量值，以<code>name = &#39;mirror&#39;</code>为例，获取过程为：</p>\n<p><code>customDir</code>进行下划线分割转换，得到<code>const lowerName = &#39;mirror&#39;</code>（name为’customDir’则转换为’custom_dir’）。</p>\n<p>依次检查如下环境变量值：</p>\n<ol>\n<li>NPM_CONFIG_ELECTRON_MIRROR</li>\n<li>npm_config_electron_mirror</li>\n<li>npm_package_config_electron_mirror</li>\n<li>ELECTRON_MIRROR</li>\n<li>options[‘mirror’]</li>\n</ol>\n<p>上述任意变量存在值则直接使用，否则，使用默认值<code>defaultValue</code>。</p>\n<p>读到这里，也许有读者疑惑了，我明明是在<code>.npmrc</code>文件中配置的<code>ELECTRON_MIRROR</code>变量，而这里读取的明明是环境变量里面的值，怎么会有呢？如果直接使用node作为入口，那么确实不会有这些变量，但是通过npm运行就不一样了。这里用一个小例子来说明。</p>\n<p>首先在一个node项目中编写一个脚本env-test.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(process.env);</span><br></pre></td></tr></table></figure>\n<p>我们通过使用node运行该js脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node env-test.js</span><br></pre></td></tr></table></figure>\n<p>看到命令行的输出，只会有当前机器的环境变量：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/just-env.jpg\" alt=\"\"></p>\n<p>但是一旦通过npm进行运行，又会不一样：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/run-with-npm.jpg\" alt=\"\"></p>\n<p>运行命令<code>npm run dev</code>，会得到如下的结果，这里本人使用IDEA的断掉调试，会更加清晰的看到env的值：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/npm-env.jpg\" alt=\"\"></p>\n<p>通过<code>npm run</code>的方式，我们发现我们在<code>~/.npmrc</code>文件中配置的一些参数，都能在这里得到，并且是以<code>npm_config_</code>作为开头的。可能还有读者有疑惑，上面读取的变量，都是同意大小写的，这里是<code>npm_config_ELECTRON_MIRROR</code>，能读取到吗？事实上，env的读取是忽略大小写的：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/proc-env-ignore-case.jpg\" alt=\"\"></p>\n<p>综合目前的研究，相信读者已经清楚了为什么通过配置ELECTRON_MIRROR在<code>.npmrc</code>能够达到加快Electron二进制基座的下载速度的目的了，至于一些其他的配置变量，可以阅读附录的官方文档翻译。</p>\n<h2 id=\"本地缓存机制\"><a href=\"#本地缓存机制\" class=\"headerlink\" title=\"本地缓存机制\"></a>本地缓存机制</h2><p>有的读者看了上述的远端下载可能会说，我的机器就在内网环境，内网也没有镜像让我来写，我该怎么下载呢？实际上，<code>@electron/get</code>也不会完全从远端下载制品。它在下载的过程，会优先进行本地缓存文件的查找，如果已经存在了缓存好的制品，自然也就不会从远端下载了。那么这个查找缓存的过程是怎样的呢？或者说，<code>@electron/get</code>会从本地哪个目录去查找呢？让我们回到<code>@electron/get/dist/cjs/index.js</code>脚本的<code>downloadArtifact</code>函数中，看该部分：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/get-cache-path.jpg\" alt=\"\"></p>\n<p>在<code>url</code>变量获取的下一行，构建了一个Cache缓存对象，继续往下，通过判断不进行强制从远端下载的标志，会进入<code>getPathForFileInCache</code>函数返回一个本地的缓存文件路径，如果路径不为空则使用它。所以，我们只需要让这个函数能够返回一个合法的缓存文件路径就能让<code>@electron/get</code>不进行远端下载，而是使用本地的缓存文件。所以我们跟到该函数中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/getCachePath.jpg\" alt=\"\"></p>\n<p>函数最终会使用上一节中的<code>url</code>变量形成一个本地的缓存路径，至于代码中的<code>url.format</code>以及<code>filenamify</code>的效果，读者可以自行编写Demo验证。</p>\n<p>最后，路径还使用到了<code>this.cacheRoot</code>，查看Cache的构造函数，发现如果没有传递<code>cacheRoot</code>，则使用<code>defaultCacheRoot</code>，该值在该脚本文件上面有定义：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/default-cache-root-def.jpg\" alt=\"\"></p>\n<p>通过一段脚本输出该路径：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> env_paths_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;env-paths&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultCacheRoot = env_paths_1.default(<span class=\"string\">&#x27;electron&#x27;</span>, &#123;</span><br><span class=\"line\">  suffix: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">&#125;).cache;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(defaultCacheRoot);</span><br><span class=\"line\"><span class=\"comment\">// 在本人的机器上输出：</span></span><br><span class=\"line\"><span class=\"comment\">// C:\\Users\\w4ngzhen\\AppData\\Local\\electron\\Cache</span></span><br></pre></td></tr></table></figure>\n<p>所以在Windows机器下，默认的缓存目录在<code>~/AppData/Local/electron/Cache/</code>，在本人的机器上，已经缓存的文件如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/cache-file-list.jpg\" alt=\"\"></p>\n<p>源码个人认为也不用继续解析了，读者结合文件夹名称应该能够很容易分析。</p>\n<h1 id=\"附录：-electron-get-官方Wiki翻译\"><a href=\"#附录：-electron-get-官方Wiki翻译\" class=\"headerlink\" title=\"附录：@electron/get 官方Wiki翻译\"></a>附录：@electron/get 官方Wiki翻译</h1><blockquote>\n<p>下载Electron发行版制品</p>\n</blockquote>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"基础方式：下载一个Electron二进制ZIP\"><a href=\"#基础方式：下载一个Electron二进制ZIP\" class=\"headerlink\" title=\"基础方式：下载一个Electron二进制ZIP\"></a>基础方式：下载一个Electron二进制ZIP</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; download &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@electron/get&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NB: Use this syntax within an async function, Node does not have support for</span></span><br><span class=\"line\"><span class=\"comment\">//     top-level await as of Node 12.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> zipFilePath = <span class=\"keyword\">await</span> download(<span class=\"string\">&#x27;4.0.4&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶：下载macOS下带有调试符号的Electron文件\"><a href=\"#进阶：下载macOS下带有调试符号的Electron文件\" class=\"headerlink\" title=\"进阶：下载macOS下带有调试符号的Electron文件\"></a>进阶：下载macOS下带有调试符号的Electron文件</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; downloadArtifact &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@electron/get&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NB: Use this syntax within an async function, Node does not have support for</span></span><br><span class=\"line\"><span class=\"comment\">//     top-level await as of Node 12.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> zipFilePath = <span class=\"keyword\">await</span> downloadArtifact(&#123;</span><br><span class=\"line\">  version: <span class=\"string\">&#x27;4.0.4&#x27;</span>,</span><br><span class=\"line\">  platform: <span class=\"string\">&#x27;darwin&#x27;</span>,</span><br><span class=\"line\">  artifactName: <span class=\"string\">&#x27;electron&#x27;</span>,</span><br><span class=\"line\">  artifactSuffix: <span class=\"string\">&#x27;symbols&#x27;</span>,</span><br><span class=\"line\">  arch: <span class=\"string\">&#x27;x64&#x27;</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"指定镜像\"><a href=\"#指定镜像\" class=\"headerlink\" title=\"指定镜像\"></a>指定镜像</h3><p>下列选项可以用来指定从其他的地方下载Electron资源：</p>\n<ul>\n<li><code>mirrorOptions</code> Object（JavaScript对象）<ul>\n<li><code>mirror</code> String (可选) - 下载资源的镜像地址的基础URL。</li>\n<li><code>nightlyMirror</code> String (可选) - Electron nightly-specific版本的镜像URL。</li>\n<li><code>customDir</code> String (可选) - 下载资源的目录名称，通常由版本号来设定。</li>\n<li><code>customFilename</code> String (可选) - 将要下载的资源的文件名称。</li>\n<li><code>resolveAssetURL</code> Function (可选) - 允许通过编程方式来进行资源下载的函数回调。</li>\n</ul>\n</li>\n</ul>\n<p>下载资源的URL进行如下的分解，每一项都来可以映射到<code>mirrorOptions</code>:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-02-01-install-electron/url-resolve.jpg\" alt=\"\"></p>\n<p>Example:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; download &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@electron/get&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> zipFilePath = <span class=\"keyword\">await</span> download(<span class=\"string\">&#x27;4.0.4&#x27;</span>, &#123;</span><br><span class=\"line\">  mirrorOptions: &#123;</span><br><span class=\"line\">    mirror: <span class=\"string\">&#x27;https://mirror.example.com/electron/&#x27;</span>,</span><br><span class=\"line\">    customDir: <span class=\"string\">&#x27;custom&#x27;</span>,</span><br><span class=\"line\">    customFilename: <span class=\"string\">&#x27;unofficial-electron-linux.zip&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 上述将会从如下URL下载：</span></span><br><span class=\"line\"><span class=\"comment\">// https://mirror.example.com/electron/custom/unofficial-electron-linux.zip</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> nightlyZipFilePath = <span class=\"keyword\">await</span> download(<span class=\"string\">&#x27;8.0.0-nightly.20190901&#x27;</span>, &#123;</span><br><span class=\"line\">  mirrorOptions: &#123;</span><br><span class=\"line\">    nightlyMirror: <span class=\"string\">&#x27;https://nightly.example.com/&#x27;</span>,</span><br><span class=\"line\">    customDir: <span class=\"string\">&#x27;nightlies&#x27;</span>,</span><br><span class=\"line\">    customFilename: <span class=\"string\">&#x27;nightly-linux.zip&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 上述将会从如下URL下载：</span></span><br><span class=\"line\"><span class=\"comment\">// https://nightly.example.com/nightlies/nightly-linux.zip</span></span><br></pre></td></tr></table></figure>\n<p><code>customDir</code>参数可以使用<code>&#123;&#123; version &#125;&#125;</code>占位符来设置版本（务必注意：<code>&#123;&#125;</code>括号之间一定要有空格，否则会解析失败，即，<code>&#123;&#123;[空格]version&#123;空格&#125;&#125;&#125;</code>），这个占位符将会由所下载的资源的版本（没有首字符<code>v</code>）来动态替换。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> zipFilePath = <span class=\"keyword\">await</span> download(<span class=\"string\">&#x27;4.0.4&#x27;</span>, &#123;</span><br><span class=\"line\">  mirrorOptions: &#123;</span><br><span class=\"line\">    mirror: <span class=\"string\">&#x27;https://mirror.example.com/electron/&#x27;</span>,</span><br><span class=\"line\">    customDir: <span class=\"string\">&#x27;version-&#123;&#123; version &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    platform: <span class=\"string\">&#x27;linux&#x27;</span>,</span><br><span class=\"line\">    arch: <span class=\"string\">&#x27;x64&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 将会从如下的URL下载：</span></span><br><span class=\"line\"><span class=\"comment\">// https://mirror.example.com/electron/version-4.0.4/electron-v4.0.4-linux-x64.zip</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用环境变量来指定镜像选项\"><a href=\"#使用环境变量来指定镜像选项\" class=\"headerlink\" title=\"使用环境变量来指定镜像选项\"></a>使用环境变量来指定镜像选项</h4><p>镜像配置选项也可以通过如下的环境变量来指定：</p>\n<ul>\n<li><code>ELECTRON_CUSTOM_DIR</code> - 指定资源下载的自定义目录。</li>\n<li><code>ELECTRON_CUSTOM_FILENAME</code> - 指定资源下载的自定义文件名。</li>\n<li><code>ELECTRON_MIRROR</code> - 指定如果版本没有使用nightly的时候，服务器的下载URL。</li>\n<li><code>ELECTRON_NIGHTLY_MIRROR</code> - 指定如果版本使用nightly的时候，服务器的下载URL。</li>\n</ul>\n<h3 id=\"重写下载的资源版本\"><a href=\"#重写下载的资源版本\" class=\"headerlink\" title=\"重写下载的资源版本\"></a>重写下载的资源版本</h3><p>所下载的资源的版本可以通过设置<code>`ELECTRON_CUSTOM_VERSION</code> 环境变量来进行覆盖。设置该版本将会覆盖传入<code>download</code>或是<code>downloadArtifact</code>函数的version参数。</p>\n<h2 id=\"它是如何运行的\"><a href=\"#它是如何运行的\" class=\"headerlink\" title=\"它是如何运行的\"></a>它是如何运行的</h2><p>下载Electron资源到操作系统中已知的位置，并且缓存该资源的模块，用于便于在将来请求同一个资源的时候能够立刻完成并返回。缓存路径如下：</p>\n<ul>\n<li>Linux: <code>$XDG_CACHE_HOME</code> or <code>~/.cache/electron/</code></li>\n<li>MacOS: <code>~/Library/Caches/electron/</code></li>\n<li>Windows: <code>%LOCALAPPDATA%/electron/Cache</code> or <code>~/AppData/Local/electron/Cache/</code></li>\n</ul>\n<p>默认情况下，该模块使用 <a href=\"https://github.com/sindresorhus/got\"><code>got</code></a>作为下载器。因此，您可以通过<code>downloadOptions</code>使用与<code>get</code>相同的选项（<a href=\"https://github.com/sindresorhus/got#options\">options</a>）来进行下载。</p>\n<h3 id=\"进度条\"><a href=\"#进度条\" class=\"headerlink\" title=\"进度条\"></a>进度条</h3><p>默认情况下，下载工件超过30秒时会显示进度条。若要禁用，请将<code>ELECTRON_GET_NO_PROGRESS</code> 环境变量设置为任何非空值，或设置<code>downloadOptions</code>中的<code>quiet</code>为<code>true</code>。如果您需要通过API自己监视进度，请设置<code>downloadOptions</code>中的<code>getProgressCallback</code> 回调，其函数签名与<code>got</code>的<a href=\"https://github.com/sindresorhus/got#ondownloadprogress-progress\"><code>downloadProgress</code> event callback</a>相同。</p>\n<h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><p>下游软件包应利用 <code>initializeProxy</code>功能来添加HTTP(S)代理支持。如果设置了环境变量<code>ELECTRON_GET_USE_PROXY</code>，则会自动调用它。根据使用的Node版本，使用不同的代理模块.因此，设置代理环境变量的方式略有不同。对于Node 10及更高版本，使用<a href=\"https://github.com/gajus/global-agent#environment-variables\"><code>global-agent</code></a>。否则，将使用<a href=\"https://github.com/np-maintain/global-tunnel#auto-config\"><code>global-tunnel-ng</code></a>。请参阅相应的链接模块以确定如何配置代理支持。</p>\n","categories":[],"tags":["electron"]},{"title":"使用CEF（二）— 基于VS2019编写一个简单CEF样例","url":"http://compilemind.com/2021/01/15/2021-01-15-使用CEF（二）— 基于VS2019编写一个简单CEF样例/","content":"<h1 id=\"使用CEF（二）—-基于VS2019编写一个简单CEF样例\"><a href=\"#使用CEF（二）—-基于VS2019编写一个简单CEF样例\" class=\"headerlink\" title=\"使用CEF（二）— 基于VS2019编写一个简单CEF样例\"></a>使用CEF（二）— 基于VS2019编写一个简单CEF样例</h1><p>在这一节中，本人将会在Windows下使用VS2019创建一个空白的C++<strong>Windows Desktop Application</strong>项目，逐步进行修改配置和代码编写，并在这个过程中介绍vs使用过程中和C++项目的结合。源码见文章末尾Github链接。</p>\n<a id=\"more\"></a>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>你已经阅读过《使用CEF（1）— 起步》，你可以在这些地方读到：<a href=\"https://zhuanlan.zhihu.com/p/344306287\">知乎链接</a>、<a href=\"https://www.cnblogs.com/w4ngzhen/p/14278187.html\">cnblogs</a>。或，你知道如何获得libcef的库以及libcef_dll_wrapper静态库。</p>\n<h2 id=\"文件准备\"><a href=\"#文件准备\" class=\"headerlink\" title=\"文件准备\"></a>文件准备</h2><p>接下来，本人将以Debug的模式下完成代码的开发工作。在Release下是同样的步骤，但是需要注意的是你所选择的目标是Debug或是Release都需要和libcef库以及libcef_dll_wrapper完全一致。</p>\n<ul>\n<li>现在，你需要libcef库文件相关文件，它来自于：</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/libcef-lib-list.jpg\" alt=\"\"></p>\n<ul>\n<li>你需要使用libcef_dll_wrapper静态库文件，它来自于你编译出来的静态库：</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/libcef-dll-lib-list.jpg\" alt=\"\"></p>\n<ul>\n<li>你需要libcef与wrapper的include文件，它来自于：</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/include-files.jpg\" alt=\"\"></p>\n<p>接下来我们创建一个名为cef的文件夹，并且把上述提到的文件夹和文件放到该目录下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cef</span><br><span class=\"line\">│  libcef_dll_wrapper.lib</span><br><span class=\"line\">│  libcef_dll_wrapper.pdb</span><br><span class=\"line\">│</span><br><span class=\"line\">├─Debug</span><br><span class=\"line\">│  │  ......</span><br><span class=\"line\">│  │  libcef.dll</span><br><span class=\"line\">│  │  libcef.lib</span><br><span class=\"line\">│  │  libEGL.dll</span><br><span class=\"line\">│  │  libGLESv2.dll</span><br><span class=\"line\">│  │  ......</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─swiftshader</span><br><span class=\"line\">│          libEGL.dll</span><br><span class=\"line\">│          libGLESv2.dll</span><br><span class=\"line\">│</span><br><span class=\"line\">└─include</span><br><span class=\"line\">    │  cef_accessibility_handler.h</span><br><span class=\"line\">    │  cef_api_hash.h</span><br><span class=\"line\">    │  cef_app.h</span><br><span class=\"line\">    │  cef_audio_handler.h</span><br><span class=\"line\">    |  .....</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/files-dir.jpg\" alt=\"\"></p>\n<p>基础文件创建完成后，我们开始编写一个简单的基于CEF的程序吧！</p>\n<h2 id=\"项目创建\"><a href=\"#项目创建\" class=\"headerlink\" title=\"项目创建\"></a>项目创建</h2><p>创建一个Windows桌面应用程序</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/create-sln.jpg\" alt=\"\"></p>\n<p>创建一个名为simple-cef的项目</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/create-proj.jpg\" alt=\"\"></p>\n<p>创建完成后，我们删除所有模板生成的代码，得到一个完全空白的应用程序项目：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/delete-all-files.jpg\" alt=\"\"></p>\n<h2 id=\"依赖添加\"><a href=\"#依赖添加\" class=\"headerlink\" title=\"依赖添加\"></a>依赖添加</h2><h3 id=\"头文件添加\"><a href=\"#头文件添加\" class=\"headerlink\" title=\"头文件添加\"></a>头文件添加</h3><p>众所周知，C/C++头文件作为声明定义，对于编译过程有着举足轻重的位置。当我们引入CEF编译我们的项目时候，首先需要include正确位置的头文件，才能实现编译（狭义的编译，不包括链接）。我们首先把上述做好的cef文件夹放到<strong>项目</strong>所在目录下，也就是说我们把cef的inlucde头文件以及静态库文件全都加到了项目中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/20210122161019.png\" alt=\"\"></p>\n<p>然后，在VS中，我们通过如下的方式为我们的项目引入CEF的头文件：</p>\n<p><strong>右键项目</strong> — <strong>properties</strong> — <strong>C/C++</strong> — <strong>General</strong> — <strong>Additional Include Directories</strong></p>\n<p>PS：如果你发现没有C/C++分类，是因为你没有创建任何的源代码文件，<a href=\"https://developercommunity.visualstudio.com/content/problem/87843/property-pages-cc-category-missing.html\">官方FAQ</a>。所以我们在Source Files目录下先创建一个main.cpp，然后继续上述的配置。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/additional-include-dir.jpg\" alt=\"\"></p>\n<p>PS：这里本人使用了<code>$(ProjectDir)</code>，它是一个VS宏变量，返回项目所在目录（即，vcxproj所在目录），且目录末尾带反斜杠<code>\\</code>。从上面的Evaluated value里面展示的经过实际计算得到的值，可以验证我们配置是否正确。这里正确的返回了我们<strong>放在项目目录下的cef文件夹</strong>。</p>\n<p>这里只需要添加到<strong>cef文件夹</strong>这一层级，是因为<strong>cef/include</strong>里面的头文件在include的时候，采用了对应的”include/xxx.h”，即需要从<strong>引入目录</strong>中找到include文件夹，里面查找xxx.h头文件。当我们指定到了cef层级后，就能够使得编译器正确处理cef头文件中include的位置。</p>\n<p>这里以<strong>$(ProjectDir)cef/include/cef_broweser.h</strong>这个头文件举例：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/20210122162053.png\" alt=\"\"></p>\n<p>当编译器发现里面的#include预编译命令后，会从头文件目录中去查找，即希望从上述配置的<strong>$(ProjectDir)cef/</strong>以及默认目录下查找，默认的项目目录应该是找不到了，但是可以在<strong>$(ProjectDir)cef/</strong>目录下找到<strong>include/cef_base.h</strong>等文件，因为<strong>$(ProjectDir)cef/include/cef_base.h</strong>确实是正确的文件路径。因此，上述额外的include文件夹只需要指定到cef层级即可。</p>\n<h3 id=\"库文件添加\"><a href=\"#库文件添加\" class=\"headerlink\" title=\"库文件添加\"></a>库文件添加</h3><p>完成头文件的添加后，我们还需要添加链接目标，即cef的静态库。添加方式为：</p>\n<p><strong>properties</strong> — <strong>Linker</strong> — <strong>Input</strong>— <strong>Additional Dependencies</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/add-the-additional-dependencies.jpg\" alt=\"\"></p>\n<p>同样使用宏变量来指定对应的lib静态库：libcef_dll_wrapper.lib、libcef.lib、cef_sandbox.lib。</p>\n<p>通过上述的库文件添加，我们就完成了<strong>编译（狭义，头文件查找）——链接（库文件链接）</strong>这两个步骤的配置了，接下来就是进一步，开始我们的代码编写之路。</p>\n<h2 id=\"代码编写与说明\"><a href=\"#代码编写与说明\" class=\"headerlink\" title=\"代码编写与说明\"></a>代码编写与说明</h2><p>CEF的整体架构以及CefApp以及CefClient的概念可以参考<a href=\"https://github.com/fanfeilong/cefutil\">该仓库里面的文档</a>，或者是<a href=\"https://bitbucket.org/chromiumembedded/cef/wiki/GeneralUsage.md\">阅读官方文档</a>。接下来将使用cefsimple代码进行解释说明，并适当增加一些小的细节。</p>\n<h3 id=\"simple-app\"><a href=\"#simple-app\" class=\"headerlink\" title=\"simple_app\"></a>simple_app</h3><h4 id=\"simple-app-h\"><a href=\"#simple-app-h\" class=\"headerlink\" title=\"simple_app.h\"></a>simple_app.h</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> SIMPLE_APP_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIMPLE_APP_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_app.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implement application-level callbacks for the browser process.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleApp</span> :</span> <span class=\"keyword\">public</span> CefApp, <span class=\"keyword\">public</span> CefBrowserProcessHandler &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    SimpleApp();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CefApp methods:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefBrowserProcessHandler&gt; <span class=\"title\">GetBrowserProcessHandler</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        OVERRIDE </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CefBrowserProcessHandler methods:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnContextInitialized</span><span class=\"params\">()</span> OVERRIDE</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Include the default reference counting implementation.</span></span><br><span class=\"line\">    IMPLEMENT_REFCOUNTING(SimpleApp);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>这里引入的时候，如果发现VS提示，<code>#include &quot;include/cef_app.h&quot;</code>无效，首先检查上述的对项目的配置是否正确！上述项目Properties中配置的平台是x64，VS中也请选择一致的平台。而且在本Demo是无法使用32位的，因为我们下载的静态库是x64位的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/same-config.jpg\" alt=\"\"></p>\n<h4 id=\"simple-app-cpp\"><a href=\"#simple-app-cpp\" class=\"headerlink\" title=\"simple_app.cpp\"></a>simple_app.cpp</h4><p>在simple_app的实现中，主要需要提供3个部分的代码实现：</p>\n<ul>\n<li>CefWindowDelegate</li>\n<li>CefBrowserViewDelegate</li>\n<li>SimpleApp</li>\n</ul>\n<h5 id=\"CefWindowDelegate与CefBrowserViewDelegate\"><a href=\"#CefWindowDelegate与CefBrowserViewDelegate\" class=\"headerlink\" title=\"CefWindowDelegate与CefBrowserViewDelegate\"></a>CefWindowDelegate与CefBrowserViewDelegate</h5><p>Cef窗体代理以及Cef浏览器视图代理，他们是CEF提供的一套图形视图框架。这一套图形接口目前在Windows和Linux上支持了，所以在Windows和Linux我们完全可以不用选择原生的窗体框架（例如在Windows上的WinForm和Linux上的QT之类的），而是直接使用CEF提供的图形视图框架。而CEF的图形视图框架的内部实现原理我们暂时不需要知道，可以把它们想象成一些窗体和控件对象，它们需要在SimpleApp中的实现用到，所以也写在了simple_app.cpp中。相关代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SimpleBrowserViewDelegate</span></span><br><span class=\"line\"><span class=\"comment\">// 继承CefBrowserViewDelegate，即CEF浏览器视图代理。</span></span><br><span class=\"line\"><span class=\"comment\">// 该代理由CEF屏蔽细节，只暴露出视图控件指定的接口回调供我们实现即可</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleBrowserViewDelegate</span> :</span> <span class=\"keyword\">public</span> CefBrowserViewDelegate </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">    SimpleBrowserViewDelegate()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">OnPopupBrowserViewCreated</span><span class=\"params\">(CefRefPtr&lt;CefBrowserView&gt; browser_view,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   CefRefPtr&lt;CefBrowserView&gt; popup_browser_view,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">bool</span> is_devtools)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a new top-level Window for the popup. It will show itself after</span></span><br><span class=\"line\">        <span class=\"comment\">// creation.</span></span><br><span class=\"line\">        CefWindow::CreateTopLevelWindow(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SimpleWindowDelegate(popup_browser_view));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We created the Window.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    IMPLEMENT_REFCOUNTING(SimpleBrowserViewDelegate);</span><br><span class=\"line\">    DISALLOW_COPY_AND_ASSIGN(SimpleBrowserViewDelegate);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SimpleWindowDelegate</span></span><br><span class=\"line\"><span class=\"comment\">// 继承CefWindowDelegate，即CEF窗口代理。</span></span><br><span class=\"line\"><span class=\"comment\">// 该代理由CEF屏蔽细节，只暴露窗口一些接口回调供我们实现即可。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleWindowDelegate</span> :</span> <span class=\"keyword\">public</span> CefWindowDelegate</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">SimpleWindowDelegate</span><span class=\"params\">(CefRefPtr&lt;CefBrowserView&gt; browser_view)</span></span></span><br><span class=\"line\"><span class=\"function\">        : <span class=\"title\">browser_view_</span><span class=\"params\">(browser_view)</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 窗体创建时</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnWindowCreated</span><span class=\"params\">(CefRefPtr&lt;CefWindow&gt; window)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Add the browser view and show the window.</span></span><br><span class=\"line\">        window-&gt;AddChildView(browser_view_);</span><br><span class=\"line\">        window-&gt;Show();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Give keyboard focus to the browser view.</span></span><br><span class=\"line\">        browser_view_-&gt;RequestFocus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 窗体销毁时</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnWindowDestroyed</span><span class=\"params\">(CefRefPtr&lt;CefWindow&gt; window)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        browser_view_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 窗体是否可以关闭</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CanClose</span><span class=\"params\">(CefRefPtr&lt;CefWindow&gt; window)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Allow the window to close if the browser says it&#x27;s OK.</span></span><br><span class=\"line\">        CefRefPtr&lt;CefBrowser&gt; browser = browser_view_-&gt;GetBrowser();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (browser)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> browser-&gt;GetHost()-&gt;TryCloseBrowser();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取窗体展示的最佳尺寸</span></span><br><span class=\"line\">    <span class=\"function\">CefSize <span class=\"title\">GetPreferredSize</span><span class=\"params\">(CefRefPtr&lt;CefView&gt; view)</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CefSize(<span class=\"number\">800</span>, <span class=\"number\">600</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    CefRefPtr&lt;CefBrowserView&gt; browser_view_;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMPLEMENT_REFCOUNTING(SimpleWindowDelegate);</span><br><span class=\"line\">    DISALLOW_COPY_AND_ASSIGN(SimpleWindowDelegate);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"SimpleApp\"><a href=\"#SimpleApp\" class=\"headerlink\" title=\"SimpleApp\"></a>SimpleApp</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SimpleApp::SimpleApp()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleApp::OnContextInitialized</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    CefRefPtr&lt;CefCommandLine&gt; command_line =</span><br><span class=\"line\">        CefCommandLine::GetGlobalCommandLine();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> enable_chrome_runtime =</span><br><span class=\"line\">        command_line-&gt;HasSwitch(<span class=\"string\">&quot;enable-chrome-runtime&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(OS_WIN) || defined(OS_LINUX)</span></span><br><span class=\"line\">    <span class=\"comment\">// Create the browser using the Views framework if &quot;--use-views&quot; is specified</span></span><br><span class=\"line\">    <span class=\"comment\">// via the command-line. Otherwise, create the browser using the native</span></span><br><span class=\"line\">    <span class=\"comment\">// platform framework. The Views framework is currently only supported on</span></span><br><span class=\"line\">    <span class=\"comment\">// Windows and Linux.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views = command_line-&gt;HasSwitch(<span class=\"string\">&quot;use-views&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// SimpleHandler implements browser-level callbacks.</span></span><br><span class=\"line\">    <span class=\"function\">CefRefPtr&lt;SimpleClient&gt; <span class=\"title\">handler</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleClient(use_views))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Specify CEF browser settings here.</span></span><br><span class=\"line\">    CefBrowserSettings browser_settings;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> url;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if a &quot;--url=&quot; value was provided via the command-line. If so, use</span></span><br><span class=\"line\">    <span class=\"comment\">// that instead of the default URL.</span></span><br><span class=\"line\">    url = command_line-&gt;GetSwitchValue(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url.empty())</span><br><span class=\"line\">        url = <span class=\"string\">&quot;https://www.cnblogs.com/w4ngzhen/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (use_views &amp;&amp; !enable_chrome_runtime)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create the BrowserView.</span></span><br><span class=\"line\">        CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(</span><br><span class=\"line\">            handler, url, browser_settings, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SimpleBrowserViewDelegate());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create the Window. It will show itself after creation.</span></span><br><span class=\"line\">        CefWindow::CreateTopLevelWindow(<span class=\"keyword\">new</span> SimpleWindowDelegate(browser_view));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Information used when creating the native window.</span></span><br><span class=\"line\">        CefWindowInfo window_info;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(OS_WIN)</span></span><br><span class=\"line\">        <span class=\"comment\">// On Windows we need to specify certain flags that will be passed to</span></span><br><span class=\"line\">        <span class=\"comment\">// CreateWindowEx().</span></span><br><span class=\"line\">        window_info.SetAsPopup(<span class=\"literal\">NULL</span>, <span class=\"string\">&quot;simple-cef by w4ngzhen&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create the first browser window.</span></span><br><span class=\"line\">        CefBrowserHost::CreateBrowser(window_info, handler, url, browser_settings,</span><br><span class=\"line\">                                      <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"simple-client\"><a href=\"#simple-client\" class=\"headerlink\" title=\"simple_client\"></a>simple_client</h3><h5 id=\"simple-client-h\"><a href=\"#simple-client-h\" class=\"headerlink\" title=\"simple_client.h\"></a>simple_client.h</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> SIMPLE_CLIENT_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIMPLE_CLIENT_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_client.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleClient</span> :</span> <span class=\"keyword\">public</span> CefClient,</span><br><span class=\"line\">                     <span class=\"keyword\">public</span> CefDisplayHandler,</span><br><span class=\"line\">                     <span class=\"keyword\">public</span> CefLifeSpanHandler,</span><br><span class=\"line\">                     <span class=\"keyword\">public</span> CefLoadHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">SimpleClient</span><span class=\"params\">(<span class=\"keyword\">bool</span> use_views)</span></span>;</span><br><span class=\"line\">\t~SimpleClient();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> SimpleClient* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefDisplayHandler&gt; <span class=\"title\">GetDisplayHandler</span><span class=\"params\">()</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefLifeSpanHandler&gt; <span class=\"title\">GetLifeSpanHandler</span><span class=\"params\">()</span> OVERRIDE</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> CefRefPtr&lt;CefLoadHandler&gt; <span class=\"title\">GetLoadHandler</span><span class=\"params\">()</span> OVERRIDE </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// CefDisplayHandler的实现声明:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnTitleChange</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                           <span class=\"keyword\">const</span> CefString&amp; title)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// CefLifeSpanHandler的实现声明:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnAfterCreated</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">DoClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnBeforeClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// CefLoadHandler的实现声明:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnLoadError</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         CefRefPtr&lt;CefFrame&gt; frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         ErrorCode errorCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         <span class=\"keyword\">const</span> CefString&amp; errorText,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         <span class=\"keyword\">const</span> CefString&amp; failedUrl)</span> OVERRIDE</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CloseAllBrowsers</span><span class=\"params\">(<span class=\"keyword\">bool</span> force_close)</span></span>; <span class=\"comment\">// 请求将所有的已经存在的浏览器窗体进行关闭</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsClosing</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> is_closing_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 平台特定的标题修改</span></span><br><span class=\"line\">    <span class=\"comment\">// 当我们没有CEF的GUI视图框架的时候，就需要特定平台的标题修改实现</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如，Windows中需要我们获取窗体句柄，调用Windows的API完成对该窗体的标题修改</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PlatformTitleChange</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t                         <span class=\"keyword\">const</span> CefString&amp; title)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">bool</span> use_views_; <span class=\"comment\">// 是否使用了CEF的GUI视图框架</span></span><br><span class=\"line\">\t<span class=\"comment\">// List of existing browser windows. Only accessed on the CEF UI thread.</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;CefRefPtr&lt;CefBrowser&gt;&gt; BrowserList;</span><br><span class=\"line\">\tBrowserList browser_list_;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> is_closing_;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Include the default reference counting implementation.</span></span><br><span class=\"line\">IMPLEMENT_REFCOUNTING(SimpleClient);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"simple-client-cpp以及simple-client-os-win-cpp\"><a href=\"#simple-client-cpp以及simple-client-os-win-cpp\" class=\"headerlink\" title=\"simple_client.cpp以及simple_client_os_win.cpp\"></a>simple_client.cpp以及simple_client_os_win.cpp</h5><p>这里我们提供了两份源代码，第一份是所有平台的通用实现，而第二份源码从名称可以看出跟特定的操作系统平台有关，这里就是Windows，为什么会有两份源码我们下文会逐步了解。</p>\n<p>首先看simple_client.cpp的源代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_client.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/base/cef_bind.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_app.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_parser.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/views/cef_browser_view.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/views/cef_window.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/wrapper/cef_closure_task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/wrapper/cef_helpers.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SimpleClient* g_instance = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns a data: URI with the specified contents.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">GetDataURI</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; data, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; mime_type)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;data:&quot;</span> + mime_type + <span class=\"string\">&quot;;base64,&quot;</span> +</span><br><span class=\"line\">            CefURIEncode(CefBase64Encode(data.data(), data.<span class=\"built_in\">size</span>()), <span class=\"literal\">false</span>)</span><br><span class=\"line\">            .ToString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace</span></span><br><span class=\"line\"></span><br><span class=\"line\">SimpleClient::SimpleClient(<span class=\"keyword\">bool</span> use_views)</span><br><span class=\"line\">    : use_views_(use_views), is_closing_(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DCHECK(!g_instance);</span><br><span class=\"line\">    g_instance = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SimpleClient::~SimpleClient()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    g_instance = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// static</span></span><br><span class=\"line\"><span class=\"function\">SimpleClient* <span class=\"title\">SimpleClient::GetInstance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g_instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::OnTitleChange</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 <span class=\"keyword\">const</span> CefString&amp; title)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (use_views_)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果使用CEF的GUI视图框架，那么修改窗体的标题通过调用该视图框架的API完成</span></span><br><span class=\"line\">        CefRefPtr&lt;CefBrowserView&gt; browser_view =</span><br><span class=\"line\">            CefBrowserView::GetForBrowser(browser);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (browser_view)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CefRefPtr&lt;CefWindow&gt; window = browser_view-&gt;GetWindow();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (window)</span><br><span class=\"line\">                window-&gt;SetTitle(title);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则使用特定平台窗体标题修改API</span></span><br><span class=\"line\">        <span class=\"comment\">// 详情见simple_client_os_win.cpp</span></span><br><span class=\"line\">        PlatformTitleChange(browser, title);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::OnAfterCreated</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Add to the list of existing browsers.</span></span><br><span class=\"line\">    browser_list_.push_back(browser);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SimpleClient::DoClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Closing the main window requires special handling. See the DoClose()</span></span><br><span class=\"line\">    <span class=\"comment\">// documentation in the CEF header for a detailed destription of this</span></span><br><span class=\"line\">    <span class=\"comment\">// process.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (browser_list_.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set a flag to indicate that the window close should be allowed.</span></span><br><span class=\"line\">        is_closing_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allow the close. For windowed browsers this will result in the OS close</span></span><br><span class=\"line\">    <span class=\"comment\">// event being sent.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::OnBeforeClose</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Remove from the list of existing browsers.</span></span><br><span class=\"line\">    BrowserList::iterator <span class=\"built_in\">bit</span> = browser_list_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; <span class=\"built_in\">bit</span> != browser_list_.<span class=\"built_in\">end</span>(); ++<span class=\"built_in\">bit</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((*<span class=\"built_in\">bit</span>)-&gt;IsSame(browser))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            browser_list_.erase(<span class=\"built_in\">bit</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (browser_list_.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// All browser windows have closed. Quit the application message loop.</span></span><br><span class=\"line\">        CefQuitMessageLoop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::OnLoadError</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               CefRefPtr&lt;CefFrame&gt; frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               ErrorCode errorCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">const</span> CefString&amp; errorText,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">const</span> CefString&amp; failedUrl)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CEF_REQUIRE_UI_THREAD();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t display an error for downloaded files.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (errorCode == ERR_ABORTED)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Display a load error message using a data: URI.</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">    ss &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;&lt;body bgcolor=\\&quot;white\\&quot;&gt;&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&lt;h2&gt;Failed to load URL &quot;</span></span><br><span class=\"line\">        &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>(failedUrl) &lt;&lt; <span class=\"string\">&quot; with error &quot;</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>(errorText)</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot; (&quot;</span> &lt;&lt; errorCode &lt;&lt; <span class=\"string\">&quot;).&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    frame-&gt;LoadURL(GetDataURI(ss.str(), <span class=\"string\">&quot;text/html&quot;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::CloseAllBrowsers</span><span class=\"params\">(<span class=\"keyword\">bool</span> force_close)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!CefCurrentlyOn(TID_UI))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Execute on the UI thread.</span></span><br><span class=\"line\">        CefPostTask(TID_UI, base::Bind(&amp;SimpleClient::CloseAllBrowsers, <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                                       force_close));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (browser_list_.empty())</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    BrowserList::const_iterator it = browser_list_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; it != browser_list_.<span class=\"built_in\">end</span>(); ++it)</span><br><span class=\"line\">        (*it)-&gt;GetHost()-&gt;CloseBrowser(force_close);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码有重要部分为函数<code>SimpleClient::OnTitleChange</code>的实现。在该实现代码中，通过判断变量<code>use_views_</code>来决定是否使用CEF提供的视图框架，也就有了下面两种情况：</p>\n<ul>\n<li>使用了CEF提供的视图框架：在这种情况下，窗体的标题改变直接使用CEF视图框架提供的API完成修改；</li>\n<li><strong>未</strong>使用CEF提供的视图框架：在这种情况下，我们一定用了原生的窗体框架或者是第三方的（QT或者GTK+），那么就需要调用相关原生窗体的API或者第三方的API来完成窗体标题的修改。</li>\n</ul>\n<p>由于存在上面的情况2，才有了下面的simple_client_os_win.cpp的代码。（PS：上面的代码并没有实现头文件里面的PlatformTitleChange声明哟，只是调用了而已）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// simple_client_os_win.cpp代码</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_client.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_browser.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SimpleClient::PlatformTitleChange</span><span class=\"params\">(CefRefPtr&lt;CefBrowser&gt; browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> CefString&amp; title)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过GetHost()来获取CEF浏览器对象的宿主对象（这里就是Windows原生窗体）</span></span><br><span class=\"line\">    <span class=\"comment\">// 再获取对应的窗体句柄</span></span><br><span class=\"line\">    <span class=\"comment\">// 通过#include &lt;windows.h&gt;得到的WindowsAPI完成标题修改</span></span><br><span class=\"line\">    CefWindowHandle hwnd = browser-&gt;GetHost()-&gt;GetWindowHandle();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hwnd)</span><br><span class=\"line\">        SetWindowText(hwnd, <span class=\"built_in\">std</span>::<span class=\"built_in\">wstring</span>(title).c_str());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码实际上跟特定的平台有关，这里就是Windows平台。</p>\n<ol>\n<li>通过GetHost()来获取CEF浏览器对象的宿主对象（这里就是Windows原生窗体）；</li>\n<li>再获取对应的窗体句柄；</li>\n<li>通过#include <windows.h>得到的WindowsAPI完成标题修改。</li>\n</ol>\n<h3 id=\"入口代码main-cpp\"><a href=\"#入口代码main-cpp\" class=\"headerlink\" title=\"入口代码main.cpp\"></a>入口代码main.cpp</h3><p>编写完成上述的CEF应用模块后，我们最后编写入口代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights</span></span><br><span class=\"line\"><span class=\"comment\">// reserved. Use of this source code is governed by a BSD-style license that</span></span><br><span class=\"line\"><span class=\"comment\">// can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_command_line.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;include/cef_sandbox_win.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;simple_app.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// When generating projects with CMake the CEF_USE_SANDBOX value will be defined</span></span><br><span class=\"line\"><span class=\"comment\">// automatically if using the required compiler version. Pass -DUSE_SANDBOX=OFF</span></span><br><span class=\"line\"><span class=\"comment\">// to the CMake command-line to disable use of the sandbox.</span></span><br><span class=\"line\"><span class=\"comment\">// Uncomment this line to manually enable sandbox support.</span></span><br><span class=\"line\"><span class=\"comment\">// #define CEF_USE_SANDBOX 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(CEF_USE_SANDBOX)</span></span><br><span class=\"line\"><span class=\"comment\">// The cef_sandbox.lib static library may not link successfully with all VS</span></span><br><span class=\"line\"><span class=\"comment\">// versions.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> comment(lib, <span class=\"meta-string\">&quot;cef_sandbox.lib&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Entry point function for all processes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> APIENTRY <span class=\"title\">wWinMain</span><span class=\"params\">(HINSTANCE hInstance,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    HINSTANCE hPrevInstance,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    LPTSTR lpCmdLine,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">int</span> nCmdShow)</span> </span>&#123;</span><br><span class=\"line\">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class=\"line\">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Enable High-DPI support on Windows 7 or newer.</span></span><br><span class=\"line\">    CefEnableHighDPISupport();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>* sandbox_info = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(CEF_USE_SANDBOX)</span></span><br><span class=\"line\">    <span class=\"comment\">// Manage the life span of the sandbox information object. This is necessary</span></span><br><span class=\"line\">    <span class=\"comment\">// for sandbox support on Windows. See cef_sandbox_win.h for complete details.</span></span><br><span class=\"line\">    CefScopedSandboxInfo scoped_sandbox;</span><br><span class=\"line\">    sandbox_info = scoped_sandbox.sandbox_info();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Provide CEF with command-line arguments.</span></span><br><span class=\"line\">    <span class=\"function\">CefMainArgs <span class=\"title\">main_args</span><span class=\"params\">(hInstance)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CEF applications have multiple sub-processes (render, plugin, GPU, etc)</span></span><br><span class=\"line\">    <span class=\"comment\">// that share the same executable. This function checks the command-line and,</span></span><br><span class=\"line\">    <span class=\"comment\">// if this is a sub-process, executes the appropriate logic.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> exit_code = CefExecuteProcess(main_args, <span class=\"literal\">nullptr</span>, sandbox_info);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exit_code &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The sub-process has completed so return here.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> exit_code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Parse command-line arguments for use in this method.</span></span><br><span class=\"line\">    CefRefPtr&lt;CefCommandLine&gt; command_line = CefCommandLine::CreateCommandLine();</span><br><span class=\"line\">    command_line-&gt;InitFromString(::GetCommandLineW());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Specify CEF global settings here.</span></span><br><span class=\"line\">    CefSettings settings;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command_line-&gt;HasSwitch(<span class=\"string\">&quot;enable-chrome-runtime&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Enable experimental Chrome runtime. See issue #2969 for details.</span></span><br><span class=\"line\">        settings.chrome_runtime = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(CEF_USE_SANDBOX)</span></span><br><span class=\"line\">    settings.no_sandbox = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// SimpleApp implements application-level callbacks for the browser process.</span></span><br><span class=\"line\">    <span class=\"comment\">// It will create the first browser instance in OnContextInitialized() after</span></span><br><span class=\"line\">    <span class=\"comment\">// CEF has initialized.</span></span><br><span class=\"line\">    <span class=\"function\">CefRefPtr&lt;SimpleApp&gt; <span class=\"title\">app</span><span class=\"params\">(<span class=\"keyword\">new</span> SimpleApp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize CEF.</span></span><br><span class=\"line\">    CefInitialize(main_args, settings, app.<span class=\"built_in\">get</span>(), sandbox_info);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run the CEF message loop. This will block until CefQuitMessageLoop() is</span></span><br><span class=\"line\">    <span class=\"comment\">// called.</span></span><br><span class=\"line\">    CefRunMessageLoop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Shut down CEF.</span></span><br><span class=\"line\">    CefShutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"编译与运行\"><a href=\"#编译与运行\" class=\"headerlink\" title=\"编译与运行\"></a>编译与运行</h2><p>上述代码完成后，我们的代码结构如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/files-arch.jpg\" alt=\"\"></p>\n<p>我们右键项目使用build指令进行尝试编译，如果不出意外会看到这些内容：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/compile-error.jpg\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;: value &#39;MTd_StaticDebug&#39; doesn&#39;t match value &#39;MDd_DynamicDebug&#39;</span><br></pre></td></tr></table></figure>\n<p>译为中文大意为：未检测到运行时库：<code>MTd_StaticDebug</code>无法匹配<code>MDd_DynamicDebug</code>，MTd是什么？MDd又是什么？关键字：MD、MDd、MT以及MTd。读者可以参考这篇文章深入了解：<a href=\"https://www.cnblogs.com/xzabg/p/5875296.html\">VS运行时 /MD、/MDd 和 /MT、/MTd之间的区别</a>。简单一点讲，我们编译出来的libcef_dll_wrapper.lib库的某个标志与我们当前编译的程序的某个标志不一致：一个是MTd一个是MDd。那么这个标志在哪儿设置呢？我们可以右键项目工程——properties——C/C++——Code Generation（代码生成）——Runtime Library中看到。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/proj-runtime-lib.jpg\" alt=\"\"></p>\n<p>在我们的simple项目中，VS在创建项目的时候默认使用了MDd，那么libcef_dll_wrapper.lib又是使用的什么呢？在《使用CEF（1）— 起步》文章中编译libcef_dll_wrapper.lib的项目目录下使用的是MTd。下图是再回看当时的项目使用的运行库类型：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/wrapper-runtime-lib.jpg\" alt=\"\"></p>\n<p>当然，具体情况也要具体判断。例如Debug与Release的不同，又或者是当时确实是使用MD(d)进行编译的，总之需要一一对应起来。这里我们修改我们的simple项目的RuntimeLibrary为对应的MTd，再次进行编译。不出意外，你会看到如下的编译成功的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rebuild started...</span><br><span class=\"line\">1&gt;------ Rebuild All started: Project: simple-cef, Configuration: Debug x64 ------</span><br><span class=\"line\">1&gt;main.cpp</span><br><span class=\"line\">1&gt;simple_app.cpp</span><br><span class=\"line\">1&gt;simple_client.cpp</span><br><span class=\"line\">1&gt;simple_client_os_win.cpp</span><br><span class=\"line\">1&gt;Generating Code...</span><br><span class=\"line\">1&gt;simple-cef.vcxproj -&gt; D:\\Projects\\cef-projects\\simple-cef\\x64\\Debug\\simple-cef.exe</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Rebuild All: 1 succeeded, 0 failed, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<p>于是，我们运行生成出来的exe，不出意外会有弹框报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------------------------</span><br><span class=\"line\">simple-cef.exe - 系统错误</span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">由于找不到 libcef.dll，无法继续执行代码。重新安装程序可能会解决此问题。 </span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">确定   </span><br><span class=\"line\">---------------------------</span><br></pre></td></tr></table></figure>\n<p>检查目录下发现，确实只有个孤单的可执行程序，并没有那些依赖库。此时我们需要将所有的依赖文件全部复制到运行目录下，主要有以下几个部分需要拷贝：</p>\n<ul>\n<li>Resources</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/cef-resources.jpg\" alt=\"\"></p>\n<p>把<strong>Resources</strong>文件夹里面的所有文件和子文件夹复制到运行目录下。</p>\n<ul>\n<li>CEF依赖库文件</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/cef-runtime-dep-lib.jpg\" alt=\"\"></p>\n<p>将上图中<strong>除了两个lib库文件之外</strong>的组件拷贝到运行目录下。</p>\n<p>此时，我们的编译出来的运行目录如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/app-files-list.png\" alt=\"\"></p>\n<p>我们再次尝试运行该simple-cef，终于能够成功打开，然而<strong>再次</strong>不出意外的话，会看到一个白屏的浏览器窗口。<strong>首先会看到标题，然后转为对应的空白</strong>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/title-change-and-white-screen.gif\" alt=\"\"></p>\n<h3 id=\"运行问题：Check-failed-fallback-available-base-win-GetVersion-gt-base-win-Version-WIN8-1-vs-0\"><a href=\"#运行问题：Check-failed-fallback-available-base-win-GetVersion-gt-base-win-Version-WIN8-1-vs-0\" class=\"headerlink\" title=\"运行问题：Check failed: fallback_available == base::win::GetVersion() &gt; base::win::Version::WIN8 (1 vs. 0)\"></a>运行问题：Check failed: fallback_available == base::win::GetVersion() &gt; base::win::Version::WIN8 (1 vs. 0)</h3><p>上述白屏后，还会在运行目录下会看到一个名为<code>debug.log</code>的文件，打开检查内容。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/debug-log-error.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; debug.log</span><br><span class=\"line\">[0124&#x2F;113454.346:INFO:content_main_runner_impl.cc(976)] Chrome is running in full browser mode.</span><br><span class=\"line\">[0124&#x2F;113454.488:FATAL:dwrite_font_proxy_init_impl_win.cc(91)] Check failed: fallback_available &#x3D;&#x3D; base::win::GetVersion() &gt; base::win::Version::WIN8 (1 vs. 0)</span><br><span class=\"line\">[0124&#x2F;113454.545:FATAL:dwrite_font_proxy_init_impl_win.cc(91)] Check failed: fallback_available &#x3D;&#x3D; base::win::GetVersion() &gt; base::win::Version::WIN8 (1 vs. 0)</span><br></pre></td></tr></table></figure>\n<p>该错误的关键字：CEF base::win::GetVersion() &gt; base::win::Version::WIN8。这里能够得到一个CEF官方论坛的解答：<a href=\"https://magpcss.org/ceforum/viewtopic.php?t=14721&amp;start=10\">CEF Forum  Check failed: fallback_available (magpcss.org)</a>。简单来说，浏览器程序无法加载manifest文件从而无法处理操作系统的版本问题。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ol>\n<li>创建manifest文件放在项目根目录下</li>\n</ol>\n<p>在<strong>项目根目录下</strong>创建一个manifest文件：<strong>simple-cef.manifest</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;assembly xmlns&#x3D;&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion&#x3D;&quot;1.0&quot;&gt;  </span><br><span class=\"line\">  &lt;compatibility xmlns&#x3D;&quot;urn:schemas-microsoft-com:compatibility.v1&quot;&gt;  </span><br><span class=\"line\">    &lt;application&gt; </span><br><span class=\"line\">      &lt;!--The ID below indicates application support for Windows 8.1 --&gt;  </span><br><span class=\"line\">      &lt;supportedOS Id&#x3D;&quot;&#123;1f676c76-80e1-4239-95bb-83d0f6d0da78&#125;&quot;&#x2F;&gt;  </span><br><span class=\"line\">      &lt;!-- 10.0 --&gt;  </span><br><span class=\"line\">      &lt;supportedOS Id&#x3D;&quot;&#123;8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a&#125;&quot;&#x2F;&gt; </span><br><span class=\"line\">    &lt;&#x2F;application&gt; </span><br><span class=\"line\">  &lt;&#x2F;compatibility&gt; </span><br><span class=\"line\">&lt;&#x2F;assembly&gt;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>为项目添加上述manifest</li>\n</ol>\n<p>打开项目的属性，找到<strong>Manifest Tool —— Input and Output —— Additional Manifest Files</strong>，选择项目根目录下的<strong>simple-cef.manifest</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/add-my-manifest.png\" alt=\"\"></p>\n<p>保存后，我们再次构建项目并运行我们的simple-cef.exe，终于看到了期待已久的页面：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-15-write-simple-cef/simple-cef-demo-show.gif\" alt=\"\"></p>\n<h2 id=\"写在结尾\"><a href=\"#写在结尾\" class=\"headerlink\" title=\"写在结尾\"></a>写在结尾</h2><p>在不断的踩坑下，我们终于得到了一个网络页面，不过这并不意味着我们的使用CEF之旅就结束了，恰恰相反，通过这个Demo，我们接触到了更多的东西，有CefApp、CefClient类，有CefBrowserProcessHandler等等，这些类是干什么的？CefWindowDelegate、CefBrowserViewDelegate这里些CEF框架提供的窗体GUI代理又是怎样的概念？CEF跨平台的实现策略又是怎样的呢？问题只增不减，本人也会就着这些问题继续探索并给出总结。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><p><a href=\"https://github.com/w4ngzhen/simple-cef\">w4ngzhen/simple-cef (github.com)</a></p>\n<p>PS：在改源码中，没有将上述的cef相关库以及include文件放在源码库中，因为静态库超过了大小。请读者自行编译并按照指定的方式添加。</p>\n","categories":[],"tags":["cef"]},{"title":"使用CEF（一）— 起步","url":"http://compilemind.com/2021/01/12/2021-01-12-使用CEF（一）— 起步/","content":"<h1 id=\"使用CEF（一）—-起步\"><a href=\"#使用CEF（一）—-起步\" class=\"headerlink\" title=\"使用CEF（一）— 起步\"></a>使用CEF（一）— 起步</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Chromium Embedded Framework (CEF)是个基于Google Chromium项目的开源Web browser控件，支持Windows, Linux, Mac平台。除了提供C/C++接口外，也有其他语言的移植版。</p>\n<p>因为基于Chromium，所以CEF支持<a href=\"https://baike.baidu.com/item/Webkit\">Webkit</a> &amp; Chrome中实现的<a href=\"https://baike.baidu.com/item/HTML5\">HTML5</a>的特性，并且在性能上面，也比较接近Chrome。</p>\n<a id=\"more\"></a>\n<h2 id=\"CEF架构\"><a href=\"#CEF架构\" class=\"headerlink\" title=\"CEF架构\"></a>CEF架构</h2><p><a href=\"http://dev.chromium.org/developers/design-documents/multi-process-architecture\">Chromium架构文档</a></p>\n<h2 id=\"libcef-dll-wrapper\"><a href=\"#libcef-dll-wrapper\" class=\"headerlink\" title=\"libcef_dll_wrapper\"></a>libcef_dll_wrapper</h2><p>在网上，大多数所谓编译CEF的教程，实际上只是编译针对CEF源码的C++包装库：<strong>libcef_dll_wrapper</strong>，并不是真正的编译CEF。libcef动态链接库导出 C API 使得使用者不用关心CEF运行库和基础代码。libcef_dll_wrapper 工程把 C API 封装成 C++ API同时包含在客户端应用程序工程中。C/C++ API的转换层代码是由转换工具自动生成。实际上，想要编译CEF源码是一件非常麻烦的事情，你需要梯子、良好的网速以及不错的电脑。回归正题，我们开始编译libcef_dll_wrapper。</p>\n<h3 id=\"编译前准备\"><a href=\"#编译前准备\" class=\"headerlink\" title=\"编译前准备\"></a>编译前准备</h3><p>cmake：<a href=\"https://cmake.org/download/\">https://cmake.org/download/</a></p>\n<p>vs2019：<a href=\"https://visualstudio.microsoft.com/zh-hans/vs/\">https://visualstudio.microsoft.com/zh-hans/vs/</a></p>\n<p>CEF以及Wrapper源码：<a href=\"https://cef-builds.spotifycdn.com/index.html\">https://cef-builds.spotifycdn.com/index.html</a></p>\n<h3 id=\"下载libcef以及wrapper\"><a href=\"#下载libcef以及wrapper\" class=\"headerlink\" title=\"下载libcef以及wrapper\"></a>下载libcef以及wrapper</h3><p>我们首先从CDN上下载ceflib静态库以及wrapper源码：Windows64bit，标准分发（Standard Distribution）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/download-cef.jpg\" alt=\"\"></p>\n<p>下载完成后，我们解压到工作目录下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/cef-decompression-dir.jpg\" alt=\"\"></p>\n<p>在这个目录下，会看到很多的文件夹和目录。其中主要的几个文件夹：</p>\n<ul>\n<li><p><strong>cmake</strong>：该目录下存放了配置和构建以Windows作为编译环境的cmake配置文件，具体内容可以自行查看。</p>\n</li>\n<li><p><strong>Debug和Release</strong>：这两个文件夹中，打开会看到已经编译好的CEF核心库文件：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/libcef-files.jpg\" alt=\"\"></p>\n<ul>\n<li><strong>include</strong>：libcef本身提供的头文件以及wrapper会使用到的头文件。</li>\n<li><p><strong>libcef_dll</strong>：存放了<strong>libcef_dll_wrapper</strong>源码。</p>\n</li>\n<li><p><strong>Resources</strong>：CEF作为内核的浏览器运行时需要用到的资源文件。</p>\n</li>\n<li><strong>tests</strong>：存放了利用libcef、以及wrapper作为库来编写的浏览器Demo。其中，cefsimple编译出来的是一个简单的浏览器，而cefclient编译出来的是一个展示了cef许多API功能的exe。</li>\n</ul>\n<h3 id=\"使用cmake进行配置构建\"><a href=\"#使用cmake进行配置构建\" class=\"headerlink\" title=\"使用cmake进行配置构建\"></a>使用cmake进行配置构建</h3><p>打开cmake-gui.exe程序，在<code>Where is the source code</code>栏中选择源码所在目录，在下方的<code>Where to build the binaries</code>栏目中我们可以自定义任意位置，但是为了方便管理，我们选择在源码所在目录下增加一个build文件夹，所以综合来看，当前cmake-gui的配置为：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/cmakegui-config.jpg\" alt=\"\"></p>\n<p>接下来我们直接点击下方的<code>Configure</code>按钮，cmake-gui会弹框提示没有build文件夹，会帮助你ui创建一个build文件夹，以及让你选择构建工具：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/create-build-dir.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/select-vs.jpg\" alt=\"\"></p>\n<p>完成配置后，我们进行cmake的生成操作（Generate），并打开该解决方案：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/generate-and-open.jpg\" alt=\"\"></p>\n<h3 id=\"编译libcef-dll-wrapper\"><a href=\"#编译libcef-dll-wrapper\" class=\"headerlink\" title=\"编译libcef_dll_wrapper\"></a>编译libcef_dll_wrapper</h3><p>上述使用cmake配置构建后，在Windows下，我们得到了一个解决方案：cef.sln。使用vs2019打开后，我们会看到解决方案中已经存在了几个工程：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/projects-in-sln.jpg\" alt=\"\"></p>\n<ul>\n<li><strong>ALL_BUILD与ZERO_CHECK</strong>：是cmake自动生成的辅助工程。</li>\n<li><strong>cef_gtest与ceftests</strong>：都是测试模块,这里不关心。</li>\n<li><strong>cefclient</strong>：一个包含CEF各种API演示的浏览器程序Demo。</li>\n<li><strong>cefsimple</strong>：一个简单的CEF浏览器程序Demo。</li>\n<li><strong>libcef_dll_wrapper</strong>：对libcef库的C++代码封装。上述cefclient与cefsimple都会用它。</li>\n</ul>\n<p>我们首先完成libcef_dll_wrapper的编译，然后对cefclient以及cefsimple完成编译。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2&gt;libcef_dll_wrapper.vcxproj -&gt; D:\\Projects\\cef\\cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64\\build\\libcef_dll_wrapper\\Debug\\libcef_dll_wrapper.lib</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Build: 2 succeeded, 0 failed, 0 up-to-date, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt;   Creating library D:&#x2F;Projects&#x2F;cef&#x2F;cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64&#x2F;build&#x2F;tests&#x2F;cefsimple&#x2F;Debug&#x2F;cefsimple.lib and object D:&#x2F;Projects&#x2F;cef&#x2F;cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64&#x2F;build&#x2F;tests&#x2F;cefsimple&#x2F;Debug&#x2F;cefsimple.exp</span><br><span class=\"line\">1&gt;cefsimple.vcxproj -&gt; D:\\Projects\\cef\\cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64\\build\\tests\\cefsimple\\Debug\\cefsimple.exe</span><br><span class=\"line\">1&gt;Adding manifest...</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Build: 1 succeeded, 0 failed, 2 up-to-date, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt;   Creating library D:&#x2F;Projects&#x2F;cef&#x2F;cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64&#x2F;build&#x2F;tests&#x2F;cefclient&#x2F;Debug&#x2F;cefclient.lib and object D:&#x2F;Projects&#x2F;cef&#x2F;cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64&#x2F;build&#x2F;tests&#x2F;cefclient&#x2F;Debug&#x2F;cefclient.exp</span><br><span class=\"line\">1&gt;cefclient.vcxproj -&gt; D:\\Projects\\cef\\cef_binary_87.1.13+g481a82a+chromium-87.0.4280.141_windows64\\build\\tests\\cefclient\\Debug\\cefclient.exe</span><br><span class=\"line\">1&gt;Adding manifest...</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Build: 1 succeeded, 0 failed, 2 up-to-date, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<p>完成了编译以后，我们可以直接进入cefclient或者是cefsimple里面的输出中运行对应的浏览器程序：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/demo-show.jpg\" alt=\"\"></p>\n<p>注意，cefsimple.exe打开白屏是因为demo代码中默认访问的Google，cefclient.exe其实默认也访问的Google，但是因为可以输入任意的地址，所以这里不太容易发现。</p>\n<p>cefsimple中的默认访问地址修改为国内即可（cefclient中的自行搜索）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2021-01-12-start-cef/change-init-url.jpg\" alt=\"\"></p>\n<p>下一节，将从零开始，使用cef来编写一个简单Demo。</p>\n","categories":[],"tags":["cef"]},{"title":"node-pre-gyp以及node-gyp的源码简单解析（以安装sqlite3为例）","url":"http://compilemind.com/2020/11/27/2020-11-27-node-pre-gyp以及node-gyp的源码简单解析（以安装sqlite3为例）/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>简单来说，node是跨平台的，那么对于任何的node模块理论也是应该是跨平台的。然而，有些node模块直接或间接使用原生C/C++代码，这些东西要跨平台，就需要使用源码根据实际的操作平台环境进行原生模块编译。SQLite3就是一个经典的原生模块，让我们以安装该模块为例，探索一下安装原生模块的流程。</p>\n<a id=\"more\"></a>\n<h1 id=\"项目建立\"><a href=\"#项目建立\" class=\"headerlink\" title=\"项目建立\"></a>项目建立</h1><p>建立一个简单的node项目，我们开始安装<code>SQLite3</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir sqlite3-install-demo </span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> sqlite3-install-demo</span><br><span class=\"line\">$ npm init</span><br><span class=\"line\"><span class=\"comment\"># 初始化项目</span></span><br><span class=\"line\">Press ^C at any time to quit.</span><br><span class=\"line\">package name: (projects) sqlite3-install-demo</span><br><span class=\"line\">version: (1.0.0)</span><br><span class=\"line\">description:</span><br><span class=\"line\">entry point: (index.js)</span><br><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"built_in\">command</span>:</span><br><span class=\"line\">git repository:</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author:</span><br><span class=\"line\">license: (ISC) MIT</span><br><span class=\"line\">About to write to D:\\Projects\\package.json:</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;sqlite3-install-demo&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;version&quot;</span>: <span class=\"string\">&quot;1.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;description&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;main&quot;</span>: <span class=\"string\">&quot;index.js&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;test&quot;</span>: <span class=\"string\">&quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;author&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;license&quot;</span>: <span class=\"string\">&quot;MIT&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装SQLite3\"><a href=\"#安装SQLite3\" class=\"headerlink\" title=\"安装SQLite3\"></a>安装<code>SQLite3</code></h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -S sqlite3</span><br></pre></td></tr></table></figure>\n<p>完成命令执行后，你会看到命令行界面出现了如下的几行<strong>重要</strong>的输出：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&gt; sqlite3@5.0.0 install D:\\Projects\\sqlite3-install-demo\\node_modules\\sqlite3</span><br><span class=\"line\">&gt; node-pre-gyp install --fallback-to-build</span><br><span class=\"line\"></span><br><span class=\"line\">node-pre-gyp WARN Using request <span class=\"keyword\">for</span> node-pre-gyp https download</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>啪一下，很快啊！我们就迎来了第一个东西<code>node-pre-gyp</code>，但是提到了<code>node-pre-gyp</code>，我们不得不提及<code>node-gyp</code>，然后又不得不提及<code>gyp</code>。</p>\n<h1 id=\"gyp与node-gyp与node-pre-gyp\"><a href=\"#gyp与node-gyp与node-pre-gyp\" class=\"headerlink\" title=\"gyp与node-gyp与node-pre-gyp\"></a>gyp与node-gyp与node-pre-gyp</h1><h2 id=\"什么是gyp？\"><a href=\"#什么是gyp？\" class=\"headerlink\" title=\"什么是gyp？\"></a>什么是gyp？</h2><p>gyp全称<code>Generate Your Projects</code>（构建你的项目）。wiki的解释如下，自行翻译：</p>\n<blockquote>\n<p>GYP (generate your projects) is a build automation tool. GYP was created by Google to generate native IDE project files (such as Visual Studio Code and Xcode) for building the Chromium web browser and is licensed as open source software using the BSD software license.</p>\n</blockquote>\n<p>重点在于，它是一套用于生成原生IDE项目文件的自动化构建工具，处理C/C++项目，同类型的有CMake、ninja等自动构建工具。</p>\n<h2 id=\"什么是node-gyp？\"><a href=\"#什么是node-gyp？\" class=\"headerlink\" title=\"什么是node-gyp？\"></a>什么是node-gyp？</h2><p>直接给出<code>stackoverflow</code>高票回答：</p>\n<blockquote>\n<p><code>node-gyp</code> is a tool which compiles Node.js Addons. Node.js Addons are native Node.js Modules, written in C or C++, which therefore need to be compiled on your machine. After they are compiled with tools like node-gyp, their functionality can be accessed via <code>require()</code>, just as any other Node.js Module.</p>\n</blockquote>\n<p>简单来说，node是跨平台的，那么对于任何的node模块理论也是应该是跨平台的。然而，有些node模块直接或间接使用原生C/C++代码，这些东西要跨平台，就需要使用源码根据实际的操作平台环境进行原生模块编译。那么我们需要下载源码文件，通过node-gyp生成一定结构的代码项目让我们能够<code>require</code>引入（譬如，Windows下会生成<code>vcxproj</code>，再调用<code>MSBuild</code>进行编译，以生成Windows下的动态链接库，最后打包为一个原生node模块）。这个知乎回答的每一条可以看看：<a href=\"https://www.zhihu.com/question/36291768\">传送门</a>。</p>\n<h2 id=\"什么是node-pre-gyp？\"><a href=\"#什么是node-pre-gyp？\" class=\"headerlink\" title=\"什么是node-pre-gyp？\"></a>什么是node-pre-gyp？</h2><p>上面<code>node-gyp</code>固然相当方便了，但是每一次安装node原生模块的时候，都需要根据平台（Windows、Linux、macOS以及对应的x86、x64、arm64等等）进行源码编译，这样做费时费力。为什么不一开始就针对这些平台编译好了做成二进制制品发布呢？反正一般来说主流的平台架构就那么一些（Windows、Linux、macOS）。所以<code>node-pre--gyp</code>就帮我们做了这件事。原生模块开发者将代码编译生成各个平台架构的二进制包直接发布到<code>node-pre-gyp</code>上，当我们的node项目安装原生模块时候。处理流程就是首先去<code>node-pre-gyp</code>上找有没有当前平台的组件包，有的话直接拉取使用，如果没有则进行原生编译。</p>\n<p><code>node-pre-gyp</code>一些<strong>重要参数</strong>（不全）：</p>\n<ul>\n<li><code>-C/--directory</code>: run the command in this directory</li>\n<li><code>--build-from-source</code>: build from source instead of using pre-built binary</li>\n<li><code>--fallback-to-build</code>: fallback to building from source if pre-built binary is not available</li>\n<li><code>--target=0.4.0</code>: Pass the target node or node-webkit version to compile against</li>\n<li><code>--target_arch=ia32</code>: Pass the target arch and override the host <code>arch</code>. Valid values are ‘ia32’,’x64’, or <code>arm</code>.</li>\n<li><code>--target_platform=win32</code>: Pass the target platform and override the host <code>platform</code>. Valid values are <code>linux</code>, <code>darwin</code>, <code>win32</code>, <code>sunos</code>, <code>freebsd</code>, <code>openbsd</code>, and <code>aix</code>.</li>\n</ul>\n<p>对于<code>--fallback-to-build</code>这个参数：如果二进制不可获取则直接从源码编译，即从<code>node-pre-gyp</code>又回到<code>node-gyp</code>。所以你才会在上文看到安装sqlite3的时候，会有<code>--fallback-to-build</code>。</p>\n<p>于是乎，当我们进行node原生模块安装的时候，一般会有如下的流程：</p>\n<ol>\n<li>针对当前平台架构优先考虑<code>node-pre-gyp</code>方式进行安装，但是为了防止无法获取针对对应平台编译好的二进制包（网络原因、暂时没有对应平台的二进制包），进入第2步；</li>\n<li>下载原生模块源码，然后使用<code>node-gyp</code>进行项目构建，得到与平台相关的源码项目文件（Windows则生成<code>vcxproj</code>项目，Linux下是<code>Makefile</code>）；在这个过程，<code>node-gyp</code>会使用<code>Python</code>进行自动化构建操作，这也是为什么有些朋友安装node原生模块的时候，会报错找不到<code>Python</code>。</li>\n<li>调用平台对应的编译工具进行编译。在Windows的环境下，<code>node-gyp</code>会查找本地的<code>MSBuild/CL</code>等编译工具，而这些编译工具又一般在<code>Visual Studio</code>安装的时候，也一并安装在了机器上。这就是为什么有些朋友没有安装<code>Visual Studio</code>的时候，会报错。</li>\n</ol>\n<h1 id=\"探索SQLite3的安装流程\"><a href=\"#探索SQLite3的安装流程\" class=\"headerlink\" title=\"探索SQLite3的安装流程\"></a>探索SQLite3的安装流程</h1><h2 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a><code>npm install</code></h2><p>为什么我们安装<code>sqlite3</code>的时候，会调用<code>node-pre-gyp</code>命令呢？进入<code>项目目录/node_modules/sqlite3/</code>文件夹，让我们查看一下<code>package.json</code>中的<code>scripts</code>部分：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">    &quot;url&quot;: &quot;git://github.com/mapbox/node-sqlite3.git&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;install&quot;: &quot;node-pre-gyp install --fallback-to-build&quot;, // install</span><br><span class=\"line\">    &quot;pack&quot;: &quot;node-pre-gyp package&quot;,</span><br><span class=\"line\">    &quot;pretest&quot;: &quot;node test/support/createdb.js&quot;,</span><br><span class=\"line\">    &quot;test&quot;: &quot;mocha -R spec --timeout 480000&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;5.0.0&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案显而易见了，<code>install</code>脚本中执行了<code>node-pre-gyp install --fallback-to-build</code>命令。</p>\n<p>这就不得不提到<code>npm</code>的安装流程是。当我们进行<code>npm install xxx</code>的时候，<code>npm</code>首先下载<code>xxx</code>的包。下载完成后，若<code>package.json</code>中的scripts中存在<code>install</code>属性，则会立刻调用。至于<code>scripts</code>中的其他固定脚本：<code>test</code>、<code>preinstall</code>、<code>postinstall</code>等等作用以及<code>scripts</code>的高级用法，请直接查阅<a href=\"https://docs.npmjs.com/cli/v6/using-npm/scripts\">scripts | npm Docs (npmjs.com)</a>。</p>\n<p>所以本此<code>sqlite3</code><strong>前期</strong>安装的过程为：</p>\n<ol>\n<li><code>npm</code>下载在仓库中的<code>sqlite3</code>npm包；</li>\n<li>执行<code>$&#123;your_projects&#125;/node_modules/sqlite3/package.json</code>中的<code>install</code>脚本，即<code>node-pre-gyp install --fallback-to-build</code></li>\n</ol>\n<p>于是乎，安装进入到了一个新的环节：<code>node-pre-gyp install</code>。当然，若你没有全局安装<code>node-pre-gyp</code>，它会由<code>npm</code>帮你安装到<code>$&#123;your_projects&#125;/node_modules/</code>中，并且通过<code>node-pre-gyp/package.json</code>中的<code>bin</code>元素，建立软连接到<code>$&#123;your_projects&#125;/node_modules/.bin</code>中。这样，<code>node\\npm</code>环境中就有了<code>node-pre-gyp</code>命令可以使用。至于<code>package.json#bin</code>的作用，详细参考官方文档<a href=\"https://docs.npmjs.com/cli/v6/configuring-npm/package-json#bin\">package.json | npm Docs (npmjs.com)</a>。</p>\n<h2 id=\"node-pre-gyp-install\"><a href=\"#node-pre-gyp-install\" class=\"headerlink\" title=\"node-pre-gyp install\"></a><code>node-pre-gyp install</code></h2><p><code>node-pre-gyp</code>在上述的安装流程中，已经能够被我们在CLI中所使用。查看<code>node_modules/node-pre-gyp/bin/node-pre-gyp</code>文件（下文都将省略<code>$&#123;your_projects&#125;/</code>），用文本的形式打开。就是<code>node-pre-gyp</code>CLI的执行过程，脚本中的主要内容为最后一行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// start running the given commands!</span><br><span class=\"line\">run();</span><br></pre></td></tr></table></figure>\n<p>检查该函数的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> command = prog.todo.shift();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!command) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// done!</span></span><br><span class=\"line\">    completed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    log.info(<span class=\"string\">&#x27;ok&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  prog.commands[command.name](command.args, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      log.error(command.name + <span class=\"string\">&#x27; error&#x27;</span>);</span><br><span class=\"line\">      log.error(<span class=\"string\">&#x27;stack&#x27;</span>, err.stack);</span><br><span class=\"line\">      errorMessage();</span><br><span class=\"line\">      log.error(<span class=\"string\">&#x27;not ok&#x27;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err.message);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> process.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args_array = [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args_array.length) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, args_array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// now run the next command in the queue</span></span><br><span class=\"line\">    process.nextTick(run);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>prog</code>是什么？该文件往上查看定义，原来是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node_pre_gyp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../&#x27;</span>); <span class=\"comment\">// 上一个目录作为模块引入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> log = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;npmlog&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Process and execute the selected commands.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> prog = <span class=\"keyword\">new</span> node_pre_gyp.Run(); <span class=\"comment\">// 来自于node_pre_gyp中的Run，而node_pre_gyp在上方</span></span><br></pre></td></tr></table></figure>\n<p>继续检查上一个目录，发现并没又<code>indes.js</code>文件，熟悉<code>npm</code>的朋友应该知道要去看<code>package.json</code>中的<code>main</code>元素了：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">\t&quot;license&quot;: &quot;BSD-3-Clause&quot;,</span><br><span class=\"line\">\t&quot;main&quot;: &quot;./lib/node-pre-gyp.js&quot;, // 模块是这个文件</span><br><span class=\"line\">\t&quot;name&quot;: &quot;node-pre-gyp&quot;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>查阅<code>lib/node-pre-gyp.js</code>代码中的Run：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.commands = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  commands.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">command</span>) </span>&#123;</span><br><span class=\"line\">    self.commands[command] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argv, callback</span>) </span>&#123;</span><br><span class=\"line\">      log.verbose(<span class=\"string\">&#x27;command&#x27;</span>, command, argv);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./&#x27;</span> + command)(self, argv, callback); <span class=\"comment\">// 这里是核心</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>核心功能就是引入当前所在目录下的模块进行执行。例如，本次调用的是<code>node-pre-gyp install</code>，则会<code>require(./install)</code>，检查一下<code>node-pre-gyp.js</code>目录下，果然存在该<code>js</code>文件。继续阅读<code>install.js</code>源码。里面有几个函数的定义。咱们先不看内容，把函数名列举出来，猜测一下作用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 去下载平台编译好的二进制？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">download</span>(<span class=\"params\">uri,opts,callback</span>) </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">// 把下载好的二进制放到对应目录？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">place_binary</span>(<span class=\"params\">from,to,opts,callback</span>) </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">// 进行构建。难道是没有下载，就调用node-gyp源码编译？</span></span><br><span class=\"line\"><span class=\"comment\">// 还有，node-pre-gyp又--fallback-to-build参数，也会调用这个？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do_build</span>(<span class=\"params\">gyp,argv,callback</span>) </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">// 打印回退出现的异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print_fallback_error</span>(<span class=\"params\">err,opts,package_json</span>) </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">// 安装，核心没跑了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span>(<span class=\"params\">gyp, argv, callback</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>首先看<code>download</code>的调用点是在<code>place_binary</code>中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">place_binary</span>(<span class=\"params\">from,to,opts,callback</span>) </span>&#123; <span class=\"comment\">// place_binary函数</span></span><br><span class=\"line\">    download(<span class=\"keyword\">from</span>,opts,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,req</span>) </span>&#123; <span class=\"comment\">// 调用了download</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!req) <span class=\"keyword\">return</span> callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;empty req&quot;</span>));</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看<code>place_binary</code>调用点是在<code>install</code>中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span>(<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 省略部分...</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> should_do_source_build = source_build === package_json.name || (source_build === <span class=\"literal\">true</span> || source_build === <span class=\"string\">&#x27;true&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (should_do_source_build) &#123; <span class=\"comment\">// 源码编译</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&#x27;build&#x27;</span>,<span class=\"string\">&#x27;requesting source compile&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> do_build(gyp,argv,callback);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 省略部分...</span></span><br><span class=\"line\">        mkdirp(to,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">\t\t\t\tafter_place(err);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tplace_binary(<span class=\"keyword\">from</span>,to,opts,after_place); <span class=\"comment\">// 调用点</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 省略部分...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 省略部分...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述分析，整个大的处理流程如下：</p>\n<ol>\n<li>进入<code>install</code>函数</li>\n<li>检查是否需要<code>build-from-source</code>。是则进，入<code>do_build</code>分支，进行源码编译；否则进入步骤3。</li>\n<li>检查是否启用<code>--fallback-to-build</code>参数，设定是否启用标志位。</li>\n<li>解析编译好的二进制文件的选项配置，譬如二进制文件存放地址，也就是通过请求下载对应二进制包的地址，以及各种各样参数。所以说，为什么下载很慢，我们后文会重点关注下载地址。</li>\n</ol>\n<h3 id=\"下载二进制包\"><a href=\"#下载二进制包\" class=\"headerlink\" title=\"下载二进制包\"></a>下载二进制包</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/hosted_tarball_download.png\" alt=\"\"></p>\n<p>根据流程，接下来我们进一步检查<code>versioning.js</code>文件，找到其中的<code>evaluate</code>函数，分析最后的<code>hosted_tarball</code>路径：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/analysis_hosted_path.png\" alt=\"\"></p>\n<p><code>hosted_tarball</code>路径主要分为两个部分：1、<code>hosted_path</code>；2、<code>package_name</code>。</p>\n<h4 id=\"hosted-path\"><a href=\"#hosted-path\" class=\"headerlink\" title=\"hosted_path\"></a>hosted_path</h4><p>经过源码分析来源路径为：</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/opts.hosted_path-analysis.png\" alt=\"\"></p>\n<p>我们自底向上分析。</p>\n<p><code>host</code>变量取决于从环境变量中检查名称为<code>&#39;npm_config_&#39; + opts.module_name + &#39;_binary_host_mirror&#39;</code>的环境变量。如果不存在，则使用<code>package_json.binary.host</code>。正常使用的时候，我们并不会设定环境变量，所以这里就进入<code>package_json.binary</code>进行获取。这个<code>package_json</code>是<code>evaluate</code>函数被调用时候传入的，在<code>node-pre-gyp/install.js</code>中能够看到：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/import-gyp.png\" alt=\"\"></p>\n<p>一开始分析的时候，看到这里，本人以为<code>package_json</code>就是<code>node-pre-gyp/package.json</code>，于是本人去检查该<code>json</code>发现很奇怪，并没有binary属性，更别提host了。一番思考才明白，<code>node-pre-gyp install</code>的运行时调用者是谁呀？不是应该是<code>sqlite3</code>吗？所以这个地方的<code>require(&#39;./package.json&#39;)</code>实际上是指代的是<code>sqlite3/package.json</code>。查看<code>sqlite3/package.json</code>，果然发现了对应的元素：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/sqlite3-binary.png\" alt=\"\"></p>\n<p>在<code>binary</code>属性中，我们还能看到<code>remote_path</code>也在其中。</p>\n<p>至此，<code>hosted_path</code>我们完成了简单的分析，我们可以得出一个结论：</p>\n<p><strong><code>node-pre-gyp</code>下载二进制文件的路径，优先来源于对应模块的镜像地址，该镜像地址通过配置<code>&#39;npm_config_&#39; + 模块名 + &#39;_binary_host_mirror&#39;</code>来实现自定义；在没有定义镜像地址的情况下，读取模块<code>package.json</code>中的binary属性信息。</strong></p>\n<p>当然，读者可以根据具体情况再进一步分析源码。</p>\n<h4 id=\"package-name\"><a href=\"#package-name\" class=\"headerlink\" title=\"package_name\"></a>package_name</h4><p>其实，对于<code>hosted_path</code>的分析，我们也容易分析<code>package_name</code>了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/opts.package_name-analysis.png\" alt=\"\"></p>\n<p>自底向上分析，来自于<code>sqlite3/package.json</code>中<code>binary</code>属性中的<code>package_name</code>，内容见上图分析<code>host</code>。</p>\n<h4 id=\"失败处理\"><a href=\"#失败处理\" class=\"headerlink\" title=\"失败处理\"></a>失败处理</h4><p><code>--fallback-to-build</code>参数表明了是否进行失败后下载源码进行编译，源码不再分析。</p>\n<h3 id=\"从源码构建\"><a href=\"#从源码构建\" class=\"headerlink\" title=\"从源码构建\"></a>从源码构建</h3><h4 id=\"build-js\"><a href=\"#build-js\" class=\"headerlink\" title=\"build.js\"></a>build.js</h4><p>当我们提供了参数<code>--build-from-source</code>或是在下载编译好的二进制到本地出错的时提供了参数<code>--fallback-to-build</code>。node-pre-gyp将进入<code>do_build</code>模块，进行源码编译。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function do_build(gyp,argv,callback) &#123;</span><br><span class=\"line\">  var args &#x3D; [&#39;rebuild&#39;].concat(argv);</span><br><span class=\"line\">  gyp.todo.push( &#123; name: &#39;build&#39;, args: args &#125; );</span><br><span class=\"line\">  process.nextTick(callback);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码中，<code>gyp</code>由调用install的时候，传入：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/gyp-from-install.png\" alt=\"\"></p>\n<p>那么我们又将回到调用install的地方。实际上，gyp就是node-pre-gyp.js导出的模块：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/node-pre-gyp-export.png\" alt=\"\"></p>\n<p>也就是说在<code>do_build</code>中进行操作就是，放置了一个<code>build</code>任务在队列中。所以我们按照先前的分析，直接去看<code>build.js</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/build-buildjs.png\" alt=\"\"></p>\n<p>看源码调用了当前模块中的<code>do_build</code>，且其中最核心的就是<code>compile</code>模块：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/do_build-buildjs.png\" alt=\"\"></p>\n<h4 id=\"util-compile-js\"><a href=\"#util-compile-js\" class=\"headerlink\" title=\"util/compile.js\"></a>util/compile.js</h4><p>进入compile模块，直接找到对应的<code>run_gyp</code>函数，代码很短，不难看出进行构建调用了<code>node-gyp</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/run-gyp.png\" alt=\"\"></p>\n<p>上述代码，会先考略<code>node-webkit</code>构建。但是我们核心的还是使用<code>node-gyp</code>，所以else中，会进行<code>node-gyp</code>的工具的检查工作。最后调用命令行执行<code>node-gyp</code>。于是，node原生模块的安装工作，进入了新的阶段：<code>node-gyp</code>。</p>\n<h2 id=\"node-gyp-build\"><a href=\"#node-gyp-build\" class=\"headerlink\" title=\"node-gyp build\"></a><code>node-gyp build</code></h2><p>上文提到我们已经进入了<code>node-gyp</code>的范畴，会调用<code>node-gyp build</code>操作。当然，这个命令同样是在安装<code>node-gyp</code>依赖的时候已经完成了安装，并且进行<code>node_modules/.bin/</code>软连接操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"string\">&quot;bin&quot;</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;node-gyp&quot;</span>: <span class=\"string\">&quot;bin/node-gyp.js&quot;</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>我们进入该<code>js</code>进行分析</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/node-gyp-GYP.png\" alt=\"\"></p>\n<p>实际上，<code>node-gyp</code>这段的命令行代码，和<code>node-pre-gyp</code>非常相似！所以我们也不去深入分析调用命令行了。直接在lib文件夹下面的<code>build.js</code>。在该<code>js</code>中，核心的方法为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">build</span> (<span class=\"params\">gyp, argv, callback</span>) </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在该方法中，还编写了几个<strong>内部函数</strong>，作为了功能的划分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// function build (gyp, argv, callback) 内部函数</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Load the &quot;config.gypi&quot; file that was generated during &quot;configure&quot;.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadConfigGypi</span> (<span class=\"params\"></span>) </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * On Windows, find the first build/*.sln file.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findSolutionFile</span> (<span class=\"params\"></span>) </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Uses node-which to locate the msbuild / make executable.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doWhich</span> (<span class=\"params\"></span>) </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Search for the location of &quot;msbuild.exe&quot; file on Windows.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMsbuild</span> (<span class=\"params\"></span>) </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Actually spawn the process and compile the module.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doBuild</span> (<span class=\"params\"></span>) </span>&#123;...&#125;  </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Invoked after the make/msbuild command exits.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onExit</span> (<span class=\"params\">code, signal</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>不得不说，<code>build</code>写的真心不错，看起来很舒服。这里为了方便读者快速阅读，我整理这些函数的调用图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-11-27-node-native-install/node-gyp-build-flow.png\" alt=\"\"></p>\n<p>整个调用流程图个人认为足够进行安装的时候的一场分析了。至于每个内部函数的功能，有空继续更新本文吧。</p>\n","categories":[],"tags":["node","native","sqlite3"]},{"title":"再议Windows消息与WinForm事件","url":"http://compilemind.com/2020/10/13/2020-10-13-再议Windows消息与WinForm事件/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在2月份的时候，我之前曾经写过一篇关于Windows消息与C# WinForm事件机制的文章，名为《WinForm事件与消息》。在那篇文章中，我简单探讨了一下事件和消息。然而如今看来，当时的文章中的案例在运行上存在一定的问题，并且内容也有所缺陷，于是本文将重新优化文章的内容。</p>\n<a id=\"more\"></a>\n<h1 id=\"消息概述\"><a href=\"#消息概述\" class=\"headerlink\" title=\"消息概述\"></a>消息概述</h1><p>Windows下窗体应用程序的执行是通过消息驱动的。所有的外部事件，如键盘输入、鼠标移动、按动鼠标都由用户所触发；然后OS接收到对应的“消息”；然后送入消息队列中；接下来，启动的应用程序的工作引擎通过轮询等方式遍历获取，然后按照消息的类型逐个分发（Dispatch）到对应的组件（例如窗体、按钮等），最后才调用对应组件所注册的事件进行处理。</p>\n<h1 id=\"处理消息\"><a href=\"#处理消息\" class=\"headerlink\" title=\"处理消息\"></a>处理消息</h1><p>一般来说，使用WinForm技术进行开发，绝大部分的情况下，我们都在做上述流程的最后一件事情：给各种控件注册事件。毕竟，WinForm真的为我们封装了绝大部分的事件了。而通常的WinForm开发，我们都离不开一个东西：System.Windows.Forms.Application。</p>\n<h2 id=\"System-Windows-Forms-Application\"><a href=\"#System-Windows-Forms-Application\" class=\"headerlink\" title=\"System.Windows.Forms.Application\"></a>System.Windows.Forms.Application</h2><p>Application具有用于启动和停止应用程序和线程以及处理Windows消息的方法。例如，调用Run以启动当前线程上的应用程序消息循环，并可以选择使其窗体可见；调用Exit或ExitThread来停止消息循环。所以我们经常使用vs初始化一个基本的WinForm程序，显示的下列模板代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 应用程序的主入口点。</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">[<span class=\"meta\">STAThread</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Application.EnableVisualStyles();</span><br><span class=\"line\">    Application.SetCompatibleTextRenderingDefault(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    Application.Run(<span class=\"keyword\">new</span> Form1()); <span class=\"comment\">// 调用Run以启动当前线程上的应用程序消息循环</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为Application是在单线程中运行的，所以在Application.Run开始后，Application本身不断轮询检查消息队列，然后根据消息类型进行数据分发。例如，当我们为这个Form1增加一个鼠标的点击事件后，我们运行该打开Form1：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Form1 form1 = <span class=\"keyword\">new</span> Form1();</span><br><span class=\"line\">form1.MouseClick += </span><br><span class=\"line\">                (sender, e) =&gt; MessageBox.Show(<span class=\"string\">@&quot;MouseClick 1&quot;</span>);</span><br><span class=\"line\">form1.MouseClick += </span><br><span class=\"line\">                (sender, e) =&gt; MessageBox.Show(<span class=\"string\">@&quot;MouseClick 2&quot;</span>);</span><br><span class=\"line\">Application.Run(form1);</span><br></pre></td></tr></table></figure>\n<p>运行后点击Form，可以看到首先出现一个MessageBox，展示“MouseClick 1”，我们点击确定后，又会出现MessageBox，展示“MouseClick 2”。实际上整个过程应该如下：</p>\n<p>当我们按下鼠标左键后，消息形成并送往应用程序消息队列中，然后被Application类从应用程序消息队列中取出，然后分发到相应的窗体。窗体使用MouseClick事件中的函数指针调用已经添加的响应函数。所以C#中的事件字段实质上是一个函数指针列表，用来维护一些消息到达时的响应函数的地址。</p>\n<p>到目前为止我们可以看到，消息其实在我们进行事件调用的时候，已经被提取加工了，它已经由Application进行了预处理，形成了所谓的“事件调用”。那么，我们还能更加自定义的干预消息吗？答案是可以的。</p>\n<h2 id=\"WndProc\"><a href=\"#WndProc\" class=\"headerlink\" title=\"WndProc\"></a>WndProc</h2><p>在.NET框架类库中的System.Windows.Forms命名空间中微软采用面对对象的方式重新定义了Message。该消息主要有一下的几个公共属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.Windows.Forms.Message</span><br><span class=\"line\">HWnd     获取或设定消息的处理函数</span><br><span class=\"line\">Msg      获取或设定消息的ID号</span><br><span class=\"line\">Lparam   指定消息的LParam字段</span><br><span class=\"line\">Wparam   指定消息的WParam字段</span><br><span class=\"line\">Result   指定为响应消息处理函数而向OS系统返回的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"WndProc-1\"><a href=\"#WndProc-1\" class=\"headerlink\" title=\"WndProc\"></a>WndProc</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\"> &#x2F;&#x2F; 摘要:</span><br><span class=\"line\">&#x2F;&#x2F;     处理 Windows 消息。</span><br><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\">&#x2F;&#x2F; 参数:</span><br><span class=\"line\">&#x2F;&#x2F;   m:</span><br><span class=\"line\">&#x2F;&#x2F;     要处理的 Windows System.Windows.Forms.Message。</span><br><span class=\"line\">protected override void WndProc(ref System.Windows.Forms.Message e);</span><br></pre></td></tr></table></figure>\n<p>对于每个Form来说，我们都可以重写该方法，该方法的参数就是上面提到的Message类的实例，所有的消息在被获取后，正常情况下都会被封装为Message对象，然后由Application工作引擎调用对用的Form.WndProc传入该Messsage，由于Form子类重写了该方法，所以如果希望底层能处理相关的消息，需要通过base.WndProc传递到父类继续调用。下面就是一个代码示例来展示控制如果当前的消息是鼠标左键点击，则弹出MessageBox展示“WndProc MouseClick”：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">WndProc</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Message m</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> WM_LBUTTONDOWN = <span class=\"number\">0x0201</span>;<span class=\"comment\">// 鼠标左键点击</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.Msg == WM_LBUTTONDOWN)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBox.Show(<span class=\"string\">&quot;WndProc MouseClick&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">base</span>.WndProc(<span class=\"keyword\">ref</span> m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"IMessageFilter\"><a href=\"#IMessageFilter\" class=\"headerlink\" title=\"IMessageFilter\"></a>IMessageFilter</h3><p>除了上述的WndProc之外，其实更加便于处理应该的实现IMessageFilter接口，然后让Application将实现该接口的消息过滤器添加到Application中：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MyMessageFilter</span> : <span class=\"title\">IMessageFilter</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">PreFilterMessage</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Message m</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>     &#123;</span><br><span class=\"line\">         <span class=\"comment\">//返回值为true， 表示消息已被处理，不要再往后传递，因此消息被截获</span></span><br><span class=\"line\">         <span class=\"comment\">//返回值为false，表示消息未被处理，需要再往后传递，因此消息未被截获</span></span><br><span class=\"line\">         <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> WM_LBUTTONDOWN = <span class=\"number\">0x0201</span>;<span class=\"comment\">// 鼠标左键点击</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (m.Msg == WM_LBUTTONDOWN)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             MessageBox.Show(<span class=\"string\">&quot;MyMessageFilter MouseClick&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>编写完成后，在应用程序初始化的过程中，添加该过滤器：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application.AddMessageFilter(<span class=\"keyword\">new</span> MyMessageFilter());</span><br></pre></td></tr></table></figure>\n<p>同样的，我们启动应用程序并点击实验，可以看到正常的MessageBox输出。</p>\n","categories":[],"tags":["WinForm"]},{"title":"VirtualBox上安装Debian10","url":"http://compilemind.com/2020/09/29/2020-09-29-VirtualBox上安装Debian10/","content":"<p>本文将介绍如何使用VBox进行Debian10的安装<br><a id=\"more\"></a></p>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><h2 id=\"VirtualBox\"><a href=\"#VirtualBox\" class=\"headerlink\" title=\"VirtualBox\"></a>VirtualBox</h2><p>下载链接：<a href=\"https://www.virtualbox.org/wiki/Downloads\">Downloads – Oracle VM VirtualBox</a>，下载完成后安装即可。</p>\n<h2 id=\"Debian\"><a href=\"#Debian\" class=\"headerlink\" title=\"Debian\"></a>Debian</h2><p>下载链接：<a href=\"https://www.debian.org/CD/http-ftp/#stable\">通过 HTTP/FTP 下载 Debian CD/DVD 映像</a></p>\n<p>下载说明：</p>\n<p>从下载页面可以看到有两个介质的下载，如果你希望最大限度的离线安装的话，可以选择DVD版本</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/download-debian.png\" alt=\"\"></p>\n<p>这里本人选择CD介质中的amd64，进入后会看到下方有一系列的ISO，到底该下载哪个呢？其实在DVD介质页面里面已经给了说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">There are lots of files here! Do I need all of them?</span><br><span class=\"line\">In most cases it is not necessary to download and use all of these images to be able to install Debian on your computer. Debian comes with a massive set of software packages, hence why it takes so many disks for a complete set. Most typical users only need a small subset of those software packages.</span><br><span class=\"line\"></span><br><span class=\"line\">Initially, you will only need to download and use the first image of a set (labelled as debian-something-1 to be able to start the Debian installer and set up Debian on your computer. If there are more images available here (labelled debian-something-2, debian-something-3, etc.), they contain the extra packages that can be installed on a Debian system (as mentioned previously). They will not be bootable and are entirely optional. If you have a fast Internet connection, you&#39;re most likely better off installing any desired extra packages directly from the Debian mirrors on the Internet instead of by using these extra images.</span><br></pre></td></tr></table></figure>\n<p>简而言之，下载Debian-XXX-1.iso的即可，其他的都是可选包，可以通过网络下载。</p>\n<h1 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h1><h2 id=\"VirtualBox-1\"><a href=\"#VirtualBox-1\" class=\"headerlink\" title=\"VirtualBox\"></a>VirtualBox</h2><p>VirtualBox的安装没有什么特殊的处理，Python的支持可以去掉，然后安装路径按需放置。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/install-vbox.png\" alt=\"\"></p>\n<p>安装完成后，进入VirtualBox创建一个新的虚拟机：<strong>Machine -&gt; New</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/new-vm.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/new-vm-disk.png\" alt=\"\"></p>\n<p>接下来的进行<code>Create</code>，等待VirtualBox进行虚拟机的磁盘存储等初始化操作。这个过程的处理时间取决于工作电脑的处理器和磁盘类型。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/create-over.png\" alt=\"\"></p>\n<h2 id=\"Debian-1\"><a href=\"#Debian-1\" class=\"headerlink\" title=\"Debian\"></a>Debian</h2><h3 id=\"启动并选择镜像\"><a href=\"#启动并选择镜像\" class=\"headerlink\" title=\"启动并选择镜像\"></a>启动并选择镜像</h3><p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/pre-choose-image.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/choose-image.png\" alt=\"\"></p>\n<h3 id=\"一系列的安装过程\"><a href=\"#一系列的安装过程\" class=\"headerlink\" title=\"一系列的安装过程\"></a>一系列的安装过程</h3><p>由于步骤很多，详情可以参考这篇很有用的知乎文章：<a href=\"https://zhuanlan.zhihu.com/p/73122221\">图解 Debian 10（Buster）安装步骤 - 知乎 (zhihu.com)</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-09-29-install-debian/install-debian-step01.png\" alt=\"\"></p>\n<h1 id=\"环境初始化\"><a href=\"#环境初始化\" class=\"headerlink\" title=\"环境初始化\"></a>环境初始化</h1><h2 id=\"添加用户到sudoers\"><a href=\"#添加用户到sudoers\" class=\"headerlink\" title=\"添加用户到sudoers\"></a>添加用户到sudoers</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.切换到root用户</span></span><br><span class=\"line\">$ su</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.编辑sudoer文件</span></span><br><span class=\"line\">$ vi /etc/sudoers</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.在User privilege specification一行复制root对应的内容，添加一行当前用户的记录，内容为</span></span><br><span class=\"line\">w4ngzhen(你的用户名，本人使用的w4ngzhen) ALL=(ALL:ALL) ALL</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.强制保存</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5.退出root用户</span></span><br><span class=\"line\">$ <span class=\"built_in\">exit</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"sudo方式修改apt源\"><a href=\"#sudo方式修改apt源\" class=\"headerlink\" title=\"sudo方式修改apt源\"></a>sudo方式修改apt源</h2><p>实际上该步骤可以在上述安装Debian的时候就可以选择镜像完成配置，这里写出来主要是为了方便以后查阅修改镜像。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.编辑apt源配置文件</span></span><br><span class=\"line\">$ sudo vi /etc/apt/sources.list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.添加国内能快速访问的镜像源，这里选择腾讯。修改完成后，保存退出到命令行</span></span><br><span class=\"line\">deb http://mirrors.cloud.tencent.com/debian/ buster main non-free contrib</span><br><span class=\"line\">deb http://mirrors.cloud.tencent.com/debian-security buster/updates main</span><br><span class=\"line\">deb http://mirrors.cloud.tencent.com/debian/ buster-updates main non-free contrib</span><br><span class=\"line\">deb http://mirrors.cloud.tencent.com/debian/ buster-backports main non-free contrib</span><br><span class=\"line\">deb-src http://mirrors.cloud.tencent.com/debian-security buster/updates main</span><br><span class=\"line\">deb-src http://mirrors.cloud.tencent.com/debian/ buster main non-free contrib</span><br><span class=\"line\">deb-src http://mirrors.cloud.tencent.com/debian/ buster-updates main non-free contrib</span><br><span class=\"line\">deb-src http://mirrors.cloud.tencent.com/debian/ buster-backports main non-free contrib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.更新apt源</span></span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.更新apt已安装包</span></span><br><span class=\"line\">$ sudo apt-get upgrade</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装linux-headers\"><a href=\"#安装linux-headers\" class=\"headerlink\" title=\"安装linux-headers\"></a>安装linux-headers</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># linux-headers的版本需要与当前内核发行版一致，查看内核发行版本命令如下：</span></span><br><span class=\"line\">$ uname -r</span><br><span class=\"line\"><span class=\"comment\"># 本人机器输出：4.19.0-9-amd64</span></span><br><span class=\"line\"><span class=\"comment\"># 所以需要安装的linux-headers为：linux-headers-4.19.0-9-amd64，这里使用shell命令便捷操作</span></span><br><span class=\"line\">$ sudo apt-get install -y linux-headers-$(uname -r) </span><br></pre></td></tr></table></figure>\n<h2 id=\"安装gcc、make、perl等\"><a href=\"#安装gcc、make、perl等\" class=\"headerlink\" title=\"安装gcc、make、perl等\"></a>安装gcc、make、perl等</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install -y gcc make perl</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题及解决\"><a href=\"#问题及解决\" class=\"headerlink\" title=\"问题及解决\"></a>问题及解决</h1><h2 id=\"VBox启动Debian-Xfce图形界面黑屏\"><a href=\"#VBox启动Debian-Xfce图形界面黑屏\" class=\"headerlink\" title=\"VBox启动Debian/Xfce图形界面黑屏\"></a>VBox启动Debian/Xfce图形界面黑屏</h2><ul>\n<li>原因1：VBox虚拟机【设置】-【显示】中启用了3D加速</li>\n<li>解决方式：关闭3D加速</li>\n</ul>\n","categories":[],"tags":["Linux","Debian"]},{"title":"S_型文法到q_型文法再到LL(1)型文法演进笔记","url":"http://compilemind.com/2020/08/23/2020-08-29-S_型文法到q_型文法再到LL(1)型文法演进笔记/","content":"<h1 id=\"S型文法到q型文法再到LL-1-型文法演进笔记\"><a href=\"#S型文法到q型文法再到LL-1-型文法演进笔记\" class=\"headerlink\" title=\"S型文法到q型文法再到LL(1)型文法演进笔记\"></a>S<em>型文法到q</em>型文法再到LL(1)型文法演进笔记</h1><a id=\"more\"></a>\n<h2 id=\"S-型文法（简单的确定性文法）\"><a href=\"#S-型文法（简单的确定性文法）\" class=\"headerlink\" title=\"S_型文法（简单的确定性文法）\"></a>S_型文法（简单的确定性文法）</h2><ul>\n<li><p>每个产生式的右部都以<strong>终结符</strong>开始</p>\n</li>\n<li><p>同一非终结符的各个候选式的<strong>首终结符</strong>都不同</p>\n</li>\n</ul>\n<p>针对第一条的理解是，只要右部都是终结符开始，那么对于串当前的读入字符，我们可以很容易的直接根据右部开头的终结符来进行判断匹配，而无需进行产生式的推导；针对第二条的理解是，因为首终结符都不一样，所以根据当前串读入的字符，我们只会匹配到一个确定的产生式。</p>\n<p>举例，现有文法如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&1. \\quad S \\rightarrow aBC\\\\\n&2. \\quad B \\rightarrow b\\\\  \n&3. \\quad C \\rightarrow c\\\\  \n\\end{aligned}</script><p>现有字符串$abc$，我们从左部第一个字符开始输入，因为字符$a$能够被产生式1匹配，因此我们首先选择产生式$1. \\quad S \\rightarrow aBC$；接下来输入第二个字符$b$，于是我们从产生式1到3种进行匹配判断，找到左部非终结符为$B$（找$B$的原因是上一步我们已经匹配到了产生式1，产生式1的右部现在已经匹配上了$a$字符，我们接下来需要推导$B$，所以要找左部为非终结符$B$的产生式)，右部首终结符为$b$的产生式，于是找到产生式2。以此类推，我们最后能够如下的推导：</p>\n<script type=\"math/tex; mode=display\">\nS \\rightarrow aBC \\rightarrow abC \\rightarrow abc</script><p>个人理解觉得，针对S_型文法的特征是：<strong>我们总是能够根据读入的字符，直接匹配找到一个确定的产生式</strong>。</p>\n<p>然而，该文法的局限性非常的大，最基本的一点就是该文法<strong>不包含$\\varepsilon$的产生式</strong>。例如，现有下列文法：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&1. \\quad S \\rightarrow aBC \\\\\n&2. \\quad B \\rightarrow bC \\\\\n&3. \\quad B \\rightarrow dB \\\\\n&4. \\quad B \\rightarrow \\varepsilon \\\\\n&5. \\quad C \\rightarrow c \\\\\n&6. \\quad C \\rightarrow a \\\\\n&7. \\quad D \\rightarrow e \\\\\n\\end{aligned}</script><p>对于字符串$ade$，首先还是产生式1没得说；接下来，我们需要寻找的是左部为$B$，右部首终结符为$d$的产生式，于是我们选择产生式3，此时产生式推到得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n& 1. \\Rightarrow a，选择产生式1，得到 aBC \\\\\n& 2. \\Rightarrow d，选择产生式3，得到 adBC \\\\\n& 3. \\Rightarrow e，因为产生式2、3的首位非终结符不是e，这里选择\\varepsilon，即选择产生式4，得到 adC \\\\\n\\end{aligned}</script><p>因为此时输入字符为$e$，且当前推导的式子中还存在非终结符$C$，于是我们继续应用上述规则进行匹配选择（即，我们结束第3轮，进入第4轮准备开始查找），然而我们无法找到形如$C \\rightarrow e…$的产生式，此时报错。</p>\n<p>尽管最终报错了，但是当前的文法存在这样一个问题：因为$\\varepsilon$产生式的存在，本该在第3轮中就该发现的再无匹配的问题，在第4轮的检查过程中才被发现。为什么说第3轮就该发现呢？我们回到第3轮的检查中，上面说“因为产生式2、3的首位非终结符不是$e$，我们选择$B \\rightarrow \\varepsilon$，但是选择这个产生式真的正确吗？事实上，当产生式右部是$\\varepsilon$的时候，我们应该要考虑空串之后紧跟着的非终结符是什么，如果我们知道紧跟着的非终结符也和当前的输入符号不匹配的话，我们立刻就能知道选择了空串后的下一步必然是无法匹配的。这里$\\varepsilon$后面紧跟的等价于$B$紧跟的，那么通过产生式1我们知道$B$后面紧跟的是$C$，而$C$能够推导出$c$和$a$，故在第3轮中，我们首先知道已经无法选择产生式2和3了，接下来我们判断产生式4是否满足，因为当前的输入$e$依然无法和$c$、$a$匹配，所以在第3轮我们已经无法继续进行下去，就应该报错了。</p>\n<p>而我们上面所说的“紧跟着的…”也就是接下来要引入的一个概念：$FOLLOW$集。</p>\n<h3 id=\"FOLLOW-集-（后继符号集）\"><a href=\"#FOLLOW-集-（后继符号集）\" class=\"headerlink\" title=\"$FOLLOW 集$（后继符号集）\"></a>$FOLLOW 集$（后继符号集）</h3><blockquote>\n<p>非终结符$A$的后继符号集<br>可能在某个句型中紧跟在$A$后边的终结符$a$的集合，记为$FOLLOW(A)$</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\nFOLLOW(A)=\\{a|S \\Rightarrow^* \\alpha Aa\\beta, \\quad a \\in V_T, \\quad \\alpha, \\beta \\in (V_T \\cup V_N)^*\\}</script><p>有了$FOLLOW集$这个东西之后，再回头看待$\\varepsilon$产生式就变得很明朗了。</p>\n<p>如果当前某非终结符$A$的产生式右部的首字符与输入$a$不匹配的时候，若存在$A \\rightarrow \\varepsilon$，则我们检查$a$是否存在于$A$的后继符号集$FOLLOW(A)$中，若在其中，则匹配继续，否则程序报错。</p>\n<p>于是，对于上面的判断流程的第3步中，$FOLLOW(B) = {a, c}$，而当前我们遇到的符号是$e$，不在对应的集中，于是该步骤已经结束。</p>\n<h3 id=\"SELECT-集-（产生式可选集）\"><a href=\"#SELECT-集-（产生式可选集）\" class=\"headerlink\" title=\"$SELECT 集$（产生式可选集）\"></a>$SELECT 集$（产生式可选集）</h3><p>我们综合上述的对于非$\\varepsilon$产生式和$\\varepsilon$产生式，可以定义产生式的可选集这一概念。</p>\n<p>产生式$A \\rightarrow \\beta$的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为$SELECT(A \\rightarrow \\beta)$。例如：</p>\n<p>$SELECT(A \\rightarrow \\alpha\\beta) = {\\alpha}$</p>\n<p>$SELECT(A \\rightarrow \\varepsilon) = FOLLOW(A)$</p>\n<h2 id=\"q-文法\"><a href=\"#q-文法\" class=\"headerlink\" title=\"q_文法\"></a>q_文法</h2><blockquote>\n<p>每个产生式的右部或为$\\varepsilon$或以终结符开始</p>\n<p>具有相同左部的产生式有不可相交的可选集</p>\n</blockquote>\n<p>我们称这样的文法为q<em>型文法。为什么引入q</em>型文法，因为前面的$FOLLOW集$概念的引入，解决$\\varepsilon$产生式的问题，而这一点可以很好的地对照在q<em>型文法的第一条定义。尽管它对于S</em>型文法限制有了略微的放宽，支持了$\\varepsilon$的产生式，可是还是有一定的限制：q_文法不含右部以<code>非终结符</code>打头的产生式。</p>\n<p>在前文中，我们总是在限制产生式的右部，要么首字符是一个终结符，要么是$\\varepsilon$空串，之所以这样是因为我们总是希望在进行输入的时候右部具有确定的信息（这里就是一个首终结字符）。然而，当右部打头的是非终结符的时候，我们就无从下手了（至少目前是），因为非终结符是不确定的（至少一下子无法知道），它最终能够推导成什么样子的串，似乎变数太多，要是我们事先有一个集合，已经存放好了产生式右部的串(无论它是$\\varepsilon$，还是终结符，还是非终结符打头）的首非终结符，每次进行输入匹配的时候，看一下是不是在这里面，问题就迎刃而解了。于是，我们引入概念：串首终结符集。</p>\n<h3 id=\"串首终结符集\"><a href=\"#串首终结符集\" class=\"headerlink\" title=\"串首终结符集\"></a>串首终结符集</h3><p>给定一个文法符号串$\\alpha$，$\\alpha$的串首终结符集$FIRST(\\alpha)$被定义为：可以从$\\alpha$推导出的所有串首终结符的集合。此外，如果$\\alpha \\Rightarrow^* \\varepsilon$，那么$\\varepsilon \\in FIRST(\\alpha)$。即：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n& 对于 \\forall \\alpha \\in (V_T, V_N)^+，FIRST(\\alpha) = \\{ a | a\\beta, \\quad a \\in V_T, \\quad \\beta \\in (V_T \\cup V_N)^* \\} \\\\\n& 如果\\alpha \\Rightarrow^* \\varepsilon，那么\\varepsilon \\in FIRST(\\alpha) \\\\\n\\end{aligned}</script><p>至于这个串首终结符集如何生成，我们在后文再议。</p>\n<p>有了串首终结符集的定义后，我们再次回头看一下产生式$A \\rightarrow \\alpha$的可选集$SELECT(A \\rightarrow \\alpha)$。我们先给出定义：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation*}\nSELECT(A \\rightarrow \\alpha) = \\begin{cases}\nFIRST(\\alpha), & \\text{if} \\quad \\varepsilon \\notin FIRST(\\alpha) \\\\\n(FIRST(\\alpha) - \\{\\varepsilon\\}) \\cup FOLLOW(A), & \\text{if} \\quad \\varepsilon \\in FIRST(\\alpha)\n\\end{cases}\n\\end{equation*}</script><p>我们首先解读这个定义，先看第一种情况，因为$\\varepsilon \\notin FIRST(\\alpha)$，即$\\alpha$无法通过任意步骤推导得到空串，即产生式$A \\rightarrow \\alpha$的左部$A$是无法推导得到空串，那么该产生式的可选集是$FIRST(\\alpha)$确实是合理的，试想，现在我有个输入字符c，因为我知道$\\varepsilon \\notin FIRST(\\alpha)$，那么我检查字符c是不是在$FIRST(\\alpha)$中就可以做出判断报错还是继续，而无需担心因为左部$A$可以产生空串进而还要考虑$A$的后继符号集；</p>\n<p>对于第二种情况，其实就是把空串的情况也考虑了：不仅仅要判断输入字符是不是在右部的串首终结符集中，还因为左部$A$能够推导出空串，而判断是不是在左部的后记符号集中。当然这里排除串首终结符中的空串的含义也是显而易见的，正式因为$A \\rightarrow \\alpha \\Rightarrow^* \\varepsilon$，我们才要判断是否在$FOLLOW(A)$中，这里自然要排除空串了。</p>\n<h2 id=\"LL-1-型文法\"><a href=\"#LL-1-型文法\" class=\"headerlink\" title=\"LL(1)型文法\"></a>LL(1)型文法</h2><p>在上述理论基础上，我们现在将产生式的右部已经扩展到了任意形式了。于是，我们引入LL(1)型文法。它的定义如下：</p>\n<p>文法G是LL(1)的，当且仅当G的任意两个具有相同左部的产生式$A \\rightarrow \\alpha|\\beta$满足如下的条件：</p>\n<ol>\n<li>如果$\\alpha$和$\\beta$均不能推导出$\\varepsilon$，则$FIRST(\\alpha) \\cap FIRST(\\beta) = \\emptyset$。</li>\n<li>$\\alpha$和$\\beta$至多有一个能推导出$\\varepsilon$。如果$\\beta \\Rightarrow^<em> \\varepsilon$，则$FIRST(\\alpha) \\cap FOLLOW(A) = \\emptyset$；如果$\\alpha \\Rightarrow^</em> \\varepsilon$，则$FIRST(\\beta) \\cap FOLLOW(A) = \\emptyset$。</li>\n</ol>\n<p>对于情况1，对于$\\alpha$和$\\beta$都无法推导出空集的时候，假设两者的串首终结符集的交集不为空，那么对于某个输入字符c，我到底该选择右部为$\\alpha$的产生式还是$\\beta$的呢？很显然出现了二义性，所以我们有了交集为空集的条件；</p>\n<p>对于情况2，首先解释为什么至多有一个能推到出$\\varepsilon$。假设都能推导出空集，根据前面产生式的可选集对于右部推导有空集的情况，可选集会包含左部的后记符号集，在这里也就是说，$SELECT(A \\rightarrow \\alpha)$和$SELECT(A \\rightarrow \\beta)$都有$FOLLOW(A)$，当输入字符c属于$FOLLOW(A)$的时候，我们应该选择哪一个产生式呢？于是又出现了二义性。所以我们限定只能至多一个能够推导出$\\varepsilon$。再进一步，当其中一个右部（这里以$\\beta$为例）能够推导出$\\varepsilon$，那么$SELECT(A \\rightarrow \\beta) = {FIRST(\\beta) - {\\varepsilon}} \\cup FOLLOW(A)$，而$\\alpha$无法推导出$\\varepsilon$，所以$SELECT(A \\rightarrow \\alpha) = FIRST(\\alpha)$，为了保证不会出现二义性，我们需要$SELECT(A \\rightarrow \\beta) \\cap SELECT(A \\rightarrow \\alpha) = \\emptyset$，这里$FIRST(\\alpha)$和$FIRST(\\beta)$的交集不为空是一个隐藏的条件，因为是情况1的情形；于是，我们还需要保证$FIRST(\\alpha) \\cap FOLLOW(A) = \\emptyset$。</p>\n","categories":[],"tags":[]},{"title":"CefSharp请求资源拦截及自定义处理","url":"http://compilemind.com/2020/08/23/2020-08-23-CefSharp资源拦截处理/","content":"<h1 id=\"CefSharp请求资源拦截及自定义处理\"><a href=\"#CefSharp请求资源拦截及自定义处理\" class=\"headerlink\" title=\"CefSharp请求资源拦截及自定义处理\"></a>CefSharp请求资源拦截及自定义处理</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在CefSharp中，我们不仅可以使用Chromium浏览器内核，还可以通过Cef暴露出来的各种Handler来实现我们自己的资源请求处理。</p>\n<p>什么是资源请求呢？简单来说，就是前端页面在加载的过程中，请求的各种文本（js、css以及html）。在以Chromium内核的浏览器上，我们可以使用浏览器为我们提供的开发者工具来检查每一次页面加载发生的请求。</p>\n<a id=\"more\"></a>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>鉴于本文的重心是了解CefSharp的资源拦截处理，所以我们不讨论前端的开发以及客户端嵌入CefSharp组件的细节。我们首先完成一个基本的嵌入CefSharp的WinForm程序：该程序界面如下，拥有一个地址输入栏和一个显示网页的Panel：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/webbrowser.png\" alt=\"\"></p>\n<p>并且编写一个<strong>极其简单</strong>的页面，该页面会请求1个js资源和1个css资源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo:</span><br><span class=\"line\">    - index.html</span><br><span class=\"line\">    - test1.js</span><br><span class=\"line\">    - test1.css</span><br></pre></td></tr></table></figure>\n<p>这几个文件的代码都十分简单：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: aqua</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;test1 js file&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 如下记载js、css资源 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;test1.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;test1.css&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Resource Intercept Example<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;result&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 调用test1.js中的myFunc</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;result&#x27;</span>).innerHTML = myFunc();</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>代码很简单，效果也很容易知道，页面加载后，页面背景色为aqua，页面上会显示文本“test1 js file”。同时，当我们使用开发工具，刷新页面，能够看到对应的资源加载：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/src-web-page.png\" alt=\"\"></p>\n<h2 id=\"CefSharp资源拦截及自定义处理\"><a href=\"#CefSharp资源拦截及自定义处理\" class=\"headerlink\" title=\"CefSharp资源拦截及自定义处理\"></a>CefSharp资源拦截及自定义处理</h2><p>完成上述准备后，我们进入正文：资源拦截及自定义处理。首先我们需要对目标的理解达成一致，资源拦截是指我们能够检测到上图中的html、js还有css的资源请求事件，在接下来的Example中，因为我们是使用的客户端程序，所以会在请求的过程中弹出提示；自定义处理是指，在完成拦截提示后，我们还能够替换这些资源，这里我们设定完成拦截后，可以把js和css换为我们想要另外的文件：test2.js和test2.css：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;test2 js file&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: beige</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>即我们希望拦截并替换后，页面上的文字不再是之前的，而是“test2 js file”，页面的背景色是beige。</p>\n<h3 id=\"IRequestHandler\"><a href=\"#IRequestHandler\" class=\"headerlink\" title=\"IRequestHandler\"></a>IRequestHandler</h3><p>在CefSharp中，要想对请求进行拦截处理，最为核心的Handler就是IRequestHandler这个接口，查看官方的源码，会发现里面有数个方法的定义，通过阅读官方的summary，我们可以聚焦到如下的两个定义（注释本人进行了删减）：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Called before browser navigation.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 译：在浏览器导航前调用</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> If the navigation is allowed <span class=\"doctag\">&lt;see cref=&quot;E:CefSharp.IWebBrowser.FrameLoadStart&quot; /&gt;</span> and <span class=\"doctag\">&lt;see cref=&quot;E:CefSharp.IWebBrowser.FrameLoadEnd&quot; /&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> will be called. If the navigation is canceled <span class=\"doctag\">&lt;see cref=&quot;E:CefSharp.IWebBrowser.LoadError&quot; /&gt;</span> will be called with an ErrorCode</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> value of <span class=\"doctag\">&lt;see cref=&quot;F:CefSharp.CefErrorCode.Aborted&quot; /&gt;</span>.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">OnBeforeBrowse</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IWebBrowser chromiumWebBrowser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IBrowser browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IFrame frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IRequest request,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">bool</span> userGesture,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">bool</span> isRedirect</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Called on the CEF IO thread before a resource request is initiated.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 在一个资源请求初始化前在CEF IO线程上调用</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">IResourceRequestHandler <span class=\"title\">GetResourceRequestHandler</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IWebBrowser chromiumWebBrowser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IBrowser browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IFrame frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IRequest request,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">bool</span> isNavigation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">bool</span> isDownload,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">string</span> requestInitiator,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">ref</span> <span class=\"keyword\">bool</span> disableDefaultHandling</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>于是，我们继承一个默认的名为RequestHandler的类（请区分DefaultRequestHandler），只重写上述的两个方法。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MyRequestHandler</span> : <span class=\"title\">RequestHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">bool</span> <span class=\"title\">OnBeforeBrowse</span>(<span class=\"params\">IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, <span class=\"keyword\">bool</span> userGesture,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">bool</span> isRedirect</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用基类的实现，断点调试</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">base</span>.OnBeforeBrowse(chromiumWebBrowser, browser, frame, request, userGesture, isRedirect);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> IResourceRequestHandler <span class=\"title\">GetResourceRequestHandler</span>(<span class=\"params\">IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IRequest request, <span class=\"keyword\">bool</span> isNavigation, <span class=\"keyword\">bool</span> isDownload, <span class=\"keyword\">string</span> requestInitiator, <span class=\"keyword\">ref</span> <span class=\"keyword\">bool</span> disableDefaultHandling</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先调用基类的实现，断点调试</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">base</span>.GetResourceRequestHandler(</span><br><span class=\"line\">            chromiumWebBrowser, browser, frame, request, isNavigation, </span><br><span class=\"line\">            isDownload, requestInitiator, <span class=\"keyword\">ref</span> disableDefaultHandling);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<p>然后完成对该Handler的注册：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">this</span>._webBrowser = <span class=\"keyword\">new</span> ChromiumWebBrowser(<span class=\"keyword\">string</span>.Empty)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RequestHandler = <span class=\"keyword\">new</span> MyRequestHandler()</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>打上断点，开始访问我们的Example：index.html。这里会发现，OnBeforeBrowse调用了一次，而GetResourceRequestHandler会调用3次。检查OnBeforeBrowse中的request参数内容，是一次主页的请求，而GetResourceRequestHandler中的3次分别是：主页html资源、test1.js和test1.css。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/OnBeforeBrowse.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/GetResourceRequestHandler.png\" alt=\"\"></p>\n<p>结合官方注释和调试的结果，我们可以得出结论：要进行导航的拦截，我们可以重写OnBeforeBrowse方法，要想进行资源的拦截，我们需要实现自己的ResourceRequestHandler。</p>\n<h3 id=\"IResourceRequestHandler\"><a href=\"#IResourceRequestHandler\" class=\"headerlink\" title=\"IResourceRequestHandler\"></a>IResourceRequestHandler</h3><p>查看IResourceRequestHandler的定义，我们再次聚焦一个函数定义：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Called on the CEF IO thread before a resource is loaded. To specify a handler for the resource return a <span class=\"doctag\">&lt;see cref=&quot;T:CefSharp.IResourceHandler&quot; /&gt;</span> object</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span>To allow the resource to load using the default network loader return null otherwise return an instance of <span class=\"doctag\">&lt;see cref=&quot;T:CefSharp.IResourceHandler&quot; /&gt;</span> with a valid stream<span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">IResourceHandler <span class=\"title\">GetResourceHandler</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IWebBrowser chromiumWebBrowser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IBrowser browser,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IFrame frame,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  IRequest request</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>该定义从注释可以看出，如果实现返回null，那么Cef会使用默认的网络加载器来发起请求，或者我们可以返回一个自定义的资源处理器ResourceHandler来处理一个合法的数据流（Stream）。也就是说，对于资源的处理，要想实现自定义的处理（不是拦截，拦截到目前为止我们可以在上述的两个Handler中进行处理）我们还需要实现一个IResourceHandler接口的实例，并在GetResourceHandler处进行返回，Cef才会在进行处理的时候使用我们的Handler。所以在<code>GetResourceHandler</code>中，我们进行资源的判断，如果是想要替换的资源，我们就使用WinForm提供的OpenFileDialog来选择本地的js或是css文件，并传给我们自定义的ResourceHandler，如果不是想要拦截的资源或是用户未选择任何的文件就走默认的：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MyResourceRequestHandler</span> : <span class=\"title\">ResourceRequestHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> IResourceHandler <span class=\"title\">GetResourceHandler</span>(<span class=\"params\">IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.Url.EndsWith(<span class=\"string\">&quot;test1.js&quot;</span>) || request.Url.EndsWith(<span class=\"string\">&quot;test1.css&quot;</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            MessageBox.Show(<span class=\"string\">$@&quot;资源拦截：<span class=\"subst\">&#123;request.Url&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">string</span> type = request.Url.EndsWith(<span class=\"string\">&quot;.js&quot;</span>) ? <span class=\"string\">&quot;js&quot;</span> : <span class=\"string\">&quot;css&quot;</span>; <span class=\"comment\">// 这里简单判断js还是css，不过多编写</span></span><br><span class=\"line\">            <span class=\"keyword\">string</span> fileName = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">using</span> (OpenFileDialog openFileDialog = <span class=\"keyword\">new</span> OpenFileDialog())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                openFileDialog.Filter = <span class=\"string\">$@&quot;<span class=\"subst\">&#123;type&#125;</span>文件|*.<span class=\"subst\">&#123;type&#125;</span>&quot;</span>; <span class=\"comment\">// 过滤</span></span><br><span class=\"line\">                openFileDialog.Multiselect = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (openFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    fileName = openFileDialog.FileName;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">string</span>.IsNullOrWhiteSpace(fileName))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有选择文件，还是走默认的Handler</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">base</span>.GetResourceHandler(chromiumWebBrowser, browser, frame, request);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 否则使用选择的资源返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyResourceHandler(fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">base</span>.GetResourceHandler(chromiumWebBrowser, browser, frame, request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"IResourceHandler\"><a href=\"#IResourceHandler\" class=\"headerlink\" title=\"IResourceHandler\"></a>IResourceHandler</h3><p>根据上文，我们进一步探究IResourceHandler，对该Handler，官方有一个默认的实现：RequestHandler，该Handler通过阅读源码可以知道是网络加载的Handler，这里为了实现我们自定义拦截策略，我们最好单独实现自己的IResourceHandler。对于该接口，有如下的注释：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Class used to implement a custom resource handler. The methods of this class will always be called on the CEF IO thread.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Blocking the CEF IO thread will adversely affect browser performance. We suggest you execute your code in a Task (or similar).</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> To implement async handling, spawn a new Task (or similar), keep a reference to the callback. When you have a</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> fully populated stream, execute the callback. Once the callback Executes, GetResponseHeaders will be called where you</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> can modify the response including headers, or even redirect to a new Url. Set your responseLength and headers</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Populate the dataOut stream in ReadResponse. For those looking for a sample implementation or upgrading from</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> a previous version <span class=\"doctag\">&lt;see cref=&quot;T:CefSharp.ResourceHandler&quot; /&gt;</span>. For those upgrading, inherit from ResourceHandler instead of IResourceHandler</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> add the override keywoard to existing methods e.g. ProcessRequestAsync.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IResourceHandler</span> : <span class=\"title\">IDisposable</span></span><br><span class=\"line\">&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<p>该类的注释意思大致为：我们可以通过实现该接口来实现自定义资源的处理类。该类中的方法总是在CEF的IO线程中调用。然而，阻塞CEF IO线程将会不利于浏览器的性能。所以官方建议开发者通过把自己的处理代码放在Task（或是类似的异步编程框架）中异步执行，然后在完成或取消（失败）时，在异步中调用callback对应的操作函数（continue、cancel等方法）。当你拥有一个完全填充（fully populated）好了的Stream的时候，再执行callback（这一步对应Open方法）。一旦callback执行了，GetResponseHeaders这个方法将会调用，于是你可以在这个方法里面对Reponse的内容包括headers进行修改，或者甚至是重定向到一个新的Url。设置你自己的reponseLength和headers。接下来，通过在ReadResponse（实际上即将作废，而是Read）函数中，实现并填充dataOut这个Stream。最终CEF会对该Stream进行读取数据，获得资源数据。</p>\n<p>事实上，该Handler的实现可以有很多花样，这里我们实现一个最简单的。</p>\n<h4 id=\"Dispose\"><a href=\"#Dispose\" class=\"headerlink\" title=\"Dispose\"></a>Dispose</h4><p>对于通常进行资源释放的Dispose，因为我们这里只是一个Demo，所以暂时留空。</p>\n<h4 id=\"Open（ProcessRequest）\"><a href=\"#Open（ProcessRequest）\" class=\"headerlink\" title=\"Open（ProcessRequest）\"></a>Open（ProcessRequest）</h4><p>官方注释指出，ProcessRequest将会在不久的将来弃用，改为Open。所以ProcessRequest我们直接返回true。对于Open方法，其注释告诉我们：</p>\n<ul>\n<li>要想要立刻进行资源处理（同步），请设置handleRequest参数为true，并返回true</li>\n<li>决定稍后再进行资源的处理（异步），设置handleRequest为false，并调用callback对应的continue和cancel方法来让请求处理继续还是取消，并且当前Open返回false。</li>\n<li>要立刻取消资源的处理，设置handleRequest为true，并返回false。</li>\n</ul>\n<p>也就是说，handleRequest的true或false决定是同步还是异步处理。若同步，则Cef会立刻通过Open的返回值true或false来决定后续继续进行还是取消。若为异步，则Cef会通过异步的方式来检查callback的调用情况（这里的callback实际上是要我们创建Task回调触发的）。这里我们选择同步的方式（选择异步也没有问题）编写如下的代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">Open</span>(<span class=\"params\">IRequest request, <span class=\"keyword\">out</span> <span class=\"keyword\">bool</span> handleRequest, ICallback callback</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    handleRequest = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"GetResponseHeaders\"><a href=\"#GetResponseHeaders\" class=\"headerlink\" title=\"GetResponseHeaders\"></a>GetResponseHeaders</h4><p>在上小节中我们已经完成了对资源数据的入口（Open）的分析。既然我们已经告诉了Cef我们准备开始进行资源请求的处理了，那么接下来我们显然需要着手进行资源的处理。根据前面的概要注释，我们需要实现GetResponseHeaders方法，因为这是资源处理的第二步。该方法的注释如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Retrieve response header information. If the response length is not known</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> set <span class=\"doctag\">&lt;paramref name=&quot;responseLength&quot; /&gt;</span> to -1 and ReadResponse() will be called until it</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> returns false. If the response length is known set <span class=\"doctag\">&lt;paramref name=&quot;responseLength&quot; /&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> to a positive value and ReadResponse() will be called until it returns</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> false or the specified number of bytes have been read.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> </span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> It is also possible to set <span class=\"doctag\">&lt;paramref name=&quot;response&quot; /&gt;</span> to a redirect http status code</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> and pass the new URL via a Location header. Likewise with <span class=\"doctag\">&lt;paramref name=&quot;redirectUrl&quot; /&gt;</span> it</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> is valid to set a relative or fully qualified URL as the Location header</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> value. If an error occured while setting up the request you can call</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;see cref=&quot;P:CefSharp.IResponse.ErrorCode&quot; /&gt;</span> on <span class=\"doctag\">&lt;paramref name=&quot;response&quot; /&gt;</span> to indicate the error condition.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetResponseHeaders</span>(<span class=\"params\">IResponse response, <span class=\"keyword\">out</span> <span class=\"keyword\">long</span> responseLength, <span class=\"keyword\">out</span> <span class=\"keyword\">string</span> redirectUrl</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>Summary翻译解释如下：获取响应头信息。如果响应的数据长度未知，则设置<code>responseLength</code>为<code>-1</code>，然后CEF会一直调用<code>ReadResponse</code>（即将废除，实际上是<code>Read</code>方法）直到该Read方法返回<code>false</code>。如果响应数据的长度是已知的，可以直接设置<code>responseLength</code>长度为一个正数，然后<code>ReadResponse</code>（<code>Read</code>）将会一直调用，直到该Read方法返回false或者在已经读取的数据的字节长度达到了设置的responseLength的值。当然你也可以通过设置response.StatusCode值为重定向的值（30x）以及redirectUrl为对应的重定向Url来实现资源重定向。</p>\n<p>在本文中，我们采取简单的方式：直接返回资源的长度，然后交给下一步的<code>Read</code>方法来进行真正的资源处理。在该步骤中，我们编写获取本地文件字节数据来实现js和css文件的本地加载，并且将该数据保存在该ResourceHanlder实例私有变量中。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">GetResponseHeaders</span>(<span class=\"params\">IResponse response, <span class=\"keyword\">out</span> <span class=\"keyword\">long</span> responseLength, <span class=\"keyword\">out</span> <span class=\"keyword\">string</span> redirectUrl</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> (FileStream fileStream = <span class=\"keyword\">new</span> FileStream(<span class=\"keyword\">this</span>._localResourceFileName, FileMode.Open, FileAccess.Read))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">using</span> (BinaryReader binaryReader = <span class=\"keyword\">new</span> BinaryReader(fileStream))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> length = fileStream.Length;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._localResourceData = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[length];</span><br><span class=\"line\">            <span class=\"comment\">// 读取文件中的内容并保存到私有变量字节数组中</span></span><br><span class=\"line\">            binaryReader.Read(<span class=\"keyword\">this</span>._localResourceData, <span class=\"number\">0</span>, <span class=\"keyword\">this</span>._localResourceData.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    responseLength = <span class=\"keyword\">this</span>._localResourceData.LongLength;</span><br><span class=\"line\">    redirectUrl = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Read\"><a href=\"#Read\" class=\"headerlink\" title=\"Read\"></a>Read</h4><p>该方法的定义和注释如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Read response data. If data is available immediately copy up to</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> dataOut.Length bytes into dataOut, set bytesRead to the number of</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> bytes copied, and return true. To read the data at a later time keep a</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> pointer to dataOut, set bytesRead to 0, return true and execute</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> callback when the data is available (dataOut will remain valid until</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> the callback is executed). To indicate response completion set bytesRead</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> to 0 and return false. To indicate failure set bytesRead to &amp;lt; 0 (e.g. -2</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> for ERR_FAILED) and return false. This method will be called in sequence</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> but not from a dedicated thread.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> </span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> For backwards compatibility set bytesRead to -1 and return false and the ReadResponse method will be called.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Read</span>(<span class=\"params\">Stream dataOut, <span class=\"keyword\">out</span> <span class=\"keyword\">int</span> bytesRead, IResourceReadCallback callback</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>Summary的翻译大致为：读取响应数据。如果数据是可以立即获得的，那么可以直接将<code>dataOut.Length</code>长度的字节数据拷贝到dataOut这个流中，然后设置bytesRead的值为拷贝的数据字节长度值，最后再返回<code>true</code>。如果开发者希望继续持有dataOut的引用（注释是pointer指针，但是个人觉得这里写为指向该dataOut的引用更好）然后在稍后填充该数据流，那么可以设置<code>bytesRead</code>为<code>0</code>，通过异步方式在数据准备好的时候执行callback的操作函数，然后立刻返回<code>true</code>。（dataOut这个流会一直保持不被释放直到callback被调用为止）。为了让CEF知道当前的响应数据已经填充完毕，需要设置<code>bytesRead</code>为<code>0</code>然后返回<code>false</code>。要想让CEF知道响应失败，需要设置<code>bytesRead</code>为一个小于零的数（例如ERR_FAILED: -2），然后返回<code>false</code>。这个方法将会依次调用但不是在一个专有线程。</p>\n<p>根据上述的注释，总结如下：</p>\n<ul>\n<li>bytesRead &gt; 0，return true：填充了数据，但Read还会被调用</li>\n<li>bytesRead = 0，return false：数据填充完毕，当前为最后一次调用</li>\n<li>bytesRead &lt; 0，return false：出错，当前为最后一次调用</li>\n<li>bytesRead = 0，return true：CEF不会释放dataOut流，在异步调用中准备好数据后调用callback</li>\n</ul>\n<p>针对本例，我们增加一个该类的私有变量<code>_dataReadCount</code>用于标识已读的资源数据字节量并在构造函数中初始化为0。</p>\n<p>每次在Read中进行读取的时候，首先检查剩余待读取字节数<code>this._localResourceData.LongLength - this._dataReadCount</code>，如果该值为零，则表明已经将所有的数据通过dataOut拷贝给了外围，此时设置bytesRead为0，直接返回false；若剩余值大于0，则需要继续进行拷贝操作，但需要注意的是dataOut并不是一个无限大的流，而是一个类似于缓存的流，它的Length值为<code>2^16 = 65536</code>，所以我们需要设置bytesRead来让外围知道我们实际在这个流中放了多少字节的数据。同时在使用<code>Stream.Write</code>API的时候，需要设置正确的offset和count。</p>\n<p>最终，<code>Read</code>的实现如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">Read</span>(<span class=\"params\">Stream dataOut, <span class=\"keyword\">out</span> <span class=\"keyword\">int</span> bytesRead, IResourceReadCallback callback</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> leftToRead = <span class=\"keyword\">this</span>._localResourceData.Length - <span class=\"keyword\">this</span>._dataReadCount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leftToRead == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> needRead = Math.Min((<span class=\"keyword\">int</span>)dataOut.Length, leftToRead); <span class=\"comment\">// 最大为dataOut.Lenght</span></span><br><span class=\"line\">    dataOut.Write(<span class=\"keyword\">this</span>._localResourceData, <span class=\"keyword\">this</span>._dataReadCount, needRead);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._dataReadCount += needRead;</span><br><span class=\"line\">    bytesRead = needRead;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他的几个方法\"><a href=\"#其他的几个方法\" class=\"headerlink\" title=\"其他的几个方法\"></a>其他的几个方法</h4><p>对于Cancel和Skip方法，在本例不会调用，所以这里使用默认实现，不进行讨论，感兴趣的伙伴可以自己去研究。</p>\n<h2 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h2><p>通过上文的代码设计和编写，我们最终完成了一个简单的资源拦截及自定义处理的Example。首先我们在不进行资源拦截的情况下，加载我们的web页面：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/load-without-intercept.png\" alt=\"\"></p>\n<p>可以看到界面中呈现“test1 js file”的字样以及背景色为海蓝色。接下来我们开启资源拦截，再次加载页面，在加载过程中会有对应资源的拦截时的弹窗以及我们需要选择我们自定义的资源文件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/js-intercept.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/js-select.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/css-intercept.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/css-select.png\" alt=\"\"></p>\n<p>完成处理后，得到如下的显示页面：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-08-23-cefsharp-resource-intercept/load-with-intercept.png\" alt=\"\"></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p>本Example的源码已经开源在Github上，整个Demo较为简单，主要是对本文的验证</p>\n<p><a href=\"https://github.com/w4ngzhen/CefSharpResourceInterceptExample\">链接</a></p>\n","categories":[],"tags":[]},{"title":"Electron+Vue+ElementUI开发环境搭建","url":"http://compilemind.com/2020/08/08/2020-08-08-Electron+Vue+ElementUI开发环境搭建/","content":"<p>本文将从零开始，进行Electron+Vue+ElementUI的开发环境搭建</p>\n<a id=\"more\"></a>\n<h2 id=\"Node环境搭建\"><a href=\"#Node环境搭建\" class=\"headerlink\" title=\"Node环境搭建\"></a>Node环境搭建</h2><p>本文假定你完成了nodejs的环境基础搭建：<br>镜像配置（暂时只配置node包镜像源，部分包的二进制镜像源后续讨论）、全局以及缓存路径配置，全局路径加入到了环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"> $</span><span class=\"bash\"> node -v</span></span><br><span class=\"line\"> v12.18.1</span><br><span class=\"line\"><span class=\"meta\"> $</span><span class=\"bash\"> npm -v</span></span><br><span class=\"line\"> 6.14.5</span><br><span class=\"line\"><span class=\"meta\"> $</span><span class=\"bash\"> yarn -v</span></span><br><span class=\"line\"> 1.22.4</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\"> $</span><span class=\"bash\"> npm list -g --depth 0</span></span><br><span class=\"line\"> +-- hexo@4.2.1 // 忽略Hexo，本人写博用的</span><br><span class=\"line\">`-- yarn@1.22.4</span><br></pre></td></tr></table></figure>\n<h2 id=\"vue脚手架安装\"><a href=\"#vue脚手架安装\" class=\"headerlink\" title=\"vue脚手架安装\"></a>vue脚手架安装</h2><p>为了更加便捷的创建一个vue项目，我们安装脚手架@vue/cli和@vue/init（vue-cli已经deprecated了）。之所以要安装@vue/init，是因为@vue/cli是3的版本，创建项目使用命令<strong>vue create app-name</strong>，且无法暂时无法使用模板，但是下文要用electron-vue模板进行创建，还是需要vue2的init命令来通过指定模板创建项目，为了兼容vue2的init特性，官方提供@vue/init作为桥接方式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install -g @vue/cli</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install -g @vue/cli-init</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm list -g --depth 0</span></span><br><span class=\"line\">+-- @vue/cli@4.4.6</span><br><span class=\"line\">+-- @vue/cli-init@4.4.6</span><br><span class=\"line\">+-- hexo@4.2.1</span><br><span class=\"line\">`-- yarn@1.22.4</span><br><span class=\"line\"></span><br><span class=\"line\">关于init说明：</span><br><span class=\"line\">vue init [options] &lt;template&gt; &lt;app-name&gt;       generate a project from a remote template (legacy API, requires @vue/cli-init)</span><br></pre></td></tr></table></figure>\n<p>至此，你可以使用如下的形式，利用vue脚手架结合模板（template）来初始化你的vue项目（app-name）结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init [options] &lt;template&gt; &lt;app-name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化Electron项目结构\"><a href=\"#初始化Electron项目结构\" class=\"headerlink\" title=\"初始化Electron项目结构\"></a>初始化Electron项目结构</h2><p>在指定的目录下，我们使用如下的命令进行electron-vue的项目初始化：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">  vue init simulatedgreg/electron-vue electron-vue-demo</span></span><br></pre></td></tr></table></figure>\n<p>然而，这个过程很慢，甚至卡住不动。原因是指定模板进行创建时，会拉取github上的仓库进行模板初始化。幸运的是vue提供模板离线初始化的功能。</p>\n<p>下载模板源码</p>\n<p><a href=\"https://github.com/SimulatedGREG/electron-vue\">https://github.com/SimulatedGREG/electron-vue</a></p>\n<p>下载后解压存放在 <strong>用户目录/.vue-templates/</strong> 下（没有就创建，注意复数s），形成如下的结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;home目录&#125;&#x2F;</span><br><span class=\"line\">  .vue-templates&#x2F;</span><br><span class=\"line\">     electron-vue-master&#x2F;（目录名随便，但是在待会儿init指定的时候需要一致）</span><br><span class=\"line\">       .github&#x2F;</span><br><span class=\"line\">       template&#x2F;</span><br><span class=\"line\">       ....</span><br></pre></td></tr></table></figure>\n<p>之后就可以使用离线（offline）模式创建：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init --offline electron-vue-master electron-vue-demo # 名称和上述文件夹名称一致即可</span><br></pre></td></tr></table></figure>\n<p>之后就是按照向导进行创建工作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vue init --offline electron-vue-master electron-vue-demo</span><br><span class=\"line\">&gt; Use cached template at ~\\.vue-templates\\electron-vue-master</span><br><span class=\"line\"></span><br><span class=\"line\">? Application Name electron-vue-demo（项目名）</span><br><span class=\"line\">? Application Id com.compilemind（Id，这里本人使用了自己的域名）</span><br><span class=\"line\">? Application Version 0.0.1（版本）</span><br><span class=\"line\">? Project description electron vue demo（描述）</span><br><span class=\"line\">? Use Sass / Scss? No（是否使用Sass/Scss编译器）</span><br><span class=\"line\">? Select <span class=\"built_in\">which</span> Vue plugins to install (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class=\"line\">axios, vue-el, ectron, vue-router, vuex, vuex-electron（插件包）</span><br><span class=\"line\">? Use linting with ESLint? Yes（启用ESlint）</span><br><span class=\"line\">? Which ESLint config would you like to use? Standard（ESLint配置）</span><br><span class=\"line\">? Set up unit testing with Karma + Mocha? No（测试模块）</span><br><span class=\"line\">? Set up end-to-end testing with Spectron + Mocha? No（测试模块）</span><br><span class=\"line\">? What build tool would you like to use? builder <span class=\"comment\"># 这里我们使用electron-builder构建可执行程序</span></span><br><span class=\"line\">? author w4ngzhen &lt;w4ngzhen@hotmail.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   vue-cli · Generated <span class=\"string\">&quot;electron-vue-demo&quot;</span>.</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行Electron-Vue示例\"><a href=\"#运行Electron-Vue示例\" class=\"headerlink\" title=\"运行Electron-Vue示例\"></a>运行Electron-Vue示例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd electron-vue-demo</span><br><span class=\"line\">$ yarn (or &#96;npm install&#96;)</span><br><span class=\"line\">$ yarn run dev (or &#96;npm run dev&#96;)</span><br></pre></td></tr></table></figure>\n<p>在install的过程中，我们会看到如下一段console输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> electron@2.0.18 postinstall D:\\Projects\\electron-vue-demo\\node_modules\\electron</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> node install.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Downloading electron-v2.0.18-win32-x64.zip</span><br><span class=\"line\">[==========================================&gt;  ] 97.0% of 50.7 MB (2.77 MB/s)</span><br></pre></td></tr></table></figure>\n<p>可以注意到electron的node包安装完成后，配置了postinstall（安装完成后调用的脚本），该脚本执行其内部install.js脚本后，开始下载electron的二进制的文件。</p>\n<p>首先为什么会有这个额外下载的过程呢？在本人看来，electron是基于Chromium内核的跨平台客户端解决方案（本人另一篇文章正好进行了CefSharp的封装工作），既然涉及到跨平台，而不同平台的底层实现必然有所差异，那么electron项目通过自己去实现跨平台，封装底层逻辑，让我们不关心底层的实现，而是专心于前端的开发，封装成果就是上述的electron-v2.0.18-win32-x64.zip内容。这里因为我们调试和构建的时候，就需要运行时，所以electron根据我们的当前的平台，去下载了对应已经完成针对平台编译封装的二进制内容。</p>\n<p>为什么要下载的问题搞明白了，接下来我们要看看如何去下载。有些朋友可能会发现，自己在进行electron二进制包下载的时候，速度慢的离谱。为什么这么慢？我会过一两天对下载的脚本一探究竟（时间有限，过两天写）</p>\n<p>现阶段我们需要在.npmrc文件中增加一行配置，让electron下载二进制文件的时候从指定的地方下载：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure>\n<p>完成后，我们在install会发现有明显的提升。完成node包的install后，我们运行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm run dev</span></span><br></pre></td></tr></table></figure>\n<p>启动后会发现客户端能够运行起来（即主进程能够运行），但是渲染进程报错：</p>\n<p><strong>Webpack ReferenceError:process is not defined</strong>，官方ISSUE已经存在该条：<a href=\"https://github.com/SimulatedGREG/electron-vue/issues/871\">ISSUE</a></p>\n<p>解决方案为：移除src\\index.ejs中的该段代码，详细原因可以看ISSUE。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src\\index.ejs</span></span><br><span class=\"line\">    &lt;% <span class=\"keyword\">if</span> (!process.browser) &#123; %&gt;</span><br><span class=\"line\">      &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">&#x27;development&#x27;</span>) <span class=\"built_in\">window</span>.__static = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>).join(__dirname, <span class=\"string\">&#x27;/static&#x27;</span>).replace(<span class=\"regexp\">/\\\\/g</span>, <span class=\"string\">&#x27;\\\\\\\\&#x27;</span>)</span><br><span class=\"line\">      &lt;/script&gt;</span><br><span class=\"line\">    &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>移除后，再次运行可以看到渲染成功的界面。</p>\n<h2 id=\"引入ElementUI\"><a href=\"#引入ElementUI\" class=\"headerlink\" title=\"引入ElementUI\"></a>引入ElementUI</h2><p>引入ElementUI相关包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install element-ui -S</span><br></pre></td></tr></table></figure>\n<p>在渲染进程模块的main.js中加入ElementUI组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ElementUI <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-ui&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span> </span><br><span class=\"line\">...</span><br><span class=\"line\">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure>\n<p>完成配置以后，我们就可以按照以往的方式进行前端的开发了。</p>\n","categories":[],"tags":[]},{"title":"CefSharp基于.Net Framework 4.0 框架编译","url":"http://compilemind.com/2020/06/06/2020-06-06-CefSharp基于.Net Framework 4.0 框架编译/","content":"<p>本次源码使用的是Github上CefSharp官方的79版本源码</p>\n<a id=\"more\"></a>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><h3 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h3><p>Visual Studio 2017 Enterprise</p>\n<h3 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h3><p>Windows10 SDK</p>\n<p>VC2013 Redistributale Package x86\\x64</p>\n<h3 id=\"组件清单\"><a href=\"#组件清单\" class=\"headerlink\" title=\"组件清单\"></a>组件清单</h3><p>以下组件按照顺序进行编译最佳</p>\n<h4 id=\"基础层\"><a href=\"#基础层\" class=\"headerlink\" title=\"基础层\"></a>基础层</h4><ul>\n<li>CefSharp（C#）</li>\n<li>CefSharp.Core（C++）</li>\n<li>CefSharp.BrowserSubprocess.Core（C++）</li>\n<li>CefSharp.BrowserSubprocess（C#）</li>\n</ul>\n<h4 id=\"UI层\"><a href=\"#UI层\" class=\"headerlink\" title=\"UI层\"></a>UI层</h4><ul>\n<li>CefSharp.WinForms（C#）</li>\n</ul>\n<h4 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h4><ul>\n<li><p>CefSharp.Example</p>\n</li>\n<li><p>CefSharp.WinForms.Example</p>\n</li>\n</ul>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>建立一个名为CefSharp-DotNet4.0的空的解决方案（下文简称sln哈），咱们就开始吧！</p>\n<h3 id=\"CefSharp\"><a href=\"#CefSharp\" class=\"headerlink\" title=\"CefSharp\"></a>CefSharp</h3><p>首先把79版本的源码中的CefSharp库加入到sln中，形成如下的结构：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-06-06-build-cefsharp/1.png\" alt=\"\"></p>\n<p>先不将框架切换为4.0尝试编译一下，出现报错提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt;------ Rebuild All started: Project: CefSharp, Configuration: Debug x64 ------</span><br><span class=\"line\">1&gt;CSC : error CS7027: Error signing output with public key from file &#39;..\\CefSharp.snk&#39; -- File not found.</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Rebuild All: 0 succeeded, 1 failed, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n<p>检查79版本的源码发现，需要将CefSharp.snk文件放置到sln根目录下，这里照做，然后编译通过。</p>\n<p>接着切换为4.0尝试编译，编译出现大量错误，仔细检查发现有如下几种：</p>\n<p><strong>1、CefSharp.Web.JsonString.FromObject函数的参数DataContractJsonSerializerSettings并不存在</strong></p>\n<p><strong>原因</strong>：4.0还不存在该种形式的调用</p>\n<p><strong>解决办法</strong>：移除该方法的settings参数，移除DataContractJsonSerializerSettings构造函数的settings参数</p>\n<p><strong>2、CefSharp.Internals.ConcurrentMethodRunnerQueue.Enqueue方法中，调用了PropertyInfo.GetValue方法报错</strong></p>\n<p><strong>原因</strong>：该PropertyInfo.GetValue方法在4.5及以上可以不传入第二个参数object[] index</p>\n<p><strong>解决办法</strong>：GetValue函数传入第二个参数为null即可</p>\n<p><strong>3、CefSharp.SchemeHandler.FolderSchemeHandlerFactory.ISchemeHandlerFactory.Create中WebUtility.UrlDecode报错</strong></p>\n<p><strong>原因</strong>：该方法是对一般字符串编码为Url的实现，在4.5及以上中才有</p>\n<p><strong>解决办法</strong>：实现一个相同的功能的方法替换之，因为后续还有些处理转为4.0后的兼容问题的代码，所以本人在CefSharp增加了一个ExHelper命名空间，用于存放后续的扩展处理代码的Helper，这里首先增加一个WebUtilityHelper的处理类，该类有一个静态方法UrlDecode，其实现本人直接拷贝的.NET 4.7.2的实现，代码如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">CefSharp.ExHelper</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> https://referencesource.microsoft.com/#System/net/System/Net/HttpListenerRequest.cs,80a5cbf6a66fa610</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">WebUtilityHelper</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> _bufferSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Accumulate characters in a special array</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> _numChars;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">char</span>[] _charBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Accumulate bytes for decoding into characters in a special array</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> _numBytes;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] _byteBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Encoding to convert chars to bytes</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Encoding _encoding;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"title\">WebUtilityHelper</span>(<span class=\"params\"><span class=\"keyword\">int</span> bufferSize, Encoding encoding</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            _bufferSize = bufferSize;</span><br><span class=\"line\">            _encoding = encoding;</span><br><span class=\"line\"></span><br><span class=\"line\">            _charBuffer = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[bufferSize];</span><br><span class=\"line\">            <span class=\"comment\">// byte buffer created on demand</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">string</span> <span class=\"title\">UrlDecode</span>(<span class=\"params\"><span class=\"keyword\">string</span> encodedValue</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (encodedValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> UrlDecodeInternal(encodedValue, Encoding.UTF8);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">string</span> <span class=\"title\">UrlDecodeInternal</span>(<span class=\"params\"><span class=\"keyword\">string</span> <span class=\"keyword\">value</span>, Encoding encoding</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"keyword\">value</span>.Length;</span><br><span class=\"line\">            WebUtilityHelper helper = <span class=\"keyword\">new</span> WebUtilityHelper(count, encoding);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// go through the string&#x27;s chars collapsing %XX and</span></span><br><span class=\"line\">            <span class=\"comment\">// appending each char as char, with exception of %XX constructs</span></span><br><span class=\"line\">            <span class=\"comment\">// that are appended as bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>; pos &lt; count; pos++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> ch = <span class=\"keyword\">value</span>[pos];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ch == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ch = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ch == <span class=\"string\">&#x27;%&#x27;</span> &amp;&amp; pos &lt; count - <span class=\"number\">2</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> h1 = HexToInt(<span class=\"keyword\">value</span>[pos + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> h2 = HexToInt(<span class=\"keyword\">value</span>[pos + <span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (h1 &gt;= <span class=\"number\">0</span> &amp;&amp; h2 &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;     <span class=\"comment\">// valid 2 hex chars</span></span><br><span class=\"line\">                        <span class=\"keyword\">byte</span> b = (<span class=\"keyword\">byte</span>)((h1 &lt;&lt; <span class=\"number\">4</span>) | h2);</span><br><span class=\"line\">                        pos += <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// don&#x27;t add as char</span></span><br><span class=\"line\">                        helper.AddByte(b);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((ch &amp; <span class=\"number\">0xFF80</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    helper.AddByte((<span class=\"keyword\">byte</span>)ch); <span class=\"comment\">// 7 bit have to go as bytes because of Unicode</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    helper.AddChar(ch);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> helper.GetString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">HexToInt</span>(<span class=\"params\"><span class=\"keyword\">char</span> h</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (h &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; h &lt;= <span class=\"string\">&#x27;9&#x27;</span>) ? h - <span class=\"string\">&#x27;0&#x27;</span> :</span><br><span class=\"line\">            (h &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; h &lt;= <span class=\"string\">&#x27;f&#x27;</span>) ? h - <span class=\"string\">&#x27;a&#x27;</span> + <span class=\"number\">10</span> :</span><br><span class=\"line\">            (h &gt;= <span class=\"string\">&#x27;A&#x27;</span> &amp;&amp; h &lt;= <span class=\"string\">&#x27;F&#x27;</span>) ? h - <span class=\"string\">&#x27;A&#x27;</span> + <span class=\"number\">10</span> :</span><br><span class=\"line\">            <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">FlushBytes</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_numBytes &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _numChars += _encoding.GetChars(_byteBuffer, <span class=\"number\">0</span>, _numBytes, _charBuffer, _numChars);</span><br><span class=\"line\">                _numBytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"keyword\">void</span> <span class=\"title\">AddChar</span>(<span class=\"params\"><span class=\"keyword\">char</span> ch</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_numBytes &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                FlushBytes();</span><br><span class=\"line\"></span><br><span class=\"line\">            _charBuffer[_numChars++] = ch;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"keyword\">void</span> <span class=\"title\">AddByte</span>(<span class=\"params\"><span class=\"keyword\">byte</span> b</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_byteBuffer == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                _byteBuffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_bufferSize];</span><br><span class=\"line\"></span><br><span class=\"line\">            _byteBuffer[_numBytes++] = b;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">internal</span> String <span class=\"title\">GetString</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_numBytes &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                FlushBytes();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_numChars &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(_charBuffer, <span class=\"number\">0</span>, _numChars);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> String.Empty;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在报错地方进行如下调用：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> filePath = ExHelper.WebUtilityHelper.UrlDecode(Path.GetFullPath(Path.Combine(rootFolder, asbolutePath)));</span><br></pre></td></tr></table></figure>\n<p><strong>4、Type.GetTypeInfo报错</strong></p>\n<p><strong>原因</strong>：4.0中没有将Type的信息（TypeInfo）从Type中抽离，所以4.0种的Type并没有GetTypeInfo的方法</p>\n<p><strong>解决办法</strong>：4.0访问Type的BaseType、IsGenericType等属性，直接从Type对象调用即可，即如下的形式：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type type = XXX;</span><br><span class=\"line\"><span class=\"comment\">// 4.0版本</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> val = type.IsGenericType;</span><br><span class=\"line\">Type baseType = type.BaseType;</span><br><span class=\"line\"><span class=\"comment\">// 4.5以及以上版本</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> val = type.GetTypeInfo().IsGenericType;</span><br><span class=\"line\">Type baseType = type.GetTypeInfo().BaseType;</span><br></pre></td></tr></table></figure>\n<p>这里本人将代码抽离到ExHelper.ReflecionHelper中方便统一调用</p>\n<p><strong>5、Task.Run、Task.FromResult以及Task.Delay报错</strong></p>\n<p><strong>原因</strong>：在4.0中都不支持上述的几种方式进行调用</p>\n<p><strong>解决方案</strong>：通过Nuget加入Microsoft.Bcl、Microsoft.Bcl.Build以及Microsoft.Bcl.Async三个库到本项目中，然后将上述的所有地方的调用都替换为Microsoft.Threading.Tasks.TaskEx，如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4.5之后</span></span><br><span class=\"line\">Task.Run</span><br><span class=\"line\">Task.FromResult</span><br><span class=\"line\">Task.Delay</span><br><span class=\"line\"><span class=\"comment\">// 4.0，加入了Bcl之后</span></span><br><span class=\"line\">TaskEx.Run</span><br><span class=\"line\">TaskEx.FromResult</span><br><span class=\"line\">TaskEx.Delay</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里讲一下背景，微软发布了Microsoft.Bcl.Async的最终版本，参看博客<a href=\"http://blogs.msdn.com/b/bclteam/archive/2013/04/17/microsoft-bcl-async-is-now-stable.aspx\">Microsoft.Bcl.Async is Now Stable</a>。该包允许开发者在.NET 4、Silverlight 4和Windows Phone 7.5使用C# 5和VB中的异步特性。该包由三个库组成：Microsoft.Bcl、Microsoft.Bcl.Async和Microsoft.Bcl.Build。<strong>由于使用了<a href=\"http://msdn.microsoft.com/en-us/library/db7849ey.aspx\">程序集统一</a>的方式，解决方案中的所有工程都必须引用这三个库</strong>。</p>\n<p>C#发展至今，已经从最初的1.0到了5.0版本：</p>\n<ol>\n<li>1.0版本 - 基本C#语法。</li>\n<li>2.0版本 - 泛型的支持，CLR进行了升级，从根本上支持了运行时泛型。</li>\n<li>3.0版本 - LINQ，添加了<code>from</code> / <code>join</code>等类SQL关键字，添加了扩展函数，添加了编译期动态类型var关键字。</li>\n<li>4.0版本 - dynamic关键字，CLR进行升级，加入DLR，开始对动态进行友好的支持。同时加入动态参数、参数默认值、泛型协变等特性。</li>\n<li>5.0版本 - async/await关键字，将异步变得更为简单。</li>\n</ol>\n<p>async/await 将异步的编程模型统一为同步模型，简化开发复杂度，提升生产效率。微软正式发布了Microsoft.Bcl.Async的最终版本，这让.NET4里头也可以用上async/await，而不需要把项目更改为.net 4.5。</p>\n</blockquote>\n<p>这里为了统一入口，本人把这几个TaskEx的调用收口到ExHelper.TaskHelper中便于查找改动点。</p>\n<p>目前为止，我们应该解决了CefSharp库所有的问题，再次Rebuild该项目，Succeeded！</p>\n<h3 id=\"CefSharp-Core\"><a href=\"#CefSharp-Core\" class=\"headerlink\" title=\"CefSharp.Core\"></a>CefSharp.Core</h3><p>CefSharp.Core是一个C++的库，但是由于该C++库里面调用了一些C#代码，所以跟.Net Framework版本出现了相关性。这里我们同上一样，把79版本的CefSharp.Core源码加入到sln中，右键该项目，打开菜单最下面的properties：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-06-06-build-cefsharp/2.png\" alt=\"\"></p>\n<p>这里我们修改3个点：</p>\n<p>1、选择Windows SDK Version。点击Windows SDK Version右边的下拉框，选择我们安装的Windos10 SDK，如果你和我的SDK版本安装的是一样的，应该就是10.0.17763.0，但是理论上Windows8以上的SDK都应该没啥问题；</p>\n<p>2、选择Platform Toolset为我们安装的IDE的版本，这里我的就是Visual Studio 2017；</p>\n<p>3、手动填入.NET Target Framework Version 为：”v4.0”。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-06-06-build-cefsharp/3.png\" alt=\"\"></p>\n<p>完成上述修改后，我们还需要进行如下的操作：</p>\n<p>拷贝79版本源码解决方案根目录下的CefSharp.props文件到本sln根目录下</p>\n<p>这么做的原因是在CefSharp.Core的vcxproj文件中（VC++项目编译文件），有一处Import（自行搜索）：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Import</span> <span class=\"attr\">Project</span>=<span class=\"string\">&quot;..\\CefSharp.props&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后我们进行编译Rebuild，不出意外应该还是有大量的错误，乍一看出现的错误似乎让人摸不着头脑，什么” ‘AssmblyInfo’ : is not a class or namesapce name”等C#问题，可是明显在这些.NET 4.0上没有问题。本人突然想起以前在学校学习C/C++的时候，老师告诉我们处理C/C++编译处理一定要从最上面看，仔细看命令行编译最开始的地方有两处warning：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">warning MSB3268: The primary reference &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp\\bin\\x64\\Debug\\CefSharp.dll&quot; could not be resolved because it has an indirect dependency on the framework assembly &quot;System.Runtime, Version&#x3D;1.5.11.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a&quot; which could not be resolved in the currently targeted framework. &quot;.NETFramework,Version&#x3D;v4.0&quot;. To resolve this problem, either remove the reference &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp\\bin\\x64\\Debug\\CefSharp.dll&quot; or retarget your application to a framework version which contains &quot;System.Runtime, Version&#x3D;1.5.11.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">warning MSB3268: The primary reference &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp\\bin\\x64\\Debug\\CefSharp.dll&quot; could not be resolved because it has an indirect dependency on the framework assembly &quot;System.Threading.Tasks, Version&#x3D;1.5.11.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a&quot; which could not be resolved in the currently targeted framework. &quot;.NETFramework,Version&#x3D;v4.0&quot;. To resolve this problem, either remove the reference &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp\\bin\\x64\\Debug\\CefSharp.dll&quot; or retarget your application to a framework version which contains &quot;System.Threading.Tasks, Version&#x3D;1.5.11.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a&quot;.</span><br></pre></td></tr></table></figure>\n<p>这两个warning说我们的CefSharp因为Tasks相关动态库的版本不对无法编译，但是我们之前CefSharp已经完成了编译，似乎没有什么问题。实际上，我们CefSharp为了兼容使用了Bcl相关组件，上面我们提到：</p>\n<blockquote>\n<p><strong>由于使用了<a href=\"http://msdn.microsoft.com/en-us/library/db7849ey.aspx\">程序集统一</a>的方式，解决方案中的所有工程都必须引用这三个库</strong>。</p>\n</blockquote>\n<p>实际上C++的工程代码也不例外，所以我们添加Bcl库代码到工程中，由于nuget似乎无法为C++工程添加包，所以本人采用手工的方式添加：</p>\n<p>1、在vcxproj文件的适当位置添加如下的节点引入Bcl包里面的组件：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">......</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">&quot;System.ServiceModel&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">&quot;System.Runtime&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span>..\\packages\\Microsoft.Bcl.1.1.10\\lib\\net40\\System.Runtime.dll<span class=\"tag\">&lt;/<span class=\"name\">HintPath</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Reference</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">&quot;System.Threading.Tasks&quot;</span>&gt;</span>           \t       <span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span>..\\packages\\Microsoft.Bcl.1.1.10\\lib\\net40\\System.Threading.Tasks.dll<span class=\"tag\">&lt;/<span class=\"name\">HintPath</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Reference</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ClCompile</span> <span class=\"attr\">Include</span>=<span class=\"string\">&quot;AssemblyInfo.cpp&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">......</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2、让编译的时候识别到该Nuget包，vcxproj文件末尾添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">......</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">ImportGroup</span> <span class=\"attr\">Label</span>=<span class=\"string\">&quot;ExtensionTargets&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Import</span> <span class=\"attr\">Project</span>=<span class=\"string\">&quot;..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets&quot;</span> <span class=\"attr\">Condition</span>=<span class=\"string\">&quot;Exists(&#x27;..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets&#x27;)&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ImportGroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Target</span> <span class=\"attr\">Name</span>=<span class=\"string\">&quot;EnsureNuGetPackageBuildImports&quot;</span> <span class=\"attr\">BeforeTargets</span>=<span class=\"string\">&quot;PrepareForBuild&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">PropertyGroup</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">ErrorText</span>&gt;</span>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is &#123;0&#125;.<span class=\"tag\">&lt;/<span class=\"name\">ErrorText</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">PropertyGroup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Error</span> <span class=\"attr\">Condition</span>=<span class=\"string\">&quot;!Exists(&#x27;..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets&#x27;)&quot;</span> <span class=\"attr\">Text</span>=<span class=\"string\">&quot;$([System.String]::Format(&#x27;$(ErrorText)&#x27;, &#x27;..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets&#x27;))&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Target</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>3、修改packge.config文件（没有则新增）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packages</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- cef.sdk是需要的依赖包 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cef.sdk&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;79.1.36&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;native&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;Microsoft.Bcl&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.1.10&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net40&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;Microsoft.Bcl.Async&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.168&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net40&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;Microsoft.Bcl.Build&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.21&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net40&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">packages</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上述操作完成后需要进行Restore还原一下cef.sdk的NuGet包，然后再次进行编译，发现warning已经消除，但是还是编译失败，还是有很多“报错”，本人一开始找问题也找了很久以为全都是error，后来发现很多都是warning，最后发现2处关键点error（你们可以先自行搜索这两个地方，双击就可以跳转到对应的报错处）：</p>\n<p><strong>1、</strong>在CefSharp::Internals::Serialization中的SerializeV8SimpleObject有一处GetValue调用报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error C2661: &#39;System::Reflection::PropertyInfo::GetValue&#39;: no overloaded function takes 1 arguments</span><br></pre></td></tr></table></figure>\n<p><strong>2、</strong>在CefSharp::Internals::JavascriptCallbackProxy中的ExecuteWithTimeoutAsync有一处调用报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error C2039: &#39;FromResult&#39;: is not a member of &#39;System::Threading::Tasks::Task&#39;</span><br></pre></td></tr></table></figure>\n<p>这两处很明显是使用了C#的代码，且该代码是 .Net4.0不支持的，原因以及解决方法在上面的CefSharp中已经说了。这里我们修改按照C++语法改写下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、</span><br><span class=\"line\"><span class=\"keyword\">auto</span> propertyValue = properties[i]-&gt;GetValue(obj); <span class=\"comment\">// 4.5.2</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> propertyValue = properties[i]-&gt;GetValue(obj, <span class=\"literal\">nullptr</span>); <span class=\"comment\">// 4.0</span></span><br><span class=\"line\"><span class=\"number\">2</span>、</span><br><span class=\"line\"><span class=\"built_in\">Task</span>::FromResult(invalidFrameResponse); <span class=\"comment\">// 4.5.2</span></span><br><span class=\"line\">ExHelper::TaskHelper::FromResult(invalidFrameResponse); <span class=\"comment\">// 4.0 命名空间就对应的CefSharp里面的Helper</span></span><br></pre></td></tr></table></figure>\n<p>完成操作后，Rebuild sln，Succeeded！</p>\n<h3 id=\"CefSharp-BrowserSubprocess-Core\"><a href=\"#CefSharp-BrowserSubprocess-Core\" class=\"headerlink\" title=\"CefSharp.BrowserSubprocess.Core\"></a>CefSharp.BrowserSubprocess.Core</h3><p>同上操作，将4.5.2源码加入到sln中，和上述CefSharp.Core相同方式：</p>\n<p>1、修改properties；</p>\n<p><strong>2、增加Bcl包的依赖到vsxproj中。</strong></p>\n<p>完成操作后，直接进行Rebuild操作，因为该C++库并不涉及到C#的代码，所以只需要做上述增加Bcl库的相关操作，编译成功！</p>\n<h3 id=\"CefSharp-BrowserSubprocess\"><a href=\"#CefSharp-BrowserSubprocess\" class=\"headerlink\" title=\"CefSharp.BrowserSubprocess\"></a>CefSharp.BrowserSubprocess</h3><p>同上操作，将4.5.2源码加入到sln中，然后：<strong>1、切换版本为.NET 4.0；2、增加Bcl相关依赖包。</strong>因为是C#项目我们终于不用手工给csproj添加节点了，可以使用nuget添加Bcl三个包。</p>\n<p>添加完成后我们尝试编译该组件，不知道为什么，在我的机器上编译过程会出现如下的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">找不到命令的错误提示</span><br></pre></td></tr></table></figure>\n<p>但是查看编译结果还有输出目录能够看到是编译成功的，我也索性没有继续看下去了</p>\n<h3 id=\"CefSharp-WinForm\"><a href=\"#CefSharp-WinForm\" class=\"headerlink\" title=\"CefSharp.WinForm\"></a>CefSharp.WinForm</h3><p>终于到我们的UI层了，如上方式添加源码到项目里，然后：<strong>1、切换版本为.NET 4.0；2、增加Bcl相关依赖包。</strong>（如果你切换了框架后，右键该项目-Manage NuGet Packages出现报错nuget is invalid，请尝试关闭解决方案重新打开）。编译该项目，不出意外，编译成功～</p>\n<p>至此，跟.NET Framework绑定的代码已经全部编译通过，本来到此步骤，我们的编译工作已经完成了，但是官方提供了Example让我们可以调用看看样例，本人索性把Example和WinForm.Example两个工程也一并.NET 4.0化了。</p>\n<h3 id=\"CefSharp-Example\"><a href=\"#CefSharp-Example\" class=\"headerlink\" title=\"CefSharp.Example\"></a>CefSharp.Example</h3><p>该组件并非是必须组件，但是后续无论是Wpf还是WinForm的Example运行，都需要该组件，所以我们还是把它也.NET 4.0化。</p>\n<p>还是上述方式，添加到项目，然后：<strong>1、切换版本为.NET 4.0；2、增加Bcl相关依赖包。</strong>最后尝试进行编译，出现编译错误：</p>\n<p><strong>1、在CefSharp.Example.Handlers.DownloadHandler.OnBeforeDownloadFired函数中，定义的Eventhandler的泛型参数DownloadItem并不是EventArgs子类</strong></p>\n<p><strong>原因</strong>：在4.5之后，EventHandler的泛型参数可以不是EventArgs的子类，而在.Net 4.0必须是继承自EventArgs</p>\n<p><strong>解决办法</strong>：因为DownloadItem较为公共，我们不方便将其继承EventArgs，所以我们单独写一个自己的EventHandler，让其泛型参数接收任意类型：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">DownloadEventHandler</span>&lt;<span class=\"keyword\">in</span> <span class=\"title\">T</span>&gt;(<span class=\"params\"><span class=\"keyword\">object</span> sender, T args</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 改成我们的自己的下载事件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">event</span> DownloadEventHandler&lt;DownloadItem&gt; OnBeforeDownloadFired;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">event</span> DownloadEventHandler&lt;DownloadItem&gt; OnDownloadUpdatedFired;</span><br></pre></td></tr></table></figure>\n<p>再次编译，还会有一些剩下的和Task相关的编译报错问题，上文已经解释了原因和提供了解决方案，Do It！完成修改后，编译成功！</p>\n<h3 id=\"CefSharp-WinForm-Example\"><a href=\"#CefSharp-WinForm-Example\" class=\"headerlink\" title=\"CefSharp.WinForm.Example\"></a>CefSharp.WinForm.Example</h3><p>我们依然如上的方式进行工程的添加，添加的过程会弹出提示框报如下的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------------------------</span><br><span class=\"line\">Microsoft Visual Studio</span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">The imported project &quot;E:\\Projects\\CefSharp-DotNet4.0\\CefSharp.Native.props&quot; was not found. Confirm that the path in the &lt;Import&gt; declaration is correct, and that the file exists on disk.  E:\\Projects\\CefSharp-DotNet4.0\\CefSharp.WinForms.Example\\CefSharp.WinForms.Example.csproj</span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">确定   </span><br><span class=\"line\">---------------------------</span><br></pre></td></tr></table></figure>\n<p>上述提示表明，我们缺少CefSharp.Native.props，在官方源码中的解决方案根目录下找到对应的文件拷贝到我们的目录下。拷贝完成后，<strong>我们先不进行切换Framework和添加Bcl依赖包的操作</strong>，我们首先打开该项目的package.config文件，可以看到有如下的内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cef.redist.x64&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;79.1.36&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net462&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cef.redist.x86&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;79.1.36&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net462&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;Microsoft.Net.Compilers&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.9.0&quot;</span> <span class=\"attr\">targetFramework</span>=<span class=\"string\">&quot;net462&quot;</span> <span class=\"attr\">developmentDependency</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>很明显和我们即将要切换的.NET4.0不符合，接下来我们再进行如下操作：</p>\n<p>1、先Restore这些NuGet包，然后卸载掉，最后再切换为4.0；</p>\n<p>2、<strong>只安装Bcl相关组件包，不安装上述卸载的cef.redist和Compiler</strong></p>\n<p>进行编译，不出意外会出现如下的几个编译错误：</p>\n<p><strong>1、error CS0117: ‘TaskContinuationOptions’ does not contain a definition for ‘HideScheduler’</strong></p>\n<p><strong>原因</strong>：Net4.0中没有这个定义</p>\n<p><strong>解决办法</strong>：因为是Demo，我们使用的TaskContinuationOptions.None的枚举暂时避过编译</p>\n<p><strong>2、error CS0103: The name ‘AppContext’ does not exist in the current context</strong></p>\n<p><strong>原因</strong>：Net4.0中没有这个定义</p>\n<p><strong>解决办法</strong>：这里的目的是获取CefSharp.Example\\Extensions里面的文件，我们使用System.AppDomain.CurrentDomain.BaseDirectory即可</p>\n<p>剩下的几个编译问题还是Task的问题，不在赘述。</p>\n<p>完成编译以后，我们尝试运行该WinForm.Example，提示：</p>\n<blockquote>\n<p>未能加载文件或程序集“CefSharp.Core.dll”或它的某一个依赖项。找不到指定的模块</p>\n</blockquote>\n<p>检查Bin目录下的，发现已经有了该dll，那么就是缺少了CefSharp.Core.dll需要的组件。实际上，刚才我们移除了2个NuGet依赖包：</p>\n<p>cef.redist.x64、cef.redist.x86，这里面是Cef的核心资源与类库，就包含了CefSharp.Core所需要的所有资源。</p>\n<p>重新安装这两个组件包，但需要注意的是对应版本一定要对应当前的版本（79.1.36）。安装完成后，我们检查packages里面的cef.redist组件包，可以看到CEF文件夹下面有我们需要的ceflib.dll等类库和资源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locales(dir)</span><br><span class=\"line\">swiftshader(dir)</span><br><span class=\"line\">cef.pak</span><br><span class=\"line\">cef_100_percent.pak</span><br><span class=\"line\">cef_200_percent.pak</span><br><span class=\"line\">cef_extensions.pak</span><br><span class=\"line\">chrome_elf.dll</span><br><span class=\"line\">d3dcompiler_47.dll</span><br><span class=\"line\">devtools_resources.pak</span><br><span class=\"line\">icudtl.dat</span><br><span class=\"line\">libcef.dll</span><br><span class=\"line\">libEGL.dll</span><br><span class=\"line\">libGLESv2.dll</span><br><span class=\"line\">natives_blob.bin</span><br><span class=\"line\">README.txt</span><br><span class=\"line\">snapshot_blob.bin</span><br><span class=\"line\">v8_context_snapshot.bin</span><br></pre></td></tr></table></figure>\n<p>我们再次运行，终于出现关于WinForm的Example！</p>\n<h2 id=\"制品梳理\"><a href=\"#制品梳理\" class=\"headerlink\" title=\"制品梳理\"></a>制品梳理</h2><ul>\n<li>NuGet引用Microsoft.Bcl、Microsoft.Bcl.Build以及Microsoft.Bcl.Async</li>\n</ul>\n<p>引入上述3个依赖库组件是因为我们为了将CefSharp代码使用.NET 4.0进行编译，兼容async/await等Task相关的特性而引入的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Miscrosoft.Threading.Tasks.dll</span><br><span class=\"line\">Miscrosoft.Threading.Tasks.Extensions.dll</span><br><span class=\"line\">Miscrosoft.Threading.Tasks.Extensions.Desktop.dll</span><br><span class=\"line\">System.IO.dll</span><br><span class=\"line\">System.Runtime.dll</span><br><span class=\"line\">System.Threading.Tasks.dll</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NuGet引用cef.redist. x86/x64</li>\n</ul>\n<p>该NuGet包中包含Cef原生需要的组件和资源包，包括核心的ceflib.dll，具体内容请查看packages/cef.redist. x86/x64/CEF中的所有。</p>\n<ul>\n<li>基于DotNet 4.0编译的CefSharp核心依赖库</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CefSharp（C#）</span><br><span class=\"line\">CefSharp.Core（C++）</span><br><span class=\"line\">CefSharp.BrowserSubprocess.Core（C++）</span><br><span class=\"line\">CefSharp.BrowserSubprocess（C#）</span><br><span class=\"line\">CefSharp.WinForms（C#）</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["CefSharp"]},{"title":"Git常用命令参考手册","url":"http://compilemind.com/2020/04/06/2020-04-06-Git常用命令参考手册/","content":"<h1 id=\"Git常用命令参考手册\"><a href=\"#Git常用命令参考手册\" class=\"headerlink\" title=\"Git常用命令参考手册\"></a>Git常用命令参考手册</h1><p>基本git命令</p>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#配置\">配置</a></li>\n<li><a href=\"#初始化本地仓库\">初始化本地仓库</a></li>\n<li><a href=\"#文件状态\">文件状态</a></li>\n<li><a href=\"#日志\">日志</a></li>\n<li><a href=\"#克隆\">克隆</a></li>\n<li><a href=\"#查看分支\">查看分支</a></li>\n<li><a href=\"#切换分支\">切换分支</a></li>\n<li><a href=\"#创建分支\">创建分支</a></li>\n<li><a href=\"#删除分支\">删除分支</a></li>\n<li><a href=\"#重命名分支\">重命名分支</a></li>\n<li><a href=\"#代码合并\">代码合并</a></li>\n<li><a href=\"#暂存\">暂存</a></li>\n<li><a href=\"#删除\">删除</a></li>\n<li><a href=\"#提交\">提交</a></li>\n<li><a href=\"#推送\">推送</a></li>\n<li><a href=\"#提交\">提交</a></li>\n<li><a href=\"#拉取、获取内容\">拉取、获取内容</a></li>\n<li><a href=\"#查看文件的改动\">查看文件的改动</a></li>\n<li><a href=\"#回滚版本\">回滚版本</a></li>\n<li><a href=\"#撤销\">撤销</a></li>\n<li><a href=\"#标签\">标签</a></li>\n<li><a href=\"#其他\">其他</a></li>\n</ul>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看配置列表</span></span><br><span class=\"line\">git config -l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看已设置的用户名</span></span><br><span class=\"line\">git config --global --get user.name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置用户名</span></span><br><span class=\"line\">git config --global user.name <span class=\"variable\">$&#123;username&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看已设置的邮箱</span></span><br><span class=\"line\">git config --global --get user.email</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置邮箱</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;example@example.com&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 上述配置均可在用户目录下的.gitconfig文件中进行查看配置</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化本地仓库\"><a href=\"#初始化本地仓库\" class=\"headerlink\" title=\"初始化本地仓库\"></a>初始化本地仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 会在当前目录生成.git</span></span><br><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件状态\"><a href=\"#文件状态\" class=\"headerlink\" title=\"文件状态\"></a>文件状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<h3 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看完整历史提交记录</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看前2次提交记录 commit message</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看前2次提交记录，包括diff</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -p -2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索关键词</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -S 你好</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出提交者贡献数量</span></span><br><span class=\"line\">git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 单行简要显示内容</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --oneline</span><br></pre></td></tr></table></figure>\n<h3 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># https 协议</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/<span class=\"variable\">$&#123;username&#125;</span>/<span class=\"variable\">$&#123;git-repo&#125;</span>.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># SSH协议</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:<span class=\"variable\">$&#123;username&#125;</span>/<span class=\"variable\">$&#123;git-repo&#125;</span>.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 克隆某个分支， -b 后面分支名字</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> -b <span class=\"variable\">$&#123;branch-name&#125;</span> https://github.com/<span class=\"variable\">$&#123;username&#125;</span>/<span class=\"variable\">$&#123;git-repo&#125;</span>.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 递归克隆，适用于项目中包含子模块</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive <span class=\"variable\">$&#123;username&#125;</span>@github.com/<span class=\"variable\">$&#123;username&#125;</span>/<span class=\"variable\">$&#123;git-repo&#125;</span>.git</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h2><h3 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有分支</span></span><br><span class=\"line\">git branch --all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看本地分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看远程仓库地址</span></span><br><span class=\"line\">git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看远端分支</span></span><br><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 2种方法，切换到master分支</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git switch master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换上一个分支</span></span><br><span class=\"line\">git checkout -</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建dev分支</span></span><br><span class=\"line\">git branch dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建develop分支并切换</span></span><br><span class=\"line\">git checkout -b dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换远端分支</span></span><br><span class=\"line\">git checkout -t origin/dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除本地分支</span></span><br><span class=\"line\">git branch -d <span class=\"variable\">$&#123;branchName&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程分支</span></span><br><span class=\"line\">git branch -d -r origin/<span class=\"variable\">$&#123;branchName&#125;</span></span><br><span class=\"line\">git push origin :<span class=\"variable\">$&#123;branchName&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"重命名分支\"><a href=\"#重命名分支\" class=\"headerlink\" title=\"重命名分支\"></a>重命名分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重命名当前分支</span></span><br><span class=\"line\">git branch -m <span class=\"variable\">$&#123;branchName&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"代码合并\"><a href=\"#代码合并\" class=\"headerlink\" title=\"代码合并\"></a>代码合并</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 两步法, 将feature分支代码合并到dev</span></span><br><span class=\"line\"><span class=\"comment\"># 1、切换到dev分支</span></span><br><span class=\"line\">git checkout dev</span><br><span class=\"line\"><span class=\"comment\"># 2、将feature合并到当前dev分支</span></span><br><span class=\"line\">git merge feature</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同上效果</span></span><br><span class=\"line\">git merge feature dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"内容操作\"><a href=\"#内容操作\" class=\"headerlink\" title=\"内容操作\"></a>内容操作</h2><h3 id=\"暂存\"><a href=\"#暂存\" class=\"headerlink\" title=\"暂存\"></a>暂存</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 暂存所有</span></span><br><span class=\"line\">git add -A</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂存某个文件</span></span><br><span class=\"line\">git add ./README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加当前目录所有改动文件</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂存一系列文件</span></span><br><span class=\"line\">git add 1.txt 2.txt ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>git add 的反向操作<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除1.txt 文件</span></span><br><span class=\"line\">git rm 1.txt</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -m 提交的信息</span></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;changes log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交显示diff变化</span></span><br><span class=\"line\">git commit -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"推送\"><a href=\"#推送\" class=\"headerlink\" title=\"推送\"></a>推送</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 推送内容到主分支</span></span><br><span class=\"line\">git push -u origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本地分支推送到远程， 本地分支:远程分支</span></span><br><span class=\"line\">git push origin <span class=\"variable\">$&#123;localBranchName&#125;</span>:<span class=\"variable\">$&#123;remoteBranchName&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 简写，默认推送当前分支</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 强制推送, -f =&gt; --force</span></span><br><span class=\"line\">git push -f</span><br></pre></td></tr></table></figure>\n<h3 id=\"拉取、获取内容\"><a href=\"#拉取、获取内容\" class=\"headerlink\" title=\"拉取、获取内容\"></a>拉取、获取内容</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取远端名为master的分支，但不会进行自动合并，需要手动merge</span></span><br><span class=\"line\">git fetch origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 等同于git fetch 然后 git merge</span></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉去远端分支master到本地分支master</span></span><br><span class=\"line\">git pull origin master:master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取远端分支master到本地【当前】分支</span></span><br><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看文件的改动\"><a href=\"#查看文件的改动\" class=\"headerlink\" title=\"查看文件的改动\"></a>查看文件的改动</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有文件改动</span></span><br><span class=\"line\">git diff</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看具体文件的改动</span></span><br><span class=\"line\">git diff README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看某个版本的改动, 后面那一窜是commitId， git log后就能看到</span></span><br><span class=\"line\">git diff <span class=\"variable\">$&#123;commitId&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看某个文件的历史修改记录</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> README.md</span><br><span class=\"line\">git show <span class=\"variable\">$&#123;commitId&#125;</span> README.md</span><br></pre></td></tr></table></figure>\n<h3 id=\"回滚版本\"><a href=\"#回滚版本\" class=\"headerlink\" title=\"回滚版本\"></a>回滚版本</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回滚上一个版本</span></span><br><span class=\"line\">git reset --hard HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回滚上两个版本</span></span><br><span class=\"line\">git reset --hard HEAD^^</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回退到指定版本，git log 就能看到commit id了</span></span><br><span class=\"line\">git reset --hard <span class=\"string\">&#x27;$&#123;commitId&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回滚版本是不保存在 git log，如果想查看使用</span></span><br><span class=\"line\">git reflog</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 撤销当前目录下所有文件的改动</span></span><br><span class=\"line\">git checkout -- .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 撤销指定文件修改</span></span><br><span class=\"line\">git checkout -- README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂存区回到工作区, 指定 ./README.md 文件从暂存区回到工作区</span></span><br><span class=\"line\">git reset HEAD ./README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 撤销commit, 回到工作区, 一般commitId是前一个</span></span><br><span class=\"line\">git reset <span class=\"variable\">$&#123;commitId&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 撤销commit, 并且把修改同时撤销</span></span><br><span class=\"line\">git reset --hard <span class=\"variable\">$&#123;commitId&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出本地所有标签</span></span><br><span class=\"line\">git tag</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出远程所有标签</span></span><br><span class=\"line\">git ls-remote --tags origin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按照特定模式查找标签, `*` 模板搜索</span></span><br><span class=\"line\">git tag -l <span class=\"string\">&quot;v1.0.0*&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建带有附注标签</span></span><br><span class=\"line\">git tag -a v1.1.0 -m <span class=\"string\">&quot;标签描述&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建轻量标签, 不需要带任何参数</span></span><br><span class=\"line\">git tag v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后期打标签, 假设之前忘记打标签了，可以通过git log查看commit id</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\">git tag -a v1.1.0 <span class=\"variable\">$&#123;commitId&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推送到远程，默认只是本地创建</span></span><br><span class=\"line\">git push origin v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一次性推送所有标签到远程</span></span><br><span class=\"line\">git push origin --tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除标签, 你需要再次运行 git push origin v1.1.0 才能删除远程标签</span></span><br><span class=\"line\">git tag -d v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程标签</span></span><br><span class=\"line\">git push origin --delete v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查标签</span></span><br><span class=\"line\">git checkout v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看本地某个标签详细信息</span></span><br><span class=\"line\">git show v1.1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"密码配置\"><a href=\"#密码配置\" class=\"headerlink\" title=\"密码配置\"></a>密码配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 记住提交账号密码</span></span><br><span class=\"line\">git config --global credential.helper store</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清除git已保存的用户名和密码</span></span><br><span class=\"line\"><span class=\"comment\"># windows</span></span><br><span class=\"line\">git credential-manager uninstall</span><br><span class=\"line\"><span class=\"comment\"># mac linux</span></span><br><span class=\"line\">git config --global credential.helper store</span><br></pre></td></tr></table></figure>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><h3 id=\"MIT\"><a href=\"#MIT\" class=\"headerlink\" title=\"MIT\"></a>MIT</h3>","categories":[],"tags":[]},{"title":"WinForm事件与消息","url":"http://compilemind.com/2020/02/05/2020-02-05-WinForm事件与消息/","content":"<h3 id=\"消息概述以及在C-下的封装\"><a href=\"#消息概述以及在C-下的封装\" class=\"headerlink\" title=\"消息概述以及在C#下的封装\"></a>消息概述以及在C#下的封装</h3><p>Windows下应用程序的执行是通过消息驱动的。所有的外部事件，如键盘输入、鼠标移动、按动鼠标都由OS系统转换成相应的“消息”，进入到应用程序的消息队列中，由应用程序引擎轮询处理。在C#中，消息被应用程序的工作引擎通过轮询等方式遍历获取并按照消息的类型逐个分发到对应的组件（例如窗体、按钮等），最后调用对应组件所注册的事件进行处理。</p>\n<a id=\"more\"></a>\n<p>在.NET框架类库中的System.Windows.Forms命名空间中微软采用面对对象的方式重新定义了Message。该消息主要有一下的几个公共属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.Windows.Forms.Message</span><br><span class=\"line\">HWnd     获取或设定消息的处理函数</span><br><span class=\"line\">Msg      获取或设定消息的ID号</span><br><span class=\"line\">Lparam   指定消息的LParam字段</span><br><span class=\"line\">Wparam   指定消息的WParam字段</span><br><span class=\"line\">Result   指定为响应消息处理函数而向OS系统返回的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"System-Windows-Forms-Application\"><a href=\"#System-Windows-Forms-Application\" class=\"headerlink\" title=\"System.Windows.Forms.Application\"></a>System.Windows.Forms.Application</h3><p>System.Windows.Forms.Application类具有用于启动和停止应用程序和线程以及处理Windows消息的方法。例如，调用Run以启动当前线程上的应用程序消息循环，并可以选择使其窗体可见；调用Exit或ExitThread来停止消息循环。所以我们经常使用vs初始化一个基本的WinForm程序，显示的下列模板代码：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 应用程序的主入口点。</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">[<span class=\"meta\">STAThread</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Application.EnableVisualStyles();</span><br><span class=\"line\">    Application.SetCompatibleTextRenderingDefault(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    Application.Run(<span class=\"keyword\">new</span> Form1()); <span class=\"comment\">// 调用Run以启动当前线程上的应用程序消息循环</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为Application是在单线程中运行的，所以在Application.Run开始后，Application本身不断轮询检查消息队列，然后根据消息类型进行数据分发。例如，当我们为这个Form1增加一个鼠标的点击事件后，我们运行该打开Form1：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Form1 form1 = <span class=\"keyword\">new</span> Form1();</span><br><span class=\"line\">form1.MouseClick += (sender, e) =&gt; MessageBox.Show(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">form1.MouseClick += (sender, e) =&gt; MessageBox.Show(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">Application.Run(form1);</span><br></pre></td></tr></table></figure><br>运行后点击Form，可以看到首先出现一个MessageBox，展示“1”，我们点击确定后，又会出现MessageBox，展示“2”。实际上整个过程应该如下：</p>\n<p>当我们按下鼠标左键后，消息形成并送往应用程序消息队列中，然后被Application类从应用程序消息队列中取出，然后分发到相应的窗体。窗体使用MouseClick事件中的函数指针调用已经添加的响应函数。所以C#中的事件字段实质上是一个函数指针列表，用来维护一些消息到达时的响应函数的地址。</p>\n<p>到目前为止我们可以看到，消息其实在我们进行事件调用的时候，已经被提取加工了，它已经由Application进行了预处理，形成了所谓的“事件调用”。那么，我们还能更加自定义的干预消息吗？答案是可以的。</p>\n<h3 id=\"WndProc\"><a href=\"#WndProc\" class=\"headerlink\" title=\"WndProc\"></a>WndProc</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\"> &#x2F;&#x2F; 摘要:</span><br><span class=\"line\">&#x2F;&#x2F;     处理 Windows 消息。</span><br><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\">&#x2F;&#x2F; 参数:</span><br><span class=\"line\">&#x2F;&#x2F;   m:</span><br><span class=\"line\">&#x2F;&#x2F;     要处理的 Windows System.Windows.Forms.Message。</span><br><span class=\"line\">protected override void WndProc(ref System.Windows.Forms.Message e);</span><br></pre></td></tr></table></figure>\n<p>对于每个Form来说，我们都可以重写该方法，该方法的参数就是上面提到的Message类的实例，所有的消息在被获取后，正常情况下都会被封装为Message对象，然后由Application工作引擎调用对用的Form.WndProc传入该Messsage，由于Form子类重写了该方法，所以如果希望底层能处理相关的消息，需要通过base.WndProc传递到父类继续调用。下面就是一个代码示例来展示控制如果当前的消息是鼠标左键点击，则弹出MessageBox展示“WndProc MouseClick”：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">WndProc</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Message m</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> WM_LBUTTONDOWN = <span class=\"number\">0x0201</span>;<span class=\"comment\">// 鼠标左键点击</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.Msg == WM_LBUTTONDOWN)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBox.Show(<span class=\"string\">&quot;WndProc MouseClick&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">base</span>.WndProc(<span class=\"keyword\">ref</span> m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"IMessageFilter\"><a href=\"#IMessageFilter\" class=\"headerlink\" title=\"IMessageFilter\"></a>IMessageFilter</h3><p>除了上述的WndProc之外，其实更加便于处理应该的实现IMessageFilter接口，然后让Application将实现该接口的消息过滤器添加到Application中：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MyMessageFilter</span> : <span class=\"title\">IMessageFilter</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">PreFilterMessage</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Message m</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>     &#123;</span><br><span class=\"line\">         <span class=\"comment\">//返回值为true， 表示消息已被处理，不要再往后传递，因此消息被截获</span></span><br><span class=\"line\">         <span class=\"comment\">//返回值为false，表示消息未被处理，需要再往后传递，因此消息未被截获</span></span><br><span class=\"line\">         <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> WM_LBUTTONDOWN = <span class=\"number\">0x0201</span>;<span class=\"comment\">// 鼠标左键点击</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (m.Msg == WM_LBUTTONDOWN)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             MessageBox.Show(<span class=\"string\">&quot;MyMessageFilter MouseClick&quot;</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>编写完成后，在应用程序初始化的过程中，添加该过滤器：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application.AddMessageFilter(<span class=\"keyword\">new</span> MyMessageFilter());</span><br></pre></td></tr></table></figure>\n<p>同样的，我们启动应用程序并点击实验，可以看到正常的MessageBox输出。</p>\n","categories":[],"tags":["WinForm"]},{"title":"基于Tesseract组件的OCR识别","url":"http://compilemind.com/2020/02/04/2020-02-04-基于Tesseract组件的OCR识别学习/","content":"<h2 id=\"背景以及介绍\"><a href=\"#背景以及介绍\" class=\"headerlink\" title=\"背景以及介绍\"></a>背景以及介绍</h2><p>欲研究C#端如何进行图像的基本OCR识别，找到一款开源的OCR识别组件。该组件当前已经已经升级到了4.0版本。和传统的版本（3.x）比，4.0时代最突出的变化就是基于LSTM神经网络。Tesseract本身是由C++进行编写，但为了同时适配不同的语言进行调用，开放调用API并产生了诸如Java、C#、Python等主流语言在内的封装版本。本次主要研究C#封装版。</p>\n<a id=\"more\"></a>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>Tesseract本身由C++编写并开源在<a href=\"https://github.com/tesseract-ocr/tesseract\">Github</a>，在3.X版本中，Tesseract的识别模式为字符识别，该种识别方式识别能力较低，所以在后来的4.X版本中，引入了LSTM（Long short-term memory，长短期记忆神经网络），极大的提升了识别率。为了让不同的语言均能够使用Tesseract进行OCR识别，Tesseract也是开放了API并产生了诸如Java、C#、Python等主流语言在内的封装版本。而本次C#端的封装版也开源在了<a href=\"https://github.com/charlesw/tesseract\">Github</a>，目前已知的C#封装版已发布在nuget上，封装了对应Tesseract的版本为3.05.02。所以目前的项目结构如下：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/版本封装.png\" alt=\"版本封装\"></p>\n<h2 id=\"Demo实验\"><a href=\"#Demo实验\" class=\"headerlink\" title=\"Demo实验\"></a>Demo实验</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><h4 id=\"文本识别数据包准备\"><a href=\"#文本识别数据包准备\" class=\"headerlink\" title=\"文本识别数据包准备\"></a>文本识别数据包准备</h4><p>因为图像识别本身需要文本识别数据进行匹配，所以我们需要下载对应Tesseract官方的文本数据包：<br><a href=\"https://tesseract-ocr.github.io/tessdoc/Data-Files\">https://tesseract-ocr.github.io/tessdoc/Data-Files</a><br>注意，针对不同版本的Tesseract-OCR（3.X和4.X底层的实现方式不同，所以文本识别数据包是不同的），我们需要找到对应的不同的文本训练数据包，官网为了更好的兼容性，4.X版本的文本数据包是兼容了3.X版本的。</p>\n<p>&gt;<br>the third set in tessdata is the only one that supports the legacy recognizer. The 4.00 files from November 2016 have both legacy and older LSTM models. The current set of files in tessdata have the legacy models and newer LSTM models (integer versions of 4.00.00 alpha models in tessdata_best).<br>&gt;</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/数据包下载.png\" alt=\"数据包下载\"></p>\n<p>为了Demo，我下载了中文简体和英文的数据包作为实验对象</p>\n<h4 id=\"开发环境准备\"><a href=\"#开发环境准备\" class=\"headerlink\" title=\"开发环境准备\"></a>开发环境准备</h4><p>为了实验并对比上面两个封装版本的识别效果，这里在同一解决方案中创建了两个项目：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/项目创建.png\" alt=\"项目创建\"></p>\n<p>BaseNewBeta使用的是封装了4.1版本Tesseract的C#封装版Tesseract.4.1.0-beta1，因为该版本还还没有上传只Nuget，所以只能从github上下载，放到本地，然后把对应的C++的底层库（leptonica-1.78.0.dll，tesseract41.dll）放置到了x86和x64文件夹下面且需要输出。</p>\n<p>BaseNuget是已经上传至Nuget的封装了底层库3.05.20版本的C#封装版3.3.0.0，因为使用nuget进行组件安装，所以x64和x86的Tesseract组件会在编译输出时候自动输出到对应的生成目录。</p>\n<h4 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h4><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (openFileDialog1.ShowDialog() == DialogResult.OK)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//PictureBox控件显示图片</span></span><br><span class=\"line\">    pictureBox1.Load(openFileDialog1.FileName);</span><br><span class=\"line\">    <span class=\"comment\">//获取用户选择文件的后缀名 </span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extension = Path.GetExtension(openFileDialog1.FileName);</span><br><span class=\"line\">    <span class=\"comment\">//声明允许的后缀名 </span></span><br><span class=\"line\">    <span class=\"keyword\">string</span>[] str = <span class=\"keyword\">new</span> <span class=\"keyword\">string</span>[] &#123; <span class=\"string\">&quot;.jpg&quot;</span>, <span class=\"string\">&quot;.png&quot;</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!str.Contains(extension))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBox.Show(<span class=\"string\">&quot;仅能上传jpg,png格式的图片！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//识别图片文字</span></span><br><span class=\"line\">        Bitmap img = <span class=\"keyword\">new</span> Bitmap(openFileDialog1.FileName);</span><br><span class=\"line\">        <span class=\"comment\">// 构建识别引擎</span></span><br><span class=\"line\">        TesseractEngine orcEngine = <span class=\"keyword\">new</span> TesseractEngine(<span class=\"string\">&quot;./tessdata&quot;</span>, <span class=\"string\">&quot;eng&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 识别并获取文本数据</span></span><br><span class=\"line\">        Page page = orcEngine.Process(img);</span><br><span class=\"line\">        richTextBox1.Text = page.GetText();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h4><h5 id=\"英文识别效果\"><a href=\"#英文识别效果\" class=\"headerlink\" title=\"英文识别效果\"></a>英文识别效果</h5><p>先是3.X版本识别：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/EnNuget.png\" alt=\"EnNuget\"><br>可以看到文本中还有很多识别的错误的，特别是把英文字符C识别为了括号（。<br>而封装了新版本的识别结果比起之前更好：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/EnNewBeta.png\" alt=\"EnNewBeta\"></p>\n<h5 id=\"中文识别效果\"><a href=\"#中文识别效果\" class=\"headerlink\" title=\"中文识别效果\"></a>中文识别效果</h5><p>先是3.X版本识别：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/CNNuget.png\" alt=\"CNNuget\"><br>然后是封装的版本：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2020-02-04-tesseract/CNNewBeta.png\" alt=\"CNNewBeta\"><br>看的出来，官方的数据包对于中文的识别还是有很大问题的，不过庆幸的是，4.X版本的后的Tesseract支持我们使用的自己的数据进行识别训练。这样一来，虽然该组件还比不上市面上大多数的商业OCR识别，但是我们可以使用训练数据，来训练适用于我们特定业务的文字识别（比如XX码的提取之类）</p>\n","categories":[],"tags":["OCR"]},{"title":"那些我用Windows时必备的软件","url":"http://compilemind.com/2019/02/25/2019-02-25-那些我用Windows时必备的软件/","content":"<a id=\"more\"></a>\n<h1 id=\"坚果云\"><a href=\"#坚果云\" class=\"headerlink\" title=\"坚果云\"></a><a href=\"https://www.jianguoyun.com/s/downloads\">坚果云</a></h1><h1 id=\"Microsoft-YaHei-Mono-字体-（提取码：epsq）\"><a href=\"#Microsoft-YaHei-Mono-字体-（提取码：epsq）\" class=\"headerlink\" title=\"Microsoft YaHei Mono 字体 （提取码：epsq）\"></a><a href=\"https://pan.baidu.com/s/1WuCJ5VW7nypzp4dgCTcMtQ\">Microsoft YaHei Mono 字体</a> （提取码：epsq）</h1><h1 id=\"7-Zip\"><a href=\"#7-Zip\" class=\"headerlink\" title=\"7-Zip\"></a><a href=\"https://www.7-zip.org/\">7-Zip</a></h1><h1 id=\"AIDA64Extreme\"><a href=\"#AIDA64Extreme\" class=\"headerlink\" title=\"AIDA64Extreme\"></a><a href=\"https://www.aida64.com/downloads\">AIDA64Extreme</a></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key：FARRD-CU2D6-J9D59-LD2Q4-3AJG7</span><br></pre></td></tr></table></figure>\n<h1 id=\"apache-maven\"><a href=\"#apache-maven\" class=\"headerlink\" title=\"apache-maven\"></a><a href=\"http://maven.apache.org/download.cgi\">apache-maven</a></h1><ol>\n<li>环境变量设置</li>\n<li>阿里镜像配置<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bin目录conf中复制一份settings.xml到用户目录/.m2/下（没有就手动创建）</span><br><span class=\"line\">// 在settings.xml的mirrors节点下面添加如下子节点</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus-aliyun<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Nexus aliyun<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>命令行进行初始化<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn help:system</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"BaiduNetdisk\"><a href=\"#BaiduNetdisk\" class=\"headerlink\" title=\"BaiduNetdisk\"></a><a href=\"https://pan.baidu.com/download\">BaiduNetdisk</a></h1><h1 id=\"VLC-media-player\"><a href=\"#VLC-media-player\" class=\"headerlink\" title=\"VLC media player\"></a><a href=\"https://www.videolan.org/\">VLC media player</a></h1><h1 id=\"滴答清单\"><a href=\"#滴答清单\" class=\"headerlink\" title=\"滴答清单\"></a><a href=\"https://www.dida365.com/about/download\">滴答清单</a></h1><h1 id=\"eudic\"><a href=\"#eudic\" class=\"headerlink\" title=\"eudic\"></a><a href=\"https://www.eudic.net/v4/en/app/eudic\">eudic</a></h1><h1 id=\"Everything\"><a href=\"#Everything\" class=\"headerlink\" title=\"Everything\"></a><a href=\"https://www.voidtools.com/zh-cn/\">Everything</a></h1><h1 id=\"FSCapture\"><a href=\"#FSCapture\" class=\"headerlink\" title=\"FSCapture\"></a><a href=\"https://faststone.org/FSCaptureDownload.htm\">FSCapture</a></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name：bluman</span><br><span class=\"line\">key：VPISCJULXUFGDDXYAUYF</span><br></pre></td></tr></table></figure>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a><a href=\"https://git-scm.com/downloads\">Git</a></h1><h1 id=\"grepWin\"><a href=\"#grepWin\" class=\"headerlink\" title=\"grepWin\"></a><a href=\"https://github.com/stefankueng/grepWin/releases\">grepWin</a></h1><h1 id=\"ILSpy\"><a href=\"#ILSpy\" class=\"headerlink\" title=\"ILSpy\"></a><a href=\"https://github.com/icsharpcode/ILSpy/releases\">ILSpy</a></h1><h1 id=\"jdk8（AdoptOpenJDK）\"><a href=\"#jdk8（AdoptOpenJDK）\" class=\"headerlink\" title=\"jdk8（AdoptOpenJDK）\"></a><a href=\"https://adoptopenjdk.net/releases.html?variant=openjdk8&amp;jvmVariant=hotspot\">jdk8（AdoptOpenJDK）</a></h1><ol>\n<li>环境变量设置</li>\n</ol>\n<h1 id=\"JetBrains-IntelliJ-IDEA\"><a href=\"#JetBrains-IntelliJ-IDEA\" class=\"headerlink\" title=\"JetBrains IntelliJ IDEA\"></a><a href=\"https://www.jetbrains.com/idea/download/\">JetBrains IntelliJ IDEA</a></h1><h1 id=\"Microsoft-Visual-Studio\"><a href=\"#Microsoft-Visual-Studio\" class=\"headerlink\" title=\"Microsoft Visual Studio\"></a><a href=\"https://visualstudio.microsoft.com/zh-hans/vs/\">Microsoft Visual Studio</a></h1><h1 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a><a href=\"https://nodejs.org/en/\">nodejs</a></h1><h1 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a><a href=\"https://www.vim.org/\">vim</a></h1><h1 id=\"PicGo\"><a href=\"#PicGo\" class=\"headerlink\" title=\"PicGo\"></a><a href=\"https://github.com/Molunerfinn/PicGo/releases\">PicGo</a></h1><h1 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"$$R\"></a><a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\">$$R</a></h1><h1 id=\"SumatraPDF\"><a href=\"#SumatraPDF\" class=\"headerlink\" title=\"SumatraPDF\"></a><a href=\"https://github.com/sumatrapdfreader/sumatrapdf/releases\">SumatraPDF</a></h1><h1 id=\"Thunder-Network-提取码：ufce\"><a href=\"#Thunder-Network-提取码：ufce\" class=\"headerlink\" title=\"Thunder Network (提取码：ufce)\"></a><a href=\"https://pan.baidu.com/s/1b8mJY_wwGO8zt0nCDVW86Q\">Thunder Network</a> (提取码：ufce)</h1><h1 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a><a href=\"https://typora.io/\">Typora</a></h1><h1 id=\"uTools\"><a href=\"#uTools\" class=\"headerlink\" title=\"uTools\"></a><a href=\"https://u.tools/\">uTools</a></h1><h1 id=\"AutoHotKey\"><a href=\"#AutoHotKey\" class=\"headerlink\" title=\"AutoHotKey\"></a><a href=\"https://www.autohotkey.com/\">AutoHotKey</a></h1><h1 id=\"WinSCP\"><a href=\"#WinSCP\" class=\"headerlink\" title=\"WinSCP\"></a><a href=\"https://winscp.net/eng/download.php\">WinSCP</a></h1>","categories":[],"tags":["软件"]},{"title":"关于人的思考","url":"http://compilemind.com/2019/02/16/2019-02-16-关于人的思考/","content":"<p><em>人总是要思考的。人生一世，思考总是每时每刻都伴随我们前行。各种情景中，如：失落、高兴、烦恼等等，我们都要思考。有了思考，我们才能在这个世界立足;有了思考，我们才能与众不同，拥有自己的标志。思考是无形的，但它却在无形中左右着我们的生活，左右着我们的人生之路。“思考”是一件很神奇的东西，因为它，我们才能够解决问题;因为它，我们才能讨论“关于人的思考”。我们的世界正是因为有很多善于思考的人才会如此的进步，也正是因为有那些不善于思考的人才会变的如此复杂。</em></p>\n<a id=\"more\"></a>\n<p>  <strong>关键词：思考;哲学;理解</strong></p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>古往今来，许许多多的人都在思考“人为什么思考”。人们对于这个话题的讨论的热情从未减少过。的确，这个话题是每个人都想要知道的，因为人的大脑是神秘的，人的思想是神秘的，而人类恰恰有着对神秘事物探索的好奇心。我要研究关于人的思考，也正是基于我对与“思考”的好奇心。现在，我正在用“思考”来思考“关于人的思考”这一个话题，想一想，不免觉得这“人的思考”还真有点趣味。</p>\n<h2 id=\"一、人为什么要思考？\"><a href=\"#一、人为什么要思考？\" class=\"headerlink\" title=\"一、人为什么要思考？\"></a>一、人为什么要思考？</h2><p>我们的大脑每一天都没有停歇过，因为它在承担着我们人生之中最重要的一件事，那就是思考。一旦我们忙完一天的事情之后，休息的时候，我们的大脑里的各种想法就会开始浮现出来，各种问题，让我们变得烦恼。偶尔，我们会想为何我们总是毫无成就，偶尔，我们会觉得很郁闷。我们为什么会郁闷的呢？因为我们思考了。<br>人为什么要思考？倘若一个人不思考，可以吗？当然可以，的确，维持生命是每个人或者概括一点的话每个动物的本能，为了让我们能够心中如水般的平静，我们少一点思考也许对我与我们来说反而有好处，毕竟烦恼都是思考出来的，比如很多的人也许曾经或者正在花着大量的时间“思考”一些毫无意义的事情，把这些时间用来睡觉，用来运动，难道不比苦坐着伤害脑细胞好吗？</p>\n<p>十七世纪法国的伟大科学家和思想家布雷兹.巴斯卡曾经在他的《思想录》中这样写到：“世界上只有三种人：找到上帝事奉上帝的人；竭诚寻求上帝而没有找到上帝的人；活着不肯寻求也没有发现上帝的人。第一种人既有理性而有幸福；第二种人有理性而不幸；最后一种人既愚蠢而有不幸。”巴斯卡的这段话曾启迪了不少人的心灵。为什么不寻求上帝的人就不幸呢？这是一个非常重大的课题。谁都知道，人是有智慧的高等动物，人和其它动物之间的本质区别，就在于人有智慧，人能够思考，可以通过思考，透过现象，发现本质、认识本质，而其它动物则不能。然而人类却把思考忽略了，世界上就有很多人没有利用人所特有的这一本质特征，没有利用思考，不肯致力思考这一重大的课题。他们对于鸡虫琐事、各位荣辱金钱享受却绞尽脑汁，充满预感；而对于什么是真正的幸福？什么是真正的不幸？对于身何从来，死往而去这样一些重大的课题，去无动于衷，麻木不仁。这样的理性知识问题，难道可以用鸡犬禽兽的感觉或用庸愚之辈、贪生之徒的理解来回答吗？他们既无远见有无畏惧地玩忽这一重大课题，而不知不觉地走向死亡；明知他们所为之奋斗一切，将来随着死亡而失去，对自己永恒的命运，却漠然无动于衷。这是何等的可悲，何等的不幸啊！</p>\n<h2 id=\"二、人该如何思考？\"><a href=\"#二、人该如何思考？\" class=\"headerlink\" title=\"二、人该如何思考？\"></a>二、人该如何思考？</h2><p>通常来讲，人一天要遇到很多问题。可是有多少是自己认真的处理分析的呢！ 往往都是问题在自己这匆匆而过，就是抓不住。 要想不让问题跑掉，首先要做到的就是守住问题不放，怎么守的住呢！ 就是要淡定，对待自己遇到的事情要淡定。所以，思考问题的第一步，就是要把问题抓住看明白，怎么抓住，就要怎么守住，就要做到淡定！为什么淡定就能守住呢！  因为淡定可以使得人神气稳定不散，所以能守得住。那么，再让我们回到今天要说明的问题上来，就是 “人该如何思考问题”。</p>\n<p>在上面，我们已经把问题抓住了，要做的是要把问题往好的方向去处理，现实的说法就是立场问题。这个立场要符合一个原则就是：积极、发展、上进。 面对问题，唯独积极上进，才可在顺境之中越走越远，在逆境之中越加坚强。在“淡定”的基础之上，再以一种上进的心去思考，我想我们已经获得了一种很好的思考方式了。</p>\n<p>那么，在达到上面的条件后，现在我们可以做到不受任何情绪干扰的来处理问题了，做到这一步真的不容易。可 是事情总有难有易的，那遇到真正的难题怎么办呢！ 一方面非得解决，一方面又解决不了。这个时候也要注意方法。就是不要抓住问题不放，为什么这么说呢。当守住一个难题不放松的时候，外面就因为感到无法解决而觉得空虚，心里呢，也会被问题困住不得解脱。这时，我们就要懂得“止”，何谓“止”？就是停一会，总结一下，接下来再做，这么做，不仅不会在思考的时变得压抑，反而会使得底气更充足。思考问题的效果也很好，有句话叫“思之而不通，鬼神将通之。非鬼神之力，精气之极也”。就是讲，这么来思考问题，就象有神仙帮助一样，能很好的解决问题。</p>\n<p>样下来，问题分析的有结果了。有结果之后也要注意，不要以为分析完成了就了事了。还有重要的一步要去做，就是分析结果出来后，要回到开始遇到的问题上面想想。是这么个问题发生了这样许多的事情。为什么要做这样一步呢！思考的过程我们可以理解为大脑运转的过程，在我看来是一种轮回。所以想的结果要回到思考的问题上，这样才是一个完整的思考过程。如果不回到思考的问题上，实际上就是轮回没有完全终止，给人一种不连续的感觉。<br>小结</p>\n<p>思考，也许对于许多的哲学家来说，是一个永恒的话题。新的问题在思考中诞生，更新的问题又在解决中诞生。我觉得这都是思考在控制着。个人的一生是短暂的，快乐的时间更是短暂的，世界上的人很多，每一个人在社会中都有他的位置，把自己的心思用到自己所能力及的地方，不要花费你宝贵的生命、时间去思考那些属于别人的问题了，重复建设既不利于解决问题又浪费时间和感情。不要花费属于你自己的时间去议论别人的长短了，大家活的都很累，何必烦人又烦己呢？最后，人的思考是不可避免的，但是如何又能避免思考所带来的新的问题呢？我想，人为什么要思考就是这个问题的答案。</p>\n<h2 id=\"文献\"><a href=\"#文献\" class=\"headerlink\" title=\"文献\"></a>文献</h2><blockquote>\n<p>[1] 胡道位. 帕斯卡尔《思想录》读解[D].扬州大学,2012.<br>[2] 陈宣良. 思考的芦苇——读帕斯卡尔《思想录》[J]. 读书,1986,07:39-44.<br>[3] 海伦·杜卡斯,巴纳希·霍夫曼,李宏昀. 爱因斯坦谈人生[J]. 书城,2014,01:130.<br>[4] 杨叶平,李晗龙. 从哲学的角度思考人生价值[J]. 学理论,2009,27:110-111.</p>\n</blockquote>\n","categories":[],"tags":[]},{"title":"硝烟中的Scrum和XP","url":"http://compilemind.com/2019/01/15/2019-01-15-硝烟中的Scrum和XP/","content":"<p>初次接触Scrum和XP（更加准确的说是“看到”），心里不免有些疑问，软件开发为什么会有如此多的方式，难道软件开发、软件工程不就是写写代码的事儿吗？直到后来，才明白，一个庞大的软件工程，不会只是一个人的事儿，倘若我们现在（学生时代）还是只有着一种写代码是自己的事儿的态度来看待软件工程这样的“工程”，是低端的，是不全面的。</p>\n<a id=\"more\"></a>\n<p>作为一名软件工程的学生，编写代码的能力是一方面，理解计算机对于代码编辑、编译、链接、运行过程是一方面，理解算法、数据结构有事另一方面。这些当然是我们软件工程学生应该有的素质，但同时，我们还应该明白，一个只有几个人能胜任的软件工程的小组毕竟只是少数，少数中的少数，更多的则是庞大的集合体，我们（对于一般的程序员、工程师）只这个庞大的集合体中的一两个小小的元素。所以，我们应当有团队意识。</p>\n<p>说了一大堆空白话，让我们回到《硝烟中的Scrum和XP》来。</p>\n<p>何为Scrum？这里我不想复制某度百科一堆，我只想说说我的理解（拙见），在我看来，Scrum更加给人一种具有技术的高效开发团队组织的感觉，这个组织拥有对于时间掌控的能力，能够充分利用时间的分割来进行项目的开发、管理，从这一点来看，Scrum更加注重管理，注重一种形式，一种规则。XP则是在另一番景象，XP所做到的是注重了编程的实践，注重强有力的工程实践，是实际的，具有技术的。为什么二者能够和谐的处在一起，因为它们都是在处理软件工程领域不同的部分，而不同的部分，则是软件工程如今所面临的重要之处，同时，它们都强调了个人与组织的关系，强调了个人应当与组织形成一种高效的交流。本书序章中看到了一句话“实际上，Scrum和XP都关注如何把事情做好”。的确如此，所以才造就了如今的敏捷开发与极限编程所拥有的魅力。</p>\n<p>Scrum与XP的共同点：实践与交流。正如书中所说“但在纷乱芜杂的信息中，我感到最有价值的就是那些真枪实弹的故事。它们把‘原则与实践’变成了‘如何真正动手去做’”。理论知识就是动动嘴皮子，在此我并非贬低理论的形成过程，是的，理论也是需要动用你的大脑去真正的考虑设置一种想法的“实现”，这种“实现”并不是简单想想就能搞定的。但是，现实是残酷的，时间是不等人的，在如今的软将工程这个领域里，你永远不知道“下一个巧克力是什么味道的”。甜的，恭喜你“侥幸”度过了软件工程实践里的难处；哭的，很遗憾，你的项目，你的工程将很有可能面临淘汰。（胡乱扯了一通，拙见）</p>\n<p>在书中我还看到了一个很有意思或者说确实也出现在我身上的事例。就是在backlog这一部分，书中所讲的就是“需求，或故事，或特性等组成的列表”，理解一下就是贴了一些便条的梗概，这些都是业务层次上的（产品负责人来负责），不需要你添加一些技术性的问题在其中（技术人员的事儿）。然而（比如我）在写这个backlog的时候，常常就会添加一些技术性的比如这里用某某算法、这里用某某结构体等来描述，这实际上已经突破了业务的层次，这在实际过程中应当避免。</p>\n<p>本书中还提到了Scrum Master：负责监督整个Scrum进程。是的，Scrum确实需要这样的Master存在，Scrum Master并非团队的领导，而是一个负责屏蔽外界对开发团队干扰的角色。Scrum Master是规则的执行者，他是Scrum团队中的服务型领导。不难看出，SM的需要非常熟悉敏捷开发模式，同时还需要很强的能力。</p>\n<p>我在看这本书的时候，其实并没有太关注Scrum与XP的过程，而是在思考Scrum与XP的思想，这样的思想是如何体现的。其实作为一名程序员，我们不能仅仅关注于技术，而是应当在做技术的同时，思考一些理念，一些想法，一些蕴藏在软件开发之中的文化（当然实在已经有较好的技术的前提下，否则就是理想主义者了）。</p>\n","categories":[],"tags":["read"]},{"title":"人月神话","url":"http://compilemind.com/2019/01/01/2019-01-01-人月神话/","content":"<p>先来讲一讲“睡前”想法，也许会有所偏离主题，请见谅。初次面对“人月神话”这个标题的时候，就不禁从中感受到了一种差距，一种关于国内与国外（西方）计算机软件相关的文化差距。就最近所接触到的计算机相关知识来看，我觉文艺复兴的意义是非同凡响的，是深远的，最近接触到的许多关于计算机、软件程序相关的书籍，尽管还未曾读过，但名字已经给我留下了深刻的印象。例如，《人件》、《大教堂与集市》、《黑客与画家》、《人月神话》等等。也许我监视太过于片面，但我还是想说尽管国内程序开发人员、管理人员在技术层面上与国外同行差距并不是很大，甚至在某些方面更加优秀，然而，文化层面却是差了一大截，缺少了灵性，缺少了思维的敢于跳跃。追根溯源，我认为是西方的历史、文艺复兴、文化、哲学给西方的计算机领域注入了太多有意味的，有营养的东西。正如翻开《软件工程》这本厚重的书的第一页，看到序章的第一句话“文艺复兴以降”。</p>\n<a id=\"more\"></a>\n<p>回顾正题，《人月神话》究竟是怎样的一本书呢。你可以把它当作你以后作为一名程序开发者、产品经理或者是任何与计算机相关开发有关的职位的职业手册，因为你可以从中了解到作为一名开发人员，你讲面临怎样的上司，面临怎样的工作境遇，并且你可以从中懂得作为一名开发人员的自律与抗争（抗争所面临的难题、危机）；同时你也可以从中了解到作为一名产品经理你将如何面对团队、面对堆积如山的难题，以及你那“不听话”的手下。</p>\n<p>然而，你又可以把它看作一本关于哲学的书籍，一本仅仅是用了大量计算机职场语言、管理语言描述的探讨哲学难题的书籍。在书中，无时无刻不充满着具有哲学意味的探讨，简明却引人入胜。对于我说，这本书就是后者。正如上面所讲的“睡前”想法一样，在软件工程这门课程中，说到了这本书《人月神话》，再看看每章的标题：焦油坑、人月神话、贵族专制、民主政治和系统设计…没有银弹…注定，这本书将不是一本因为计算机软件开发需求的快餐阅读产物，而是一本融合了思想的，从真正具有开发管理意义的书籍。看过之后，的确如此，它除去了大量晦涩难懂的，亦或是平淡无味的专业词汇，更像是一本用简明语言阐述在计算机软件开发过程中的文学、哲学问题。对于每章的开头，作者总是以某件贴近生活或者更贴近现象而非抽象的事例来抓住我的阅读胃口。</p>\n<p>讲完了一些玄学的东西以后，让我们再来看看一些更加实质性的东西。《人月神话》所站立的角度，很显然是产品经理的方面，或者笼统的说应该是只要是相关软件开发管理的。但是针对程序开发者同样是有作用的，作为程序开发者你懂得如何规范自身开发行为，因为你已经站立在项目经理的角度思考过了，就如同中学老师所讲的“站在出题人的角度，解题才会得心应手”。以上就是我从外在角度来看待这本书的。</p>\n<p>在从内容上来看，“焦油坑”预示着从大项目、编程系统产品开发是有多么棘手，它远远超过了所谓的针对一个项目的简简单单的规划。“他们相互纠缠在一起的时候，团队的行动就会变得越来越慢”以及，最重要的一点是，编程系统产品开发是独立小程序的九倍，从这点完全可以印证我上面所说的超过了一个简单的规划，因为很多东西在不经意间，就在就在纠缠这你的团队，你的进度。</p>\n<p>而在“人月神话”又向我们表明，“人月”这一估算暗示了工作量与工作进度是可以互换的，然而这种互换有时却又是致命的，显然，15人月的项目，1人15月与5人3月是完完全全不可对等的。再来说一说“没有银弹”，这一章是我最喜欢的章节。作者把一种能将开发效率提高的方法与软件开发分别比作银弹和人狼，又让我心中想起了在前文所说的，一种与西方艺术、西方文化结合的描述。（请原谅我用大把的修辞，譬如“西方艺术”、“西方文化”来结合程序开发管理，因为在我看来这其中定然有着意料之外又在情理之中的联系）回归“没有银弹”，作者在此章预示了“银弹”在未来一段时间内是不可能出现的，尽管技术在不断的革新，但是管理的革新将会是困难的。看完这章以后，我最大的感受就是人不是机器，尽管科技不断革新，编程技术在不断革新，算法在不断革新，但这些终究只是机器方面。一个大型项目，是人机结合的，针对于计算机的、软件的管理是固定的，是有模式，是能够加以限制的。然而对于人来说，却是个“纠缠”的，“不可控”的。</p>\n<p>焦油坑依旧存在。</p>\n","categories":[],"tags":["read"]},{"title":"再见，贰零壹捌","url":"http://compilemind.com/2018/12/31/2018-12-31-再见，贰零壹捌/","content":"<h4 id=\"再见，2018\"><a href=\"#再见，2018\" class=\"headerlink\" title=\"再见，2018\"></a>再见，2018</h4><p>这一年我毕业在6月，离别在7月。似乎每个人都要等到怀念的时候，才会觉得当初的好，就像在毕业之后，我时常怀念起大学的美好时光。要说每一幕都难以忘记似乎太假惺惺，但却依然难以忘记大家的第一次的见面，第一次的聚会，第一次的活动，以及第一次也是最后一次的离别。</p>\n<a id=\"more\"></a>\n<p>今年冬天似乎特别的冷，一开始我也很疑惑，但后来明白了，有时候，孤单会让一个人的感官敏感起来，让人失去热情。多少次我想要离别，多少次我却又害怕离别。与我相别的不仅是我的大学生涯，还有那群伴我成长的朋友，以及，我“终将逝去的青春”。我的青春始于2011年的夏天，那一件淋湿的衬衣，我的青春止于2018年夏天，那几本墨绿色的证书。</p>\n<p>时间就这样过去了。我常常在想，究竟怎样才算长大。究竟要明白多少的道理才算是长大，为什么父母、长辈就是一种成熟的象征？为什么我们就是和他们有所区别，以至于他们常常会说，“等你长大了就明白了”。后来发觉，我们不过是在模仿长辈，模仿他们的行为，模仿他们的口吻，然后在一个合适的时机，对着我们的晚辈说：“等你长大了就明白了”。渐渐的，我们在模仿中“成长”。但这“成长”终究是假象，当我们模仿的对象，比如父母，出现的时候，我们就好像被打回原形一般，乖乖听着他们的教导。然后，爷爷奶奶一旦出现，父母也立刻“显出原形”，我们之于父母，如同父母之于爷爷奶奶辈一样，终究是孩子。</p>\n<p>其实我常常有很多的想法，想要在博客上去诉说，但是正如大多数的常人一样，感觉有千万语言在脑海中涌现，而等到真正下笔的时候，反而一个字写不出来了。这时候我其实总是有点沮丧，沮丧我的“不争气”，“沮丧”我的懒惰。写到此，突然觉得，是该给自己定一些目标来实现了，毕竟如上所说的一样，我们终究是要成长的，定下一些目标，然后一步一步去做些许会让我安心一点。</p>\n<h5 id=\"2018即将过去，定几个重要目标：）\"><a href=\"#2018即将过去，定几个重要目标：）\" class=\"headerlink\" title=\"2018即将过去，定几个重要目标：）\"></a>2018即将过去，定几个重要目标：）</h5><p>其实我很少像这样为自己制定目标，因为我老是这样有点故意作秀之嫌，后来发觉，如果定目标定的太多可能真的会这样，所有我就定两三个小目标以鞭策自己。</p>\n<h6 id=\"每个月至少产出3篇有价值的文章，或生活或学习或工作。\"><a href=\"#每个月至少产出3篇有价值的文章，或生活或学习或工作。\" class=\"headerlink\" title=\"每个月至少产出3篇有价值的文章，或生活或学习或工作。\"></a>每个月至少产出3篇有价值的文章，或生活或学习或工作。</h6><p>以往我都是学些某些东西的时候，有了心得才写上那么一两篇，我渐渐地发现不再那么“勤劳”了。仔细一想还是定一个目标好一些，一来保持写作习惯（虽然我的写作功力真的很差）；二来保持技能的熟悉程度，把心得记录下来也是不错的。</p>\n<h6 id=\"开始坚持每天跳绳锻炼（依据阶段1-3-5-10-min进行）。\"><a href=\"#开始坚持每天跳绳锻炼（依据阶段1-3-5-10-min进行）。\" class=\"headerlink\" title=\"开始坚持每天跳绳锻炼（依据阶段1 - 3 - 5 - 10 min进行）。\"></a>开始坚持每天跳绳锻炼（依据阶段1 - 3 - 5 - 10 min进行）。</h6><p>为什么是跳绳？为什么不是健身、跑步呢？出于场地、时间等考虑（主要是场地），我没有选择进行所谓的“锻炼宏图”，免得弄的过于“专业”，结果适得其反，从一些简单的小锻炼（跳绳）入手，每天晚上回到家，在小区里跳绳，不需要什么专业的场地，我觉得更能长期坚持。而且据我查到的相关知识，让我对跳绳更加有了信心：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、可以减肥，能使全身的肉变得结实有弹性，减少大腿及臀部的脂肪，健美塑性，使得身体动作敏捷。</span><br><span class=\"line\">2、可以长个子。跳绳可以促进骨骼的生长，从而达到长个子的效果。</span><br><span class=\"line\">3、能锻炼耐力。经常跳绳的人，能很好的锻炼耐力。</span><br><span class=\"line\">4、能帮助我们很好的放松情绪。</span><br><span class=\"line\">5、能缓解腰酸背痛。经常做办公室的上班者，可采用跳绳的方法，缓解身体的酸痛。</span><br><span class=\"line\">...balabala</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"找到女朋友\"><a href=\"#找到女朋友\" class=\"headerlink\" title=\"找到女朋友\"></a>找到女朋友</h6><p>这条可以不实现。：）</p>\n","categories":[],"tags":["journal"]},{"title":"演员 Or 开发者的自我修养","url":"http://compilemind.com/2018/11/11/2018-11-11-演员 Or 开发者的自我修养/","content":"<p>时至今日，我都还是很怀念小时候与一群玩伴编写剧本、拍摄，那时候的我还有一个远大的“白日梦”——成为一名导演。很可惜，终究是“白日梦”。在完成了一系列的“艰苦”拍摄以后，一个半成品的微电影就出世了：没有字幕，没有主题，昏暗的镜头，富有浓郁特色的四川方言。随后发布到网上，差评如潮：）。</p>\n<a id=\"more\"></a>\n<p>如今的我，已投奔IT，愈来愈热爱这个职业。成为一名合格的软件开发者，已经成为了我现在的理想，而非“白日梦”。为什么我会去读《演员的自我修养》？大概是在一代喜剧之王周星驰的影响之下，想要看看这本书真正的魅力。尽管是一本完全讲述表演艺术的书籍，不过在阅读的过程中，我却能够联想到很多对于IT，对于软件工程的东西，大概是我的脑洞太大吧。</p>\n<p>《演员的自我修养》第一部分以日记的形式，记叙了一个名叫Kostya的戏剧系大学一年级学生以及他的同班同学们在斯坦尼斯拉夫斯基式的表演教学方法下度过的一年时光。这样一群学生，没有或者极少有表演的经验，在他们的导师也是他们的戏剧排演的导演的协同之下，进行舞台表演。对于这期间的描述，斯坦尼斯拉夫斯基表达出了对于舞台戏剧的各种理论原理的态度，以及指出了在实践中各种各种各样的不良现象。仔细想一想，这一部分和我们软件工程的似乎是很相像的。初出茅庐的一群软件开发者，没有或者极少有实践的经验（毫无疑问，没有或者极少有实践经验在当前的IT领域是常见的），在主管或者部门老大的带领之下一同协作进行软件开发。于是乎，各种各样的弊端出现，没有精确版本控制，没有标准化的代码规范，没有一个明确的项目目标，业务开发ACID日复一日。其实，对于一个软件项目，和一个舞台是很像的。每一位开发者都是上面的表演者，他们各自运用其学到的理论知识，为舞台剧贡献自己的一份力量。但是，若没有真正的体会，没有真正的热爱这项事业，只是抱着假大空的理论，棒读台词（一味地照着别人的代码），这样的舞台剧会有人为其买单吗？结果可想而知。</p>\n<p>斯坦尼斯拉夫斯基在第二部分阐述了一种体验艺术的思想。何谓体验艺术？即不仅仅是在表演的过程中才全身心的投入，而是每时每刻都要有这样一种意识，他认为：“……只有这种充满了人——演员的活生生的、有机的体验的舞台艺术，才能够把角色内心生活的一切不可捉摸的细微变化和全部深度，艺术地表达出来。”在联想一下，对比着我们日常的开发，开发者写下的每一行代码都在不断的塑造整个“舞台”中的内容，每一位开发者都是“演员”，若没有一种奉献的精神，没有一种每时每刻的都为了追求代码质量的意识，没有以工程、以代码的角度去开发，这样的“舞台剧”势必轻则不被人看好，重则影响后续人员的加入。剧本愈来愈难以看懂，难以维护。</p>\n<p>读过《人月神话》的人都知道，软件工程永远充满了焦油坑。我大概没有那么大的神力去挽救如今IT行业充斥的各种各样的“坑”，但是我不会因此而随波逐流，丧失斗志，做一个只在底层打拼的龙套演员。都说，不会写代码的演员不是好的工程师。</p>\n","categories":[],"tags":["think"]},{"title":"九零后","url":"http://compilemind.com/2018/10/25/2018-10-25-九零后/","content":"<p>“70后”是理想，“80后”是仗义，那么“90后”是什么？</p>\n<p>2019年，最小的“90后”应该已经步入了大学校园，正找寻着自己的理想；最大的“90后”应该有的已经成家立业，担起了另一种角色。或许他们曾失落过、迷茫过，但他们终将一一突破。</p>\n<a id=\"more\"></a>\n<p>似乎每一代人，都要经历一个先被否定然后再为自己正名的过程。就像是一个孩子的成人礼，当人们意识到他不再柔弱、不再荒唐的时候，他才是真正地长大了。</p>\n<p>“垮掉的‘90后’”这个标题像是无情的审判，给予他们沉重的打击。后来大家慢慢发现，似乎每一代都陷入了被上一代人否定的怪象，就好像“你们是我教过的最差的一届”。但为什么偏偏又不是““70后”垮掉”？不是““80后”垮掉”的？在我看来，“90后”所处的时代，也就是当前，它是信息最为开放的时代！“90后”有着不循规蹈矩爱创新的秀自我价值观、既开放又理性的消费观、为爱而爱宁缺毋滥的恋爱观、追求品质提前养身的生活观，但这些与70、80后的观念显得大相径庭，以至于“90后”太容易被贴上“不稳重”、“太不传统”的标签。再加上信息的开放，导致“90后”所做的一切都被放大放大再放大。“90后”只想说：求同存异！Why not?</p>\n<p>“我知道我的未来不是梦”，那未来是什么呢？王小波在《黄金时代》曾说：“那一年我二十一岁，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程。”70、80后的生活，已渐渐步入正轨，而90后才开始接受生活的洗礼。他们的双眼前被迷雾遮住，而迷雾来自生活，让他们看不到未来。时代在变化，相比之下“90后”面对的竞争压力更大、诱惑与选择更多、雾霾也更厚。但是，“90后”更愿意在困境中去奋斗，去突破。他们愿意用更加严谨的方式对待工作，用更加幽默的态度面对生活。“90后”身体力行，跟大家论证了“知识就是力量”这一观点，随着高学历青年大批大批的涌入社会，他们默默地担起了这个时代的使命，在迷茫中坚定，在继承中创新。</p>\n<p>很多人说“90后”不稳重，是因为他们爱花钱，缺乏存钱意识，但在我看来，“90后”不穷，他们作为互联网的原住民，早已成为了消费的主力军。品质、版权意识、多元、体验、参与感等成为了90后的消费标签。他们爱花钱，但不任性，他们热衷于享受生活，提高品质，他们更愿意为故事和文化买单，对于恋爱也信奉宁缺毋滥。</p>\n<p>“90后”提前养身，这已经是近几年的热门话题了，他们的特殊养生，似乎是从某个冬天开始，伴随着保温杯里的大枣枸杞，融到了每个“90后”的身体里。“油腻”、“发际线”以及“秃”，每一个词都好像一颗子弹绽放在“90后”的胸口。于是乎，熬夜玩手机对皮肤不好？敷最贵的面膜，用最贵的眼霜；啤酒加冰？No，加枸杞、人参？Yes；暴饮暴食？我有健胃消食。这些年流行一个词叫“佛性”，“90后”表示，这个“佛”既是“济公活佛”，也是“斗战圣佛”。他们明白，倘若就这样默默的接受无情的审判，垮掉的是他们的内心；倘若不试图去拨开眼前的迷雾，未来永远不会到来。</p>\n<p>所以，“90后”是什么？<br>“90后”是不被定义的一代！</p>\n","categories":[],"tags":["article"]},{"title":"CSharpEntityFramework与CodeFirst实践","url":"http://compilemind.com/2018/09/13/2018-09-13-CSharpEntityFramework与CodeFirst实践/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>当我们进行开发的时候,常常会用到数据库来对数据进行持久化的操作，有的时候,我们并不想要在进行代码开发的过程中，还去关注数据库的构建,表的构建等等。于是，就有了Code First模式。何为Code First模式呢？它思想就是先定义模型中的类，再通过这些类生成数据库。这种开发模式适合于全新的项目，它使得我们可以以代码为核心进行设计而不是先构造数据库。这样一来，使得我们更加关注代码的开发。在c#中，我们使用EntityFramework来实现Code First场景。</p>\n<a id=\"more\"></a>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>试想一下，现在有一个图书管理项目，里面会用到Book实体类，Book会唯一编号Id、书名Title、价格Price，在数据库优先的情形下，我们可能会首先创建Book对应的表，里面创建对应于Id、Title和Price的字段，然后回到代码中继续来开发，亦或者先在代码中进行开发，然后在需要DA（数据访问）的时候创建数据库以及表结构。无论怎样，我们作为开发都要与数据库进行打交道，来回切换关注的东西，还要注意数据库的表建立的对不对，数据类型对不对等等。好在c#中有了EF这样的强大的框架以及Code First的思想。带给我们全新的开发体验。</p>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><h4 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h4><p>创建一个项目，并利用Nuget引入EntityFramework6</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/nugetef6.png\" alt=\"nugetef6\"></p>\n<p>当我们引入EF时，我们发现项目下app.config其中的配置会发生更改，这个配置文件<strong>更改的内容</strong>就是EF为我们创建的，也是我们配置数据库连接的地方。</p>\n<p>回到项目中，接下来我们创建Book实体类，为其添加Id、Title以及Price属性，同时使用特性在属性以及类名上标注该实体类在数据库中的体现方式：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">CodeFirstDemo</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Table(<span class=\"meta-string\">&quot;Book&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Book</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Guid id;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Guid Id</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = id == <span class=\"literal\">null</span> ? Guid.NewGuid() : id;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"meta\">Required</span>]</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Title &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">        [<span class=\"meta\">Required</span>]</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> Price &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用Table特性来表名该实体类Book将对应数据库中的book表（不需要此刻已经有Book表），使用[Required]特性来表明字段是否可为空，此外，由于EF默认将Id属性视为主键，所以无需使用[Key]特性来指明上面的Id为主键。</p>\n<p>接下来，我们需要使用继承EF的DbContext来构建数据库上下文类，我们直接使用VS自带生成工具即可生成对应的数据库上下文模型：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/bookdbdemo.png\" alt=\"bookdbdemo\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/genguide.png\" alt=\"genguide\"></p>\n<p>点击完成后我们就得到了如下的一个配置类</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BookDbDemo</span> : <span class=\"title\">DbContext</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"comment\">//您的上下文已配置为从您的应用程序的配置文件(App.config 或 Web.config)</span></span><br><span class=\"line\">       <span class=\"comment\">//使用“BookDbDemo”连接字符串。默认情况下，此连接字符串针对您的 LocalDb 实例上的</span></span><br><span class=\"line\">       <span class=\"comment\">//“CodeFirstDemo.BookDbDemo”数据库。</span></span><br><span class=\"line\">       <span class=\"comment\">// </span></span><br><span class=\"line\">       <span class=\"comment\">//如果您想要针对其他数据库和/或数据库提供程序，请在应用程序配置文件中修改“BookDbDemo”</span></span><br><span class=\"line\">       <span class=\"comment\">//连接字符串。</span></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BookDbDemo</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">           : <span class=\"title\">base</span>(<span class=\"params\"><span class=\"string\">&quot;name=BookDbDemo&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>       &#123;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//为您要在模型中包含的每种实体类型都添加 DbSet。有关配置和使用 Code First  模型</span></span><br><span class=\"line\">       <span class=\"comment\">//的详细信息，请参阅 http://go.microsoft.com/fwlink/?LinkId=390109。</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// public virtual DbSet&lt;MyEntity&gt; MyEntities &#123; get; set; &#125;</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//public class MyEntity</span></span><br><span class=\"line\">   <span class=\"comment\">//&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">//    public int Id &#123; get; set; &#125;</span></span><br><span class=\"line\">   <span class=\"comment\">//    public string Name &#123; get; set; &#125;</span></span><br><span class=\"line\">   <span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure>\n<p>一个十分简单的数据库上下文类就建立完成。</p>\n<p>正如生成的DbContext所说：“为您要在模型中包含的每种实体类型都添加 DbSet。”，我们在该类中添加如下的DbSet属性，并将注释删除，更加直观的看一看当前的结构：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BookDbDemo</span> : <span class=\"title\">DbContext</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BookDbDemo</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">        : <span class=\"title\">base</span>(<span class=\"params\"><span class=\"string\">&quot;name=BookDbDemo&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> DbSet&lt;Book&gt; Books &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个类中，我们声明了一个DbSet属性books，这就对应了数据库中的book表。换句话说，继承了DbContext的类就对应了某一个数据库，其连接属性由配置文件中的连接配置决定，并在DbContext中设置进去（基类构造函数设置），这个DbContext中的所有DbSet就对应到数据库中的表。</p>\n<p>注意到，构造函数调用了基类构造函数，传入了”name=BookDbDemo”字符串，这个字符串就是指app.config配置文件中的数据库连接名，然后我们查看App.config文件，发现vs已经为我们生成了一个连接字符串节点：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;BookDbDemo&quot;</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">&quot;data source=(LocalDb)\\MSSQLLocalDB;initial catalog=CodeFirstDemo.BookDbDemo;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework&quot;</span> <span class=\"attr\">providerName</span>=<span class=\"string\">&quot;System.Data.SqlClient&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是这还段配置还是有点问题，首先连接地址数据库用户名等等都不对，更主要的是，我是MySQL数据库，怎么能用SQL呢，所以，我们要解决EF进行MySQL的连接问题。</p>\n<h4 id=\"使用EF进行MySQL数据库连接配置\"><a href=\"#使用EF进行MySQL数据库连接配置\" class=\"headerlink\" title=\"使用EF进行MySQL数据库连接配置\"></a>使用EF进行MySQL数据库连接配置</h4><p>如果使用ado.net链接mysql数据库则只需要MySql.Data.dll，即使用Nuget安装Mysql.Data就行了，并不需要安装mysql-connector-net驱动程序；</p>\n<p>如果使用EF的话一般来说需要安装mysql-connector-net驱动程序；</p>\n<p>其中mysql-connector-net驱动程序安装目录包含了<br>MySql.Data.dll；<br>MySql.Data.Entity.EF5.dll；<br>MySql.Data.Entity.EF6.dll；<br>MySql.Fabric.Plugin.dll；<br>MySql.Web.dll；</p>\n<p>注意：就算把mysql-connector-net安装目录下所有的类库都拷到bin目录而不在应用环境上安装mysql-connector-net驱动程序，EF代码还是会报错，因为mysql-connector-net安装不仅装了各种dll类库，还在机器上.net环境的全局machine.config里加过如下配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">system.data</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">DbProviderFactories</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;MySQL Data Provider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">invariant</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">description</span>=<span class=\"string\">&quot;.Net Framework Data Provider for MySQL&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">type</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient.MySqlClientFactory, MySql.Data, Version=6.9.6.0, Culture=neutral,        PublicKeyToken=c5687fc88969c44d&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">DbProviderFactories</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">system.data</span>&gt;</span></span><br></pre></td></tr></table></figure><br>所以要使用EF必须在站点服务器安装mysql-connector-net启动程序（数据库所在的服务器不需要安装，只需要c#程序所运行的电脑需要安装）<strong>或者</strong>在应用的配置文件（app.config或web.config）里configuration节点下加上上面的配置。</p>\n<p>这里，为了我们机器环境的纯净，我们使用nuget安装对应项目需要的库（MySql.Fabric.Plugin.dll和MySql.Web.dll这两个库如果没有需要不用安装）到项目中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/mysqldata.png\" alt=\"mysqldata\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/mysqldataentity.png\" alt=\"mysqldataentity\"></p>\n<p><strong>务必注意！MySql.Data和MySql.Data.Entity必须要保持相同的版本！否则会出现 “找到的程序集清单定义与程序集引用不匹配。 (异常来自 HRESULT:0x80131040)” 的错误，所以这里的Mysql.Data版本我并没有选择最新的</strong></p>\n<p>并且在配置文件中加如上述system.data配置，此时app.config配置主要有如下的变化：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configSections</span>&gt;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">configSections</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">startup</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">startup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">entityFramework</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">defaultConnectionFactory</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">...</span></span></span><br><span class=\"line\">    &lt;/defaultConnectionFactory&gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 新增了 MySql.Data.MySqlClient Provider --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">provider</span> <span class=\"attr\">invariantName</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient.MySqlProviderServices, MySql.Data.Entity.EF6, Version=6.10.8.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">entityFramework</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;BookDbDemo&quot;</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">&quot;data source=(LocalDb)\\MSSQLLocalDB;initial catalog=CodeFirstDemo.BookDbDemo;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework&quot;</span> <span class=\"attr\">providerName</span>=<span class=\"string\">&quot;System.Data.SqlClient&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 引入MySql.Data写入的 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">runtime</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">assemblyBinding</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependentAssembly</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">assemblyIdentity</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;MySql.Data&quot;</span> <span class=\"attr\">publicKeyToken</span>=<span class=\"string\">&quot;c5687fc88969c44d&quot;</span> <span class=\"attr\">culture</span>=<span class=\"string\">&quot;neutral&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bindingRedirect</span> <span class=\"attr\">oldVersion</span>=<span class=\"string\">&quot;0.0.0.0-6.9.6.0&quot;</span> <span class=\"attr\">newVersion</span>=<span class=\"string\">&quot;6.9.6.0&quot;</span> /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependentAssembly</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">assemblyBinding</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">runtime</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 手动新增system.data配置节点 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">system.data</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">DbProviderFactories</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;MySQL Data Provider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">invariant</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">description</span>=<span class=\"string\">&quot;.Net Framework Data Provider for MySQL&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">type</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient.MySqlClientFactory, MySql.Data, Version=6.9.6.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">DbProviderFactories</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">system.data</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><br>PS：实际上本人在实践过程中发现，引入Mysql.Data后写如的节点（见上面xml）作用似乎和手动新增的一样，没有求证差别。</p>\n<h4 id=\"实际数据库配置\"><a href=\"#实际数据库配置\" class=\"headerlink\" title=\"实际数据库配置\"></a>实际数据库配置</h4><p>完成EF的Mysql连接环境配置后，最基础的数据库还是需要建立的，所以去数据库创建一个名为bookdbdemo的数据库，按道理来说，我们只需要在这个地方触碰到数据库，况且这还是DBA的事情。创建好的数据库如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/mysqldb.png\" alt=\"mysqldb\"></p>\n<p>于是，我们将其中的连接字符串connectionString内容修改为我们当前的数据库连接字符串：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;BookDbDemo&quot;</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">&quot;Data Source=localhost; Database=bookdbdemo; User ID=root; Password=;&quot;</span> <span class=\"attr\">providerName</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">注意：providerName写的是在引入MySql.Data.Entity之后在app.config中出现的</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">provider</span> <span class=\"attr\">invariantName</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient.MySqlProviderServices, MySql.Data.Entity.EF6, Version=6.10.8.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d&quot;</span>&gt;</span>节点</span><br></pre></td></tr></table></figure><br>完成上面的配置之后，我们接下来就要使用EF最强大的Migration数据库迁移功能。</p>\n<h4 id=\"EF-Database-Migration-EF数据库迁移\"><a href=\"#EF-Database-Migration-EF数据库迁移\" class=\"headerlink\" title=\"EF Database Migration EF数据库迁移\"></a>EF Database Migration EF数据库迁移</h4><p>首先启用迁移功能。在Nuget命令行中输入：Enable-Migrations（有个s，注意）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> <span class=\"built_in\">enable</span>-migrations</span></span><br></pre></td></tr></table></figure><br>注意：如果此处提示：具有固定名称“MySql.Data.MySqlClient”的 ADO.NET 提供程序未在计算机或应用程序配置文件中注册或无法加载。需要在上下文继承类中（此处就是BookDbDemo）上添加特性[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">[<span class=\"meta\">DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BookDbDemo</span> : <span class=\"title\">DbContext</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>启动迁移功能后，Nuget命令行提示：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> <span class=\"built_in\">enable</span>-migrations</span></span><br><span class=\"line\">正在检查上下文的目标是否为现有数据库...</span><br><span class=\"line\">已为项目 CodeFirstDemo 启用 Code First 迁移。</span><br></pre></td></tr></table></figure></p>\n<p>此处提示我们，EF的数据迁移功能已经启用，在项目中我们会发现创建了一个名为Migtaions的文件夹，里面还存在一个Configuration配置类，这个类中，我们需要将AutomaticMigrationsEnabled设置为true，即启用自动迁移功能</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Configuration</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AutomaticMigrationsEnabled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，我们的数据库还没有创建的任何的表。</p>\n<p>接下来，我们使用Add-Migtaion XXX命令来添加一个变更模块。</p>\n<h4 id=\"初始化以及创建表\"><a href=\"#初始化以及创建表\" class=\"headerlink\" title=\"初始化以及创建表\"></a>初始化以及创建表</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> add-migration InitDb</span></span><br><span class=\"line\">正在为迁移“InitDb”搭建基架。</span><br><span class=\"line\">此迁移文件的设计器代码包含当前 Code First 模型的快照。在下一次搭建迁移基架时，将使用此快照计算对模型的更改。如果对要包含在此迁移中的模型进行其他更改，则您可通过再次运行“Add-Migration InitDb”重新搭建基架。</span><br></pre></td></tr></table></figure>\n<p>注意后面的命名，InitDb只是我们取的名字，为了区分对数据库进行的变更，这里是我们第一次构建，所以我取名为InitDb，完成该命令后，你会发现Migrations文件夹下出现了一个以你迁移模块创建时刻+下划线+刚刚迁移模块的命名的类文件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/InitDb.png\" alt=\"InitDb\"></p>\n<p>其类文件内容如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">InitDb</span> : <span class=\"title\">DbMigration</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            CreateTable(</span><br><span class=\"line\">                <span class=\"string\">&quot;dbo.Book&quot;</span>,</span><br><span class=\"line\">                c =&gt; <span class=\"keyword\">new</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        Id = c.Guid(nullable: <span class=\"literal\">false</span>),</span><br><span class=\"line\">                        Title = c.String(nullable: <span class=\"literal\">false</span>),</span><br><span class=\"line\">                        Price = c.Double(nullable: <span class=\"literal\">false</span>),</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                .PrimaryKey(t =&gt; t.Id);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Down</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            DropTable(<span class=\"string\">&quot;dbo.Book&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到里面重写了DbMigration的Up和Down方法，同时从方法中的代码我们能大致推测，Up方法就是发生的变更，这里会创建表Book（dbo是EF的一些配置语法），设置表字段以及设置主键；而Down方法就是回滚操作，将表Book删除。</p>\n<p>但是此时，我们数据库中的表还是没有发生变化，因为我们现在添加了变更模块，只是根据当前的代码来的，要将变更同步到数据库，需要Update-Database命令（添加-Versbose方便我们查看数发生执行的SQL语句）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> update-database -verbose</span></span><br><span class=\"line\">Using StartUp project &#x27;CodeFirstDemo&#x27;.</span><br><span class=\"line\">Using NuGet project &#x27;CodeFirstDemo&#x27;.</span><br><span class=\"line\">指定“-Verbose”标志以查看应用于目标数据库的 SQL 语句。</span><br><span class=\"line\">目标数据库为: “bookdbdemo”(DataSource: localhost，提供程序: MySql.Data.MySqlClient，来源: Configuration)。</span><br><span class=\"line\">正在应用显式迁移: [201809131330306_InitDb]。</span><br><span class=\"line\">正在应用显式迁移: 201809131330306_InitDb。</span><br><span class=\"line\">create table `Book` (`Id` CHAR(36) BINARY default &#x27;&#x27;  not null ,`Title` longtext not null ,`Price` double not null ,primary key ( `Id`) ) engine=InnoDb auto_increment=0</span><br><span class=\"line\">create table `__MigrationHistory` (`MigrationId` nvarchar(150)  not null ,`ContextKey` nvarchar(300)  not null ,`Model` longblob not null ,`ProductVersion` nvarchar(32)  not null ,primary key ( `MigrationId`) ) engine=InnoDb auto_increment=0</span><br><span class=\"line\">INSERT INTO `__MigrationHistory`(</span><br><span class=\"line\">`MigrationId`, </span><br><span class=\"line\">`ContextKey`, </span><br><span class=\"line\">`Model`, </span><br><span class=\"line\">`ProductVersion`) VALUES (</span><br><span class=\"line\">&#x27;201809131330306_InitDb&#x27;, </span><br><span class=\"line\">&#x27;CodeFirstDemo.Migrations.Configuration&#x27;, </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">中间有一大段经过摘要的字符串，应该是变更的摘要</span></span><br><span class=\"line\">, </span><br><span class=\"line\">&#x27;6.2.0-61023&#x27;);</span><br><span class=\"line\">正在运行 Seed 方法。</span><br></pre></td></tr></table></figure>\n<p>我们可以从输出中很容易的看到执行了创建book数据库的sql语句，以及创建了一个MigrationHistory表，这个表就是记录了数据库迁移的一些摘要，供我们以后来进行回退操作。</p>\n<p>完成了迁移之后，查看数据库：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/initcomplete.png\" alt=\"initcomplete\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/tabledetail.png\" alt=\"tabledetail\"></p>\n<p>我们可以看到，表及其结构按照我们预期创建成功了。</p>\n<h4 id=\"删除表\"><a href=\"#删除表\" class=\"headerlink\" title=\"删除表\"></a>删除表</h4><p>为了证明EF再删除表的时候，并不会影响其他的表，我再次利用创建了一个新的实体类EBook并更新DbContext以及进行EF迁移功能：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">CodeFirstDemo</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Table(<span class=\"meta-string\">&quot;EBook&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">EBook</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Guid id;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Guid Id</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = id == <span class=\"literal\">null</span> ? Guid.NewGuid() : id;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">set</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"meta\">Required</span>]</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">string</span> EBookTitle &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新DbContext：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BookDbDemo</span> : <span class=\"title\">DbContext</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BookDbDemo</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    : <span class=\"title\">base</span>(<span class=\"params\"><span class=\"string\">&quot;name=BookDbDemo&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> DbSet&lt;Book&gt; Books &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新增的DbSet</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> DbSet&lt;EBook&gt; EBooks &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进行EF数据库迁移，此时我们不需要再次进行启用迁移功能了，而是使用add-migration检测并增加行的变更模块：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> add-migration AddEBookEntity</span></span><br><span class=\"line\">正在为迁移“AddEBookEntity”搭建基架。</span><br><span class=\"line\">此迁移文件的设计器代码包含当前 Code First 模型的快照。在下一次搭建迁移基架时，将使用此快照计算对模型的更改。如果对要包含在此迁移中的模型进行其他更改，则您可通过再次运行“Add-Migration AddEBookEntity”重新搭建基架。</span><br></pre></td></tr></table></figure>\n<p>此时Migrations文件夹下面又增加了新的类文件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/addebookentity.png\" alt=\"addebookentity\"></p>\n<p>其内容和前面大致，创建表以及回滚，这里不再展示。之后我们再次使用update-database命令将变更更新到数据库中，得到当前的数据库内容：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afteraddtable.png\" alt=\"afteraddtable\"></p>\n<p>此时我们将book表中填充一些数据：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/booktablecontent.png\" alt=\"booktablecontent\"></p>\n<p>然后，我们将DbContext中的DbSet<EBook>属性删除，再次进行迁移：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/delebook.png\" alt=\"delebook\"></p>\n<p>进行更新以后，我们可以看到Ebook表已经删除了，但是book表内容没有发生任何变化：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afterdelebook.png\" alt=\"afterdelebook\"></p>\n<h4 id=\"变更属性\"><a href=\"#变更属性\" class=\"headerlink\" title=\"变更属性\"></a>变更属性</h4><p>有的时候，我们可能很少会将实体类，更多的是对现有实体类中进行属性的增加、删除以及修改，变相的，对数据库中的表的字段进行增加、删除和修改：</p>\n<h5 id=\"增加属性\"><a href=\"#增加属性\" class=\"headerlink\" title=\"增加属性\"></a>增加属性</h5><p>现在，我们想要将Book实体类中增加一个Abstract摘要属性，它会影响我们上面我们已有的数据吗？试一试就知道了。</p>\n<p>首先，在Book类中增加这一属性，不设置Required特性：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">[<span class=\"meta\">Required</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Title &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"><span class=\"comment\">// 增加的摘要属性</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Abstract &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">Required</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> Price &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>此时我们增加变更模块：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> add-migration AddNewProp</span></span><br><span class=\"line\">正在为迁移“AddNewProp”搭建基架。</span><br><span class=\"line\">此迁移文件的设计器代码包含当前 Code First 模型的快照。在下一次搭建迁移基架时，将使用此快照计算对模型的更改。如果对要包含在此迁移中的模型进行其他更改，则您可通过再次运行“Add-Migration AddNewProp”重新搭建基架。</span><br></pre></td></tr></table></figure><br>我们可以看到变更模块类：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">AddNewProp</span> : <span class=\"title\">DbMigration</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Abstract&quot;</span>, c =&gt; c.String(unicode: <span class=\"literal\">false</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Down</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Abstract&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>从这个类的Up方法中，我们看，他调用了AddColumn增加列的方法。而Down回退方法则调用了DropColumn删除列的方法。当我们执行update-database命令有什么效果呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> update-database -verbose</span></span><br><span class=\"line\">Using StartUp project &#x27;CodeFirstDemo&#x27;.</span><br><span class=\"line\">Using NuGet project &#x27;CodeFirstDemo&#x27;.</span><br><span class=\"line\">指定“-Verbose”标志以查看应用于目标数据库的 SQL 语句。</span><br><span class=\"line\">目标数据库为: “bookdbdemo”(DataSource: localhost，提供程序: MySql.Data.MySqlClient，来源: Configuration)。</span><br><span class=\"line\">正在应用显式迁移: [201809131406177_AddNewProp]。</span><br><span class=\"line\">正在应用显式迁移: 201809131406177_AddNewProp。</span><br><span class=\"line\">alter table `Book` add column `Abstract` longtext </span><br><span class=\"line\">INSERT INTO `__MigrationHistory`(</span><br><span class=\"line\">...</span><br><span class=\"line\">）</span><br></pre></td></tr></table></figure>\n<p>重点看到这句SQL：“alter table <code>Book</code> add column <code>Abstract</code> longtext ”，这句SQL就是对我们表添加了一个字段，类型为longtext。我们进入数据库中，看一看变化：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afteraddprop.png\" alt=\"afteraddprop\"></p>\n<p>可以看到数据库中其他字段的值都没有发生变化，仅仅多出了这个字段，同时符合我们设置的可以为空的预期</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/addpropdetail.png\" alt=\"addpropdetail\"></p>\n<h5 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h5><p>删除与增加同理，我们直接将Book实体类的属性删除，然后增加变更，最后同步更新变更到数据库。这里我们将Price和Abstract属性都删除，变更模块如下：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">RemoveProp</span> : <span class=\"title\">DbMigration</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Abstract&quot;</span>);</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Price&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Down</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Price&quot;</span>, c =&gt; c.Double(nullable: <span class=\"literal\">false</span>));</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Abstract&quot;</span>, c =&gt; c.String(unicode: <span class=\"literal\">false</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>得到如下的结果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afterdel2prop.png\" alt=\"afterdel2prop\"></p>\n<h5 id=\"重命名属性\"><a href=\"#重命名属性\" class=\"headerlink\" title=\"重命名属性\"></a>重命名属性</h5><p>重命名比起前面的增删属性有所不同，就当前情形为例子，当前Book类属性如下：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">CodeFirstDemo</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Table(<span class=\"meta-string\">&quot;Book&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Book</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Guid id;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Guid Id</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = id == <span class=\"literal\">null</span> ? Guid.NewGuid() : id;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">set</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                id = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"meta\">Required</span>]</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Title &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>对应数据库为<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/beforerename.png\" alt=\"beforerename\"></p>\n<p>此时如果我们想要修改属性名，我们将Book中的Title属性改为Name属性：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">[<span class=\"meta\">Required</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Name &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>然后执行Add-Migration命令：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PM&gt; <span class=\"keyword\">add</span>-migration ChangePropName</span><br></pre></td></tr></table></figure><br>我们看到变更类的内容为：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">ChangePropName</span> : <span class=\"title\">DbMigration</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Name&quot;</span>, c =&gt; c.String(nullable: <span class=\"literal\">false</span>, unicode: <span class=\"literal\">false</span>));</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Title&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Down</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        AddColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Title&quot;</span>, c =&gt; c.String(nullable: <span class=\"literal\">false</span>, unicode: <span class=\"literal\">false</span>));</span><br><span class=\"line\">        DropColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Name&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们发现，只要更新到数据库，EF会在表中先添加一个字段Name，然后删除字段Title，很显然，这样更新，会将我们现有的数据清空。如何不造成这样的情况呢？其实我们首先知道，在进行Update-database的时候，EF框架会执行Up方法，同时，AddColumn、DropColumn很显然是DbMigration这个类中的方法，我们找一找看有没有重命名的方法呢。令我们欣喜的是，有：<br><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Up</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//AddColumn(&quot;dbo.Book&quot;, &quot;Name&quot;, c =&gt; c.String(nullable: false, unicode: false));</span></span><br><span class=\"line\">    <span class=\"comment\">//DropColumn(&quot;dbo.Book&quot;, &quot;Title&quot;);</span></span><br><span class=\"line\">    RenameColumn(<span class=\"string\">&quot;dbo.Book&quot;</span>, <span class=\"string\">&quot;Title&quot;</span>, <span class=\"string\">&quot;Name&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>注释掉Add和DropColumn，使用RenameColumn，填入表、原字段名、新字段名；接下来我们执行Update-Database -Verbose：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">PM&gt;</span><span class=\"bash\"> UPDATE-DATABASE -VERBOSE</span></span><br><span class=\"line\">...</span><br><span class=\"line\">Fatal error encountered during command execution. ---&gt; MySql.Data.MySqlClient.MySqlException (0x80004005): Parameter &#x27;@columnType&#x27; must be defined.</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>我们发现报了一个错误，实际上解决方法在链接字符串中加入这样一句话“;Allow User Variables=True”就可以了，即如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;BookDbDemo&quot;</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">&quot;Data Source=localhost; Database=bookdbdemo; User ID=root; Password=;Allow User Variables=True&quot;</span> <span class=\"attr\">providerName</span>=<span class=\"string\">&quot;MySql.Data.MySqlClient&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这样一来，再次运行，不报错。查看数据库：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-09-13-EF/afterrename.png\" alt=\"afterrename\"></p>\n","categories":[],"tags":["C#","EF"]},{"title":"WebXml文件与SpringMVC的联系","url":"http://compilemind.com/2018/08/26/2018-08-26-WebXml文件与SpringMVC的联系/","content":"<p>无论采用何种框架来进行Java Web的开发，只要是Web项目必须在WEB-INF下有web.xml，这是java规范。 当然，我们最早接触到Java Web容器通常是tomcat，但这并不意味着web.xml是属于Tomcat的，同样，Servlet本身也不属于Tomcat，它与JSP等是Java Web的基础规范。而Servlet的运行需要有Servlet容器的支持，常见的容器有Tomcat、Jetty、JBoss等。</p>\n<a id=\"more\"></a>\n<p>对于一个web.xml文件，比较重要的节点有context-param、listener、filter以及servlet：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- context-param元素声明应用范围内的初始化参数 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- filter 过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- filter-mapping 一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- listener 对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。Listener元素指出事件监听程序类。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- servlet 在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><br>其他关于web.xml解释可以参考这里，本文不再详细介绍。本文主要是在整理关于Java Web使用SpringMVC过程的心得。</p>\n<p>我们知道一个最基本的Spring MVC项目需要在web.xml中区配置如下信息：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;WebApp_ID&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.5&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:application-context.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">            org.springframework.web.context.ContextLoaderListener</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>web-app<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">            org.springframework.web.servlet.DispatcherServlet</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:context-mvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>web-app<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br>对于这样一份配置，我们不仅要知其然还要知其所以然。这样不仅能够加深对Java web以及web.xml的理解，对于以后排错也会有很大的帮助。</p>\n<h4 id=\"回到一个普通的Java-Web项目\"><a href=\"#回到一个普通的Java-Web项目\" class=\"headerlink\" title=\"回到一个普通的Java Web项目\"></a>回到一个普通的Java Web项目</h4><p>为什么要这么配置，首先我们要<strong>回到</strong>web.xml加载顺序介绍。web.xml基础节点的加载顺序是context-param &gt; listener &gt; filter &gt; serlvet。</p>\n<h5 id=\"context-param节点\"><a href=\"#context-param节点\" class=\"headerlink\" title=\"context-param节点\"></a>context-param节点</h5><p>context-param节点中的键值对首先会被容器读取并存放到ServletContext对象中，这里面的键值对信息被整个web项目共享。</p>\n<p>如何读取context-param中的值呢？我们只要获得ServletContext对象，然后再调用它的getInitParameter提供键名来获得方法就可以获得。在哪些地方能获得SerlvetContext对象呢？我们继承HttpServlet的Serlvet中去调用getServletContext就能获取ServletContext对象；这里我首先来编写一个简单Java web项目来读取相关的参数，首先是配置文件：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">version</span>=<span class=\"string\">&quot;4.0&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>test-param<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>this is a test-param string<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>simple-web-app<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">            servlet.SimpleServlet</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>simple-web-app<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在这个配置文件中，我只定义了最简单的两个节点context-param与servlet，对于context-param节点，我定义了”test-param” : “this is a test-param string”键值对，然后定义了servlet相关配置（这一部分我认为你已经明白了）。最后，SimpleServlet中的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        doPost(req, resp); <span class=\"comment\">// 将所有的Get请求转移到Post请求方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        ServletContext context = <span class=\"keyword\">this</span>.getServletContext();</span><br><span class=\"line\">        String param = context.getInitParameter(<span class=\"string\">&quot;test-param&quot;</span>);</span><br><span class=\"line\">        resp.getWriter().print(param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在doPost方法中，我们按照前面说的方式获取ServletContext对象，然后再通过getInitParameter方法获取”test-param”键对应的字符串，然后输出到网页上：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-08-26-JavaWeb/print.png\" alt=\"print.png\"></p>\n<h5 id=\"listener节点\"><a href=\"#listener节点\" class=\"headerlink\" title=\"listener节点\"></a>listener节点</h5><p>web.xml第二步加载就是listener节点，该节点的形式如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">        listener.MyInitListener</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><br>而MyInitListener类需要实现ServletContextListener接口，并重写其中的方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInitListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletContextListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> Date() + <span class=\"string\">&quot; contextInitialized....&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextDestroyed</span><span class=\"params\">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>当web.xml在加载监听器节点之后，会创建我们定义的对应的MyInitListener对象，并且会执行其中的contextInitialized方法，在整个项目关闭的时候会执行contextDestroyed方法。上面我们编写了contextInitialized方法中的内容，然后启动项目，会在控制台看到输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sun Aug 26 13:02:19 CST 2018 contextInitialized....</span><br></pre></td></tr></table></figure></p>\n<p>当然，我们也可以ServletContextEvent.getServletContext().getInitParam(“xxx”)来获取context-param了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"keyword\">new</span> Date() + <span class=\"string\">&quot;contextInitialized....&quot;</span>);</span><br><span class=\"line\">    System.out.println(sce.getServletContext().getInitParameter(<span class=\"string\">&quot;test-param&quot;</span>) + <span class=\"string\">&quot; in contextInitialized()&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// OUTPUT</span></span><br><span class=\"line\">    <span class=\"comment\">// Sun Aug 26 13:19:16 CST 2018 contextInitialized....</span></span><br><span class=\"line\">    <span class=\"comment\">// this is a test-param string in contextInitialized()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"回到Spring-MVC配置\"><a href=\"#回到Spring-MVC配置\" class=\"headerlink\" title=\"回到Spring MVC配置\"></a>回到Spring MVC配置</h4><p>回到Spring。为什么想要使用spring mvc，需要设置param-name=contextConfigurationLocation，param-value=xxxx-spring（非mvc部分配置）.xml；然后设置listener节点中监听器类是org.springframework.web.context.ContextLoaderListener。其实就比较好理解了，因为在这一步通过首先将spring基础上下文的配置文件通过ContextLoaderListener监听器去加载，然后读取出基础spring IOC以及AOP部分配置，将一些基础组件加载到spring的bean容器中，在接下来的无论是filter节点中的对象还是serlvet节点中的对象需要依赖注入的部分，都已经通过加载context-param中对于spring基础配置文件定位加载好了，后续spring相关的bean的创建以及注入等都交给了spring来进行管理。</p>\n<p>同时在加载serlvet时候，因为所有的请求都交给了DispatcherSevlet，且指定了mvc.xml配置文件的路径参数，所以，我们在这个mvc.xml中去设置静态资源的处理规则以及试图和控制器等处理规则。</p>\n","categories":[],"tags":["SpringMVC","Servlet"]},{"title":"CSharp委托与匿名函数","url":"http://compilemind.com/2018/08/04/2018-08-04-CSharp委托与匿名函数/","content":"<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>面对事件处理，我们通常会通过定义某一个通用接口，在该接口中定义方法，然后在框架代码中，调用实现该接口的类实例的方法来实现函数的回调。可能这样来说有些抽象，那我们提供一个具体的情形来实现这一情形。</p>\n<a id=\"more\"></a>\n<p>假设目前我在编写某一个服务，这个服务通过Start启动，并在一定的时间内不停地监听某一个事件的发生：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Service</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Random rand = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt;= <span class=\"number\">10000</span>)<span class=\"comment\">// 一段时间内</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> eventInt = rand.Next(<span class=\"number\">10</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 监听事件的发生，这里就是i能够被随机数整除的事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % eventInt == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODU</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>以上这段代码就大致描述了我的服务运行过程。往往我们都是自行的编写服务代码，在上面的TODU处编写处理函数，以应对这些事件发生的时候进行的操作。比如，现在我想要当事件发生的时候，能够打印eventInt，只需要在TODU处编写输出函数就行了。</p>\n<p>然而，我们编写这样的代码扩展性受到了严重的限制。因为假如我要修改事件处理的函数，就必须要到这个地方来修改。其次，假设我现在的想法是这段框架代码我编写好了，而你作为客户端代码使用者，想要定义其他的处理函数，当我打包编译好了这段代码，你完全没法修改它，只能够告诉我，然后将你的代码加入TODU中，这样的维护几乎不现实。</p>\n<p>但是，接口（或者是抽象类等其他同思想）可以帮助我们改变这一现状。我们使用一个通用的接口比如EventHandler，在其中定义一个名为EventHandle的方法，就像下面这样：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IEventHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后在原先的服务代码，定义一个接口对象域，通过构造函数或者是定义一个注册方法来注册这个处理类，就像下面这样：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Service</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个接口对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IEventHandler _eventHandler;</span><br><span class=\"line\">    <span class=\"comment\">// 通过构造函数注册这个处理对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Service</span>(<span class=\"params\">IEventHandler eventHandler</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._eventHandler = eventHandler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 通过顶定义一个方法来注册这个对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RegistHandler</span>(<span class=\"params\">IEventHandler eventHandler</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._eventHandler = eventHandler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>(<span class=\"params\"></span>) </span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        ...<span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % eventInt == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把操作全部交给 _eventHandler 来进行</span></span><br><span class=\"line\">            _eventHandler.EventHandle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>于是，在我们客户端代码，只需要实现这个接口，并定义自己的方法处理内容，然后实例化这个对象并将其注册到Service中就能够，那么当事件发生的时候，就能够通过运行时候的多态，动态根据我们new出来的不同的Handler对象进行定制的操作，并且，Service端是可以与客户端分离出来的。</p>\n<h4 id=\"更好的语法糖——c-委托\"><a href=\"#更好的语法糖——c-委托\" class=\"headerlink\" title=\"更好的语法糖——c#委托\"></a>更好的语法糖——c#委托</h4><h5 id=\"使用委托的角度\"><a href=\"#使用委托的角度\" class=\"headerlink\" title=\"使用委托的角度\"></a>使用委托的角度</h5><p>诚然，在学习的初期，我十分推荐完全利用面向对象的思想来构建和理解接口与事件处理的代码。但是我们可以发现，这样的代码还不足够的简练。还是以上面的例子来说，每次我要去定制属于自己的事件处理代码的时候，都需要我们去实现这个接口，然后实现其中的接口的方法，然后把这个实例化对象，再注册到代码中去。实际上，在c#中，我们可以利用更加舒服的语法糖来实现：委托。委托的声明类似于函数，但是不带函数体，且要用delegate关键字。大致形式如下：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">XXX</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 不同的返回类型以及参数类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">Check</span>(<span class=\"params\"><span class=\"keyword\">int</span> param</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实际上，委托的语法应该这样理解：第一个是我定义了一个名为EventHandle的委托，它代表了一个函数，这个函数名字我也不知道是什么，只知道他是参数为空，返回为void的函数；第二个是我定义了一个名为Check的委托，它代表了一个只有一个int类型参数的，返回值为bool的函数。</p>\n<p>定义规则如下：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">XXX</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 不同的返回类型以及参数类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">Check</span>(<span class=\"params\"><span class=\"keyword\">int</span> param</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>使用的方式如下：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">ServiceSimulate</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">namespace</span> <span class=\"title\">XXX</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">Check</span>(<span class=\"params\"><span class=\"keyword\">int</span> param</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">MyEventHandle</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">&quot;Do IT&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">MyCheck</span>(<span class=\"params\"><span class=\"keyword\">int</span> param</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> param &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            EventHandle myEventHandle = <span class=\"keyword\">new</span> EventHandle(Program.MyEventHandle);</span><br><span class=\"line\">            myEventHandle();</span><br><span class=\"line\">            Check myCheck = <span class=\"keyword\">new</span> Check(Program.MyCheck);</span><br><span class=\"line\">            Console.WriteLine(myCheck(<span class=\"number\">2</span>));</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在上面的Program类中，我分别定义了两个函数MyEventHandle和MyCheck，这两个函数的签名（只考虑参数和返回类型）与定义的两个委托EventHandle和Check的语义是一样的。在这样的情况下，我在使用这两个委托的时候，可以上面Main方法中的语法一样，首先定义一个委托类型（EventHandle myEventHandle），通过new 委托的方式将方法设置到委托中（= new EventHandle(Program.MyEventHandle)）。<br>于是接下来我可以直接使用委托变量来达到和使用函数一样的作用，输出见下方：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// OUTPUT</span></span><br><span class=\"line\">DO IT</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure><br>当然，我们还可以通过更加简洁的声明方式，不用new关键字，而是直接将函数赋予委托类型变量：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventHandle myEventHandle = Program.MyEventHandle;</span><br><span class=\"line\">Check myCheck = Program.MyCheck;</span><br></pre></td></tr></table></figure></p>\n<p>目前位置大致介绍了委托的语法与语义，那么回到一开始的服务代码中，我们可以看到，每次我们去实现接口，都会去实现接口中的固定的方法，然后再注册，被调用。实际上，我们完全可以使用委托的方式来来简化代码：</p>\n<p>我们现在可以不用定义统一的接口了，而是定义一个委托，然后想Service注册这个委托，就完全能够达到一开始调用实现接口的类中的方法的目的了（有点拗口）。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">ServiceSimulate</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;<span class=\"comment\">// 定义委托类型</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Service</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> EventHandle _eventHandle;</span><br><span class=\"line\">        <span class=\"comment\">// 通过构造函数注册委托对象</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Service</span>(<span class=\"params\">EventHandle eventHandle</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._eventHandle = eventHandle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 通过定义的方法注册委托对象</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RegistHandler</span>(<span class=\"params\">EventHandle eventHandle</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._eventHandle = eventHandle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            Random rand = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt;= <span class=\"number\">10000</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> eventInt = rand.Next(<span class=\"number\">10</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i % eventInt == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 注意这里直接就是委托对象语法形式来调用方法了</span></span><br><span class=\"line\">                    _eventHandle();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在客户端代码中，我们就可以定义满足委托类型语法语义的函数，将函数注册到委托对象上：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义处理方法就行了，不用再实现接口，再定义处理内容</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">MyEventHandle</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Do IT&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        Service ss = <span class=\"keyword\">new</span> Service(MyEventHandle);<span class=\"comment\">// 通过构造函数注册委托对象</span></span><br><span class=\"line\">        ss.Start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如此以来，利用委托，能够更加方便的函数回调。实际上，我个人对委托的理解，再代码的底层编译器处理的过程中，应该还是将委托转化为了接口函数（个人猜测，技艺不深，无法验证）。</p>\n<h5 id=\"定义委托的角度\"><a href=\"#定义委托的角度\" class=\"headerlink\" title=\"定义委托的角度\"></a>定义委托的角度</h5><p>在前面的介绍中，我谈了关于委托的使用过程及其思想，主要是从客户端的角度，谈了谈如何使用定义好的委托。在这一节中，我将从结合泛型来谈一谈在我们编写框架代码的时候，如何更为高效的定义我们的委托。</p>\n<p>回到一开始的例子，当作为服务端（此服务端是指为客户端程序员提供代码）代码编写者，在以后的开发中，我们会发现我们会定义大量的委托，并且，这些委托实际上绝大部分是具有共性的。有点抽象，具体一点讲，上面的例子中Service我们定义了一个名为EventHandle的委托，他代表了一个返回值为void，无参的函数类型。在以后的开发中，我们可能会定义更多的类似结构的委托，返回值或有不同，参数列表或有不同，就像下面这种情形：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">XXX</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventHandle2</span>(<span class=\"params\"><span class=\"keyword\">int</span> p1</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">EventHandle3</span>(<span class=\"params\"><span class=\"keyword\">int</span> p1</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">EventHandle4</span>(<span class=\"params\"><span class=\"keyword\">int</span> p1, <span class=\"keyword\">double</span> p2</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">EventHandle5</span>(<span class=\"params\"><span class=\"keyword\">double</span> p1, <span class=\"keyword\">int</span> p2</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，我们定义如此多的事件处理委托类型，他们由于返回值、参数的差异彼此不同。不难看出，不同的返回值、参数类型的搭配，可以定义成千上万个委托类型，同时他们彼此还很接近。为了解决这一定义爆炸，c#提供了三种基本的泛型委托，我们只需要改变泛型参数，就能够达到定义不同的委托：</p>\n<h6 id=\"Predicate\"><a href=\"#Predicate\" class=\"headerlink\" title=\"Predicate\\\"></a>Predicate\\<T></h6><p>该泛型委托的原型定义如下：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">bool</span> <span class=\"title\">Predicate</span>&lt;<span class=\"keyword\">in</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">T obj</span>)</span>;</span><br></pre></td></tr></table></figure><br>该委托只需要指定一个参数类型，就能够定义一个返回值类型为bool，一个参数的函数语义委托定义。</p>\n<h6 id=\"Action-or-Action\"><a href=\"#Action-or-Action\" class=\"headerlink\" title=\"Action or Action\"></a>Action<T1, T2, ......T16> or Action</h6><p>泛型Action\\<T>委托表示引用一个void返回类型的方法。Action\\<T>委托类存在不同的变体，可以传递至多16种不同的参数类型，没有泛型参数的Action类可以调用没有参数的方法。例如：Action\\<in T1>调用带一个参数的方法，Action\\<in T1,in T2>调用带两个参数的方法等.。其<strong>某两个</strong>原型定义如下：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">Action</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">Action</span>&lt;<span class=\"keyword\">in</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">T obj</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 极限 void Action&lt;T1,..., T16&gt;(T1 arg1, ...., T16 arg16)</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"Func-lt-T1-T2-…T16-TResult-gt\"><a href=\"#Func-lt-T1-T2-…T16-TResult-gt\" class=\"headerlink\" title=\"Func&lt;[T1, T2, …T16,] TResult&gt;\"></a>Func&lt;[T1, T2, …T16,] TResult&gt;</h6><p>Func\\<T>的用法和Action\\<T>用法类似，但是Func\\<T>表示引用一个带返回类型的方法，Func\\<T>也存在不同的变体，至多可以传递16个参数类型和1个返回类型，例如：Func\\<in T1,out Resout>表示带一个参数的方法，Func\\<in T1,in T2,out Resout>表示调用带两个参数的方法。其<strong>某两个</strong>原型定义如下：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有参数 + 1个返回类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> TResult <span class=\"title\">Func</span>&lt;<span class=\"keyword\">out</span> <span class=\"title\">TResult</span>&gt;(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 2个参数 + 个返回类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">delegate</span> TResult <span class=\"title\">Func</span>&lt;<span class=\"keyword\">in</span> <span class=\"title\">T1</span>, <span class=\"title\">int</span> <span class=\"title\">T2</span>, <span class=\"keyword\">out</span> <span class=\"title\">TResult</span>&gt;(<span class=\"params\">T1 arg1, T2 arg2</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 极限 TResult Func&lt;T1,..., T16, TResult&gt;(T1 arg1, ...., T16 arg16)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h4><p>通过前面的介绍，我们已经能够更为简洁通用的定义自己的委托类型了，比如现在我需要一个定义一个返回值为string，参一个int类型与一个double类型的参数形式的委托类型，可以按照如下定义：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">Test</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            Func&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, <span class=\"keyword\">string</span>&gt; myFunc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为了使用这个委托，我们定义一个方法并赋予这个委托myFunc：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">string</span> <span class=\"title\">f</span>(<span class=\"params\"><span class=\"keyword\">int</span> p1, <span class=\"keyword\">double</span> p2</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p1 + <span class=\"string\">&quot;, &quot;</span> + p2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>    &#123;</span><br><span class=\"line\">        Func&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, <span class=\"keyword\">string</span>&gt; myFunc = f;</span><br><span class=\"line\">        Console.WriteLine(myFunc(<span class=\"number\">2</span>, <span class=\"number\">3.33</span>));</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们会发现，每次要“实例化”一个委托，我们都要在某个地方去编写一个函数，无论是static的还是实例的方法，都需要我们到一个地方去显式指定好方法函数名等等。而且，通常这些函数我们都是某种工具函数，只会在一些特定的地方去调用，为了这些函数，我们还需要给他们创建一个类，这往往是很多余的（尽管贯彻了OO思想，但是匿名方法往往更体现在函数式编程FP而不是面向对象编程OOP，这是一种编程哲学）。于是，为了脱离面向对象，更好的方式是采取匿名的形式，因为既然我们定义好了委托类型，他制定了返回值制定了参数类型，我们还有必要去显示制定一个函数的名称吗？正如委托语义一样，委托类型就是定义了一个返回值是XXX类型，参数列表是XX t1, xx t1…的函数，至于这个函数到底叫什么根本不用关心。而匿名函数就符合这样的要求。而匿名函数在c#中又分为两种：Lambda表达式和匿名方法表达式。在几乎所有的情况下，Lambda表达式都比匿名方法表达式更为简介具有表现力。</p>\n<h6 id=\"Lambda表达式：\"><a href=\"#Lambda表达式：\" class=\"headerlink\" title=\"Lambda表达式：\"></a>Lambda表达式：</h6><p>(匿名的函数签名) =&gt; (匿名的函数体) </p>\n<p>其中匿名的函数签名可以包括两种，一种是隐式的匿名函数签名另一种是显式的匿名函数签名： </p>\n<ol>\n<li>隐式的函数签名：(p)、(p1,p1) </li>\n<li>显式的函数签名：(int p)、(int p1,int p2)、(ref int p1, out int p2) </li>\n</ol>\n<p>在显式类型化参数列表中，每个参数的类型是显式声明的，在隐式类型化参数列表中，参数的类型是从匿名函数出现的上下文中推断出来的。 </p>\n<p>匿名的函数体可以是表达式或者代码块。</p>\n<p>当Lambda表达式只有<strong>一个</strong>具有隐式类型化参数的时候，参数列表可以省略圆括号，也就是说： </p>\n<p>(参数) =&gt; 表达式 可以简写为 参数 =&gt; 表达式</p>\n<h6 id=\"匿名方法表达式：\"><a href=\"#匿名方法表达式：\" class=\"headerlink\" title=\"匿名方法表达式：\"></a>匿名方法表达式：</h6><p>delegate (显式的匿名函数签名) {代码块}</p>\n<p>从表达式来看，匿名方法实际上就是单纯的将函数名省去，而其他部分都和一般定义一个方法一样。</p>\n<p>下面是是综合了上述两种表达式形式的是实例<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lambda表达式</span></span><br><span class=\"line\">x =&gt; x + <span class=\"number\">1</span> <span class=\"comment\">//隐式的类型化，函数体为表达式</span></span><br><span class=\"line\">x =&gt; &#123;<span class=\"keyword\">return</span> x + <span class=\"number\">1</span>;&#125; <span class=\"comment\">//隐式的类型化，函数体为代码块</span></span><br><span class=\"line\">(<span class=\"keyword\">int</span> x) =&gt; x + <span class=\"number\">1</span> <span class=\"comment\">//显式的类型化，函数体为表达式</span></span><br><span class=\"line\">(<span class=\"keyword\">int</span> x) =&gt; &#123;<span class=\"keyword\">return</span> x + <span class=\"number\">1</span>;&#125; <span class=\"comment\">//显式的类型化，函数体为代码块</span></span><br><span class=\"line\">(x , y) =&gt; x * y <span class=\"comment\">//多参数</span></span><br><span class=\"line\">() =&gt; Console.WriteLine() <span class=\"comment\">//无参数</span></span><br><span class=\"line\"><span class=\"comment\">// 匿名函数方法表达式</span></span><br><span class=\"line\"><span class=\"keyword\">delegate</span> (<span class=\"keyword\">int</span> x) &#123;<span class=\"keyword\">return</span> x + <span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">delegate</span> &#123;<span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"number\">1</span>;&#125; <span class=\"comment\">//参数列表省略</span></span><br></pre></td></tr></table></figure><br>那么，匿名方法表达式和Lambda表达式有什么区别呢？从上面的介绍看来有以下的几点：</p>\n<ol>\n<li>在参数列表上，Lambda表达式能够通过上下文推断参数的类型信息，故可以使用隐式类型化参数。而匿名方法表达式必须要显示的参数类型化。</li>\n<li>当没有参数或者是多个参数的时候，Lambda表达式是不能够省略括号的；匿名方法表达式允许完全省略参数列表。</li>\n<li>在函数体上，Lambda表达式的主题可以是表达式，也可以是代码块；而匿名方法表达式只能是代码块。 </li>\n</ol>\n<p>回到上面的代码，我们利用匿名函数来实现f方法，这一次我们完全不需要在其他类中去定义这个f方法了：<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Func&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, <span class=\"keyword\">string</span>&gt; myFunc = (x, y) =&gt; x + <span class=\"string\">&quot;, &quot;</span> + y;</span><br><span class=\"line\">Func&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, <span class=\"keyword\">string</span>&gt; myFunc2 = <span class=\"keyword\">delegate</span> (<span class=\"keyword\">int</span> x, <span class=\"keyword\">double</span> y) &#123; <span class=\"keyword\">return</span> x + <span class=\"string\">&quot;, &quot;</span> + y; &#125;;</span><br><span class=\"line\">Console.WriteLine(myFunc(<span class=\"number\">2</span>, <span class=\"number\">3.33</span>));</span><br><span class=\"line\">Console.WriteLine(myFunc2(<span class=\"number\">2</span>, <span class=\"number\">3.33</span>));</span><br><span class=\"line\">Console.ReadKey();</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\"><span class=\"number\">2</span>, <span class=\"number\">2.33</span></span><br><span class=\"line\"><span class=\"number\">2</span>, <span class=\"number\">2.33</span></span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["C#","delegate","lambda"]},{"title":"做你所做","url":"http://compilemind.com/2018/07/29/2018-07-29-做你所做/","content":"<h4 id=\"昨夜\"><a href=\"#昨夜\" class=\"headerlink\" title=\"昨夜\"></a>昨夜</h4><p>昨晚我失眠了，因为在自己的机器上装东西，顺便看了小米的纪录片《一团火》。也许是太久没有看到关于非产品方面的小米了，也许是太想要看到小米一路走来的路了，看完后我内心久久不能平复。待到后半夜，我内心依然如纪录片一般“一团火”。那一群人，那样的坚定，让我羡慕与感动。</p>\n<a id=\"more\"></a>\n<h4 id=\"眼下\"><a href=\"#眼下\" class=\"headerlink\" title=\"眼下\"></a>眼下</h4><p>今天是入职第二周周末，之所以没有在前些日子就写博文，因为那段时间单纯的是报道——领东西——装机器——配环境——培训，似乎每一位到新环境工作的人总要经历的东西，还有什么可写的呢？真正让我内心激动的是昨夜的“一团火”还有这几天以来的感受，回想起去年实习的日子，我庆幸于没有因为苟且而留在那里。而在这里，我的体会是满足的，是充实的。</p>\n<h5 id=\"“温柔”\"><a href=\"#“温柔”\" class=\"headerlink\" title=\"“温柔”\"></a>“温柔”</h5><p>每一位同事都给我一种“温柔”的感觉，这“温柔”绝不是那些小说女主角一般的依偎与可爱，更贴切的是一种淡然自若。他们的眉头也偶有骤紧，但绝不会是重压下的无法呼吸，而是紧凑而繁忙的工作带给他们的充实。其次的工作环境与氛围也是”温柔“的。在我看来，工作环境对于一个人的内心或多或少都有影响。这里给了我很舒服的感觉，一种温馨的，好似家一般的感觉。或许是因为并不是单纯的开发中心的原因吧，少了理工的那种统一呆板，更多的是像成都一般的闲适。</p>\n<h5 id=\"Not-Hei\"><a href=\"#Not-Hei\" class=\"headerlink\" title=\"Not Hei\"></a>Not Hei</h5><p>回想起去年的在苏州某为的实习，好似我在黑它一般。没有人情味的工作，没有人情味的活动。好像每一个人在工作，但仅仅是每”一个“人。那段时间，我好担忧，因为进入的第一周，我就似乎看到了假如我在这里工作以后，一年两年三年的日子。以至于实习结束的时候，我没有丝毫的充实感。跟导师发出道别消息的那一刹那，我甚至没有一丝的眷念。接下来，回家，收拾行李，买回学校的车票，一切在欣欣然之中。</p>\n<p>是过于言重了吗？可我就如把一件难缠的事情磕磕碰碰磨平了一般解脱了！心情线在实习开始的顶点一路缓缓跌下，然后结束实习，又直入云霄了：）。就如鸡汤常说的，很多事情，只有经历了才知道。对，我经历了某为的实习之后，再也不想回去了！</p>\n<p>前段时间入职之前，我依然有些许的担忧——是不是还像去年那样，氛围、人情味毫无，如果那样，我该怎么办啊！事实证明，我多虑了：）。最近刚好在组内有幸参加了六月的回顾会，”老老大“让每一位员工说说自己这一个月的时间的心情变化。作为新人，当然没有处理项目的复杂心情，也只能谈一谈如之前后的一些所以想：</p>\n<p>去年在别处的实习与这段是时间的入职感受截然不同。这里的工作氛围、人与人之间的交互，让我感到十分的舒适。同样，只要是我需要接触的技术，在入门以及较为深入的学习之后，总能够给予我足够的兴趣与信心。因为好多都不懂，所以好多都想要学习。于是继续学习，继续总结心得，进而激发了更多的兴趣。如此良性的循环 + 工作环境氛围 =&gt; 继续以一个乐观的心态去面对工作中的一切。其实这种类似的话也曾在许多鸡汤中见过，那时还觉得不过尔尔，可是当我真正去体会的时候，”在听已是曲中人“，：）。</p>\n<h5 id=\"为什么会这样\"><a href=\"#为什么会这样\" class=\"headerlink\" title=\"为什么会这样\"></a>为什么会这样</h5><p>我也不知道什么时候，我的心态就变得如此乐观。但一次与高中挚友的交谈，我们大概得出了一个为什么的结论：因为家人的支持。我感激于我的家人在背后给予了我莫大的帮助，无论精神上还是物质上。对于精神层面，他们总是希望我能够在无论是生活还是工作上都学到东西，希望我能够关注过程带来的收获，而不仅仅看结果；而从物质上来说，他们无私的为我创造条件，让我不要花过多的时间来关注物质方面的需求，从而能全身心的投入到工作学习中。这两方面其实是相互结合的。说了好多大话，可这就是我最真切的感受。：）。</p>\n<h4 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h4><p>未来会是怎样呢？</p>\n<p>当我们受制于生活的”苦难“</p>\n<p>是不满命运的挣脱</p>\n<p>还是”哪里跌倒哪里趴着“的苟且</p>\n<p>当我们总是沉迷于表象安逸</p>\n<p>是当一位睁着眼睛的瞎子</p>\n<p>还是做一名不停反思的Thinker</p>\n<p>当我们发现经常无所事事</p>\n<p>是走一步看一步的慵懒</p>\n<p>还是勇敢迈出第一步去充实自己</p>\n<p>我会告诫自己：Keep Real, Keep 3</p>\n<hr>\n<h5 id=\"符号说明：）\"><a href=\"#符号说明：）\" class=\"headerlink\" title=\"符号说明：）\"></a>符号说明：）</h5><p><strong>：）</strong>：嘻嘻</p>\n<p><strong>+</strong>：结合</p>\n<p><strong>=&gt;</strong>：促使</p>\n<p><strong>3</strong>：011</p>\n","categories":[],"tags":["think"]},{"title":"Spring配置文件结构对于生成Bean的影响","url":"http://compilemind.com/2018/07/02/2018-07-02-Spring配置文件结构对于生成Bean的影响/","content":"<p>由于前段时间忙于毕设，导致Spring学习的东西忘了很多，所以最近又开始从头看Spring的基础。基础的Bean的装配不再多说了。这一次，主要是深入一点了解Spring配置文件结构搭配对于Bean装配的影响。</p>\n<a id=\"more\"></a>\n<p>首先，我们设定一个简单的场景：播放器播放歌曲。所以基于此，我们定义两个接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo;</span><br><span class=\"line\"><span class=\"comment\">// CD接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CompactDisc</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo;</span><br><span class=\"line\"><span class=\"comment\">// 媒体播放器接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MediaPlayer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>按照是实际来讲，我们定义一个BlankDisc，空白的唱片，其包含三个属性：title、artist和tracks，分别代表了唱片的标题、歌手以及歌曲目录：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.cd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.CompactDisc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlankDisc</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String artist;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; tracks; <span class=\"comment\">// 简化结构，只存放歌曲目录名称并保存为List</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BlankDisc</span><span class=\"params\">(String title, String artist, List&lt;String&gt; tracks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.artist = artist;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tracks = tracks;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Playing &quot;</span> + title + <span class=\"string\">&quot; \\n\\tby &quot;</span> + artist);</span><br><span class=\"line\">        tracks.stream().forEach(t -&gt; System.out.println(<span class=\"string\">&quot; \\t&gt;&gt;&gt; &quot;</span> + t));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>同样的，实现MediaPlayer接口，定义实际的唱片播放器，能够持有cd的引用，同时，这里我们并没有通过构造器来定义，原因是唱片播放器并非一定放有cd（当然代码没有对null进行约束，这是不好的，实际编写请勿这样编写）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.player;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.CompactDisc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.MediaPlayer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayer</span> <span class=\"keyword\">implements</span> <span class=\"title\">MediaPlayer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CompactDisc cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCd</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cd = cd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CDPlayer 开始播放: &quot;</span>);</span><br><span class=\"line\">        cd.play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下来，要说明的是，Spring支持xml与Java文件同时存在的配置方式，这里我们也会这么做，尽可能的复杂化配置依赖，因为本片文章就是探讨各种配置文件交叉依赖的情形，并理清依赖的思路。</p>\n<p>首先我们将CD类Bean与CDPlayer类Bean分离开来。</p>\n<h4 id=\"首先是CD类Bean\"><a href=\"#首先是CD类Bean\" class=\"headerlink\" title=\"首先是CD类Bean\"></a>首先是CD类Bean</h4><h5 id=\"Java类型配置文件\"><a href=\"#Java类型配置文件\" class=\"headerlink\" title=\"Java类型配置文件\"></a>Java类型配置文件</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.cd.BlankDisc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BlankDisc <span class=\"title\">yeHuiMei</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; tracks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        tracks.add(<span class=\"string\">&quot;以父之名&quot;</span>);</span><br><span class=\"line\">        tracks.add(<span class=\"string\">&quot;懦夫&quot;</span>);</span><br><span class=\"line\">        tracks.add(<span class=\"string\">&quot;晴天&quot;</span>);</span><br><span class=\"line\">        tracks.add(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlankDisc(<span class=\"string\">&quot;YeHuiMei&quot;</span>, <span class=\"string\">&quot;JayChou&quot;</span>, tracks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个配置文件中，只定义了一个Bean，Bean id名称为yeHuiMei（方法名），同时也将相关的属性设置完毕。</p>\n<h5 id=\"xml类型配置文件\"><a href=\"#xml类型配置文件\" class=\"headerlink\" title=\"xml类型配置文件\"></a>xml类型配置文件</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;onTheRun&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">class</span>=<span class=\"string\">&quot;demo.cd.BlankDisc&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;title&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;On The Run&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;artist&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;JayChou&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;tracks&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>牛仔很忙<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>彩虹<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>青花瓷<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在这个xml配置文件中，我定义了一个名为onTheRun的Bean，同时也设置了对应的属性。</p>\n<h4 id=\"CDPlayer的Bean\"><a href=\"#CDPlayer的Bean\" class=\"headerlink\" title=\"CDPlayer的Bean\"></a>CDPlayer的Bean</h4><h5 id=\"Java类型配置文件-1\"><a href=\"#Java类型配置文件-1\" class=\"headerlink\" title=\"Java类型配置文件\"></a>Java类型配置文件</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayerInJava</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;onTheRun&quot;)</span> CompactDisc cd)</span> </span>&#123;</span><br><span class=\"line\">        CDPlayer cdPlayer = <span class=\"keyword\">new</span> CDPlayer();</span><br><span class=\"line\">        cdPlayer.setCd(cd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cdPlayer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"xml类型配置文件-1\"><a href=\"#xml类型配置文件-1\" class=\"headerlink\" title=\"xml类型配置文件\"></a>xml类型配置文件</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cdPlayerInXML&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;demo.player.CDPlayer&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cd&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;yeHuiMei&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>目前配置文件搞定了，并且我们现在的配置以来结构如下：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/dependency.png\" alt=\"dependency\"></p>\n<p>当然，目前还是有一定的问题的，因为很显然，我们的配置文件都独立与彼此。尽管在CDPlayer中的配置文件通过相关的语法制定了CD Bean的选择（@Qualifier和ref），但是我们可以看到文件本身并没有明确的引入另外的配置文件，所以在IDEA中通常会有这样的提示：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/norefinjava.png\" alt=\"norefinjava\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/norefinxml.png\" alt=\"norefinxml\"><br>同时打开，IDEA的项目结构Project Structs（win默认ctrl+shift+alt+s），点击左侧的Modules，可以看到Spring项目上右下角IDEA提示我们“Unmapped Spring configuration files”并列举除了上述的四个文件。</p>\n<p>我们点击上面的+将所有的配置文件追踪上，刚刚所有的索引问题都OK了。此时，我们任意找到一个xml文件，可以看到左上方有一个小标志，点击并选择第一个：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/clickdpdiagram.png\" alt=\"clickdpdiagram\"><br>打开之后就能够看到整个项目对于配置文件的依赖：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/dpdiagram.png\" alt=\"dpdiagram\"><br>可以看到我们的项目（springdemo）具有一个是上下文应用模块，这个应用上下文包含了四份配置文件。但一定要注意，在后续我们加载配置文件的时候，必须要将有依赖关系的配置文件全部加载进来才能够读取到对应的Bean。这里我们进行一个简单的测试：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"comment\">// 设置所要加载的配置文件</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &#123;&quot;classpath:cdconfig.xml&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;onTheRun&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CompactDisc cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cdShouldNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cd.play();</span><br><span class=\"line\">        assertNotNull(cd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这个测试是可以直接通过的，因为这里我们加载的是cdconfig.xml配置文件，里面我们定义了名为onTheRun的Bean，所以打印还有非空测试也通过：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/cdxmltest.png\" alt=\"cdxmltest\"><br>然而接下来我们更换配置文件为cdplayerconfig.xml，相关注入如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &#123;&quot;classpath:cdplayerconfig.xml&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;cdPlayerInXML&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MediaPlayer mp;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mediaPlayerNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(mp);</span><br><span class=\"line\">        mp.play();</span><br><span class=\"line\">        assertNotNull(mp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这里我们指定注入的就是xml中的CDPlayer Bean，然而，并不能通过测试，在错误提示中，我们可以找到这样一行：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cannot resolve reference to bean <span class=\"string\">&#x27;yeHuiMei&#x27;</span> <span class=\"keyword\">while</span> setting bean property <span class=\"string\">&#x27;cd&#x27;</span>; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named <span class=\"string\">&#x27;yeHuiMei&#x27;</span> is defined</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:<span class=\"number\">328</span>)</span><br></pre></td></tr></table></figure><br>前面我们知道，cdPlayerInXML这个bean中我们还注入了Java配置文件下的名为yeHuiMei Bean，而在测试的过程中，我们只加载了cdplayerconfig.xml这个配置文件。所以实际上除了这个配置文件意外的其他bean都没有被Spring生成并放入Bean容器中。</p>\n<p>也许会有疑问，在上面的Bean依赖图中，我们看到所有的配置文件都有已经被放入到了Spring Application Context中，为什么不被自动加载呢？道理很简单，这只是IDE的辅助而已。IDEA中的那个部分只是IDEA自身的一些辅助功能比如静态检查，所以需要我们手动的将这些文件给添加进去。当我们还是移除掉刚刚的结构之后，进行第一次的只对没有依赖的CDBean进行测试依然有效。</p>\n<p>一定要明确，Spring的注入是发生在代码中的！不要被IDE遮蔽了双眼！这里何时会被注入呢？当我们配置了Spring的配置文件并将其加载进来了，当Spring遇到@Autowired等注入注解的时候，就会为我们注入Bean。</p>\n<p>通常，当我们有多个配置文件的是，最优的结构思路是将多个配置文件导入到一个专门的独立的配置文件中，就像下面这样，我将开始的四个配置文件全部导入到一个名为AllConfig的Java配置文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;CDConfig.class, CDPlayerConfig.class&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">// 一定要注意！！！classpath:后面一定不要带空格！否则会被识别为【[空格]cdconfig.xml】这样的文件名而不被找到，血的教训。</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource(&#123;&quot;classpath:cdconfig.xml&quot;, &quot;classpath:cdplayerconfig.xml&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后在测试文件中我们将加载配置文件为Java配置文件AllConfig，此时，所有的以来问题全部解决：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = &#123;AllConfig.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;onTheRun&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CompactDisc cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cdShouldNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cd.play();</span><br><span class=\"line\">        assertNotNull(cd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;cdPlayerInXML&quot;)</span><span class=\"comment\">// 一开始由于配置文件没有引入全导致注入失败</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MediaPlayer mp;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mediaPlayerNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(mp);</span><br><span class=\"line\">        mp.play();</span><br><span class=\"line\">        assertNotNull(mp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-07-02-Spring/passed.png\" alt=\"passed\"></p>\n","categories":[],"tags":["Spring","Bean"]},{"title":"毕业所想","url":"http://compilemind.com/2018/06/17/2018-06-17-毕业所想/","content":"<p>距离上一次博文过了接近一个月了，这期间毕设虽忙，但不至于忙到连博文都写不了的地步。早就在寻思着什么时候更一篇文章，但是就是懒，好像每天忙完毕设的事情之后，就感觉自己今天做完一件事，就可以休息了，就可以放纵自己了。其实不过都是借口罢了。趁着这个时间，写写东西，回顾一下写过的东西，觉得写的东西还是太分散了，或者说，目前为止都没有一个明确的写作目标，这里也表明一下，顺便也为今后的写作约束一下自己。</p>\n<a id=\"more\"></a>\n<h4 id=\"我的博客到底要有些什么？\"><a href=\"#我的博客到底要有些什么？\" class=\"headerlink\" title=\"我的博客到底要有些什么？\"></a>我的博客到底要有些什么？</h4><p>这段时间看Effective Java，看Scala，做做练习，其实一直都是有心得体会的，不过都只是一些小的点，没有像之前的一些博文心得，有宏观的大的系统知识结构，特别是Effective Java，本身就是对于Java的各个方面来总结的，更是说不上宏大了。于是，对于通过博文来总结这些心得体会，如果硬要写出一篇来，总感觉到时候会纯粹地拼凑。我不想我的博文到头来<strong>纯粹</strong>成为一些Tips的合集（以前写的Linux命令就有这种嫌疑）。过了这么久了，我希望我的博文能够提升一下水平，加入更多的自己的元素在其中，当然，Tips类型的还是会有的，因为我坚持一个观点：<strong>当你需要花一定的时间反复琢磨、寻找解决问题的方法的时候，就是你需要记录的时候。</strong>所以，当我花费了一定的时间去配置某些东西的时候，我就会写一篇博文来进行记录，一来是训练自己的写作表述能力（虽然找资源，装环境这种博文提升不了太多的写作能力），二来是保持写作的心态。此外，我虽然是一位普通的程序员，但是心里还是有文学写作的心的。回忆起初中时期，就写过一本诗集，很可惜未保存好而遗失了。所以，我的博文同样会有一些偏向于更为文学的东西存在，譬如诗、杂记等，希望能够纪念且告诫自己不要因为成为一名程序员而遗失对于生活，对于人生的思考与感悟。</p>\n<p>综上（好生刻板的文字），我的博文会<strong>尽量</strong>控制70%是包含有自己见解的技术类博文，20%时日常开发过程中的配置记录等相关的文章，剩下的10%则是更为文学的文章。</p>\n<h4 id=\"再谈毕业所感所想\"><a href=\"#再谈毕业所感所想\" class=\"headerlink\" title=\"再谈毕业所感所想\"></a>再谈毕业所感所想</h4><p>这一天总归是要到来的。14年的盛夏来到了大学，是平淡的，是卑微的。还记得初到校园时候的迷茫，拿着预存有200快的校园卡，跑到教育超市买了一堆东西，发现超支了，尴尬的找附近的一位他同样是新生的女同学借了饭卡代刷。面容早已忘记了，但相比此时此刻，她也在忙于离校的琐事吧。这段时间老是和杨同学聊天，这四年到底怎么过来的，怎么一晃眼就要毕业了，最后嬉笑着打住了话题。</p>\n<p>是啊，怎么过来的呢？能够回想起这四年的点点滴滴，但也觉得太快了一点。大一的军训，大一的晚自习，大一对自己写的信；大二的上课的回答，大二时候的起早贪黑的学习；大三的课设，大三的比赛；大四的实习，大四的毕设（right now），一切都是历历在目。是因为大学的生活不像高中那样的三点一线，这些事情就变“稀薄”了吗？还是因为我们的心在成长，面对未来有了更多的从容不迫了吗？说不出来，大一到大四就这么过来了，这四年，这八个学期就这么过来了。有时候时间的改变，就这么过来了，就好像两个人相互的日久生情的喜欢，就这么过来了。</p>\n<p>有那么一瞬间，我还有点羡慕就在学校所在省的同学们。这毕业一别之后，他们再见的概率超过50%，就算没有，也能创造见面的机会，毕竟如今发达的交通让他们能再短时间相见。而我就不一样了，家乡距此超过两千公里，见面是多么的不容易。也许这一别，同一个宿舍的也许还能因为某些重大的事情而见面，不是同一个宿舍的，就是永远的不再相见了。想来也是神奇，有这样一群人，你和他曾有过四年的交集，这一别之后，就再无交集了。</p>\n<p>大学的生活对于绝大多数的人来说就是一两个宿舍的小圈子。我们往往在这一个小圈子中自由的生活着，交流着。于是，临近惜别之时，就会有一些人没能参与到班级的聚会中，想来挺替他们感到遗憾的，但也能理解。大学的同学之间的交情往往还不到初高中的一半，凝聚力自然也没有初高中那么强。想起初中写过辣鸡电影剧本，“担任”导演一职，一大波同学饶有兴致地参与扮演、拍摄（我可能对电影制作有什么误解，哈哈）。但至少还是有一群可爱地大学同学们啊！不过对于我来说，也许是要永别了。</p>\n<p>作为一名即将毕业成为程序员的我，当然经常看到别说程序员怎么怎么呆板，怎么怎么冰冷。我想要做的就是成为一名积极的程序员，成为一名通俗一点来讲，“多才多艺”的程序员。所以，我始终会坚持锻炼，始终会尝试不同于一般程序员所干的事情，譬如文学方面的写作、声乐的学习。我想要成为一名乐观主义者，而不是一名单纯的极客。这始终是我的理想。我想我能够带给人们的无限的可能，这样也许说的太宏观了，太雄伟了。具体一点，我希望我的家人，我的另一半能够看到丰富多彩的我，而不是众口中的“普通”程序员。我希望，我是一个理想的，有思考的，有<strong>活力</strong>的，爱生活的人！今后的博文，我也许会介绍我曾经触碰过的很多东西，虽然有一点“不务正业”。</p>\n<p>拒绝无病呻吟。我对于别人的无病呻吟虽谈不上鄙夷，但至少总是会不去理会他们，当一个“瞎子”忽视就好。一谈到写文章，就往往会和这些东西或多或少有些联系。所以我也时常告诫自己，不要带上这样的情绪。带上这些情绪，我们往往会“迷失”自己，进而形成一种“自我感动”的情形。还是那句话，我是一个乐观实用主义者，不要因为琐事而丧失自己的前进的心态。面对任何困难，不要无病呻吟，动手去做，去处理，不要等到一切都逼近的时候才后知后觉，才忙碌，才一阵匆忙之后，说出无病呻吟的话语，这样真的只是“感动自己”。</p>\n<h4 id=\"毕\"><a href=\"#毕\" class=\"headerlink\" title=\"毕\"></a>毕</h4><p>仲夏将至，夜不能寐。其由唯二，一来夏蚊成雷，挥之不去，甚是烦恼；二来完业临近，欲与学业惜别，些许惆怅。遂起身信步于闲庭之中，观夜中明星，忆四载春秋，不禁感慨万千。吾已二十有二，求学多年，虽无当今能人之卓越，也不失一心向前之意志。<br>人生漫漫，从未停息。</p>\n","categories":[],"tags":["Graduation"]},{"title":"Java枚举细节","url":"http://compilemind.com/2018/05/18/2018-05-18-Java枚举细节/","content":"<a id=\"more\"></a>\n<h4 id=\"枚举的简单使用\"><a href=\"#枚举的简单使用\" class=\"headerlink\" title=\"枚举的简单使用\"></a>枚举的简单使用</h4><p>在java中，我们可以使用enum关键字来定义枚举：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED, GREEN, BLUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>就像上面一样，我们定义了一个名为Color的枚举类，包含了RED、GREEN、BLUE三个常量。当我们使用枚举类的时候，直接通过枚举类名.枚举常量即可。就像如下的形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(Color c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (c) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RED: System.out.println(<span class=\"string\">&quot;It&#x27;s RED&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> GREEN: System.out.println(<span class=\"string\">&quot;It&#x27;s GREEN&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: System.out.println(<span class=\"string\">&quot;It&#x27;s BLUE&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">f(Color.RED);</span><br><span class=\"line\"><span class=\"comment\">// 输出 &quot;It&#x27;s RED&quot;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"枚举的本质\"><a href=\"#枚举的本质\" class=\"headerlink\" title=\"枚举的本质\"></a>枚举的本质</h4><p>虽然Java提供枚举类的定义，但是实际上他并不是Java中一个新的对象类型，我们通过对Color枚举类进行反编译，得到如下的反编译结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ javap Color.class </span><br><span class=\"line\"><span class=\"comment\">// 反编译结果</span></span><br><span class=\"line\">Compiled from <span class=\"string\">&quot;Color.java&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnumerationAndAnnotation</span>.<span class=\"title\">Color</span> <span class=\"keyword\">extends</span> <span class=\"title\">java</span>.<span class=\"title\">lang</span>.<span class=\"title\">Enum</span>&lt;<span class=\"title\">EnumerationAndAnnotation</span>.<span class=\"title\">Color</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EnumerationAndAnnotation.Color RED;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EnumerationAndAnnotation.Color GREEN;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EnumerationAndAnnotation.Color BLUE;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> EnumerationAndAnnotation.Color[] values();</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> EnumerationAndAnnotation.<span class=\"function\">Color <span class=\"title\">valueOf</span><span class=\"params\">(java.lang.String)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到，枚举类实际上在编译的过程中，被编译器进行调整，它并不是一个新的类型，本质上依然是一个类（Color），这个类继承了java.lang.Enum<T>，而对于每一个枚举常量，实际上是public static final修饰的枚举类的静态实例对象。</p>\n<p>同时注意，编译器会为我们添加两个新的static方法：values() 和 valueOf(java.lang.String)，其实分别作用是返回枚举类中定义的所有的枚举常量，以及根据枚举名来获取枚举常量（注意，这里就是定义枚举常量的枚举名）。</p>\n<p>当然，由于每一个枚举常量实际上是实现了java.lang.Enum<T>的枚举类的一个静态实例对象，而这个过程是编译器为我们进行的，所以，自然，我们可以在枚举类中定义任何的方法、变量，以及构造函数的定义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED(<span class=\"string\">&quot;RED&quot;</span>), GREEN(<span class=\"string\">&quot;GREEN&quot;</span>), BLUE(<span class=\"string\">&quot;BLUE&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 定义类中的实例变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String colorName;</span><br><span class=\"line\">    <span class=\"comment\">// 定义构造函数，注意上面的枚举常量必须满足这种构造方式</span></span><br><span class=\"line\">    Color(String colorName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.colorName = colorName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义实例对象的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printColorName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Color name is &quot;</span> + colorName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 重写toString方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> colorName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>自然，我们可以枚举常量当作一个枚举的实例化对象，调用枚举类中的方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(Color.RED); <span class=\"comment\">// RED</span></span><br><span class=\"line\">    Color.RED.printColorName();\t<span class=\"comment\">// Color name is RED</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"为什么枚举构造器不能访问枚举的静态域\"><a href=\"#为什么枚举构造器不能访问枚举的静态域\" class=\"headerlink\" title=\"为什么枚举构造器不能访问枚举的静态域\"></a>为什么枚举构造器不能访问枚举的静态域</h4><p>查看下面这段代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED, GREEN, BLUE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Color() &#123;</span><br><span class=\"line\">        System.out.println(value); <span class=\"comment\">// 编译错误！构造器无法访问静态变量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到这里编译不通过，提示我们<strong>枚举构造器</strong>不能够访问枚举的静态域（以及静态变量）。我们知道，一般的类中，静态域以及静态变量是优于实例对象的变量、方法的初始化的。这里简要复习一下类中变量的加载机制：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 辅助静态变量的初始化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Init</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Init</span><span class=\"params\">(String init)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Init()&quot;</span> + init);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fa</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 父类静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Init initFa = <span class=\"keyword\">new</span> Init(<span class=\"string\">&quot;Fa&#x27;s static&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 父类实例变量</span></span><br><span class=\"line\">    Init initFa2 = <span class=\"keyword\">new</span> Init(<span class=\"string\">&quot;Fa&#x27;s no static&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 父类静态域</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Fa&#x27;s static&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 父类构造方法</span></span><br><span class=\"line\">    Fa() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Fa()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Su</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fa</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 子类静态域</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Su&#x27;s static&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 子类静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Init initSu = <span class=\"keyword\">new</span> Init(<span class=\"string\">&quot;Su&#x27;s static&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 子类实例变量</span></span><br><span class=\"line\">    Init initSu2 = <span class=\"keyword\">new</span> Init(<span class=\"string\">&quot;Su&#x27;s no static&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\">    Su() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Su()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下来，我们new出Su实例对象，并观察输出结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Su();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 输出</span></span><br><span class=\"line\"><span class=\"comment\">Init()Fa&#x27;s static \t// 1</span></span><br><span class=\"line\"><span class=\"comment\">Fa&#x27;s static\t\t\t// 2</span></span><br><span class=\"line\"><span class=\"comment\">Su&#x27;s static\t\t\t// 3</span></span><br><span class=\"line\"><span class=\"comment\">Init()Su&#x27;s static\t// 4</span></span><br><span class=\"line\"><span class=\"comment\">Init()Fa&#x27;s no static// 5</span></span><br><span class=\"line\"><span class=\"comment\">Fa()\t\t\t\t// 6</span></span><br><span class=\"line\"><span class=\"comment\">Init()Su&#x27;s no static// 7</span></span><br><span class=\"line\"><span class=\"comment\">Su()\t\t\t\t// 8</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure><br>我们可以看到，有static修饰的始终优于实例对象的相关的初始化的，在输出中 1 - 4 是static修饰部分，5 - 8是实例域部分。此外，在继承情形下，父类由于子，输出中 1- 2 是父类static域的初始化，3 - 4 是子类static域的初始化。在static域加载完成之后，才开始加载父类非static域，最后加载子类的非static域。注意，都为static修饰的情况下，加载顺序根绝定义时候的顺序而来，1、2与3、4就可以看出。</p>\n<p>看到这里，也许会有点疑问，既然静态域加载优于实例域（包含构造函数），那为什么在枚举类中就不行呢？让我们回到前面对枚举类的反编译，其实答案就出来了。反编译的过程我们可以看到，我们的枚举常量实际上是我们枚举类的静态实例化对象，在编译器的修改下，我们运行加载枚举类的过程中，枚举常量是static修饰的，其他静态域也是static修饰的，枚举常量又排在其他静态域的前面，按照上面的额初始化顺序，首先就会调用构造器实例化枚举常量对象，此时，枚举类中的其他静态域都还没来得及初始化，自然在构造函数中不能访问静态域了。有人可能想说，那我静态域放到枚举常量前面，让他先加载怎么样？很遗憾，Java不允许这样做：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123; <span class=\"comment\">// 编译不通过！！！</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</span><br><span class=\"line\">    RED, GREEN, BLUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用抽象函数为枚举统一方法\"><a href=\"#使用抽象函数为枚举统一方法\" class=\"headerlink\" title=\"使用抽象函数为枚举统一方法\"></a>使用抽象函数为枚举统一方法</h4><p>上面的内容探讨了枚举类的一些基础，这里提一些关于使用枚举的代码策略设计。<br>有的时候，我们想要给枚举常量定义某一些通用的方法，同时，针对不同的枚举，该通用方法呈现不同的具体内容。例如，我现在有一个如下的Color枚举类，当针对不同的Color常量的时候，能有一个方式给我返回该颜色的十六进制颜色码。也许你会如下来实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED, GREEN, BLUE;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> RED:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;#FF0000&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> GREEN:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;#00FF00&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;#0000FF&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>以上的方式较为简洁与易读，但是存在问题：枚举常量越来越多，case会不断增长，如果编写代码的过程由于不注意，增加颜色常量的时候，忘记了增加对应的case，那么编译是不会有任何的问题的，但是却隐含的将增加的颜色常量也返回的是BLUE的十六进制颜色码。</p>\n<p>鉴于上述的问题，我们需要某种方式来防止我们犯错，能够想到的，就是通过编译器来告诉我们。于是，我们在枚举类中定一个抽象方法getHexCode，于是乎，对于每一个枚举常量，编译器会提示我们实现具体实例的getHexCode：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;#FF0000&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, GREEN &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;#00FF00&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, BLUE &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;#0000FF&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> String <span class=\"title\">getHexCode</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在这样的定义下，代码牺牲了一定的简洁性，但是易读性丝毫不输于最开始的方式。针对Color枚举类，我们定义了抽象方法，表明了对于Color中的每一个枚举常量，都应该有getHexCode方法，返回自己的十六进制颜色码。如果我们新添加了枚举常量，而没有实现该方法，编译器会报错警告我们。</p>\n","categories":[],"tags":["Java","Enumeration"]},{"title":"Java泛型中的细节","url":"http://compilemind.com/2018/05/03/2018-05-03-Java泛型中的细节/","content":"<h3 id=\"如果没有泛型\"><a href=\"#如果没有泛型\" class=\"headerlink\" title=\"如果没有泛型\"></a>如果没有泛型</h3><p>学习Java，必不可少的一个过程就是需要掌握泛型。泛型起源于JDK1.5，为什么我们要使用泛型呢？泛型可以使编译器知道一个对象的限定类型是什么，这样编译器就可以在一个高的程度上验证这个类型消除了强制类型转换，使得代码可读性好，而这个过程是发生在编译时期的，即在编译时期发现代码中类型转换的错误所在，及时发现，而不必等到运行时期抛出运行时期的类型转换异常。</p>\n<a id=\"more\"></a>\n<p>泛型主要运用在譬如Java中的容器API等需要对多个对象进行管理的部分。</p>\n<p>早期（不支持泛型的时期）的Java代码，我们在使用容器的时候，需要在类型转换前手动的进行类型转换验证工作来防止异常。假设目前我们定义了一个Apple类，含有一个pare（削皮）方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Apple is pared&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下里，我们定义了一个方法void pareAll(List apples);传入包含有多个Apple实例的List，并逐一对每一个Apple进行pare操作：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">pareAll</span><span class=\"params\">(List apples)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object a : apples) &#123;</span><br><span class=\"line\">            Apple aa = (Apple)a;</span><br><span class=\"line\">            aa.pare();</span><br><span class=\"line\">            <span class=\"comment\">// 为了清晰认识出错的地方，我没有采用下面的代码</span></span><br><span class=\"line\">            <span class=\"comment\">// ((Apple)a).pare();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List apples = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">        apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">        pareAll(apples);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>首先明确一点，List、Set、Map等早期只能默认其实是Object类型的集合，即由于类型转换，像上面的List能够存放Object及其子类的对象，所以你当然可以添加多个Apple对象实例（上转型）。而在pareAll方法体中，由于我们刚刚说过，List存放的是上转型后的Object类型的对象，所以当我们获取List的对象的时候，自然只能拿到Object类型的对象，之后需要我们手动的进行下转型：((Apple)a).pare()。这段代码我们运行一下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Apple is pared</span><br><span class=\"line\">Apple is pared</span><br></pre></td></tr></table></figure><br>似乎没有问题，然而，由于容器能够接受的是Object对象，所以，我们再定一个譬如Banana类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Banana</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Banana is pared&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后将这个类也添加List中去，由于上转型，这里完全没有编译的错误：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List apples = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">apples.add(<span class=\"keyword\">new</span> Banana()); <span class=\"comment\">// 编译通过！</span></span><br><span class=\"line\">pareAll(apples);</span><br></pre></td></tr></table></figure><br>然而在运行的时候，去出现了错误：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Apple is pared</span><br><span class=\"line\">Apple is pared</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.ClassCastException: Banana cannot be cast to Apple</span><br><span class=\"line\"><span class=\"comment\">// 编译器告诉我们 Apple aa = (Apple)a;这里一段代码出错了</span></span><br></pre></td></tr></table></figure><br>首先，将List中的所有Object对象转换为Apple对象的时候，并没有出错，同时还正确输出了。但是，我们上面曾添加过Banana对象，在进行转换的过程中，却发生了类型转化的运行时异常。怎样解决这个问题？我们可以使用instanceof关键字，这个关键字可以判断一个对象是否是某一个类的实例化，所以我们修改pareAll方法，添加上实例判断：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果对象是Apple类的实例化，才进行转换</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (a <span class=\"keyword\">instanceof</span> Apple) &#123;</span><br><span class=\"line\">    ((Apple)a).pare();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>既然用这种方式就可以解决类型转换异常，那么为什么还要有泛型呢？首先，有了泛型进行麻烦的类型判断了；其次，通过编译器的支持，当我们使用泛型的时候，编译器会在编译时期就为我们解决好类型的问题，这样一来，可以保证，在运行时期，肯定不会因为类型转换出现异常。</p>\n<h3 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h3><p>JDK1.5给我们带来了泛型，当我们使用容器类的时候，自然更加推荐使用带有泛型的容器类，那么为什么那些不具备泛型的容器类还存在呢？因为早期还有很多遗留代，为了考虑兼容问题，所以才需要保留它们。</p>\n<p>说了这么多，我们来看如何在刚刚的情境中，使用泛型来为我们带来便利与类型安全：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用泛型</span></span><br><span class=\"line\">    List&lt;Apple&gt; apples = <span class=\"keyword\">new</span> ArrayList&lt;Apple&gt;();</span><br><span class=\"line\">    apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">    apples.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">    apples.add(<span class=\"keyword\">new</span> Banana()); <span class=\"comment\">// 这一句话就会出现编译错误</span></span><br><span class=\"line\">    pareAll(apples);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在Java中，在jdk自带的容器类加上尖括号&lt;&gt;，里面加上我们要明确的类名即可。而在pareAll方法，我们首先修改形参为List\\<Apple> apples，这样一来明确告诉编译器，我传入的是只能装Apple类型对象的List，如此一来，类型的判断就可以不用出现了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">pareAll</span><span class=\"params\">(List&lt;Apple&gt; apples)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先形参改变了，其次for中的类型发生了变化，注意与原来的区分和理解</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Apple a : apples) &#123;</span><br><span class=\"line\">        a.pare();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义泛型类\"><a href=\"#定义泛型类\" class=\"headerlink\" title=\"定义泛型类\"></a>定义泛型类</h4><h5 id=\"定义一般的泛型类\"><a href=\"#定义一般的泛型类\" class=\"headerlink\" title=\"定义一般的泛型类\"></a>定义一般的泛型类</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gen</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T x;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Gen</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就像我们在使用泛型容器一样，在类的后面加上尖括号，并且使用一个合法定义符号，表明Gen是一个泛型类，对于T来说，到底是什么类型，目前还不知道，只有当我需要使用的时候才确定的下来：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：jdk1.7之后类型推断的加入，使得我们可以省略后面的类型定义</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里我明确定义Gen的类型是String</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以当我想要传入一个int类型的数字时，编译会不通过</span></span><br><span class=\"line\">    Gen&lt;String&gt; x = <span class=\"keyword\">new</span> Gen&lt;&gt;(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Gen&lt;String&gt; x = new Gen&lt;&gt;(2); 编译不通过</span></span><br><span class=\"line\">    x.print(); <span class=\"comment\">// 输出“hello”</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"定义有边界的泛型类\"><a href=\"#定义有边界的泛型类\" class=\"headerlink\" title=\"定义有边界的泛型类\"></a>定义有边界的泛型类</h5><p>有的时候，即使是我们想要定义一个泛型的类，但并不意味着我们就想要任何一个类型都可以作为我们想要定义的泛型类的参数，这个时候怎么办？这就需要我们定义起边界，即这个泛型类能容许你能够定义具体的什么类型。首先我们定义三个基础的类：分别为Father、Son、MrWang。Father类是Sun超类，MrWang类与这两个类无关：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MrWang</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>接下来我们定义具有边界的泛型类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法为&lt;泛型符号 extends 已存在类型&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gen</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span>&gt; </span>&#123;</span><br><span class=\"line\">    T x;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Gen</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>于是，我们在使用我们定义的泛型类的时候，就会有所限制了：我们只能定义类型为Father以及Father子类的泛型类，除此之外都不行。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Gen&lt;Son&gt; g1;</span><br><span class=\"line\">    Gen&lt;Father&gt; g2;</span><br><span class=\"line\">    Gen&lt;MrWang&gt; g3; <span class=\"comment\">// 编译出错！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"泛型类的本质\"><a href=\"#泛型类的本质\" class=\"headerlink\" title=\"泛型类的本质\"></a>泛型类的本质</h5><p>在上面我们提到了两种泛型，一种是原始泛型类（\\<T>），另一种是为了对泛型参数进行限制而使用的边界（\\<T extends BorderClass>）；我们通过相关的定义可以知道，泛型只在编译阶段起作用，他只对编译阶段进行类型的限制，从而实现类型安全。实际上，任何的泛型类到运行的时候，都会将其泛型类型<strong>擦除</strong>到边界。对于一般的泛型类来说，在运行阶段会擦除到Object类型为止；而进行限制的使用extends的泛型则会擦除到其边界为止。综合来说就是，一般泛型类与限制了边界的泛型类都可以统一为\\<T extends BorderClass>。只是前者的BorderClass就是Object（因为任何对象都继承自Object），而后者是特定的边界类。再具体一点：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先这里有一个Father类，其定义如下：</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fatherMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Father&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Son继承自Father类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 定义一个有边界的类以及一个没有边界的泛型类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HasBorder</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尽管是泛型T，但是由于制定了边界</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以我们可以确定知道运行时，其类型会擦除到Father类</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以x一定有fatherMethod方法</span></span><br><span class=\"line\">        x.fatherMethod();</span><br><span class=\"line\">        <span class=\"comment\">// 此外还有Object类中的譬如toString、hashCode等方法</span></span><br><span class=\"line\">        x.toString();</span><br><span class=\"line\">        x.hashCode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoBorder</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于没有指定泛型的边界，T在运行时会擦除到Object</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以只能看到Object中的一些方法</span></span><br><span class=\"line\">        x.toString();</span><br><span class=\"line\">        x.hashCode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义泛型方法\"><a href=\"#定义泛型方法\" class=\"headerlink\" title=\"定义泛型方法\"></a>定义泛型方法</h4><p>泛型方法的定义则是在方法的返回值前添加\\<T>来定义的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意&lt;K&gt;是紧跟返回类型的</span></span><br><span class=\"line\">[<span class=\"keyword\">public</span> | ...] [<span class=\"keyword\">static</span>] [<span class=\"keyword\">final</span>] [<span class=\"keyword\">synchronized</span>] &lt;K&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(K x)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回类型同样可以是泛型</span></span><br><span class=\"line\">[<span class=\"keyword\">public</span> | ...] [<span class=\"keyword\">static</span>] [<span class=\"keyword\">final</span>] [<span class=\"keyword\">synchronized</span>] &lt;K&gt; <span class=\"function\">K <span class=\"title\">f</span><span class=\"params\">(K x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>使用泛型方法的时候，我们可以在方法前来定义具体的类型来确定：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.&lt;Apple&gt;f(<span class=\"keyword\">new</span> Apple())</span><br><span class=\"line\"><span class=\"comment\">// 由于类型推到，当我们传入一个Apple对象的时候，Java会为我们自动推导其类型，所以可以省略：</span></span><br><span class=\"line\">obj.f(<span class=\"keyword\">new</span> Apple());</span><br></pre></td></tr></table></figure><br>但是请注意，在一个泛型类中再定义泛型方法，它们是没有联系的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gen</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T x;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Gen</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">f</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">g</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在上面的泛型类中，我们定义了两个方法：f、g，注意前者并没有在返回类型前添加<T>，后者有\\<T>，尽管这两个方法都使用了T这个泛型符号，但是，其含义截然不同。前者的T是跟随泛型类的T来确定的，而后者是根据具体方法来确定的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Gen&lt;Father&gt; gen = <span class=\"keyword\">new</span> Gen&lt;&gt;(<span class=\"keyword\">new</span> Father());</span><br><span class=\"line\">    <span class=\"comment\">// 泛型类中的方法</span></span><br><span class=\"line\">    gen.f(<span class=\"keyword\">new</span> Father());</span><br><span class=\"line\">    <span class=\"comment\">// 泛型方法</span></span><br><span class=\"line\">    gen.g(<span class=\"keyword\">new</span> MrWang());</span><br><span class=\"line\">    <span class=\"comment\">// 互不相关</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"关于-lt-gt-的一二\"><a href=\"#关于-lt-gt-的一二\" class=\"headerlink\" title=\"关于 &lt;?&gt; 的一二\"></a>关于 &lt;?&gt; 的一二</h3><p>\\&lt;?&gt;其实和\\<T>非常的类似，都表示一种不确定性，都是告诉编译器，我现在有一个泛型，但是这个东西的具体类型我不确定到底是什么。但是，它们还是有一定的区别的。首先说一个最基础的，\\&lt;?&gt;无界通配符是不能用做声明泛型类的或者是泛型方法的；而\\<T>可以，不再赘述。<strong>在理解&lt;?&gt;的时候，请暂时不要和\\<T>联系起来，这二者的使用没有必然的联系</strong>! 它们之外的差别这里使用一个情景：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f0</span><span class=\"params\">(List&lt;T&gt; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : lists) &#123;</span><br><span class=\"line\">            System.out.println(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object o = lists.size() &gt; <span class=\"number\">0</span> ? lists.get(<span class=\"number\">0</span>) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        lists.add((T) <span class=\"keyword\">new</span> Object());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(List&lt;?&gt; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : lists) &#123;</span><br><span class=\"line\">            System.out.println(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object o = lists.size() &gt; <span class=\"number\">0</span> ? lists.get(<span class=\"number\">0</span>) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        lists.add(<span class=\"keyword\">new</span> Object()); <span class=\"comment\">// 编译出错！！！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>首先上面的f0方法接收List<T>对象，而f1方法接收List&lt;?&gt;对象。首先我们来看共同点，我们看到两个方法均可以遍历其List中的对象并且上转型为Object类型，当然，这是完全没有问题的，无论你的list中存放的是什么对象，你再不确定，但你始终可以将其上转型为Object类型，因为一切类都继承自Object这个类。</p>\n<p>上面来两个方法的不同点在于，最后一句向lists中添加一个Object对象。首先看f0，这里将Object对象往lists中添加的时候，需要我们转型为T，这里没有问题，因为既然我们定义的这个方法已经告诉了编译器，我们传入的是一个某种类型T的List，自然，往里面的添加的对象必须要上转型为T，否则如果不进行转型，那么任何的类都往里面的添加岂不是违背了类型安全。也许你有些疑问：不是说在运行时候会擦出到边界（这里就是Object），那为什么我添加Object对象都需要类型转换呢？其实不管你添加什么类型的对象，都需要类型转换，其理由在我看来是这样：在使用的泛型<strong>定义</strong>的某些类功能，尤其是添加或获取容器类中的元素，如果在一开始往里面添加的时候类型转换就失败了，肯定可以确定一点，你往里面添加的类是不正确的！是不符合我到时候（真正在使用确定了泛型类型的容器的时候）想要添加的类型的。所以这里强制需要你进行转型，以在添加的时候就保证其类型的安全。</p>\n<p>看完f0，在看f1。f1中最后一句add一个Object对象的时候始终编译不通过，其原因就是&lt;?&gt;无界通配符只告诉编译器，我这里要使用一个带有泛型的List，但是其具体类型我不知道，也不想知道！所以为了保证你到时候使用的时候的多样性（你有可能会传入List\\<String>，也有可能会传入List\\<Integer>），这里我就不支持转型操作了，请你进行一些与类型无关的操作。</p>\n<h4 id=\"关于-lt-extends-SomeClass-gt-与-lt-super-SomeClass-gt-的一二\"><a href=\"#关于-lt-extends-SomeClass-gt-与-lt-super-SomeClass-gt-的一二\" class=\"headerlink\" title=\"关于 &lt;? extends SomeClass&gt; 与 &lt;? super SomeClass&gt; 的一二\"></a>关于 &lt;? extends SomeClass&gt; 与 &lt;? super SomeClass&gt; 的一二</h4><p>在上面实例中我们使用了&lt;?&gt;这样的无界通配符，但是它太宽泛了，甚至可以说它与List无差别。于是，我们需要一种限定方式，来限定我们的容器类的类型有一定的边界。我们首先定义是那个类从上到下依次继承：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Top</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mid</span> <span class=\"keyword\">extends</span> <span class=\"title\">Top</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Mid</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>接下来我们定义带有有界通配符的相关参数：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(List&lt;? extends Mid&gt; ls)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> Mid&gt; ls)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>这里解读一下：对于方法f来说，他接受一个List，但是这个List需要满足泛型？必须是extends于Mid，即定义了目标List的泛型的上界是Mid，就是说我们传入的泛型List的其类型必须是Mid的子类；而对于g方法来说，则是必须满足泛型？必须是super于Mid，即定义了其List的泛型的下界是Mid，即我们传入的List的泛型必须是Mid的超类，所有也就有了下面的编译中的细节：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">List&lt;Top&gt; topList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">List&lt;Mid&gt; midList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">List&lt;Bottom&gt; bottomList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">f(list); <span class=\"comment\">// 1、编译出错</span></span><br><span class=\"line\">f(topList); <span class=\"comment\">// 2、编译出错</span></span><br><span class=\"line\">f(midList); <span class=\"comment\">// 3、编译通过</span></span><br><span class=\"line\">f(bottomList); <span class=\"comment\">// 4、编译通过</span></span><br><span class=\"line\">g(list); <span class=\"comment\">// 5、编译通过</span></span><br><span class=\"line\">g(topList); <span class=\"comment\">// 6、编译通过</span></span><br><span class=\"line\">g(midList); <span class=\"comment\">// 7、编译通过</span></span><br><span class=\"line\">g(bottomList); <span class=\"comment\">// 8、编译出错</span></span><br></pre></td></tr></table></figure><br>1与2编译出错的原因很显然就是因为分别不满足 Object extends Mid 和 Top extends Mid；3与4通过编译的原因也就显而易见了（Mid本身是本身的子类）；5、6和7同样满足其对应的类型是Mid的超类（Mid本身也可以是本身的超类），故通过编译，而8中的Bottom不是Mid的超类，故不通过编译。</p>\n<h4 id=\"进阶-lt-extends-T-gt-与-lt-super-T-gt\"><a href=\"#进阶-lt-extends-T-gt-与-lt-super-T-gt\" class=\"headerlink\" title=\"进阶 &lt;? extends T&gt; 与 &lt;? super T&gt;\"></a>进阶 &lt;? extends T&gt; 与 &lt;? super T&gt;</h4><p>在上面的讨论中，我们都是用一个特定的类来限定了？的边界（上面就是Mid类），但是泛型同样适用于此，就像下面：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genF</span><span class=\"params\">(List&lt;? extends T&gt; ls)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genG</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt; ls)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>当我们指定了泛型的类型为特定的类型的时候，比如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericTest.&lt;Mid&gt;genF(midList);</span><br></pre></td></tr></table></figure><br>他其实等同于上面的3中的方法，因为就是直接将对应的泛型替换为具体的类。那么genF方法与genG方法究竟有什么区别呢？答案就是PECS原则。</p>\n<h4 id=\"PECS原则\"><a href=\"#PECS原则\" class=\"headerlink\" title=\"PECS原则\"></a>PECS原则</h4><p>什么是PECS？PECS指“Producer Extends，Consumer Super”。换句话说，如果参数化类型表示一个生产者，就使用&lt;? extends T&gt;；如果它表示一个消费者，就使用&lt;? super T&gt;。</p>\n<p>这里一定要明确一点，我们在使用这两种的时候，通常是在使用容器（绝大多数）；其次，生产者和消费者的概念是针对容器的。怎么理解呢？先用一段代码来表达这个场景：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genF</span><span class=\"params\">(List&lt;? extends T&gt; ls)</span> </span>&#123;</span><br><span class=\"line\">    T o = ls.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们先看PE（Producer Extends）部分，这里我们通过方法，可以知道，我们定义了一个genF方法，接收一个泛型List，其具体类型我们还不知道，但至少可以确定的是，它的上界是T，也就是说，我传入的List中的存放的对象一定是T的子类，由于如此，我可以在这个方法中，定义T类型的对象，然后从List中取得对象，由于上面的描述，我们一定可以确定，无论你传入的List去具体的类型到底是什么，但一定可以上转型为T，这里List是一个生产者（Producer），它生产出来的（get(0)）的对象（某个类型，但一定是T的子类），一定可以传给T的引用（上转型）。这就是PE部分。</p>\n<p>而CS（Consumer Super）也很好理解，下面的代码不够严谨，但是可以让我们清楚其中的意义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genG</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt; ls)</span> </span>&#123;</span><br><span class=\"line\">    ls.add((T)<span class=\"keyword\">new</span> Object());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的方法接收一个List&lt;? super T&gt;参数，意味着，ls虽然我不知道到底会有什么样的类型的List传入，但是我一定知道，这个类型一定是T类型的超类，也就是说，ls.add方法能够存放的对象，是某个类型，而这个类型是T的超类（或本身），那么，T类型的对象我一定能够放进去（通过上转型到“？”，而这个“？”到底是什么我不知道，只知道是T的超类，T当然能够上转型到T的某个超类）。这里的List就是一个消费者，它消费（add）T类型，凭什么能够add，因为ls本身的类型是T的超类。</p>\n<h5 id=\"最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除\"><a href=\"#最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除\" class=\"headerlink\" title=\"最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除\"></a>最后注意：明确泛型发生在编译时期，请牢记Java的泛型擦除</h5>","categories":[],"tags":["Java","generic"]},{"title":"Scala trait特质 深入理解","url":"http://compilemind.com/2018/04/24/2018-04-24-Scala trait特质 深入理解/","content":"<h3 id=\"初探Scala-特质trait\"><a href=\"#初探Scala-特质trait\" class=\"headerlink\" title=\"初探Scala 特质trait\"></a>初探Scala 特质trait</h3><p>在Scala中，trait（特质）关键字有着举足轻重的作用。就像在Java中一样，我们只能在Scala中通过extends进行单一继承，但trait可以让我们从语义上实现了多重继承。通过对继承的类混入（mixin）多个特质，来达到多重继承的目的。乍一看，trait和Java中的interface接口很像，但是，细节上它们又有着大不同。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义超类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Super</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">定义特质</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">trait</span> <span class=\"title\">Trait</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">定义子类，将特质使用with关键字混入</span> <span class=\"title\">Super</span> <span class=\"title\">类，并继承之</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Super</span> <span class=\"keyword\">with</span> <span class=\"title\">Trait</span></span></span><br></pre></td></tr></table></figure>\n<p>请务必体会上面的最后一条注释，早期学习的时候，我们往往容易将特质理解为Java中的接口，同时将with理解为Java中的implements，于是我们编写出如下的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">with</span> <span class=\"title\">T</span> // 错误✖️</span></span><br></pre></td></tr></table></figure><br>这样想是因为我们没有正确理解特质，特质是对我们要<strong>被继承</strong>的类的补充，是要混入我们要继承的类的，不是我们本身类！即我们要明确，对于混入特质的子类定义，其实整体分为两个部分：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ class A ] extends [ S with T1 with T2 ...] </span><br></pre></td></tr></table></figure><br>中括号的表示两个部分才是正确的结构！</p>\n<p>此外，与Java中的接口相比，我们还能够在特质中直接实现完整的方法，就像如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 1&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在Java8以前我们无法在接口中定义并实现完整的方法，而在Java8及以后我们可以通过default关键字来后面接完整的方法来实现。</p>\n<p>现在，我们定义两个如下的特质：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 1&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 2&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>之后，我们定义一个名为Bottom的类，继承Scala中的Any类，同时混入上面定义的特质<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Any</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">/*</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">这里的Any是scala中的特殊对象</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">这里使用Any会报错</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Error</span></span>:(<span class=\"number\">16</span>, <span class=\"number\">31</span>) illegal inheritance; superclass <span class=\"type\">Any</span></span><br><span class=\"line\"> is not a subclass of the superclass <span class=\"type\">Object</span></span><br><span class=\"line\"> of the mixin <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid2</span></span></span><br><span class=\"line\"><span class=\"class\">...</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">*/</span></span></span><br></pre></td></tr></table></figure><br>“超类Any不是混入特质TrMid2的超类Object的子类”，即我们extends的类需要是Object的子类才行。面对上面的错误，我们可以将Any修改为AnyRef，这个类是scala内建类，本质上对应Java中的java.lang.Object类。修改之后，编译还是会报错：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">AnyRef</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span></span></span><br><span class=\"line\"><span class=\"class\">...</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">/*</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Error</span></span>:(<span class=\"number\">16</span>, <span class=\"number\">7</span>) <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"title\">inherits</span> <span class=\"title\">conflicting</span> <span class=\"title\">members</span></span>:</span><br><span class=\"line\">  method f in <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid2</span> <span class=\"title\">of</span> <span class=\"title\">type</span> <span class=\"title\">=&gt;</span> <span class=\"title\">Unit</span>  <span class=\"title\">and</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">method</span> <span class=\"title\">f</span> <span class=\"title\">in</span> <span class=\"title\">trait</span> <span class=\"title\">TrMid1</span> <span class=\"title\">of</span> <span class=\"title\">type</span> <span class=\"title\">=&gt;</span> <span class=\"title\">Unit</span></span></span><br><span class=\"line\"><span class=\"class\">(<span class=\"params\"><span class=\"type\">Note</span>: this can be resolved by declaring an override in class <span class=\"type\">Bottom</span>.</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">AnyRef</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> </span>&#123;</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure><br>这个错误提示我们在上面的两个特质中，均定义了相同签名的方法f，这里编译不通过，建议我们在Bottom类中实现f方法。换言之，当混入的多个特质中，分别定义了同名的方法，那么Scala会编译报错。在Java中也有类似的错误情形，下面就是关于Java，当然你可以跳过这一部分</p>\n<hr>\n<h4 id=\"Java接口中的同名方法\"><a href=\"#Java接口中的同名方法\" class=\"headerlink\" title=\"Java接口中的同名方法\"></a>Java接口中的同名方法</h4><p>以上的讨论，务必与Java中区分开来，这里需要补充一下。在Java中，首先由于我们无法进行多重继承，我们只能编写形如这样的class AA extends BB implements CC, DD这样的代码，想要建立像上面的测试情形，我们还只能使用JDK8之后的能够在接口中使用default关键字来定义具有具体实现的方法，最终我们的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [abstract] 为可选</span></span><br><span class=\"line\">[<span class=\"keyword\">abstract</span>] <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BB</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;In BB&#x27;s f()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// JDK8及以后的default关键字</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;In CC&#x27;s f()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AA</span> <span class=\"keyword\">extends</span> <span class=\"title\">BB</span> <span class=\"keyword\">implements</span> <span class=\"title\">CC</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对比验证类，保证我们接口中的方法没问题</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZZ</span> <span class=\"keyword\">implements</span> <span class=\"title\">CC</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> AA().f();</span><br><span class=\"line\">        <span class=\"comment\">// In BB&#x27;s f()</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ZZ().f();</span><br><span class=\"line\">        <span class=\"comment\">// In CC&#x27;s f()，接口方法是没有问题的</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>根据上面的区别，我们首先确定是类似这样的class AA extends BB implements CC，同时BB，CC有同名的方法，Java中首先（只会？）找类中的实现。可能你有疑惑了，为什么不能够让多个接口都创建同名的默认方法，让一个类来实现它们，调用同名方法，就想这样：class AA implements CC, DD，遗憾的是（高兴的是？），当你这样做的时候，Java编译期就给你报错了啦！<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;In CC&#x27;s f()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DD</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;In DD&#x27;s f()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AA</span> <span class=\"keyword\">implements</span> <span class=\"title\">CC</span>, <span class=\"title\">DD</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译就会报错</span></span><br><span class=\"line\"><span class=\"comment\">// Error:(25, 1) java: 类 AA从类型 CC 和 DD 中继承了f() 的不相关默认值</span></span><br></pre></td></tr></table></figure><br>要解决这个错误，要么，让其中一个接口中的同名方法改名，要么，实现类重写这个方法。</p>\n<hr>\n<h4 id=\"继续Scala特质的讨论\"><a href=\"#继续Scala特质的讨论\" class=\"headerlink\" title=\"继续Scala特质的讨论\"></a>继续Scala特质的讨论</h4><p>上面的关于同名方法的报错曾提示我们，在底层类重写实现Bottom中的f方法。这是办法之一。但是，我们还有另一种方式。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先我们定义一个顶层的抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbTop</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 让TrMid1、TrMid2均继承AbTop这个顶层抽象类，同时均重写抽象类中的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid1</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbTop</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 1&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">TrMid2</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbTop</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In TrMid 2&#x27;s f.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Bottom类继承AbTop类并混入上面定义的两个特质</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbTop</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 进行测试</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">TraitTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> top: <span class=\"type\">Bottom</span> = <span class=\"keyword\">new</span> <span class=\"type\">Bottom</span></span><br><span class=\"line\">    top.f</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们编译运行这段程序，得到了如下的结果：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">In</span> <span class=\"type\">TrMid</span> <span class=\"number\">2</span><span class=\"symbol\">&#x27;s</span> f.</span><br></pre></td></tr></table></figure><br>首先我们可以确定，我们按照上面的类层级结构混入了两个带有同名方法f的特质，并没有像上面那样出现二义性错误；为什么会这样？让我们再次理解这一段话“特质是对我们要<strong>被继承</strong>的类的补充，是要混入我们要继承的类的，不是我们本身类”。也就是说，报错的那个二义性，是由于我们想要将两个同名的f方法混入AnyRef这个类中，然而，我们没有override关键字（也无法加上），那么混入过程只是单纯的向AnyRef类中添加两个签名一样的方法f，而语法上我们无法向同一个类中添加连个签名完全一样的方法，故报错；解决方法就是在我们的子类中override这个f方法，重写覆盖它，消除二选一。</p>\n<p>而后者，我们能够编译运行还是像上面这样理解，由于我们是要向AbTop这个类中去混入特质，而我们每一个特质都是继承了AbTop类的，故我们应当重写覆盖顶层抽象类中的f方法，所以，在混入的过程中，从左到右每混入一次，他就加上一层外壳，所以这就是为什么，输出的结果是打印的第二个特质中f方法的输出，因为逐渐混入加壳的过程是从左到右的，先对AbTop加了壳，混入TrMid1特质，然后又对这一个结构加壳过程，混入TrMid2特质，就像下图：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/wrap.png\" alt=\"wrap\"><br>这样一来，不难理解混入特质的过程（加壳的过程）本身就像一个一层一层继承的过程。还是上面那段带有AbTop的代码中，这一次我们添加一个新的抽象类AbNewTop，但是其中包含一个抽象方法其名称依然为f，然我们修改Bottom的定义：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbNewTop</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bottom</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbNewTop</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid2</span> <span class=\"keyword\">with</span> <span class=\"title\">TrMid1</span> </span>&#123;&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>注意我们让Bottom不再继承AbTop，而是继承新定义的AbNewTop，其他诸如TrMid1依然继承的是AbTop不变。让我们运行代码，报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:(19, 36) illegal inheritance; superclass AbNewTop</span><br><span class=\"line\"> is not a subclass of the superclass AbTop</span><br><span class=\"line\"> of the mixin trait TrMid2</span><br><span class=\"line\">class Bottom extends AbNewTop with TrMid2 with TrMid1 &#123;</span><br></pre></td></tr></table></figure><br>英语有点绕口，我们这里翻译并分割一下：“非法的继承；<em>超类AbNewTop</em> 不是 混入特质的TrMid2的 <em>超类AbTop</em> 的子类”。再次对应这个结构：[ class A ] extends [ S with T1 with T2 …] 那么错误就在与后面的 S 与 T1、T2 对应不上了，及要实现正确的混入，S必须是T1、T2的超类的子类，当然，隐含的，本身也可以。转化为类图应该要满足如下的情形：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/class_map.png\" alt=\"class_map\"><br>可能有些人有疑惑，为什么特质不继承自任何其他的类的时候，依然可以被混入到其他的类中，就像如下的形式：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">T1</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> <span class=\"keyword\">with</span> <span class=\"title\">T1</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>因为在Scala任何的非值类（或特质）有默认的继承了scala.AnyRef类！这里的类图是如下的情形：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/animal_class.png\" alt=\"animal_class\"></p>\n<h3 id=\"使用特质来做可堆叠的改动——过滤\"><a href=\"#使用特质来做可堆叠的改动——过滤\" class=\"headerlink\" title=\"使用特质来做可堆叠的改动——过滤\"></a>使用特质来做可堆叠的改动——过滤</h3><p>试想一种情形：现在有一个客户需要我们编写一种整形数字容器，这个容器的类似于Java中的List，我们可以往里面去添加数据，但是添加数据的过程是可过滤的，或者说可按条件进行预处理的。首先我们定义一个Container类：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span>  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> list: util.<span class=\"type\">ArrayList</span>[<span class=\"type\">Int</span>] = <span class=\"keyword\">new</span> util.<span class=\"type\">ArrayList</span>[<span class=\"type\">Int</span>]()</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(n: <span class=\"type\">Int</span>): <span class=\"type\">Unit</span> = list.add(n)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span></span>(idx: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> = list.get(idx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>目前为止，这个类似乎没什么特殊之处，甚至可以说是多此一举 —— 定义Container类的结构还不如直接使用一个util.ArrayList来的快。但是，试想一个场景，我现在要在添加之前 想要 首先检查这个是是否是偶数，如果不是，直接丢弃；如果是，则除以2再加入到容器中。如果仅仅使用现在的版本，你可能会直接在Container.add方法中去进行筛选，就像如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractContainer</span> </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(n: <span class=\"type\">Int</span>): <span class=\"type\">Unit</span> = <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) list.add(n / <span class=\"number\">2</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>诚然，这段简单的代码的确能工作的很好。但是每一次的我改变规则，你难道就要在这个add代码中进行修改吗？亦或者假设这个类的源码根本就无法修改。你又如何操作？于是，使用特质来堆叠能够发挥作用：<br>首先我们还原add代码为最初始的状态，然后，我们定义如下的两个特质，并且定义我们的MyContainer类继承Container类并混入这两个特质：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Even</span> <span class=\"keyword\">extends</span> <span class=\"title\">Container</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x: <span class=\"type\">Int</span>): <span class=\"type\">Unit</span> = <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"keyword\">super</span>.add(x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Divide</span> <span class=\"keyword\">extends</span> <span class=\"title\">Container</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span></span>(x: <span class=\"type\">Int</span>): <span class=\"type\">Unit</span> = <span class=\"keyword\">super</span>.add(x / <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Container</span> <span class=\"keyword\">with</span> <span class=\"title\">Divide</span> <span class=\"keyword\">with</span> <span class=\"title\">Even</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">测试这段代码</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">object</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> myContainer = <span class=\"keyword\">new</span> <span class=\"type\">MyContainer</span></span><br><span class=\"line\">    myContainer.add(<span class=\"number\">1</span>)</span><br><span class=\"line\">    myContainer.add(<span class=\"number\">6</span>)</span><br><span class=\"line\">    println(myContainer.get(<span class=\"number\">0</span>)) <span class=\"comment\">// 输出3</span></span><br><span class=\"line\">    <span class=\"comment\">// println(myContainer.get(1)) // 超出边界</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在前面的讨论中我们知道，如果是一个类混入了多个特质，这多个特质含有同名的方法，会从左到右包装出来，即最终调用的是靠近右侧的实现了的方法。首先要实现筛选偶数，再除以2，最终添加到容器中。所以最先发挥作用的Even特质放在了最右侧。为什么这里，不仅能够筛选出偶数，同时还能除以2呢？答案就在super这个关键点。super.add即调用超类的add方法。这里再次用图来说明：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/evendivide.png\" alt=\"evendivide\"><br>我想这个图足以说明了吧。调用过程就是先调用最右侧的Even.add方法，进行偶数筛选；然后调用超类super.add(x)；超类即从右到左开始Even左侧是Divide，Divide.add(x)，Divide.add内部对x除以2，传入super.add()方法，即再次向左侧，是Container.add()，此时接收到的数已经是除以2的数了：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/flow.png\" alt=\"flow\"><br>还有一种情况是更为复杂的：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = println(<span class=\"string\">&quot;In A&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;In B&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.f</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span></span>: <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;In C&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.f</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> <span class=\"keyword\">with</span> <span class=\"title\">C</span></span></span><br></pre></td></tr></table></figure><br>关系图对应如下：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-24-trait/classrelation.png\" alt=\"classrelation\"><br>输出：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> t: <span class=\"type\">T</span> = <span class=\"keyword\">new</span> <span class=\"type\">T</span></span><br><span class=\"line\">    t.f</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"type\">In</span> <span class=\"type\">C</span></span><br><span class=\"line\"><span class=\"type\">In</span> <span class=\"type\">B</span></span><br><span class=\"line\"><span class=\"type\">In</span> <span class=\"type\">A</span></span><br></pre></td></tr></table></figure><br>看到输出，再根据前面的内容，我们也很容易理解，当某一个特质本生继承了其他的类的时候，super一定是其对应的超类，而不是class AA extends BB with TT中的BB这个类！</p>\n","categories":[],"tags":["Scala","trait"]},{"title":"Linux下iptables学习笔记","url":"http://compilemind.com/2018/04/18/2018-04-18-Linux下iptables笔记/","content":"<p>在Centos7版本之后，防火墙应用已经由从前的iptables转变为firewall这款应用了。但是，当今绝大多数的Linux版本（特别是企业中）还是使用的6.x以下的Centos版本，所以对iptables的了解还是很有必要的。此外，需要说明的是iptables自身并不具备防火墙的功能，它需要通过内核netfilter（网络过滤器）来实现，与firewalld一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结构以及使用方法不一样，他们都只是一个外壳应用罢了。打个比方，就好像有一本书，同样的内容，一种是纸质的，另一种是电子的，我们翻阅它的方式不同，给它做笔记的方式不同，但是内容（内核）一样。</p>\n<a id=\"more\"></a>\n<h3 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h3><p><strong>iptables概念</strong></p>\n<p>iptables中的规则（rule）。在我看来，规则是iptables中进行数据包检查的基本单元。每一条规则都定义了对于数据包的条件验证，譬如网络地址的验证、端口验证、协议验证等。</p>\n<p>iptables中的链（chain）。链是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。就像这里，我们有一个INPUT链（INPUT概念之后再作解释），数据包来到这条链时，就会根据该链中的规则进行检查，譬如源、目的地址是否符合规则；源、目的端口是否符合规则等等。当一个数据包到达一个<strong>链</strong>时，iptables就会从INPUT链中规则1开始检查，看该数据包是否满足规则所定义的条件——如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则2，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/inputchain.png\" alt=\"inputchain\"></p>\n<p>iptables中的表（table）。表是一组链的集合，在iptables中默认定义了四张表：filter、nat、mangle和raw，分别用于实现包过滤（最常用去配置的表），网络地址转换、包重构(修改)和数据跟踪处理。如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/alltables.png\" alt=\"alltables\"><br>当然，上图只是一个大致示意，并不意味着每个表中的例如想PREROUTING这样的链是独自在各个表中的，实际上表与链之间是一种交叉的关系，为什么这么说呢？这需要我们理解在iptables中传输数据包的流程（请结合下图慢慢阅读）。<br>（1）当一个数据包进入网卡时，它首先进入PREROUTING链，根据该链中的规则判定数据包的处理方式（ACCEPT？DROP？REJECT？），一旦通过规则检测，Linux内核根据数据包的IP地址决定是将数据包留下传入进入内部，还是转发出去。<br>1）如果数据包就是进入本机的（IP地址表明），它就会到达INPUT链。数据包到了INPUT链后，便开始根据INPUT链中的规则来检查数据包是否满足一系列的条件，满足之后，完全进入主机，任何进程都会收到它。同时，主机中的任何程序都可以发送数据包，发送出来的数据包会走到OUTPUT链，再根据里面的规则判定处理，最后到POSTROUTING链，再判定处理。<br>2）如果数据包是准备转发的，他就会到达FORWARD链，再根据FORWARD链中的规则进行检查判定决定接下来的处理。如果通过了FORWARD链，说明内核允许该数据包转发，那么数据包就会到POSTROUTING链进行最后的判断。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/flow.png\" alt=\"flow\"><br>同时我们可以看到，这里的角度并不是以table来看的，而是以chain来看的，这就是为什么我在上面提到的，尽管table是chain的集合，但并不意味着当我们定义防火墙的时候是按照table角度来定义，而是要根据chain角度来定义。我们要根据上图来决定我们要在何处怎样处理进入的数据包。这个flow在我看来必须要非常熟悉，对之后的命令行配置也有很大的帮助，因为iptables的命令行配置十分复杂。</p>\n<h4 id=\"iptables命令行配置\"><a href=\"#iptables命令行配置\" class=\"headerlink\" title=\"iptables命令行配置\"></a>iptables命令行配置</h4><p>iptables的命令格式如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables [-t table] COMMAND chain rules [-j action]</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> table 表名</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> chain 链名</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rules 规则</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> action 动作</span></span><br></pre></td></tr></table></figure><br><strong>table</strong> </p>\n<p>表选项用于指定命令要作用于哪一个表（raw、mangle、nat、filter）</p>\n<p><strong>COMMAND</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、对某一条的整条链进行管理的命令</span><br><span class=\"line\">-P或–policy &lt;链名&gt; 定义默认策略</span><br><span class=\"line\">  设置默认策略的（设定默认门是关着的还是开着的）</span><br><span class=\"line\">  默认策略一般只有两种（DROP 关闭 | ACCEPT 打开 ）</span><br><span class=\"line\">  比如：</span><br><span class=\"line\">  iptables -P INPUT DROP </span><br><span class=\"line\">  这条命令就是我们将INPUT链默认的策略设置为关闭，即所有的想要进入我们主机的连接全部被拒绝。</span><br><span class=\"line\">-F或-flush &lt;链名&gt; 清空某个表中的某条链中的所有规则</span><br><span class=\"line\">  比如：</span><br><span class=\"line\">  iptables -t filter -F INPUT # 清空filter表中的INPUT链中的所有规则</span><br><span class=\"line\">  iptables -t filter -F # 清空filter表中的所有链的所有规则</span><br><span class=\"line\">-Z或–zero &lt;链名&gt; 将表中数据包计数器和流量计数器归零</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">2、对某一条链的具体规则进行相关的定义</span><br><span class=\"line\">-A或—append &lt;链名&gt; 追加，在当前链的最后新增一个规则</span><br><span class=\"line\">-I或–insert num &lt;链名&gt; 在指定的num位置插入1条规则</span><br><span class=\"line\">-D或–delete num &lt;链名&gt; 从规则列表中删除第num条规则</span><br><span class=\"line\">-R或–replace num &lt;链名&gt; 替换规则列表中的第num条规则</span><br><span class=\"line\"></span><br><span class=\"line\">3、查看管理命令 “-L”</span><br><span class=\"line\">-L或–list &lt;链名&gt; 查看iptables规则列表</span><br><span class=\"line\">附加命令</span><br><span class=\"line\">  -n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名。</span><br><span class=\"line\">  -v：显示详细信息</span><br><span class=\"line\">  -vv</span><br><span class=\"line\">  -vvv :越多越详细</span><br><span class=\"line\">  -x：在计数器上显示精确值，不做单位换算</span><br><span class=\"line\">  --line-numbers : 显示规则的行号</span><br><span class=\"line\">  -t nat：显示所有的关卡的信息</span><br></pre></td></tr></table></figure><br><strong>rules</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i或–in-interface &lt;网络接口名&gt; 指定数据包从哪个网络接口进入，如ppp0、eth0和eth1等</span><br><span class=\"line\">-o或–out-interface &lt;网络接口名&gt; 指定数据包从哪块网络接口输出，如ppp0、eth0和eth1等</span><br><span class=\"line\">-p或—proto协议类型 &lt;协议类型&gt; 指定数据包匹配的协议，如TCP、UDP和ICMP等</span><br><span class=\"line\">-s或–source &lt;源地址或子网&gt; 指定数据包匹配的源地址</span><br><span class=\"line\">–sport &lt;源端口号&gt; 指定数据包匹配的源端口号，可以使用“起始端口号:结束端口号”的格式指定一个范围的端口</span><br><span class=\"line\">-d或–destination &lt;目标地址或子网&gt; 指定数据包匹配的目标地址</span><br><span class=\"line\">–dport目标端口号 指定数据包匹配的目标端口号，可以使用“起始端口号:结束端口号”的格式指定一个范围的端口</span><br></pre></td></tr></table></figure><br><strong>action</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 主要的action有如下的几个</span><br><span class=\"line\">ACCEPT 接受数据包</span><br><span class=\"line\">DROP 丢弃数据包（只丢弃，不作回应，与下面的REJECT不一样）</span><br><span class=\"line\">REJECT 明确的拒绝，还向发送者返回错误信息。</span><br><span class=\"line\">SNAT 源地址转换，即改变数据包的源地址</span><br><span class=\"line\">DNAT 目标地址转换，即改变数据包的目的地址</span><br><span class=\"line\">REDIRECT：重定向，主要用于实现端口重定向</span><br><span class=\"line\">MASQUERADE IP伪装，即是常说的NAT技术</span><br><span class=\"line\">LOG 日志功能，将符合规则的数据包的相关信息记录在日志中，以便管理员的分析和排错</span><br></pre></td></tr></table></figure><br>这里大致整理一下iptables命令的格式：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/fullformat.png\" alt=\"fullformat\"></p>\n<p>接下来详细的讲解一下实际使用命令的要点：</p>\n<p><strong>1、定义默认策略</strong></p>\n<p>什么叫默认策略？可以试想这样的场景，首先结合上面的当一个数据包到达链的时候，会根据链中定义的规则进行处理，但是很显然，我们没法对任何一种数据包的处理方式都定义在规则中，当我们的数据包进入链的时候，如果不满足所有规则的进入条件，那么我们起码要有一种默认的策略方式来处理这个数据包。这个定义默认策略就是这个作用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables [-t表名] &lt;-P&gt; &lt;链名&gt; &lt;动作&gt; </span><br><span class=\"line\">参数说明如下。</span><br><span class=\"line\">[-t表名]：指默认策略将应用于哪个表，可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认使用filter表。</span><br><span class=\"line\">&lt;-P&gt;：定义默认策略。</span><br><span class=\"line\">&lt;链名&gt;：指默认策略将应用于哪个链，可以使用INPUT、OUTPUT、FORWARD、PREROUTING、OUTPUT和POSTROUTING。</span><br><span class=\"line\">&lt;动作&gt;：处理数据包的动作，可以使用ACCEPT（接受数据包）和DROP（丢弃数据包）。</span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/defaultPolicy.png\" alt=\"defaultPolicy\"><br><strong>2、增加、插入、删除和替换规则</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">相关规则定义的格式为：</span><br><span class=\"line\">iptables [-t表名] &lt;-A | I | R | D&gt; 链名 [规则编号] [-i | o 网卡名称] [-p 协议类型] [-s 源IP地址 | 源子网] [--sport 源端口号] [-d 目标IP地址 | 目标子网] [--dport目标端口号] &lt;-j动作&gt;</span><br><span class=\"line\">参数说明如下。</span><br><span class=\"line\">[-t表名]：定义默认策略将应用于哪个表，可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认使用filter表。</span><br><span class=\"line\">-A：新增加一条规则，该规则将会增加到规则列表的最后一行，该参数不能使用规则编号。</span><br><span class=\"line\">-I：插入一条规则，原本该位置上的规则将会往后顺序移动，如果没有指定规则编号，则在第一条规则前插入。</span><br><span class=\"line\">-R：替换某条规则，规则被替换并不会改变顺序，必须要指定替换的规则编号。</span><br><span class=\"line\">-D：从规则列表中删除一条规则，可以输入完整规则，或直接指定规则编号加以删除。</span><br><span class=\"line\">&lt;链名&gt;：指定查看指定表中哪个链的规则列表，可以使用INPUT、OUTPUT、FORWARD、PREROUTING、OUTPUT和POSTROUTING。</span><br><span class=\"line\">[规则编号]：规则编号用于插入、删除和替换规则时用，编号是按照规则列表的顺序排列，规则列表中第一条规则的编号为1。</span><br><span class=\"line\">[-i | o 网卡名称]：i是指定数据包从哪块网卡进入，o是指定数据包从哪块网卡输出。网卡名称可以使用ppp0、eth0和eth1等(注意CentOS6.x与7.x网卡命名区别)。</span><br><span class=\"line\">[-p 协议类型]：可以指定规则应用的协议，包含TCP、UDP和ICMP等。</span><br><span class=\"line\">[-s 源IP地址 | 源子网]：源主机的IP地址或子网地址。</span><br><span class=\"line\">[--sport 源端口号]：数据包的IP的源端口号。</span><br><span class=\"line\">[-d目标IP地址 | 目标子网]：目标主机的IP地址或子网地址。</span><br><span class=\"line\">[--dport目标端口号]：数据包的IP的目标端口号。</span><br><span class=\"line\">&lt;-j动作&gt;：处理数据包的动作，各个动作的详细说明可以参考前面的说明。</span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/modifyRule.png\" alt=\"modifyRule\"></p>\n<p><strong>3、查看iptables规则</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看iptables规则的命令格式为：</span><br><span class=\"line\">iptables [-t表名] &lt;-L&gt; [链名]</span><br><span class=\"line\">参数说明如下。</span><br><span class=\"line\">[-t表名]：指查看哪个表的规则列表，表名用可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认查看filter表的规则列表。</span><br><span class=\"line\">&lt;-L&gt;：查看指定表和指定链的规则列表。</span><br><span class=\"line\">[链名]：指查看指定表中哪个链的规则列表，可以使用INPUT、OUTPUT、FORWARD、PREROUTING、OUTPUT和POSTROUTING，如果不指明哪个链，则将查看某个表中所有链的规则列表。</span><br></pre></td></tr></table></figure><br>由于这个命令比较简单，就不贴图了。</p>\n<p><strong>4、清除规则和计数器</strong></p>\n<p>在新建规则时，往往需要清除原有的、旧的规则，以免它们影响新设定的规则。如果规则比较多，一条条删除就会十分麻烦，这时可以使用iptables提供的清除规则参数达到快速删除所有的规则的目的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义参数的格式为：</span><br><span class=\"line\">iptables [-t表名] &lt;-F | Z&gt;</span><br><span class=\"line\">参数说明如下。</span><br><span class=\"line\">[-t表名]：指定默认策略将应用于哪个表，可以使用filter、nat和mangle，如果没有指定使用哪个表，iptables就默认使用filter表。</span><br><span class=\"line\">-F：删除指定表中所有规则。</span><br><span class=\"line\">-Z：将指定表中的数据包计数器和流量计数器归零。</span><br></pre></td></tr></table></figure><br>同上，由于这个命令比较简单，就不贴图了。</p>\n<p>当然，我们只看命令格式是枯燥的，这里我们使用一些实例来结合命令，使我们更加直观的理解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">禁止客户机访问某个网站或者某个IP地址</span><br><span class=\"line\">【例1】添加iptables规则禁止用户访问域名为www.xxx.com的网站。</span><br><span class=\"line\">iptables &lt;-A | I&gt; FORWARD -d www.xxx.com -j DROP</span><br><span class=\"line\">【例2】添加iptables规则禁止用户访问IP地址为xxx.xxx.xxx.xxx的网站。</span><br><span class=\"line\">iptables &lt;-A | I&gt; FORWARD -d xxx.xxx.xxx.xxx -j DROP</span><br></pre></td></tr></table></figure>\n<p>解析：首先我们可以确定是需要添加或者是插入一条我们的规则，所以使用&lt;-A | I&gt;；由于这里的拓扑是客户机连接我们的Linux服务器，客户机访问某一个网站，数据包到我们这里并不进入我们主机内部，而是经过转发FORWARD，所以我们要给FORWARD链插入或添加规则；由于指定了目标IP或域名，所以使用 -d 参数，又因为是禁止访问，所以 -j 之后的操作我们使用DROP。</p>\n<p>总结：这条命令告诉防火墙，我们现在添加了一条规则在默认的filter表中的FORWARD链，其规则为如果数据包到我们目前这个Linux服务器时，是要准备转发访问IP或域名为XXX的目标（-d），那么我们禁止它访问（DROP）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">禁止某些客户机上网</span><br><span class=\"line\">【例1】添加iptables规则禁止IP地址为192.168.1.X的客户机上网。</span><br><span class=\"line\">iptables &lt;-A | I&gt; FORWARD -s 192.168.1.X -j DROP</span><br><span class=\"line\">【例2】添加iptables规则禁止192.168.1.0子网里所有的客户机上网。</span><br><span class=\"line\">iptables &lt;-A | I&gt; FORWARD -s 192.168.1.0&#x2F;24 -j DROP</span><br></pre></td></tr></table></figure>\n<p>解析：同上的拓扑一样，客户机连接我们的Linux服务器，我们的Linux服务器是要准备做转发服务器，替我们的客户机去访问资源。所以还是对FORWARD链添加或者插入规则；但是这一次我们是要准备禁止某个IP地址的客户机上网，或者是某一子网下所有的客户机上网，也就是说，只要数据包的源IP地址或者是源子网下的我们都要禁止，所以这里采用 -s 参数。后面 -j 接DROP代表我们要丢弃来自这些源地址的数据包</p>\n<p>总结：这条命令告诉防火墙，我们现在添加了一条规则在默认的filter表中的FORWARD链，其规则为如果客户机的数据包到我们的服务器了，如果其源地址是xxx或者是某个子网下的地址，那么我们禁止转发他。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">禁止客户机访问某些服务</span><br><span class=\"line\">【例1】禁止192.168.1.0子网里所有的客户机使用FTP协议下载。</span><br><span class=\"line\">iptables -I FORWARD -s 192.168.1.0&#x2F;24 -p tcp –dport 21 -j DROP</span><br><span class=\"line\">【例2】禁止192.168.1.0子网里所有的客户机使用Telnet协议连接远程计算机。</span><br><span class=\"line\">iptables -I FORWARD -s 192.168.1.0&#x2F;24 -p tcp –dport 23 -j DROP</span><br></pre></td></tr></table></figure>\n<p>解析：以例1为例，首先我们要知道FTP协议使用的是TCP下默认21号端口。禁止192.168.1.0子网里所有的客户机使用FTP协议下载，首先还是转发的地方进行限定所以要在FORWARD链添加规则，源地址为192.168.1.0/24这个子网下的所有客户机，协议使用的是TCP，目的端口为21号。后面 -j 接DROP代表我我们要丢弃满足上述规则的数据包。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">强制访问指定的站点</span><br><span class=\"line\">【例】强制所有的客户机访问192.168.1.x这台Web服务器。</span><br><span class=\"line\">iptables -t nat -I PREROUTING -i eth0 -p tcp –dport 80 -j DNAT –to-destination 192.168.1.x:80</span><br><span class=\"line\"></span><br><span class=\"line\">禁止使用ICMP协议</span><br><span class=\"line\">【例】禁止Internet上的计算机通过ICMP协议ping到NAT服务器的ppp0接口，但允许内网的客户机通过ICMP协议ping的计算机。</span><br><span class=\"line\">iptables -I INPUT -i ppp0 -p icmp -j DROP</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"补充学习-NAT类型\"><a href=\"#补充学习-NAT类型\" class=\"headerlink\" title=\"[补充学习]NAT类型\"></a>[补充学习]NAT类型</h3><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。</p>\n<p>这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。</p>\n<p>另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。</p>\n<p>静态NAT(Static NAT)<br>静态NAT设置起来最为简单和最容易实现的一种，内部网络中的每个主机都被永久映射成外部网络中的某个合法的地址。</p>\n<p>动态地址NAT(Pooled NAT)<br>动态地址NAT是在外部网络中定义了一系列的合法地址，采用动态分配的方法映射到内部网络。<br>动态地址NAT只是转换IP地址，它为每一个内部的IP地址分配一个临时的外部IP地址，主要应用于拨号，对于频繁的远程联接也可以采用动态NAT。</p>\n<p>网络地址端口转换NAPT（Port－Level NAT）<br>NAPT是把内部地址映射到外部网络的一个IP地址的不同端口上。<br>最熟悉的一种转换方式。NAPT普遍应用于接入设备中，它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的TCP端口号。</p>\n<h3 id=\"了解-在Centos7-x上卸载firewalld，安装iptables\"><a href=\"#了解-在Centos7-x上卸载firewalld，安装iptables\" class=\"headerlink\" title=\"[了解]在Centos7.x上卸载firewalld，安装iptables\"></a>[了解]在Centos7.x上卸载firewalld，安装iptables</h3><p>由于CentOS7.x开始，防火墙应用已经不实用iptables，而是使用firewalld了。其应用的管理理念与iptables有着很大的区别。鉴于你确实可能不想用firewalld而是习惯使用iptables，这里提供相关的操作方式来卸载firewalld安装iptables。</p>\n<h4 id=\"安装iptables、iptables-service\"><a href=\"#安装iptables、iptables-service\" class=\"headerlink\" title=\"安装iptables、iptables-service\"></a>安装iptables、iptables-service</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先检查是否安装了iptables</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl status iptables.service</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装iptables</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install -y iptables</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 升级iptables（安装的最新版本则不需要）</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum update iptables </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装iptables-services</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install iptables-services <span class=\"comment\"># service!s!</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"禁用-停止自带的firewalld服务\"><a href=\"#禁用-停止自带的firewalld服务\" class=\"headerlink\" title=\"禁用/停止自带的firewalld服务\"></a>禁用/停止自带的firewalld服务</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">停止firewalld服务</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl stop firewalld</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">禁用firewalld服务</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl mask firewalld</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"设置现有的规则\"><a href=\"#设置现有的规则\" class=\"headerlink\" title=\"设置现有的规则\"></a>设置现有的规则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查看iptables现有规则</span><br><span class=\"line\">$ iptables -L -n</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/iptables-L-n.png\" alt=\"iptables-L-n\"><br>可以看到显示的INPUT、FORWARD、OUTPUT上没有任何规则配置且默认策略均为ACCEPT<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 务必先配置INPUT链的默认规则为ACCEPT，这样一来，避免误配置导致我们无法进入</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -P INPUT ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">清空所有默认规则</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -F</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">清空所有自定义规则</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -X</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">所有计数器归0</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -Z</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">允许来自于lo接口的数据包(本地访问)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -i lo -j ACCEPT</span></span><br></pre></td></tr></table></figure><br>接下来定义特别的入站规则<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开放22端口</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开放21端口(FTP)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开放80端口(HTTP)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开放443端口(HTTPS)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 允许ping</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 允许接受本机请求之后的返回数据 RELATED,是为FTP设置的</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -A INPUT -m state --state  RELATED,ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure><br>在上面的入站规则配置好以后，接下来我们可以将INPUT默认策略转为DROP（拒绝）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 其他入站一律丢弃</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -P INPUT DROP</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 所有出站一律允许</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -P OUTPUT ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 所有转发一律丢弃</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> iptables -P FORWARD DROP</span></span><br></pre></td></tr></table></figure><br>最终我们可以看到我们目前定义的配置表：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/finalConfig.png\" alt=\"finalConfig\"></p>\n<h4 id=\"保存规则设定、开启iptables服务\"><a href=\"#保存规则设定、开启iptables服务\" class=\"headerlink\" title=\"保存规则设定、开启iptables服务\"></a>保存规则设定、开启iptables服务</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 保存上述规则</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> service iptables save</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注册iptables服务</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 相当于以前的chkconfig iptables on</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl <span class=\"built_in\">enable</span> iptables.service</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开启服务</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl start iptables.service</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看状态</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> systemctl status iptables.service</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-18-iptables/enableAndStart.png\" alt=\"enableAndStart\"><br>防火墙配置完成！</p>\n","categories":[],"tags":["Linux","iftables"]},{"title":"树莓派3B上手一二","url":"http://compilemind.com/2018/04/12/2018-04-12-树莓派3B上手一二/","content":"<p>早些时间心血来潮买过一个树莓派，但是当时只是玩一玩，买来按照网上的教程摆弄了一下就闲置了。最近毕业设计，做时序数据分析的相关的工作，刚好想起能够用到树莓派+Node-RED来生成模拟的时序数据。于是开始搭建相关的环境。特此记录一下。</p>\n<a id=\"more\"></a>\n<p><strong>系统镜像下载</strong></p>\n<p>树莓派如今已是一个状态的生态圈。其本身有Linux定制的发行版树莓派系统。首先<a href=\"https://www.raspberrypi.org/downloads/raspbian/\">官网</a>去下载系统系统镜像：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/officialwebsite.png\" alt=\"officialwebsite\"><br>上面有两个版本左边是带有图形界面的，右边是没有图形界面的。个人推荐不带图形界面的，既然是玩树莓派的，我想大多数还是有一定Linux基础的，真没有必要装图形界面。</p>\n<p>下载好以后我们能够看到压缩包中存在一个.img后缀的文件，这个就是系统镜像。</p>\n<p><strong>系统烧录</strong></p>\n<p>由于本人使用的macOS，所以接下来实际操作的都是在macOS环境下进行的，在windows下进行系统烧录，可以参考<a href=\"https://blog.csdn.net/u012313335/article/details/53405734\">这篇文章</a>。</p>\n<p>1）格式化SD卡</p>\n<p>这里我使用SD官方的SD格式化工具SD Card Formatter，<a href=\"https://www.sdcard.org/chs/downloads/formatter_4/index.html\">下载地址</a></p>\n<p>下载好以后，安装并打开该工具，然后插入SD卡，SD Card Formatter会自动识别插入的Sd卡，我们直接点击format进行格式化。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/sdformat.png\" alt=\"sdformat\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/formatsuccess.png\" alt=\"formatsuccess\"></p>\n<p>2）烧录系统镜像</p>\n<p>在mac下烧录系统是很容易的，因为Linux/UNIX本身有相关的命令操作。</p>\n<p>首先在命令行我们使用命令df -h来显示目前的挂载情况<br>这里稍微补充一下Linux/UNIX下的磁盘的命名规则：<br>本人的mac只有一块磁盘就像下面的disk1，而后面的s1、s4则代表这块磁盘上的分区<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> df -h  <span class=\"comment\"># 我只粘贴了有代表性的输出</span></span></span><br><span class=\"line\">Filesystem                        Size   Used  Avail Capacity iused               ifree %iused  Mounted on</span><br><span class=\"line\">/dev/disk1s1                     234Gi   99Gi  132Gi    43% 1230474 9223372036853545333    0%   /</span><br><span class=\"line\">/dev/disk1s4                     234Gi  2.0Gi  132Gi     2%       2 9223372036854775805    0%   /private/var/vm</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重点是下面这一个条</span></span><br><span class=\"line\">/dev/disk3s1                      15Gi  2.4Mi   15Gi     1%       0                   0  100%   /Volumes/BOOT</span><br></pre></td></tr></table></figure><br>上面的disk3则是我们的SD的磁盘，并且，只有一个分区s1，我们还可以看到容量为15Gi就是我们预期的格式化好了之后的容量。当然，既然这里能够显示则说明，这些磁盘我们已经挂载好了。接下来首先需要取消挂载：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 千万注意一定要取消挂载正确的磁盘！不要把你的mac磁盘给取消挂载了：）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 另外，请记住disk3s1这个名称，后面要用</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> diskutil unmount /dev/disk3s1</span></span><br><span class=\"line\">Volume BOOT on disk3s1 unmounted</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这个时候再df发现我们的SD已经不再显示里面了，说明卸载成功</span></span><br></pre></td></tr></table></figure><br>接下来进行正式的烧录，使用dd命令将系统镜像写入，需要特别特别注意disk后的数字，不能搞错！/dev/disk3s1是分区，/dev/disk3是块设备，/dev/rdisk3是原始字符设备<br>我们接下来就是要吧镜像烧录到原始字符设备<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 下面dd用于将系统镜像写入</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> bs代表了文件系统的页大小这里设置为4m</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"keyword\">if</span>=后面接上镜像文件的对应路径</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> of=后面接上原始字符设备的路径，因为上面是我们卸载之前是disk3s1，所以这里就是rdisk3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo dd bs=4m <span class=\"keyword\">if</span>=(镜像存放路径)/XXX.img of=/dev/rdisk3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 不放心可以在命令行末尾双击tab会出现类似下面的输出</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rdisk3    rdisk3s1</span></span><br></pre></td></tr></table></figure><br>回车开始烧录，这个过程按机器的差异时间会有所不同。烧录完成以后会出现下面的输出：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">443+0 records in</span><br><span class=\"line\">443+0 records out</span><br><span class=\"line\">1858076672 bytes transferred in 237.453302 secs (7825019 bytes/sec)</span><br></pre></td></tr></table></figure><br>至此，树莓派系统的烧录工作就完成了。<strong>补充</strong>：为了方便以后的SSH连接树莓派，完成树莓派的系统烧录之后，先别着急推出SD，打开SD卡（通常在桌面），我们在系统目录下创建一个名为SSH（大写，没有文件后缀）的文件，以供树莓派开启SSH。</p>\n<p>命令行下如何进入SD卡？所有挂载的外部设备都会在/Volumes下查创建对应的文件夹：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /Volumes</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l</span></span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel     1  4  8 10:59 Macintosh HD -&gt; /</span><br><span class=\"line\">drwxr-xr-x+ 3 root  wheel    96 11 11 15:22 Preboot</span><br><span class=\"line\">drwxrwxrwx@ 1 zhen  staff  2560  4 12 10:30 boot # 这个boot名称的设备就是SD卡</span><br></pre></td></tr></table></figure>\n<p>至此，系统初始化工作完全搞定。</p>\n<p><strong>登陆系统</strong></p>\n<p>以下的操作我们都是在没有显示器的情况下进入树莓派系统，如果你本身有外接显示器，自然不需要这么麻烦，连接然后开机就行了：）</p>\n<p>树莓派3B本身带有wifi模块，但是，如果要开启首先你需要进入系统进行配置：），所以最开始你需要有线连接树莓派</p>\n<p>理论上，mac在有以太网转雷电或者是转USB情况下，我们可以通过网线直连树莓派和mac，但是本身尝试了多次发现就是发现不了同一网段的树莓派（树莓派都给mac分配了IP地址了），猜测macOS High Serria安全性增强了？这个坑以后在研究一下，填了。</p>\n<p>另外一种是路由器组网方式<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/topology.png\" alt=\"topology\"><br>按照这样的连接，你的mac和树莓派都在同一网段中，同时你还可以登陆路由器的管理界面去查看树莓派分配到的IP地址，然后通过ssh连接树莓派。</p>\n<p>组网完成以后，登陆网关，找到设备管理（不同品牌的路由器界面不同，道理上类似）<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/alldevice.png\" alt=\"alldevice\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/netgate.png\" alt=\"netgate\"><br>可以看到我们的树莓派已经分配到了IP，然后我们直接通过命令行登陆：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh pi@192.168.1.100</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意默认的用户名和密码分别为pi和raspberry</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将树莓派加入到已识别的主机中</span></span><br><span class=\"line\">The authenticity of host &#x27;192.168.1.100 (192.168.1.100)&#x27; can&#x27;t be established.</span><br><span class=\"line\">ECDSA key fingerprint is SHA256:p1UPTb5aXIOUiiqdpdaP/e2MV+vbkZJVey0wCYOUEJE.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输入密码，看到一堆信息之后，我们成功进入系统</span></span><br><span class=\"line\">pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure><br>注意：由于我们使用的lite版的树莓派系统，vi使用过程中会出现上下左右方向键成为ABCD等字符，同时mac上的delete（windows上是backspace）都会失效，我们要进行如下的操作：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 1、编辑/etc/vim/vimrc.tiny</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo vi /etc/vim/vimrc.tiny</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将 <span class=\"built_in\">set</span> compatible 改为 <span class=\"built_in\">set</span> nocompatible 这里解决方向键ABCD问题</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 2、依旧在该文件中添加 <span class=\"built_in\">set</span> backspace=2 解决删除问题</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> :wq保存</span></span><br></pre></td></tr></table></figure><br><strong>打开wifi模块</strong></p>\n<p>首先我们扫描当前环境中能够找到的wifi<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo iwlist wlan0 scan <span class=\"comment\"># 此步骤非必须，如果你本来就知道wifi名称就可以不用扫描</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果当前环境中有很多会出现类似下面的格式的信息：</span></span><br><span class=\"line\">Cell 10 - Address: 94:D9:B3:15:7F:28</span><br><span class=\"line\">                    Channel:6</span><br><span class=\"line\">                    Frequency:2.437 GHz (Channel 6)</span><br><span class=\"line\">                    Quality=70/70  Signal level=-16 dBm</span><br><span class=\"line\">                    Encryption key:on</span><br><span class=\"line\">                    ESSID:&quot;210&quot;</span><br><span class=\"line\">                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s</span><br><span class=\"line\">                              9 Mb/s; 12 Mb/s; 18 Mb/s</span><br><span class=\"line\">                    Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s</span><br><span class=\"line\">                    Mode:Master</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 我删除很多不重要的输出信息，这里重点看ESSID，这个就是wifi名称。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 接下来我们需要在下面的文件中开启它：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo vi /etc/wpa_supplicant/wpa_supplicant.conf</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加如下的信息</span></span><br><span class=\"line\">network=&#123;</span><br><span class=\"line\">        ssid=&quot;你的Wi-Fi名称&quot;</span><br><span class=\"line\">        psk=&quot;Wi-Fi密码&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果有多个wifi，你可以创建多个network</span></span><br></pre></td></tr></table></figure><br>最后一步，首先请重启（$ sudo reboot）树莓派，然后拔掉网线，通过mac登陆网关，你会发现树莓派已经通过wifi连接到了。下面两款设备都是wifi连接的。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-raspberry-system/twowifi.png\" alt=\"twowifi\"><br>此外，由于lite版本，树莓派不具备vim，所以需要我们手动下载：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 首先移除掉旧的vi</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo apt-get remove -y vim-common</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 然后安装vim</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo apt-get install -y vim</span></span><br></pre></td></tr></table></figure><br>接下来在用户目录下打开（没有就创建）.vimrc，并添加如下的vim配置<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vim ~/.vimrc</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加：</span></span><br><span class=\"line\">set nocompatible &quot;不兼容vi</span><br><span class=\"line\">set nu &quot;显示行号</span><br><span class=\"line\">set nowrap &quot;不自动折行</span><br><span class=\"line\">set scrolloff=3 &quot;距离顶部底部3行</span><br><span class=\"line\">hi MatchParen ctermbg=DarkRed guibg=lightblue</span><br><span class=\"line\">set encoding=utf-8 &quot;编码方式</span><br><span class=\"line\">set fenc=utf-8 &quot;存储时候的编码方式</span><br><span class=\"line\">set hlsearch &quot;搜索高亮</span><br><span class=\"line\">syntax on &quot;语法高亮</span><br><span class=\"line\">set ts=4 &quot;一个tab长度为4</span><br><span class=\"line\">set expandtab &quot;tab替换为空格（配合上面即一个tab四个空格）</span><br><span class=\"line\">set autoindent &quot;自动缩进</span><br></pre></td></tr></table></figure><br>至此，树莓派的初始环境已经OK！</p>\n","categories":[],"tags":["Linux","Raspberry"]},{"title":"树莓派3B搭建NODE-RED运行环境并构建数据流","url":"http://compilemind.com/2018/04/12/2018-04-12-树莓派3B搭建NODE-RED运行环境并进行基础练习/","content":"<p><strong>树莓派搭建Node-RED环境</strong></p>\n<p>树莓派自2015年开始是默认就带NODE-RED的，但是如今已是2018年：）自带的版本已经很老了，可通过下面的命令进行自动升级NODE.JS和NODE-RED</p>\n<a id=\"more\"></a>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash &lt;(curl -sL https://raw.githubusercontent.com/node-red/raspbian-deb-package/master/resources/update-nodejs-and-nodered)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果出现失败请多尝试几次</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 之后进入如下界面，展示更新进度</span></span><br><span class=\"line\">  Stop Node-RED                       ✔</span><br><span class=\"line\">  Remove old version of Node-RED      ✔</span><br><span class=\"line\">  Remove old version of Node.js</span><br><span class=\"line\">  Install Node.js</span><br><span class=\"line\">  Clean npm cache</span><br><span class=\"line\">  Install Node-RED core</span><br><span class=\"line\">  Move global nodes to local</span><br><span class=\"line\">  Install extra Pi nodes</span><br><span class=\"line\">  Npm rebuild existing nodes</span><br><span class=\"line\">  Add menu shortcut</span><br><span class=\"line\">  Update systemd script</span><br><span class=\"line\">  Update update script</span><br><span class=\"line\"></span><br><span class=\"line\">Any errors will be logged to   /var/log/nodered-install.log</span><br></pre></td></tr></table></figure>\n<p>一段时间过后，升级完毕：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">All done.</span><br><span class=\"line\">  You can now start Node-RED with the command  node-red-start</span><br><span class=\"line\">  or using the icon under   Menu / Programming / Node-RED</span><br><span class=\"line\">  Then point your browser to localhost:1880 or http://&#123;your_pi_ip-address&#125;:1880</span><br></pre></td></tr></table></figure><br>根据提示我么可以知道，通过如下的命令启用NODE-RED服务，并且访问树莓派地址并加上1880端口访问WEB下的NODE-RED：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> node-red-start</span></span><br><span class=\"line\">Start Node-RED</span><br><span class=\"line\"></span><br><span class=\"line\">Once Node-RED has started, point a browser at http://192.168.2.7:1880 # 这里是树莓派分配到IP地址</span><br><span class=\"line\">On Pi Node-RED works better with the Firefox or Chrome browser</span><br><span class=\"line\"></span><br><span class=\"line\">Use   node-red-stop                          to stop Node-RED</span><br><span class=\"line\">Use   node-red-start                         to start Node-RED again</span><br><span class=\"line\">Use   node-red-log                           to view the recent log output</span><br><span class=\"line\">Use   sudo systemctl enable nodered.service  to autostart Node-RED at every boot</span><br><span class=\"line\">Use   sudo systemctl disable nodered.service to disable autostart on boot</span><br><span class=\"line\"></span><br><span class=\"line\">To find more nodes and example flows - go to http://flows.nodered.org</span><br><span class=\"line\"></span><br><span class=\"line\">Starting as a systemd service.</span><br><span class=\"line\">Started Node-RED graphical event wiring tool..</span><br><span class=\"line\">12 Apr 04:33:27 - [info]</span><br><span class=\"line\">Welcome to Node-RED</span><br></pre></td></tr></table></figure><br>然后我们打开浏览器访问web网页，能够看到如下的界面：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/node-red-web.png\" alt=\"node-red-web\"><br>Node-RED  UI——显示节点选择板（左）、流的编辑界面（中心）和输出窗格（右）</p>\n<p>左侧里面全是node-red包含的节点，而节点就是node-red的基本单位，它包含了生成数据的节点、处理数据的节点以及最终输出的节点。</p>\n<p>中间是我们的工作区，在该区域内，我们按照正确的形式构建节点，来形成一套数据流生成、处理过程。</p>\n<p>右侧是输出窗格可以切换信息和调试选项卡等。选择信息后，将显示所选节点的文档。当调试被选中时，它将显示调试节点的信息、错误和警告。</p>\n<p>作为Node-red最基本的单位：节点。在Node-red中主要分为3类：</p>\n<p>1、输入节点（例如inject）<br>2、处理节点（例如function）<br>3、输出节点（例如debug）</p>\n<p>输入节点</p>\n<p>输入节点允许数据输入到整个流工作空间中。它们至少有一个输出（端点由右边的小灰色方块表示）。同时也可以将其他服务数据连接到输入节点，例如TCP、WebSockets、UDP等节点，或利用手动输入数据到一个流之中。</p>\n<p>处理节点</p>\n<p>处理节点主要功能是处理数据。它们有一个输入端点和一个或多个输出端点。我们通常使用function节点来处理收到的数据。当然它页可以转换数据类型（例如：JSON、CSV、XML）节点。</p>\n<p>输出节点</p>\n<p>输出节点允许在Node-RED的流之外发送数据。它们的左侧有一个输入端点。使用输出节点将数据发送到其他服务，TCP等或者使用调试节点输出到调试窗进行观察。</p>\n<p>而对于各种数据来说，其本质的最简单的数据结构如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg=&#123;</span><br><span class=\"line\">  payload:”负载数据”</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>即每一条数据都会有其本身的负载数据。</p>\n<p>讲完了基础的知识，我们来通过动手实践来更加直观的了解node-red</p>\n<p><strong>构建时间戳流</strong></p>\n<p>这个例子十分简单，我们不需要任何的处理节点，只需要一个输入和一个输出就可以了：</p>\n<p>我们首先从左侧拉取一个inject输入节点，放置到工作空间中，它会自动变为默认的时间戳节点，单击这个时间戳节点，查看右侧信息栏，我们能看到这个节点的描述：这个时间戳节点能够生成自1970年1月1号以来的所过的毫秒数<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/inject-timestamp.png\" alt=\"inject-timestamp\"><br>通过双击该节点我们还可以看到更加具体的细节：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/inject-detail.png\" alt=\"inject-detail\"></p>\n<p>接下来我们拉取一个debug节点到工作空间中，它会自动转变为msg.payload节点，这个节点就是会将数据直接输出：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/debug-node-info.png\" alt=\"debug-node-info\"><br>接下来我们连接两个节点，同时可以看到每个节点上面都有一个小蓝点，意味着我们的节点只放置到了工作空间中，但是并没有部署：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/node-linked.png\" alt=\"node-linked\"><br>点击右上角的部署之后，我们发现小蓝点消失了。接下来我们让时间戳节点产生时间数据并输出查看。首先点击右侧的调试窗口，然后点击时间戳节点左侧的蓝色矩形按钮：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/clickit.png\" alt=\"clickit\"><br>点击过程中我们可以看到提示我们注入成功，并且在右侧的还能看到输出的数据：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/successinject.png\" alt=\"successinject\"><br>此外，当我们双击debug节点，然后在输出那一栏选择“完整消息”，我们发现输出节点变成了“msg”即整个msg消息体，同时再次部署并点击时间戳产生数据，我们发现输出的信息变得更加完整：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/completeinfo.png\" alt=\"completeinfo\"></p>\n<p>最后，让我们产生编程界的经典输出：Hello, World!</p>\n<p>首先双击“注入节点”，我们不选时间戳类型了，而是替换为文字列：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/change2String.png\" alt=\"change2String\"><br>再次部署并点击消息注入按钮（就是蓝色矩形）<br>得到如下的结果：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-12-nodered/injecthw.png\" alt=\"injecthw\"></p>\n<p>至此，我们成功的使用Node-RED构建了我们的第一条简单的流。</p>\n","categories":[],"tags":["Raspberry","nodejs","NODE-RED"]},{"title":"Linux文件系统与inode、Block笔记","url":"http://compilemind.com/2018/04/08/2018-04-08-Linux文件系统与inode、Block笔记/","content":"<p>在Linux下一切都是文件，无论是设备还是接口，亦或是网卡等均被抽象成了文件，并且有相关的内核代码进行调度。然而，在一切都是文件的前提下，最需要进行探讨的则是文件存储的根源：文件系统。文件系统的好坏能够更加完美的解决在一个操作系统中对于文件的管理。</p>\n<a id=\"more\"></a>\n<p>Linux下的文件系统是按照inode + block模式来进行了的。通俗一点讲，类似于指针一样的形式存在。即inode作为“指针”记录并指向了真正的”数据块“block。 </p>\n<p><strong>环境</strong></p>\n<p>为了方便后面的实际操作，我们按照如下进行环境的搭建<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 首先在<span class=\"built_in\">test</span>目录下创建一个名为temp的文件夹与一个普通的文件test.txt</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/root/test</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir temp &amp;&amp; touch test.txt</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 文件结构如下</span></span><br><span class=\"line\">test</span><br><span class=\"line\">├── temp</span><br><span class=\"line\">└── test.txt</span><br><span class=\"line\">1 directory, 1 file</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 向test.txt写入一句话</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Its&#x27;s a test.txt&quot;</span> &gt;&gt; test.txt</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>inode</strong></p>\n<p>在Linux中，每一份文件都对应了独一无二的inode编号，通过使用命令ls加参数-i，则可以在显示的文件前显示inode编号。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -i</span></span><br><span class=\"line\">33933113 temp 17414066 test.txt</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 前面的数字就是inode且独一无二</span></span><br></pre></td></tr></table></figure><br>除此之外，inode中还存储更加关键的文件元信息：权限、属性等。例如当我们使用ls -l显示文件的相关属性时，这里面的信息就存储在inode：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l</span></span><br><span class=\"line\">total 4</span><br><span class=\"line\">drwxr-xr-x. 2 root root  6 Apr  8 13:05 temp</span><br><span class=\"line\">-rw-r--r--. 1 root root 16 Apr  8 13:08 test.txt</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 文件夹、文件名前面的诸如读、写、执行权限，修改时间等均存储在inode中</span></span><br></pre></td></tr></table></figure><br>当然，对于inode来说，既然它本身能够记录这些信息，所以自身是有大小的，每个inode 大小均固定为128 bytes，虽然不大，但是记录元信息完全足够了。同时，它本身还记录此文件数据所在的block数据块的编号。inode记录一个block编号需要花掉4bytes</p>\n<p><strong>block</strong></p>\n<p>既然inode是记录文件的元信息的，那么一般文件本身的数据记录在何处呢？答案则是block数据块。在Linux中，block文件快大小通常选择4KB，当然我们还可以选择1KB、2KB等。这是不定的，但是如果选择的太小，那么inode需要记录block编号就要增多，如果太大，容易造成存储碎片。如何理解？其实我们可以把block看作是文件的基本单位，例如，我们现在有一个22KB大小的文件，一个简单的计算，倘若我们使用4KB的block需要6块才能完全装下，不过会有2KB是浪费了的。如果我们采用2KB的block则刚好11块可以装下。这里虽然是选择2KB是最合适的，但是在一般Linux系统中是4KB，为什么？请自行查阅相关的资料，不再赘述。</p>\n<p><strong>综合inode与block进行探讨</strong></p>\n<p>上面的inode与block只是大致介绍了相关的，下面才是更加实在的内容。</p>\n<p>inode具体包含了哪些东西？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、文件的字节数</span><br><span class=\"line\">2、文件拥有者的User ID</span><br><span class=\"line\">3、文件的Group ID</span><br><span class=\"line\">4、文件的读、写、执行权限</span><br><span class=\"line\">5、文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class=\"line\">6、链接数，即有多少文件名指向这个inode</span><br><span class=\"line\">7、文件数据block的位置</span><br></pre></td></tr></table></figure><br>1-5点不难理解，第6点在后面的软硬连接再叙，第七点这里要提一下。上面说过inode本身128 Bytes，还是能记录很多信息的，这里1-6点不至于花光128 Bytes，而对于第7点，inode本身能够记录12个block，如果采用4KB block显然，我们只能存储12 <em> 4KB大小的文件，这显然是不现实的。为了解决这个问题，inode中在第12个记录block编号之后，还能动态的增加二级、甚至三级间接指向，这里我们使用如下的图更为形象的说明：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-08-inode-block/inode-block.png\" alt=\"inode-block\"><br>在上图的情况下，我们可以知道假设我们使用4KB大小的block，并且刚好使用满二次间接，能够存储的数据大小为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12*4KB + 1024*4KB + 1024*1024*4KB</span><br><span class=\"line\">&#x3D; 48KB + 4MB + 4GB</span><br><span class=\"line\">≈ 4GB</span><br></pre></td></tr></table></figure><br><em>*关于文件夹的inode、block</em></em></p>\n<p>上面讨论inode与block我们都是以一个普通文件的角度来看待的。然而，文件夹inode与block与普通文件是有一定的差别的。对于一个文件夹来说，inode与普通文件类似，包含了关于文件夹的属性、读写执行权限、时间戳等。然而，文件夹inode中的直接block通常不会超过12个直接的。为什么呢？因为文件夹所指向的block只会存储这个文件夹拥有的文件的inode编号，并不会存储实际的文件内容。</p>\n<p>例如，当我们拥有一个文件夹dir，这个文件夹下面只有一份文件大小为4GB的inode为1234的文件，那么实际上，文件夹inode中存储的block中只会存储类似inode=1234这样的信息。下图能够更加形象的展示：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-04-08-inode-block/dir-inode-block.png\" alt=\"dir-inode-block\"><br>总结一下，文件夹的block只会存储对应文件夹下面的文件的inode。所以当我们访问某一个文件的时候，譬如我问需要查看/root/test.txt的时候，流程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先检查根目录下的权限“&#x2F;”，符合权限</span><br><span class=\"line\">通过之后，检查根目录的block是否存储有“root&#x2F;”目录以及对应inode</span><br><span class=\"line\"></span><br><span class=\"line\">查找成功，找到&#x2F;root&#x2F;目录的inode，检查权限等信息，符合权限</span><br><span class=\"line\">通过之后，检查&#x2F;root&#x2F;inode下的block中是否存在test.txt以及inode</span><br><span class=\"line\"></span><br><span class=\"line\">查找成功，找到&#x2F;root&#x2F;test.txt的inode检查权限等信息，符合</span><br><span class=\"line\">查询inode中的直接或间接block将数据读出</span><br></pre></td></tr></table></figure><br>那么，通过以上的分析，我们也很容易的能够理解，如果我们没有对文件夹有写的权限，是不能够删除文件夹下面的文件或者是创建文件的。因为当我们删除一个文件的时候，是对<strong>文件夹</strong>inode对应的block中存储的文件信息进行删除或添加。由于root用户的特殊性，我们使用一个普通用户zhen，并在zhen用户的home目录下创建一个temp文件夹<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l</span></span><br><span class=\"line\">drwxrwxr-x. 2 zhen zhen  6 Apr  8 13:05 temp</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> temp文件夹对于zhen用户有读写以及执行的权限，所以我们（zhen）可以自由的在里面添加删除文件</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ./temp</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> touch <span class=\"built_in\">test</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">test</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> rm <span class=\"built_in\">test</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建删除都没有问题</span></span><br></pre></td></tr></table></figure><br>接下来我们首先在temp文件夹中创建一个test2文件，再回到上一目录，将temp的写权限移除<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建test2文件</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> touch test2</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">test2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 回到上一目录</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ..</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将temp对于zhen的写权限移除</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> chmod 500 ./temp</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l</span></span><br><span class=\"line\">total 4</span><br><span class=\"line\">dr-x------. 2 zhen zhen  6 Apr  8 14:52 temp</span><br></pre></td></tr></table></figure><br>然后，我们再次进入temp文件夹，试图创建文件，发现失败：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ./temp</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> touch test3</span></span><br><span class=\"line\">touch: cannot touch ‘test3’: Permission denied</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> rm test2</span></span><br><span class=\"line\">rm: cannot rm ‘test3’: Permission denied</span><br></pre></td></tr></table></figure><br>操作发现，无论是在该文件夹下创建还是删除文件，都是失败的。那么，我们还能不能编辑该文件夹该文件夹下面的文件呢？譬如想test2文件插入一句“Hello”？理论上来讲，是可以的，因为我们修改test2文件内容，并不会影响temp文件夹的block内容，而事实上也是如此：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello&quot;</span> &gt; test2</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat test2</span></span><br><span class=\"line\">Hello</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 没有问题</span></span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Linux","inode","block"]},{"title":"Java编译运行环境讨论（复古但能加深对Java项目的理解）","url":"http://compilemind.com/2018/03/30/2018-03-30-Java编译运行环境讨论（复古但能加深对Java项目的理解）/","content":"<p>如今我们大多数情况都会使用IDE来进行Java项目的开发，而一个如今众多优秀的IDE已经能够帮助我们自动的部署并调试运行我们的Java程序。然而在早期我们进行Java开始需要手动的建立逻辑包（package）与目录来管理我们的Java项目或是更高级一点的则是使用ant这样的构建工具。作为Javaer，对于Java的编译过程应当是熟悉的，这样即使脱离了IDE我们依然能够很好的理解Java的构建过程。</p>\n<a id=\"more\"></a>\n<p>初级</p>\n<p>我们首先建立一个基础的项目文件夹java-demo，并在其中建立Main.java文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim Main.java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tips:</span><br><span class=\"line\">在Java中，.java文件中至多有一个共有类，并且文件名和改共有类相同，如果没有共有类，则任选一个类名作为文件名即可。</span><br></pre></td></tr></table></figure><br>完成了我们的编辑工作之后，我们使用javac命令进行编译工作：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> javac -d . ./Main.java</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">Main.class Main.java</span><br><span class=\"line\">tips:上述的-d .表示在当前目录下生成class文件</span><br></pre></td></tr></table></figure><br>之后我们可以使用java命令运行得到的.class文件（不需要带.class文件后缀）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> java Main</span></span><br><span class=\"line\">Hello</span><br></pre></td></tr></table></figure><br>初级++</p>\n<p>在上述的示例中，我们并没有在代码中对我们的Java程序打包（package xxx;），我们知道Java中对程序进行package有很重要的意义：能够模块化程序，通过定义不同的包来实现模块化的开发，同时也能够帮助其他接手或者学习代码的人能够有很好的引导作用，能够明白整个Java项目模块的分布。</p>\n<p>所以我们现在需要在代码中定义包，从而模块化我们的代码，这里我们在Main.java代码的第一句加上这样一句代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> src.main;</span><br><span class=\"line\">tips: 这句话代表了我先要把该Main类定义在包src包中的main包中</span><br></pre></td></tr></table></figure><br>然后我们删除刚刚编译过的class文件，为了之后的生成class文件的删除方便，我们在java-demo文件夹下创建一个target文件夹，为以后的class文件的生成目标文件夹。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前工作目录以及文件结构如下：</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">xxx/java-demo</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 目录结构</span></span><br><span class=\"line\">./</span><br><span class=\"line\">├── Main.java</span><br><span class=\"line\">└── target</span><br></pre></td></tr></table></figure><br>接着我们重新编译<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> javac -d ./target Main.java</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\">Main.java target</span><br><span class=\"line\">进入target目录之后，我们可以看到如下的结构：</span><br><span class=\"line\">./</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        └── Main.class</span><br></pre></td></tr></table></figure><br>我们可以看到，即使我们并没在原先的工作目录下创建src/main/Main.java这样的源码结构，只是在代码中定义了逻辑上的src.main，在javac之后，java会为我们自动生成这样的目录结构。</p>\n<p>接下来我们通过java命令运行Main.class。这里有很重要的一点，通过我们上面的代码定义，<strong>我们最终生成的是一个名为src.main.Main类，不是单纯的名为Main类</strong>，不能像上面java Main那样去直接运行这个Java程序，同时我们应当在目标类生成的根目录下去运行java命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在target目录下</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> java src.main.Main(或者java src/main/Main)</span></span><br><span class=\"line\">Hello</span><br></pre></td></tr></table></figure><br>即使我们进入到了target/src/main目录中（只要不是target/这样的目标根目录），直接使用java Main或者是java src.main.Main都是不行的。前者会提示：“错误: 找不到或无法加载主类 Main”， 原因就是我们定义是一个src.main.Main的类，很显然这里没有类名为Main的类；后者会提示：“错误: 找不到或无法加载主类 src.main.Main”，原因则是当我们使用java命令去运行譬如src.main.Main等在非默认包下的类时，java命令会自动将src.main.Main转换为 <strong>$classpath/</strong> src/main/Main这样路径下的类文件，而你有没有定义classpath，那么java会在当前（这个例子就是main目录类），再找src/main/Main类，这里当然没有，所以报错。诚然，你可以在使用java命令时通过-classpath来指定类加载根路径，但是这样显然没有直接在类编译根目录下来的直接。</p>\n<p>（初级++）++</p>\n<p>目前为止，我们只讨论了只有一个类的情况，当我们在一个类中通过import来引入其他类的时候，又该注意什么呢？</p>\n<p>首先我们重构整个文件目录结构如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx/java-demo</span><br><span class=\"line\">    ├── dir1</span><br><span class=\"line\">    │   └── Main.java</span><br><span class=\"line\">    ├── dir2</span><br><span class=\"line\">    │   └── Sub.java</span><br><span class=\"line\">    └── target</span><br></pre></td></tr></table></figure><br>首先在Sub.java中我们编写如下的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> myutil;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态工具方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printWithFormat</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&quot;</span> + str + <span class=\"string\">&quot;&lt;&lt;&lt;&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后编写Main.java中的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main;</span><br><span class=\"line\"><span class=\"comment\">// 引入Sub类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> myutil.Sub;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用Sub类中的静态方法</span></span><br><span class=\"line\">        Sub.printWithFormat(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这里我们定义了dir1、2两个文件加，虽然和Main类与Sub类中package的包名不同，但是，当我们在编译时，只要指定了正确目录下的对应的java类即可，就像我们可以进入dir1类中使用如下命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">xxx/java-demo/dir1</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> javac -d ../target/ ./Main.java ../dir2/Sub.java <span class=\"comment\"># 自行理解对应文件的位置关系</span></span></span><br></pre></td></tr></table></figure><br>接着我们查看对应的target下生成的class文件：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target/</span><br><span class=\"line\">├── main</span><br><span class=\"line\">│   └── Main.class</span><br><span class=\"line\">└── myutil</span><br><span class=\"line\">    └── Sub.class</span><br></pre></td></tr></table></figure><br>同样的，我们按照<strong>初级++</strong>中提到的，在根目录下，使用java main.Main命令，可以看到，没有问题：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> java main.Main</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt;Hello&lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure><br>关于java编译运行的路径相关的注意点大致就讲这些，以后会继续补充相关的更多的注意点。</p>\n","categories":[],"tags":["Java","Javac"]},{"title":"macOS下Java与JDK关系与相关路径","url":"http://compilemind.com/2018/03/15/2018-03-15-macOS下Java与JDK关系与相关路径/","content":"<p>macOS下的Java与JDK的路径曾经困扰过我一段时间，今天稍有些忘记，故记下笔记，整理一下。Java与JDK的关系不在本文笔记之内，Javaer常识。</p>\n<a id=\"more\"></a>\n<p><strong>偏好设置中的Java</strong></p>\n<p>在偏好设置中的Java是浏览器的插件，仅提供Java运行环境，其目录我们通过点击该Java图标，进入Java控制面板 —— Java —— 查看，可以显示对应的目录，本人的Java已经升级到了1.8_161，目录如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;Library&#x2F;Internet Plug-Ins&#x2F;JavaAppletPlugin.plugin&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;java</span><br></pre></td></tr></table></figure><br>通过/Library/Internet\\ Plug-Ins目录名称我们也可以知道这个Java是作为网络相关（如浏览器）的Applet插件的。再次强调，这个目录下的Java<strong>仅仅</strong>提供Java基础运行环境，进入bin中我们可以看到<strong>并没有</strong>javac，也可以说明这一点。</p>\n<p>所以，我们完全可以删除Internet  Plug-Ins文件夹下的JavaAppletPlugin.plugin这个文件夹，并且同时为了删除偏好设置中的图标，需要删除/Library/PreferencesPanes/JavaControlPanel.prefPane这个文件夹，看文件夹名不难理解。（理论上是这样的，但是没有必要删除）</p>\n<p><strong>通过oracle安装的jdk</strong></p>\n<p>当我们安装了oracle的jdk之后，我们在命令行中输入which java，通常会显示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;java</span><br></pre></td></tr></table></figure><br>进入/usr/bin中，查看该目录下java的详细信息，可以看到如下的信息：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls -l java</span></span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  74 11 11 15:08 java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</span><br></pre></td></tr></table></figure><br>可以看到这里的java是一个软链接，链接到上述输出目录中。我们进入到<strong>Versions</strong>目录中，这里我们只安装了一个版本的jdk，所以只会有如下的显示信息：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drwxr-xr-x  8 root  wheel  256  1 24 22:01 A</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel    1 11 11 15:05 Current -&gt; A</span><br></pre></td></tr></table></figure><br>可以看到，Current也只是一个软链接，链接到该目录下的A文件夹（这样的好处是装了多个版本java后，可以方便地调整Current指向，使得不同版本java变成系统默认的）</p>\n<p>我们可以看到，实际上这里面也还不是真正的jdk目录，A文件夹是安装java后系统生成的。它里面的Commands文件夹下有个java可执行文件，然而，我们可以看到这个目录下结构明显不是正常的jdk的目录结构，我们会发下这个目录下有一个java_home，使用如下命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./java_home -V</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">Matching Java Virtual Machines (1):</span><br><span class=\"line\">    1.8.0_121, x86_64:\t&quot;Java SE 8&quot;\t/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home</span><br></pre></td></tr></table></figure><br>上面是我机器上的输出，这个输出才是真正的jdk目录。所以在我看来，oracle安装过程应该是如下流程的：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.首先解压完整的JDK到</span><br><span class=\"line\">/Library/Java/JavaVirtualMachines/jdk&#123;version&#125;.jdk/Content/Home</span><br><span class=\"line\"></span><br><span class=\"line\">2.在/System/Library/Frameworks/JavaVM.framework/Versions/目录中</span><br><span class=\"line\"></span><br><span class=\"line\">  1)创建对应的A或者其他版本的文件夹（猜测是不同的JDK版本依次B、C、D之类的）</span><br><span class=\"line\"></span><br><span class=\"line\">  2)创建Current文件夹（已存在就忽略）并软链接到A或其他版本的文件夹上</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 从A中的Commands文件夹内容本人认为，这个文件夹就是用来协调jdk相关的资源的，比如java与javac，而这里面的java、javac一类的命令会去调用第一步中对应版本的jdk目录中的java、javac</span></span><br><span class=\"line\">3.将/usr/bin下的java、javac、javadoc等软链接到第二步中对应的bin上</span><br><span class=\"line\">ls -l /usr/bin/java*</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  74 11 11 15:08 /usr/bin/java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  75 11 11 15:08 /usr/bin/javac -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javac</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  77 11 11 15:08 /usr/bin/javadoc -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javadoc</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  75 11 11 15:08 /usr/bin/javah -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javah</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  75 11 11 15:08 /usr/bin/javap -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javap</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  82 11 11 15:08 /usr/bin/javapackager -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javapackager</span><br><span class=\"line\">lrwxr-xr-x  1 root  wheel  76 11 11 15:08 /usr/bin/javaws -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javaws</span><br></pre></td></tr></table></figure><br>根据上面的常识，我们也完全可以卸载oracle安装的Java，同时，我们可以将真正的Java目录提取出来，放置到我们需要的地方，通过设置环境变量的方式来设置JAVA_HOME。</p>\n","categories":[],"tags":["Java","macOS"]},{"title":"Linux Bash命令杂记(tr col join paste expand)","url":"http://compilemind.com/2018/03/13/2018-03-13-Linux Bash命令杂记(tr col join paste expand)/","content":"<a id=\"more\"></a>\n<p><strong>tr命令</strong></p>\n<p>tr命令可以将输入的数据中的某些字符做替换或者是作删除<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tr [-ds] STR</span><br><span class=\"line\">d: 删除输入数据的中的STR</span><br><span class=\"line\">s: 替换重复的字符</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例</span></span><br><span class=\"line\">last | tr &#x27;[a-z]&#x27; &#x27;A-Z&#x27;</span><br><span class=\"line\">将last输出的数据中的所有小写字符替换为大写字符</span><br><span class=\"line\">SPPU     UUZ1                          TVF MBS 13 18:45   TUJMM MPHHFE JO   </span><br><span class=\"line\">SFCPPU   TZTUFN CPPU  3.10.0-693.17.1. TVF MBS 13 18:45 - 18:47  (00:01)    </span><br><span class=\"line\">SPPU     UUZ1                          TVF MBS 13 10:55 - 13:15  (02:20)    </span><br><span class=\"line\">SFCPPU   TZTUFN CPPU  3.10.0-693.17.1. TVF MBS 13 10:54 - 18:47  (07:52)    </span><br><span class=\"line\">SPPU     UUZ1                          MPO MBS 12 18:33 - 19:35  (01:02)  </span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">cat /etc/passwd | tr -d &#x27;:&#x27;</span><br><span class=\"line\">将cat /etc/passwd输出的数据中的&#x27;:&#x27;全部删除</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">rootx00root/root/bin/bash</span><br><span class=\"line\">binx11bin/bin/sbin/nologin</span><br><span class=\"line\">daemonx22daemon/sbin/sbin/nologin</span><br><span class=\"line\">admx34adm/var/adm/sbin/nologin</span><br><span class=\"line\">lpx47lp/var/spool/lpd/sbin/nologin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br><strong>col命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">col [-xb]</span><br><span class=\"line\">-x: 将tab键替换为等长的空个</span><br><span class=\"line\">-b: 在文字内由反斜杠时，仅保留反斜杠后接的那个字符</span><br><span class=\"line\"></span><br><span class=\"line\">cat -A ~/.bashrc</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用cat -A可以讲输出中所有的特殊按键</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Source global definitions$</span></span><br><span class=\"line\">if [ -f /etc/bashrc ]; then$</span><br><span class=\"line\">^I. /etc/bashrc$</span><br><span class=\"line\"><span class=\"meta\">fi$</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意这里有个^I就是tab字符。</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat -A ~/.bashrc | col -x</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Source global definitions$</span></span><br><span class=\"line\">if [ -f /etc/bashrc ]; then$</span><br><span class=\"line\">    . /etc/bashrc$</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tab字符不再出现</span></span><br></pre></td></tr></table></figure>\n<p><strong>join命令</strong></p>\n<p>用于对两个文件按照某一个字符或者字段进行按行连接<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">join [-ti12] file1 file2</span><br><span class=\"line\">-t: 选择分割字符，并且对比“第一个字段”的数据，如果两个文件相同，则将两条数据连成一行，并将第一个字段放在最前</span><br><span class=\"line\">-i: 忽略大小写</span><br><span class=\"line\">-1: 表示第一个文件</span><br><span class=\"line\">-2: 表示第二个文件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例1</span></span><br><span class=\"line\">head -n 3 /etc/passwd /etc/shadow</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先查看这两个文件前三行数据</span></span><br><span class=\"line\">==&gt; /etc/passwd &lt;==</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; /etc/shadow &lt;==</span><br><span class=\"line\">root:&lt;密码太长，我忽略了方便查看&gt;:17593:0:99999:7:::</span><br><span class=\"line\">bin:*:17110:0:99999:7:::</span><br><span class=\"line\">daemon:*:17110:0:99999:7:::</span><br><span class=\"line\"></span><br><span class=\"line\">join -t &#x27;:&#x27; /etc/passwd /etc/shadow | head -n 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash:&lt;密码太长，我忽略了方便查看&gt;:17593:0:99999:7:::</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin:*:17110:0:99999:7:::</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin:*:17110:0:99999:7:::</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">  我们可以看到，按照<span class=\"string\">&#x27;:&#x27;</span>分割，并且默认一第一个字段进行连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例2</span></span><br><span class=\"line\">我们知道/etc/passwd中第四个字段是GID，而/etc/group中第三个字段是GID，我们就可以像如下进行整合：</span><br><span class=\"line\">join -t &#x27;:&#x27; -1 4 /etc/passwd -2 3 /etc/group | head -n 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">0:root:x:0:root:/root:/bin/bash:root:x:</span><br><span class=\"line\">1:bin:x:1:bin:/bin:/sbin/nologin:bin:x:</span><br><span class=\"line\">2:daemon:x:2:daemon:/sbin:/sbin/nologin:daemon:x:</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 我们可以看到，将我们需要的字段提到了最前</span></span><br></pre></td></tr></table></figure><br><strong>paste命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">直接讲两个文件中的数据按行连接</span><br><span class=\"line\">paste [-d] file1 file2</span><br><span class=\"line\">-d: 设定每行数据连接的字符，默认为tab</span><br><span class=\"line\">paste /etc/passwd /etc/group | head -n 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash\troot:x:0:</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin\tbin:x:1:</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin\tdaemon:x:2:</span><br></pre></td></tr></table></figure><br><strong>expand命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expand [-t] file</span><br><span class=\"line\">-t: 后面接数字，代表了将一个tab替换为多少个空格键</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例</span></span><br><span class=\"line\">cat -A ~/.bashrc</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用cat -A可以讲输出中所有的特殊按键</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Source global definitions$</span></span><br><span class=\"line\">if [ -f /etc/bashrc ]; then$</span><br><span class=\"line\">^I. /etc/bashrc$</span><br><span class=\"line\"><span class=\"meta\">fi$</span></span><br><span class=\"line\">注意看有个^I，是tab符号</span><br><span class=\"line\">cat -A ~/.bashrc | expand -t 10 -(标准输入) | cat -A</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Source global definitions$</span></span><br><span class=\"line\">if [ -f /etc/bashrc ]; then$</span><br><span class=\"line\">          . /etc/bashrc$</span><br><span class=\"line\"><span class=\"meta\">fi$</span></span><br><span class=\"line\">我们可以看到原先的tab变为了10个空格</span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Linux","Bash"]},{"title":"Linux Bash命令杂记(cut sort uniq wc tee)","url":"http://compilemind.com/2018/03/12/2018-03-12-Linux Bash命令杂记(cut sort uniq wc tee)/","content":"<a id=\"more\"></a>\n<p><strong>数据流重定向</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">标准输入（stdin）：代码为0，使用&lt;或&lt;&lt;；</span><br><span class=\"line\">标准输出（stdout）：代码为1，使用&gt;或&gt;&gt;；</span><br><span class=\"line\">标准错误输出（stderr）：代码为2，使用2&gt;或2&gt;&gt;；</span><br><span class=\"line\">&gt;：覆盖的方式，&gt;&gt;：追加的方式</span><br></pre></td></tr></table></figure>\n<p>如果想要一般输出与错误输出同时输入到某一个文件，如果采取如下的方式进行输出是错误的：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出数据  1&gt; list 2&gt; list</span><br></pre></td></tr></table></figure><br>如果按照上面的方式输出到list文件中时而没有采用特殊的语法，会因为两个输出进程的同步问题，导致正确的数据与错误的数据可能会交叉的输入到list文件中。正确的方式应该如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出数据 &gt; list 2&gt;&amp;1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 或者是</span></span><br><span class=\"line\">输出数据 &amp;&gt; list</span><br></pre></td></tr></table></figure><br><strong>命令执行&amp;&amp; ||</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd1 &amp;&amp; cmd2</span><br><span class=\"line\">若cmd1执行完毕且正确执行($?&#x3D;&#x3D;0)，则执行cmd2</span><br><span class=\"line\">若cmd1执行完毕且错误执行($?!&#x3D;0)，则不执行cmd2</span><br><span class=\"line\"></span><br><span class=\"line\">cmd1 || cmd2</span><br><span class=\"line\">若cmd1执行完毕且执行正确($?&#x3D;&#x3D;0)，则不执行cmd2</span><br><span class=\"line\">若cmd1执行完毕且执行错误($?!&#x3D;0)，则执行cmd2</span><br></pre></td></tr></table></figure><br><strong>cut命令</strong></p>\n<p>cut命令按行数据进行处理，常用的方式如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">参数 -d -f（组合使用）</span></span><br><span class=\"line\">输出数据 | cut -d &#x27;分个字符&#x27; -f fields</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例</span></span><br><span class=\"line\">str=ni:hao:ma:?</span><br><span class=\"line\">echo $str | cut -d &#x27;:&#x27; -f 2</span><br><span class=\"line\">表示将echo出的str字符串按照&#x27;:&#x27;字符分割，且取第2个字段</span><br><span class=\"line\">得到的结果是</span><br><span class=\"line\">hao</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 补充</span></span><br><span class=\"line\">-f 1,3 代表取第1和第3字段，输出 ni:man</span><br><span class=\"line\">-f 1-3 取1到3字段，输出 ni:hao:ma</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 参数 -c</span></span><br><span class=\"line\">输出数据 | cut -c 字符范围</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例</span></span><br><span class=\"line\">str=hello</span><br><span class=\"line\">echo $str | cut -c 1</span><br><span class=\"line\">输出</span><br><span class=\"line\">h</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 补充</span></span><br><span class=\"line\">-c 1-，输出 hello</span><br><span class=\"line\">-c 1-3，输出 hel</span><br></pre></td></tr></table></figure><br><strong>sort命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head -4 /etc/passswd</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class=\"line\">我们可以看到并没有按照首字母排序</span><br><span class=\"line\"></span><br><span class=\"line\">head -4 /etc/passwd | sort</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">我们可以看到已经按照首字母排序了</span><br><span class=\"line\"></span><br><span class=\"line\">同样，我们可以指定想按照哪一个字段来排序，</span><br><span class=\"line\">head /etc/passwd | sort -t &#x27;:&#x27; -k 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 不看前4行了，准备输出所有行</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将输出按照类型<span class=\"string\">&#x27;:&#x27;</span>分割(-t <span class=\"string\">&#x27;:&#x27;</span>)，并且取第3个字段(-k 3)</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 然而此时的字段依然是按照字符进行，如本测试机上输出的结果注意看第二行：</span></span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意第三个字段，11跑到了2前面去了，因为字符串11排在2前面</span></span><br><span class=\"line\">此时我们需要加上 -n 参数提示按照数字进行</span><br><span class=\"line\">head /etc/passwd | sort -t &#x27;:&#x27; -k 3 -n</span><br></pre></td></tr></table></figure><br><strong>last命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 该命令用来列出目前与过去登录系统的用户相关信息</span></span><br><span class=\"line\">last</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">root     tty1                          Mon Mar 12 18:33   still logged in   </span><br><span class=\"line\">reboot   system boot  3.10.0-693.17.1. Mon Mar 12 18:33 - 19:02  (00:29)    </span><br><span class=\"line\">root     tty1                          Sat Mar 10 20:18 - 20:18  (00:00)    </span><br><span class=\"line\">reboot   system boot  3.10.0-693.17.1. Sat Mar 10 20:18 - 20:18  (00:00)    </span><br><span class=\"line\">root     tty1                          Fri Mar  9 19:10 - 20:50  (01:40)    </span><br><span class=\"line\">...</span><br><span class=\"line\">其中：</span><br><span class=\"line\">第一列：用户名</span><br><span class=\"line\">第二列：终端位置。(pts/0通过ssh或者telnet远程连接的用户，tty：直接连接到计算机或者本地用户)</span><br><span class=\"line\">第三列：登陆IP或者内核（看到0.0或者什么都没有，意味着用户通过本地终端连接，除了重启，内核版本会显示在状态中）</span><br><span class=\"line\"></span><br><span class=\"line\">第四列：开始时间(如：sun apr 3 ：四月三号星期天)</span><br><span class=\"line\">第五列：结束时间（still login in 还未退出，down：直到正常关机，crash：直到强制关机）</span><br><span class=\"line\">第六列:持续时间</span><br></pre></td></tr></table></figure><br><strong>uniq命令</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">last | cut -d &#x27; &#x27; -f 1 | sort | uniq</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先取用户名，然后排序，最后去重</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">reboot</span><br><span class=\"line\">root</span><br><span class=\"line\">wtmp</span><br><span class=\"line\">zhen</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 加上 -c 显示统计</span></span><br><span class=\"line\">last | cut -d &#x27; &#x27; -f 1 | sort | uniq -c</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">1</span><br><span class=\"line\">27 reboot</span><br><span class=\"line\">26 root</span><br><span class=\"line\">1 wtmp</span><br><span class=\"line\">3 zhen</span><br></pre></td></tr></table></figure>\n<p>务必注意，uniq命令是通过叠加去重<strong>相邻</strong>的字符串，如果你不首先进行排序，那么会出现下面的情况：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">      1 zhen</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 reboot</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br><strong>wc命令</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc [-lwm]</span><br><span class=\"line\">-l: 仅列出行</span><br><span class=\"line\">-w: 仅列出多少个英文单词</span><br><span class=\"line\">-m: 仅列出多少个字符</span><br><span class=\"line\">head /etc/passwd | wc</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\">  10  10  385</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 分别代表行数，词数，字符数（这里10个“词”应该是因为每一行没有空格的原因，wc统计是按空格来分词的）</span></span><br></pre></td></tr></table></figure><br><strong>tee双向重定向</strong></p>\n<p>由前面的数据流我们可以知道，我们在将数据定向时，如果不采取特殊的操作，数据要么输出到屏幕，要么输出到文件或者是设备中，没有办法，既输出到屏幕有输出到文件中；又或者是，我们想要对数据进行处理存放到一个文件中，但是同时对原始数据又存到另一个文件中。使用tee命令，我们就可以做到。</p>\n<p>例如，我们使用last命令首先要把数据存放到last.log中，同时要对用户去重并输出到屏幕上：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">last | tee [-a 追加] last.log | cut -d &#x27; &#x27; -f 1 | sort | uniq</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> output</span></span><br><span class=\"line\"></span><br><span class=\"line\">reboot</span><br><span class=\"line\">root</span><br><span class=\"line\">wtmp</span><br><span class=\"line\">zhen</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 同时我们打开last.log文件可以看到没有做任何处理的原始数据</span></span><br><span class=\"line\">root     tty1                          Mon Mar 12 18:33   still logged in   </span><br><span class=\"line\">reboot   system boot  3.10.0-693.17.1. Mon Mar 12 18:33 - 19:29  (00:56)    </span><br><span class=\"line\">root     tty1                          Sat Mar 10 20:18 - 20:18  (00:00)    </span><br><span class=\"line\">reboot   system boot  3.10.0-693.17.1. Sat Mar 10 20:18 - 20:18  (00:00)    </span><br><span class=\"line\">root     tty1                          Fri Mar  9 19:10 - 20:50  (01:40)    </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Linux","Bash"]},{"title":"Spring自动装配歧义性笔记","url":"http://compilemind.com/2018/03/11/2018-03-11-Spring自动装配歧义性笔记/","content":"<a id=\"more\"></a>\n<p><a href=\"/2018/03/10/Spring-Bean装配笔记/\">前情提要</a>，如果系统中存在两个都实现了同一接口的类，Spring在进行@Autowired自动装配的时候，会选择哪一个？如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一下两个类均被标记为bean</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CD is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Video</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Video is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//配置类仅打开自动扫描</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;zhen&quot;</span></span><br><span class=\"line\"><span class=\"meta\">public class MyConfig &#123;</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">//测试类</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = MyConfig.class)</span></span><br><span class=\"line\"><span class=\"meta\">public class MyConfigTest &#123;</span></span><br><span class=\"line\"><span class=\"meta\">    @Autowired</span></span><br><span class=\"line\"><span class=\"meta\">    Playable playable;</span></span><br><span class=\"line\"><span class=\"meta\">    @Test</span></span><br><span class=\"line\"><span class=\"meta\">    public void checkNULL() &#123;</span></span><br><span class=\"line\"><span class=\"meta\">        Assert.assertNotNull(playable);</span></span><br><span class=\"line\"><span class=\"meta\">    &#125;</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>此时再次运行测试类会发现，FAILD并且报错：</p>\n<p>Unsatisfied dependency expressed through field ‘playable’; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘zhen.Playable’ available: <strong>expected single matching bean but found 2: CD,video</strong> //  找到了两个都bean都能匹配</p>\n<p><strong>自动装配歧义性问题</strong></p>\n<p>上面的异常就是出现了歧义性。Spring为我们扫描了我们代码中的bean（这个部分是没有问题的），但是，在自动装配的过程中却由于歧义性而报错，并且，造成这样的歧义性还有由于Autowired这个注解仅仅按照类型进行装配——上面的CD与Video都实现了Playable接口，Autowired注解仅告诉Spring在测试类中的playable接受一个Playable类型的对象但是这里有两个bean：CD、video都是Playable类型的，所以Spring不知道。</p>\n<p>为了解决这个问题，我们需要通过一定的手段来限定：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">声明首选的bean</span><br><span class=\"line\">限定自动转配的bean</span><br></pre></td></tr></table></figure><br><strong>声明首选的bean</strong></p>\n<p>根据名字我们很容易理解，就是声明在有歧义性情况下，Spring到底选择哪一个bean来装配。方式就是在bean组件下添加@Primary注解,例如在原先的CD的@Component下加上首选注解，再次运行测试代码，PASS。但是，这种方式通常只在同类型bean较少的或者是系统简单的情况使用，而且还存在一个情况：假如目前有两位开发人员，在各自的环境编写bean，他们都希望自己的bean是Primary的，都加该注解，实际上还是会报错，因为系统现在同样有两个Primary bean，Spring还是不能判断选择哪一个bean注入。</p>\n<p><strong>限定自动装配的bean——@Qualifier注解</strong></p>\n<p>首先，我们可以通过在@Component中加入字符串来更明确的指定bean id而不是使用Spring的默认bean id策略。就像如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;myCD&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Component(&quot;myVideo&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Video</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当这样指定以后，我们在自动转配的地方，使用@Qualifier(“指定id”)来限定我们要注入的确定的bean：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"meta\">@Qualifier(&quot;myCD&quot;)</span></span><br><span class=\"line\">  Playable playable;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>再次运行不会报错。</p>\n<p>关于@Qualifier，最佳的情形应该是来标记bean特性。但是，如果多个bean都有相同的特性，都是用了相同的标记的@Qualifier注解，那么同样又会出现歧义性问题。所以我们又要添加新的@Qualifier注解来进一步限定，这样做没有问题，但是Java语法规定，不允许在同一条目上重复出现相同类型的多个注解。你<strong>不能</strong>这么做：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译器会报错</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;myCD&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Qaulifier(&quot;JayChou&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为了结局这样的问题，我们可以创建自己的注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.TYPE, ElementType.METHOD&#125;)</span> <span class=\"comment\">//字段注解  </span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span> <span class=\"comment\">//在运行期保留注解信息</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span> <span class=\"comment\">// 需要使用@Qualifier注解来限定</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MyCD &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> JayChou &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如此定义了注解以后，我们就可以在原先的@Component下如下定义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@MyCD</span></span><br><span class=\"line\"><span class=\"meta\">@JayChou</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>并且在测试类下如下声明：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@MyCD</span></span><br><span class=\"line\"><span class=\"meta\">@JayChou</span></span><br><span class=\"line\">Playable playable;</span><br></pre></td></tr></table></figure><br>测试通过！</p>\n","categories":[],"tags":["Spring","Bean"]},{"title":"Spring Bean装配笔记","url":"http://compilemind.com/2018/03/10/2018-03-10-Spring Bean装配笔记/","content":"<p>Spring中的Bean是一个很重要的概念。Spring作为一个Bean容器，它可以管理对象和对象之间的依赖关系，我们不需要自己建立对象，把这部分工作全部转交给容器完成，具有低耦合，对代码没有侵略性。</p>\n<a id=\"more\"></a>\n<p>目前本人的水平还不足以透彻的分析Spring是如何来构建Bean的装配的概念的，这里仅来记录总结Spring中多种Bean的装配方式。</p>\n<p>Spring的配置方式有Java类配置形式与XML配置两种形式。大致提一下，不赘述，如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java类config形式，需要@Configuration注解来声明</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 类路径下的XML形式</span></span><br><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;beans ...&gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><br>Spring提供了三种装配机制：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">隐式的bean发现机制和自动装配</span><br><span class=\"line\">在Java中进行显示配置</span><br><span class=\"line\">在XML中进行显示配置</span><br></pre></td></tr></table></figure><br><strong>隐式的bean发现机制和自动装配</strong></p>\n<p><strong>隐式bean发现与自动装配即我们完全不必在配置类或者配置文件中定义bean属性（但是这两者必要提供一种）。</strong> 如何定义一个Java类是bean？我们可以在类上使用@Component注解声明一个bean。<br>首先定义一个接口：Playable<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下来，我们定一个CD类，实现该接口，并添加@Component注解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CD is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如此定义，即可表明CD是一个bean。接下来如何开启扫描？</p>\n<p>如果使用Java类配置的方式来配置Spring，我们可以使用@ComponentScan注解在配置类上，告诉Spring开启了组建扫描。并且进行形如如下的bean配置：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"comment\">// 务必注意此处的自动扫描的基础包</span></span><br><span class=\"line\"><span class=\"comment\">// 因为通常配置类与其他类的包在不同的地方</span></span><br><span class=\"line\"><span class=\"comment\">// 默认的包路径是当前配置类所在包下</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(backPakages = &quot;xxx&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果使用XMl来定义，则如下定义：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span></span></span><br></pre></td></tr></table></figure><br>接下来编写测试类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = MyConfig.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfigTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    Playable playable; <span class=\"comment\">// 运行时，将扫描到的在容器中的CD bean装配到这里的playable</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkNULL</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Assert.assertNotNull(playable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果自然是PASS</span></span><br></pre></td></tr></table></figure></p>\n<p>这里在配置类中我们完全没有定义任何的bean，Spring自动为我们扫描出对应的组件进行自动装配（Autowired）到测试类中。</p>\n<p>CD这个类过于简单了，现在重构CD，使其拥有一个title属性，用以表示CD的名字。如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CD</span><span class=\"params\">(String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CD:&quot;</span> + title + <span class=\"string\">&quot; is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果我们再次运行测试代码，会发现报错：</p>\n<p>Unsatisfied dependency expressed through constructor parameter 0;// 大意是提示我们，CD这个类没有默认的参数个数为0的构造器。这里我们大致可以猜测，Spring在进行普通的构建对象时，是调用的该类的默认构造函数，在Java中我们知道，在一个类中若定义了任意形式的构造函数，原先的默认无参构造函数自然失效，而我们定义了有参数的构造函数，所以这里Spring调用不了无参构造函数，顾不能为我们构造这个bean。解决办法就是添加一个无参构造函数。</p>\n<p>但是问题还没有彻底解决，这里Spring只是为我们创建了一个title没有初始化的CD实例对象，我们应该如何去初始化这个title呢？注入的是一个普通的对象，我们同样可以使用@Autowired注入，但是这里只是一个字面量String，如何注入？其实我们可以采用一种更加直观的方式来注入——<strong>显式配置</strong></p>\n<p><strong>通过显式配置</strong></p>\n<p>配置类形式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;zhen&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">Playable <span class=\"title\">cd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CD(<span class=\"string\">&quot;JayChou&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面通过@Bean来声明下面我们将要定义一个bean，紧接着定义一个方法，返回值为Playable（这里没有严格的要求是接口类还是本身实现类，满足语法即可），方法名即为该bean对应的id，参数虽没有定义，但是不代表不能有，这里可以注入其它的bean。方法体中的内容自然是返回具体的实现类了，然而这里就很灵活，我们可以将字符串通过这里构造函数传入，假如我们的CD类中如果有setTitle方法，甚至还可以像下面这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\">Playable <span class=\"title\">cd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CD cd = <span class=\"keyword\">new</span> CD(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    cd.setTitle(<span class=\"string\">&quot;JayChou&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>配置文件XML如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cd&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;zhen.CD&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;JayChou&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br>对比上面的两种显示注入的用法，对应也是很清楚的，Java类中的方法名即为bean id，返回对象对应的类即为XML中的class属性。同时，根据构造函数参数类型的不同，也有不同的形式，这里本篇笔记不多提，以后会有相关的笔记探讨的。</p>\n<p>但是请注意，如果Java类配置文件中已经有一个@Bean，同时还启动了自动扫描，在原先的组件类上添加了@Component注解，Spring是会我们创建两个同为CD类实例bean的。如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意已经添加了@Component注解</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">Playable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title = <span class=\"string\">&quot;Default Title&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//  定义一个可以设置的title的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTitle</span><span class=\"params\">(String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;CD:&quot;</span> + title + <span class=\"string\">&quot; is playing...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//配置类中开启了组建扫描，且也定义了一个bean</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;zhen&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">Playable <span class=\"title\">cd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CD cd = <span class=\"keyword\">new</span> CD();</span><br><span class=\"line\">        cd.setTitle(<span class=\"string\">&quot;JayChou&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在测试类不变的情况下，运行测试代码，会报错：</p>\n<p>No qualifying bean of type ‘zhen.component.Playable’ available: expected single matching bean but found 2: CD,cd</p>\n<p>这行报错告诉我们，发现了两个bean：CD cd都满足Playable，都可以注入到此处。 <strong>（注意，如果一个类有@Component组件注解，该类的bean id默认为类名首字母小写，这里CD由于其本身两个字母都是大写，Spring所以给其的默认名没有将首字母小写，一定注意命名特殊性）</strong> 到底该选谁呢？如果我们不指定，Spring也不能为我们做主。如果我们将测试类中的Playable playable改为Playable cd 或者 CD，如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = MyConfig.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfigTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"comment\">// 为了配合下面输出title进行验证</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里我将类型改为了CD，且CD类中的私有title我修改为了公有</span></span><br><span class=\"line\">    CD cd;</span><br><span class=\"line\">    <span class=\"comment\">// CD CD;</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkNULL</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(cd.title); <span class=\"comment\">// 输出 “CD:JayChou is playing...”</span></span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(CD.title); // 输出 &quot;CD:Default String is playing...&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 下面均通过</span></span><br><span class=\"line\">        Assert.assertNotNull(cd);</span><br><span class=\"line\">        <span class=\"comment\">// Assert.assertNotNull(CD);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>由上面的现象，我们可以推测Spring在注入的时候，首先根据@Autowired下面的引用名来查找对应类型的bean id，如果没有，再找同类型的bean（这里要补充一下，@Autowired是根据类型来匹配注入的）</p>\n<p>以上笔记大致总结了一下Spring bean装配问题，然而还有问题没有解决：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面提到过的报错，Spring如果找到了多个同类型的bean会提示报错，在没有声明的情况下，Spring不知道到底改选哪一个，这就是自动装配的歧义性问题。</span><br></pre></td></tr></table></figure><br>以上两个问题，我会继续做笔记的。</p>\n","categories":[],"tags":["Spring","Bean"]},{"title":"Linux下关于用户账户的几个文件解析","url":"http://compilemind.com/2018/03/09/2018-03-09-Linux下关于用户账户的几个文件解析/","content":"<p>Linux是一个多用户系统，但是对于一个多用户共存的系统中，当然不能够出现用户相互越权等一系列的安全问题，所以如何正确的管理账户成为了Linux系统中至关重要的一环。</p>\n<a id=\"more\"></a>\n<p>在Linux下，与用户账户有着紧密联系的文件又如下的几个：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/passwd   #管理用户的UID、GID等重要用户信息</span><br><span class=\"line\">/etc/shadow   #管理用户密码的等重要信息</span><br><span class=\"line\">/etc/group    #管理用户组</span><br><span class=\"line\">/etc/gpasswd  #管理用户组密码</span><br></pre></td></tr></table></figure>\n<p><strong>1./etc/passwd</strong></p>\n<p>虽说这个文件的文件名写着passwd，但是里面并没有存放密码（早起存放，后来为了安全将密码分离出来）</p>\n<p>打开该文件，里面的内容大致如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>上面的每一行代表了存在你系统中的一个用户。按照“:”来进行字段的划分，可以划分为7个字段，从左到右依次如下意义：</p>\n<ul>\n<li><strong>账号名称（1）</strong>。用以来对应UID，例如上面的第一行root。</li>\n<li><strong>密码位（2）</strong>。早期的该字段的确用来存放密码，但是这个文件特性是所有程序都能读取，为了安全起见，后来将密码放置在了/etc/shadow中了，所以这里只有一个“x”。</li>\n<li><strong>UID（3）</strong>。用户标识，在Linux中，该UID是整数。且多个账号可以对应一个UID，因为Linux系统内核只认UID的。不同的区间有不同的意义：<br>0（系统管理员）。如果你希望其他的某些账号也是系统管理员，可以讲其UID修改为0。（极度不推荐，一是安全性，二是UID还与多处文件及系统有关联，单一修改往往设置不全会出问题）<br>1～499。保留给系统账户使用的ID，不强制，只是一个习惯。<br>500～2^32-1。给一般用户使用的。</li>\n<li><strong>GID（4）</strong>。这个与/etc/group有关，即与用户组相关，后续会提到。</li>\n<li><strong>用户信息说明（5）</strong>。没有重要用途，单纯作简单描述。</li>\n<li><strong>主文件夹（6）</strong>。例如上面的/root目录，当root登陆以后，直接进入root的主目录中。当然你可以进行个性化配置。</li>\n<li><strong>Shell（7）</strong>。当用户root登陆以后，会查找该字段并使用该字段指定的shell（这里是/bin/bash）。但这是里有一个特殊的shell（nologin）可以用来替代成让账号无法取得shell环境的登陆操作。譬如，你当然不希望一个在你Linux上的邮件账户来通过shell操作你的电脑。</li>\n</ul>\n<p>当然，如果记不住的话，可以使用finger命令与id命令，例如：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finger root</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出如下：</span></span><br><span class=\"line\">Login: root           \t\t\tName: root</span><br><span class=\"line\">Directory: /root                    \tShell: /bin/bash</span><br><span class=\"line\">On since Fri Mar  9 19:10 (CST) on tty1   7 seconds idle</span><br><span class=\"line\">Mail last read Sat Mar  3 15:58 2018 (CST)</span><br><span class=\"line\">No Plan.</span><br><span class=\"line\"></span><br><span class=\"line\">id root</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出如下：</span></span><br><span class=\"line\">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><br>输出内容不在解释，十分 -h 了。</p>\n<p><strong>2./etc/shadow</strong></p>\n<p>打开该文件，内容大致如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:$6$tVBKdRxY$myJhWrhIwlXh42zNYLz1fmwu4ONQWP03O/5ccx1/34koU8GTn0M0ACx3xI4Bl.wPN3DPrrGbQX7vbPqqR//xv0:17593:0:99999:7:::</span><br><span class=\"line\">bin:*:17110:0:99999:7:::</span><br><span class=\"line\">daemon:*:17110:0:99999:7:::</span><br><span class=\"line\">adm:*:17110:0:99999:7:::</span><br></pre></td></tr></table></figure><br>shadow文件夹自然也以“:”作为分隔符，这里一共有9个字段，从左到右依次具有如下意义：</p>\n<ul>\n<li><strong>账号名称（1）</strong>。</li>\n<li><strong>密码（2）</strong>。该处使用了摘要加密技术，即不容易逆向破译，只可做验证。</li>\n<li><strong>最近改动密码的日期（3）</strong>。自1970年1月1日以来累加的天数。</li>\n<li><strong>密码不可被改动的天数（4）</strong>。相当于改密码的冻结天数。root中为0代表你随时可以更改，如果修改为20就代表了20天内不可修改。</li>\n<li><strong>密码需要重新更改的天数（5）</strong>。这里root行填写的99999代表了root的密码在99999天以内需要修改，可以理解为允许你永不更改。</li>\n<li><strong>密码需要更改前的警告天数（6）</strong>。这一字段与上一字段配合。例如，上一字段设置为了20，即希望你在20天要重新修改密码，这里设置为5，就代表了第15天到第20天之前你登录的时候会提示你洗修改密码。</li>\n<li><strong>密码过期后的账号宽限天数（7）</strong>。例如，在字段（5）设置为了20，即希望你在20天内要修改密码，但是你在20天以后都还没有修改，那么该密码就过期了（密码过期你的账户依然可以使用bash等，但是重新登录时系统会提醒你修改密码），在过期期间你还没有修改密码，那么这个账户就失效了，该账号再也无法使用该密码登录了。</li>\n<li><strong>账号失效日期（8）</strong>。同样基于1970年1月1号以来的天数，日期到了以后，该账号会直接失效，与账号是否过期无关。</li>\n<li><strong>保留（9）。</strong></li>\n</ul>\n<p><strong>3./etc/group</strong></p>\n<p>/etc/group文件中存放的是用户组的相关的信息，打开大致如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:x:0:root</span><br></pre></td></tr></table></figure><br>一共有四个字段：</p>\n<ul>\n<li><strong>用户组名称(1)</strong>。</li>\n<li><strong>用户组密码(2)</strong>。通常不需要设置，是给“用户组管理员”来使用的。</li>\n<li><strong>GID(3)</strong>。/etc/passwd中第四个字段使用GID就是对应于此的。</li>\n<li><strong>此用户组支持的账户名(4)</strong>。当我们想要将一个用户添加到该用户组时，就可以将其写在该字段中，使用“,“无空格连接。</li>\n</ul>\n<p><strong>4./etc/gpasswd</strong></p>\n<p>/etc/gpasswd文件中存放的是用户组没密码的相关信息，大致如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root:::root</span><br></pre></td></tr></table></figure></p>\n<p>同样有四个字段：</p>\n<ul>\n<li><strong>用户组名(1)</strong>。</li>\n<li><strong>密码(2)</strong>。</li>\n<li><strong>用户组管理员账号(3)</strong>。</li>\n<li><strong>该用户组所属账号(4)</strong>。</li>\n</ul>\n<p>当然，对于一个用户来说，当然可以在多个组当中。但是，当我们使用一个账户进行某些操作时，系统如何判断我们当前属于哪个组呢？例如，当前有个文件属性如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----r----- root group1  x.txt</span><br></pre></td></tr></table></figure><br>有一个用户名为user既属于group1又属于group2。那该用户到底能不能读取这个txt呢？</p>\n<p>其实这就涉及到了一个有效用户组与初始用户组两个概念了。使用groups命令，可以看到类似如下的输出（这里模拟有groups1、2两个组）：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groups</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出</span></span><br><span class=\"line\">groups1 groups2</span><br></pre></td></tr></table></figure><br>第一个就是有效用户。有效用户组意味着目前你身份是user，现在属于group1。所以你是可以读取那个txt的。如何进行切换呢？使用newgrp命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newgrp group2</span><br><span class=\"line\">groups</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出</span></span><br><span class=\"line\">group2 group1</span><br></pre></td></tr></table></figure><br>此时尝试读取x.txt会提示权限不足。</p>\n<p>那么初始用户组是什么呢？其实就是/etc/passwd中的GID对应的用户组，也是我们在登陆是的第一个用户组。</p>\n","categories":[],"tags":["Linux"]},{"title":"CentOS7下Hadoop伪分布式环境搭建","url":"http://compilemind.com/2018/03/08/2018-03-08-CentOS7下Hadoop伪分布式环境搭建/","content":"<a id=\"more\"></a>\n<p>前期准备</p>\n<p><strong>1.配置hostname(可选，了解)</strong></p>\n<p>在CentOS中，有三种定义的主机名:静态的（static），瞬态的（transient），和灵活的（pretty）。“静态”主机名也称为内核主机名，是系统在启动时从/etc/hostname自动初始化的主机名。“瞬态”主机名是在系统运行时临时分配的主机名，例如，通过DHCP或mDNS服务器分配。静态主机名和瞬态主机名都遵从作为互联网域名同样的字符限制规则。而另一方面，“灵活”主机名则允许使用自由形式（包括特殊/空白字符）的主机名，以展示给终端用户（如Linuxidc）。</p>\n<p>在CentOS7以前，配置主机的静态hostname是在/etc/sysconfig/network中配置HOSTNAME字段值来配置，而CentOS7之后若要配置静态的hostname是需要在/etc/hostname中进行。</p>\n<p>进入Linux系统，命令行下输入hostname可以看到当前的hostname，而通常默认的hostname是local.localadmin。</p>\n<p>本次试验环境在CentOS7下，所以我们编辑/etc/hostname文件，试验hostname为：hadoop.w4ng，填入其中，重启Linux，可以看到已经生效。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-08-hadoop-install/hostname.png\" alt=\"hostname.png\"></p>\n<p><strong>2.配置静态IP</strong></p>\n<p>同样，在CentOS7以后，其网卡配置已经有原先的/etc/sysconfig/network/network-scripts下面的ifcfg-eth0等改名为乐ifcfg-enpXsY（en表示ethnet，p表示pci设备，s表示soket）<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-08-hadoop-install/ll-network-scripts.png\" alt=\"ll-network-scripts.png\"><br>本人这里有两个ifcfg文件是因为配置了两块网卡<a href=\"http://blog.csdn.net/wangshfa/article/details/8813505\">分别做NAT以及与虚拟机Host-Only两个功能，实现双网卡上网</a></p>\n<p>打开ifcfg-enp0s8，配置如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEVICE=enp0s8 #设备名</span><br><span class=\"line\">HWADDR=08:00:27:10:6B:6B #硬件地址</span><br><span class=\"line\">TYPE=Ethernet #类型</span><br><span class=\"line\">BOOTPROTO=static #静态IP(必备)</span><br><span class=\"line\">IPADDR=192.168.56.88 #IP地址</span><br><span class=\"line\">NETMASK=255.255.255.0 #子网掩码</span><br><span class=\"line\">ONBOOT=yes #设备开机自动启动该网卡</span><br></pre></td></tr></table></figure><br><strong>3.配置hosts</strong></p>\n<p>打开/etc/hosts<br>配置为如下的：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class=\"line\">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class=\"line\">192.168.56.88   hadoop.w4ng</span><br></pre></td></tr></table></figure><br>配置hosts的理由是后期hadoop配置中相关的主机填写我们都是使用域名的形式，而IP地址与域名的转换在这里进行查询（还有DNS，但是这里不讨论）。</p>\n<p><strong>4.关闭防火墙</strong></p>\n<p>CentOS7与6的防火墙不一样。在7中使用firewall来管理防火墙，而6是使用iptables来进行管理的。<a href=\"https://www.cnblogs.com/silent2012/archive/2015/07/28/4682770.html\">当然，我们可以卸载7的firewall安装6的iptables来管理</a>。本人就切换回了6的防火墙管理方式。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]#servcie iptables stop  # 临时关闭防火墙</span><br><span class=\"line\">[root@localhost ~]#chkconfig iptables off # 永久关闭防火墙</span><br></pre></td></tr></table></figure><br><strong>5.JDK与Hadoop的安装</strong></p>\n<p><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\">下载JDK8</a><br><a href=\"http://hadoop.apache.org/releases.html\">下载Hadoop3-binary</a><br>下载完毕将文件传到主机中。</p>\n<p>在/usr/local/下创建java文件夹，并将JDK解压至该文件夹下。<br>在根目录下创建/bigdata文件夹，并将Hadoop解压至其中。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解压命令 tar -zxv -f [原压缩文件.tar.gz] -C [目标文件夹目录] # 实际命令没有中括号，其次，命令参数重-z对应gz压缩文件，若为bz2则使用-j</span><br></pre></td></tr></table></figure><br>在JDK解压完成后，在~/.bash_profile中配置环境变量 <a href=\"http://blog.csdn.net/field_yang/article/details/51087178\">点这里看/etc/bashrc、~/.bashrc、~/.bash_profile关系</a><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/usr/local/java/jdkx.x.x_xxx</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><br>配置完成，保存退出并 source ~/.bash_profile</p>\n<p>hadoop无需配置环境变量</p>\n<p><strong>6.配置hadoop</strong></p>\n<p>在hadoop的home下，进入etc文件夹，有五个主要的文件需要进行配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hadoop-env.sh</span><br><span class=\"line\">core-site.xml</span><br><span class=\"line\">hdfs-site.xml</span><br><span class=\"line\">mapred-site.xml</span><br><span class=\"line\">yarn-site.xml</span><br></pre></td></tr></table></figure><br>基本配置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.配置 hadoop-env.sh</span><br><span class=\"line\">export JAVA_HOME</span><br><span class=\"line\">#找到该处，填写上上面配置的JAVA_HOME，因为hadoop是基于Java的，需要Java的环境</span><br><span class=\"line\"></span><br><span class=\"line\">2.配置 core-site.xml</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;hdfs:&#x2F;&#x2F;hostnameXXX:9000&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">    &lt;!-- 配置hadoop文件系统目录 --&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;&#x2F;bigData&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">&lt;&#x2F;configuration&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">3.配置 hdfs-site.xml</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">&lt;&#x2F;configuration&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">4.配置 mapred-site.xml</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">&lt;&#x2F;configuration&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">5.配置 yarn-site.xml</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;yarn.resourecemanager.hostname&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;hostnameXXX&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">    &lt;property&gt;</span><br><span class=\"line\">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class=\"line\">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class=\"line\">    &lt;&#x2F;property&gt;</span><br><span class=\"line\">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><br>然后配置相关服务启动过程中需要的配置变量：<br>进入${HADOOP_HOME}/sbin中，在start-dfs.sh与stop-dfs.sh中添加字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HDFS_DATANODE_USER&#x3D;root</span><br><span class=\"line\">HDFS_DATANODE_SECURE_USER&#x3D;hdfs</span><br><span class=\"line\">HDFS_NAMENODE_USER&#x3D;root</span><br><span class=\"line\">HDFS_SECONDARYNAMENODE_USER&#x3D;root</span><br></pre></td></tr></table></figure><br>在start-yarn.sh与stop-yarn.sh中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YARN_RESOURCEMANAGER_USER&#x3D;root</span><br><span class=\"line\">HADOOP_SECURE_DN_USER&#x3D;yarn</span><br><span class=\"line\">YARN_NODEMANAGER_USER&#x3D;root</span><br></pre></td></tr></table></figure></p>\n<p>配置完成以后，进行hadoop的文件系统格式化，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;HADOOP_HOME&#125;&#x2F;bin&#x2F;hdfs namenode -format</span><br></pre></td></tr></table></figure><br>最后是启动服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行$&#123;HADOOP_HOME&#125;&#x2F;sbin&#x2F;start-all.sh  # 他会去调用start-dfs.sh与start-yarn.sh</span><br></pre></td></tr></table></figure></p>\n<p>根据配置中我们都是配置的root用户，显然需要我们以root身份进行，且过程中需要root密码。当然，通过ssh免密可以方便很多。启动完成以后，命令行中使用jps命令打印Java进程，会看到下图五个进程（忽略Jps进程）：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-08-hadoop-install/jps.png\" alt=\"jps.png\"><br>当然，Hadoop在服务启动以后以提供web端：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visit hdfs manage page</span><br><span class=\"line\">xxx.xxx.xxx.xxx:50070</span><br><span class=\"line\">visit yarn manage page</span><br><span class=\"line\">xxx.xxx.xxx.xxx:8088</span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Linux","Hadoop"]},{"title":"IntelliJ中Spring识别BUG","url":"http://compilemind.com/2018/03/07/2018-03-07-IntelliJ中Spring提示BUG/","content":"<p>最近开始学习Spring，在看《Spring实战4th》3.3“处理自动装配的歧义性”那一部分时，书上提到（也从网上看到了类似的用法）:<br>通过在一个类上加注@Component以及@Qualifier(“x”)可以为其配置限定符来标识区分同一个接口下的不同实现类，用以在需要进行@Autowired自动装配的地方使用@Qualifier(“x”)来指定特定的实现类对象bean。</p>\n<a id=\"more\"></a>\n<p>但是本人在练习过程中，IntelliJ通过上述方式识别不了，只能在@Bean处添加@Qualifier(“x”)，在后续的测试中才能识别。如下：</p>\n<p>在Dessert的实现类Cake上加上@Component以及@Qualifier(“Lovely”)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;Lovely&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cake</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dessert</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>然后是配置类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">Dessert <span class=\"title\">cake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cake();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">Dessert <span class=\"title\">iceCream</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IceCream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类中无法识别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(classes = JavaConfig.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlateTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;Lovely&quot;)</span> <span class=\"comment\">// IDEA 提示&quot;Cannot find bean with qualifier &#x27;Lovely&#x27; &quot;</span></span><br><span class=\"line\">    Dessert dessert;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testNotNull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Assert.assertNotNull(dessert);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，测试能PASS，应该是IntelliJ中的识别BUG。虽然是一个BUG，但是个人的理解是推荐在配置Bean中，进行限定，而不是在每一个类处进行限定。如下在JavaConfig类中进行配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;Lovely&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Dessert <span class=\"title\">cake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cake();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就不会出现报提示错。<br><strong>以上在运行过程均没有错误，只是IDE辅助出现了问题。</strong></p>\n","categories":[],"tags":["Spring","IntelliJ"]},{"title":"在macOS上通过虚拟机搭建基础CentOS7系统环境","url":"http://compilemind.com/2018/03/06/2018-03-06-在macOS上通过虚拟机搭建基础CentOS系统环境/","content":"<p>尽管从Mac的Terminal可以看出，macOS与UNIX、Linux或多或少都有血缘关系（shell、bash等），但是在mac进行Linux开发，或者把macOS直接当作Linux来使用依然是说不过去的，这其中包括一些命令行的使用，一些基本的文件夹体系等（如，在Linux上的/home目录与在macOS下的/Users）不一致。如果想要在macOS上进行Linux的学习，或者进行Linux开发，最完美的方案自然是安装虚拟机。</p>\n<a id=\"more\"></a>\n<h3 id=\"虚拟机的选择\"><a href=\"#虚拟机的选择\" class=\"headerlink\" title=\"虚拟机的选择\"></a>虚拟机的选择</h3><p>mac平台上的主流虚拟机有VMWare Fusion、Parallels Desktop、VrtualBox。前两者均是付费产品，价格虽不是很贵（参考JetBrains、Adobe系列），但是对于只是在Linux上进行学习或者是进行一些简单的开发颇有些大材小用了。所以，本次教程选择免费的VirtualBox进行搭建。</p>\n<p>地址：<a href=\"https://www.virtualbox.org/\">VirtualBox</a></p>\n<p>下载好以后，打开dmg双击pkg正常安装即可。</p>\n<ul>\n<li><p><strong>注意</strong></p>\n<p>VirtualBox在安装的时候需要安装内核扩展（Kernel extenstion）由于macOS 10.13 High Sierra的新安全特性会阻止外部内核扩展的安装，所以安装总是会被系统拦截，出现安装失败的情况，这时候打开“系统偏好设置 - 安全性与隐私”在界面下方会出现提示“来自Oracle America, Inc….”，点击“允许”再次安装即可。</p>\n</li>\n<li><p><strong>点击“允许”没反应？</strong></p>\n<p>本人安装VBox还有其他软件曾经出现过点击“允许”没有反应的情况，可能是macOS存在的一个BUG。此时首先关闭“安全性与隐私”，进入“系统偏好设置 - 键盘 - 快捷键”，选择“所有控制”，然后在此进入“安全性与隐私”，按tab键移动光标焦点到“允许”按钮处按空格键即可点击成功。</p>\n</li>\n</ul>\n<h3 id=\"Linux的选择\"><a href=\"#Linux的选择\" class=\"headerlink\" title=\"Linux的选择\"></a>Linux的选择</h3><p>本人选择CentOS 7作为本次的教程的Linux版本。</p>\n<p>官方地址：<a href=\"https://www.centos.org/\">CentOS</a></p>\n<p>在download界面我们可以看到三种iso镜像：</p>\n<ul>\n<li>DVD.iso 可以用安装程序安装的所有安装包。</li>\n<li>Everything.iso 包含centos7的一套完整的软件包，可以用来安装系统或者填充本地镜像。</li>\n<li>Minimal.iso 最小安装盘，只有必要的软件，自带的软件最少。（<strong>只有命令行界面</strong>）</li>\n</ul>\n<p>这里我们选择minimal，首先因为它是最精炼的一个，其次，一步一步定制我们的系统才能够更好的熟悉Linux系统。<br>下载好以后，打开VirtualBox安装CentOS系统。</p>\n<p><strong>开始安装</strong></p>\n<p>打开VirtualBox，点击“新建” - “专家模式”<br>按照如下的方式配置<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/create-v.png\" alt=\"create-v.png\"><br>内存大小会使用到你mac的运行时内存，请合理分配，这里我们分配1G内存<br>点击创建，进入下一步：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/create-v2.png\" alt=\"create-v2.png\"><br>创建完成之后界面如下（CentOS7是我们创建的）：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/create-v3.png\" alt=\"create-v3.png\"><br>由于我们只是为虚拟机分配了相关的空间以及配置，但是并没有将系统挂载，点击“启动”会提示我们选择镜像文件，点击右侧小图标来选择镜像文件：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/chooseimg-detail.png\" alt=\"chooseimg-detail\"><br>选择完毕，准备启动：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/chooseimg.png\" alt=\"chooseimg\"><br>接下来点击“start”，经过短暂的等待，我们进入到系统安装界面，我们点击该界面，直接进入虚拟机内部（mac上退出虚拟机操控请按 command 键），此时可以操作方向键来选择我们接下来的步骤，这里我们选择“Install CentOS 7”并回车：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/installUI.png\" alt=\"installUI\"><br>接下来我们会进入到一个鼠标操控极差的界面来安装我们的系统，这里我们选择中文语言来进行系统安装：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/chooseEn.png\" alt=\"chooseCN\"><br>选择过语言之后，会看到“安装位置”有红色警告提示是自动分区，这里CentOS已经为我们选择好了“自动分区”<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/installCentos.png\" alt=\"installCentos\"><br>此时只需要点击进去然后在左上角点击“完成”即可，只做一个确认即可：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/partition.png\" alt=\"partition\"><br>回到主界面我们可以点击“开始安装”进行安装了。这里还要说一下，在安装过程中，就像下面的图示，系统是一直在安装的，但是此时系统中只有一个没有设置密码的root用户，就连管理员用户也没有，这里<strong>需要</strong>你设置root用户密码，可以不配置新的管理员用户：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/installing.png\" alt=\"installing\"><br>密码设置短一点没有事儿，毕竟是练习机：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/setpasswd.png\" alt=\"setpasswd\"><br>然后完成配置<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/completeInstall.png\" alt=\"completeInstall\"><br>之后等待最后的收尾工作结束，点击“重启”，进入命令行界面（选择的minimal，只有命令行界面），选择第一个系统，登陆root用户：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/chooseFirst.png\" alt=\"chooseFirst\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/login.png\" alt=\"login\"><br>至此，虚拟机下Linux基本配置完成。</p>\n<h3 id=\"配置双网卡实现虚拟机-与主机（mac）与外网通信\"><a href=\"#配置双网卡实现虚拟机-与主机（mac）与外网通信\" class=\"headerlink\" title=\"配置双网卡实现虚拟机 与主机（mac）与外网通信\"></a>配置双网卡实现虚拟机 与主机（mac）与外网通信</h3><p>在上面的配置中，我们已经搭建好了一个最基本的，不具备网络通信的CentOS7操作系统，但是不能与外网通信，我们不能通过在线安装我们需要的软件，这样的单机操作系统用处是不大的。接下来我将介绍如何通过双网卡的方式来实现实现虚拟机 与主机（mac）与外网通信。</p>\n<h4 id=\"配置仅仅与主机通信的仅主机模式网卡\"><a href=\"#配置仅仅与主机通信的仅主机模式网卡\" class=\"headerlink\" title=\"配置仅仅与主机通信的仅主机模式网卡\"></a>配置仅仅与主机通信的仅主机模式网卡</h4><p>以下配置方式是不能与外网通信的，仅仅与主机通信，但好处在于我们可以使用静态IP地址，避免IP地址的变动。如果你没有这方面的需求，可以直接进入下一节。</p>\n<p>无论是哪一台计算机，要进行网络通信，都必须要至少有一块网卡来进行通信，当然，我们可以通过软件来虚拟出网卡，让这个虚拟的网卡获取IP来通信，更多的细节需要你有计算机网络的相关知识来支撑，这里不多提。这里既然我们需要让虚拟机中的系统来与我们的主机（mac）来通信，自然而然，需要让我们mac有一块网卡，虚拟机有一块网卡，让它们处于同一网段，这样一来，我们自然就实现了虚拟机与主机（mac）之间的通信。主机上怎么创建一块虚拟网卡呢？这里VirtualBox就可以帮我们实现。</p>\n<p>点击主界面上的“全局工具” - “主机网络管理器”，进入后点击“创建”（<strong>注意</strong>：这里可能会存在显示BUG，导致你点击创建之后没反应，<strong>请不要</strong>连续点击创建，点了一次之后切换一下画面），之后你就会在主机上（mac）创建一块用于和VirtualBox中的虚拟机进行通信的虚拟网卡：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/createHostNetworkUI.png\" alt=\"createHostNetworkUI\"><br>这里VBox自动为我们在mac主机上创建了一块名称为vboxnet0的网卡<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/createHostNetwork.png\" alt=\"createHostNetwork\"><br>我们进入mac终端，显示当前的所有的网卡信息也能看到这块网卡在我们的mac主机上已经创建成功了：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ifconfig</span></span><br><span class=\"line\">...</span><br><span class=\"line\">vboxnet0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class=\"line\">\tether 0a:00:27:00:00:00</span><br><span class=\"line\">\tinet 192.168.56.1 netmask 0xffffff00 broadcast 192.168.56.255</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 我们看到这块网卡已经有一个IP地址为192.168.56.1</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 要让我们的虚拟机与我们的主机通信，只要虚拟机中有一块我们主机在同一网段的网卡就行了</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br><strong>注意：请明确以上操作是为我们的主机mac，不是为我们的虚拟机创建网卡：）</strong></p>\n<p>接下来，我们可以通过VirtualBox给CentOS配置一块网卡，用于我们的虚拟机中的操作系统与我们的主机（mac）之间的通信，所以首先我们要配置一块“仅主机（Host-Only）网络”：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/host-only.png\" alt=\"host-only\"><br>我们可以看到，VirtualBox已经很智能的为我们选择了我们刚刚为主机mac创建的网卡。点击“OK”之后，我们虚拟机与主机之间的通信网卡配置完成（<strong>注意</strong>：仅仅是虚拟网卡配置好了，IP地址什么还没有配置）。接下来我们登录我们的虚拟机查看网卡的配置情况。<br>进入系统之后，我们使用命令ip addr来查看CentOS下的网卡配置情况（默认是没有ifconfig命令的，我们之后再装）<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ip_addr.png\" alt=\"ip_addr\"><br>注意查看此处第二块网卡，我们可以看到它的硬件地址是08:00…:3d，和我们上面的配置Host-Only处显示的硬件MAC地址是一样的，同时请记住这块网卡的名称。</p>\n<p><strong>配置网络</strong></p>\n<p>在CentOS7中，我们进入/etc/sysconfig/network-script目录，显示当前目录下的文件：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /etc/sysconfig/network-script</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ls</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在众多的配置文件中，我们应该是能够找到和我们上面ip addr命令中显示的那块网卡名称一样的带有“ifcfg-”前缀的配置文件</span></span><br><span class=\"line\">...</span><br><span class=\"line\">ifcfg-enp0s3</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br><strong>注意</strong>：在CentOS6.x及一下，网卡的命名规则和7不一样，相关的差别请自行搜索。</p>\n<p>接下来我们需要配置网卡的具体信息，由于我们选择的是minimal版本的CentOS，所以使用vi来打开编辑它：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vi ifcfg-enp0s3</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 同时为了配合上面的我们主机的IP网段，我们按照如下的方式来配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 类型=以太网</span></span><br><span class=\"line\">TYPE=Ethernet(默认)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设备名</span></span><br><span class=\"line\">DEVICE=enp0s3(默认)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">BOOTPROTO=dhcp(dhcp为自动分配ip地址,我们把他注释了，在下面另外加)</span></span><br><span class=\"line\">BOOTPROTO=static(新添加)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> IP地址</span></span><br><span class=\"line\">IPADDR=192.168.56.66(新添加)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 子网掩码</span></span><br><span class=\"line\">NETMASK=255.255.255.0(新添加)</span><br><span class=\"line\"></span><br><span class=\"line\">ONBOOT=yes(默认为no,修改为yes意为每次启动之后自动启动该网卡)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以上就是一个最精简的网卡配置文件</span></span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ifcfg.png\" alt=\"ifcfg\"><br>接下来reboot重启CentOS，重启之后通过ip addr再次查看我们网卡信息，也可以看到其网卡已经配置好了IP地址：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ipaddrNew.png\" alt=\"ipaddrNew\"><br>最后来进行测试，由于mac本身的安全防火墙是打开的，所以我们通过虚拟机（ip=192.168.56.66）去ping我们mac主机（ip=192.168.56.1）是ping不通的，我们只有在mac终端下去ping我们的虚拟机，发现已经ping通：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ping.png\" alt=\"ping\"></p>\n<h4 id=\"配置既能与主机通信同时还能与外网通信的桥接模式\"><a href=\"#配置既能与主机通信同时还能与外网通信的桥接模式\" class=\"headerlink\" title=\"配置既能与主机通信同时还能与外网通信的桥接模式\"></a>配置既能与主机通信同时还能与外网通信的桥接模式</h4><p>配置第二块网卡的原理十分简单，就是我们将我们主机的一块能够上网的网卡作为桥接网卡（可以理解为抽象成一台路由器上的网卡），这样，首先毫无疑问，我们的既然都是我们主机上的网卡了，自然主机与虚拟机之间是能够通信的，同时，我们的虚拟机还能够通过这块桥接网卡来与外界通信。</p>\n<p>以上的简略了解以后，我们首先可以知道，我们可以不再需要Host-Only这样的主机模式了。所以我们不再选择主机模式。</p>\n<p>选择桥接模式之前，我们首先查看我们当前能够使用的桥接的网络，在本次实验中，本人mac使用的是无线网卡en0连接的网络本地的局域网：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ifconfig</span></span><br><span class=\"line\">...</span><br><span class=\"line\">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tinet 172.20.10.12 netmask 0xfffffff0 broadcast 172.20.10.15</span><br><span class=\"line\">\tnd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class=\"line\">\tmedia: autoselect</span><br><span class=\"line\">\tstatus: active</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>在此基础之上，我们设置虚拟机的网络为桥接模式，取消仅主机模式网络，并且选择我们的无线网卡：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/nohostonly.png\" alt=\"nohostonly\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/en0.png\" alt=\"en0\"><br>接下来进入系统，验证网卡是否配置成功，之后在测试ping外网：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/ipaddrBridgeAndPing.png\" alt=\"ipaddrBridgeAndPing\"><br>再使用主机ping我们的虚拟机，发现没有问题<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/pingVM.png\" alt=\"pingVM\"><br>综上，我们的虚拟机 + 网络完全配置完成！</p>\n<h3 id=\"安装VirtaulBox增强工具包\"><a href=\"#安装VirtaulBox增强工具包\" class=\"headerlink\" title=\"安装VirtaulBox增强工具包\"></a>安装VirtaulBox增强工具包</h3><p>VirtualBox的增强工具包通常不需要我们再去下载，它通常伴随VirtualBox下载好了。一般会存放在对应应用的根目录下（在Windows中就是安装根目录），在mac中我们知道应用的根目录就是当我们安装的应用的包内容中：找到VitualBox应用，右键，“显示包内容”，“Contents”，“MacOS”，可以看到一个名为VBoxGuestAddition.iso镜像文件：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/additioniso.png\" alt=\"additioniso\"><br>接下来，就需要我们将这个iso镜像文件挂载到我们的Linux系统中。<strong>注意，一定要明确这个增强工具是给我们虚拟机中的Linux系统安装的</strong>。</p>\n<h4 id=\"为CentOS安装必要的开发库工具库\"><a href=\"#为CentOS安装必要的开发库工具库\" class=\"headerlink\" title=\"为CentOS安装必要的开发库工具库\"></a>为CentOS安装必要的开发库工具库</h4><p>进入Linux中，在前面安装配置好网络的基础上，我们使用yum安装如下待会增强功能包需要用到的工具库：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum update</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yum install gcc gcc-c++ make kernel-headers kernel-devel bzip2</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 务必注意先安装gcc、gcc-c++、make，这三个工具是后面编译的基础工具</span></span><br></pre></td></tr></table></figure><br>安装完成以后，reboot重启。<strong>(务必要重启，为了更新kernel内核系统信息)</strong></p>\n<h4 id=\"挂载增强功能镜像文件\"><a href=\"#挂载增强功能镜像文件\" class=\"headerlink\" title=\"挂载增强功能镜像文件\"></a>挂载增强功能镜像文件</h4><p>这里必须要提到Linux中的一个概念：<strong>挂载（mount）</strong>。根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”。实际上，我们Windows上同样也有挂载，比如U盘的插入并读写，新添加的硬盘并读写等等。这一切由于在Windows上已经有对应的驱动程序帮助我们自动的进行了，所以我们不太熟悉这个过程。而在Linux上，特别是在命令行界面下，我们要去读取一些系统以外的文件（就比如上面的U盘，光驱等），就必须要手动的去做这样一个操作。</p>\n<p>挂在的过程我们需要明确最主要的两点：设备以及挂载点。设备其实就是Linux操作系统中/dev/目录下显示那一些设备。挂载点其实就是Linux文件系统中的我们可以自定义的文件夹，在到时候使用挂在命令的时候，将外部文件系统与Linux内部文件系统关联起来的入口。可能还有些模糊，下面安装增强功能包会进一步根据实际来解释的。</p>\n<p>在上面我们已经安装好了开发工具并重启之后，我们首先点击VirtualBox上的“devices”选项，找到“Install Guest Addition CD image”：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/installdevices.png\" alt=\"installdevices\"><br>找到这一栏以后，我们点击它，现在是没有任何反应的，但是这里VirtualBox已经为我们将CD镜像“连接”到了Linux中了，就好像我们普通电脑装入光驱一个道理。</p>\n<p>补充：VirtualBox上的devices其实就是我们的外设接口一样。我们可以看到devices显示的Optical Drivers、Audio、Network以及USB，实际上就是为我们虚拟化的接口。假设我们想要将U盘数据传到Linux中，就可以现在电脑上插入U盘，然后在USB中找到我们这个插入的U盘对应的驱动选项，VirtualBox就会为我们读入U盘，之后在Linux中我们把对应的设备挂载到某一文件夹就可以读取了。</p>\n<p>继续上面的安装。接下来我们创建一个挂载点，挂载点通常就是创建一个临时的文件夹：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir tempdir</span></span><br></pre></td></tr></table></figure><br>创建完成以后，我们将cd设备挂载到这个文件夹上：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mount -t auto /dev/cdrom ./tempdir</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 完成挂载以后会打印设备的访问权限</span></span><br></pre></td></tr></table></figure><br>接下来，我们就可以进入刚刚创建的tempdir，我们可以看到这个文件中，出现了一些新的文件，这些文件其实就是刚刚增强功能包中的文件：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/tempdir.png\" alt=\"tempdir\"><br>看到这里，读者应该就能对挂载有基本更形象的认识了吧。其实就是将外部文件通过某一个我们内部创建的文件夹（挂载点）连接到我们Linux内部文件系统。<br>这个增强包中包含了Linux、Windows以及macOS系统的增强工具包。我们是Linux系统，所以运行VBoxLinuxAdditions.sh即可：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sh ./VBoxLinuxAdditions.sh</span></span><br></pre></td></tr></table></figure><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/building.png\" alt=\"building\"><br>完成以后，我们会发现系统的分辨率发生了变化，并且通过输出也知道增强工具安装成功了。</p>\n<p>最后请类似于像Windows上弹出U盘一样，卸载挂载点<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> umount tempdir</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"设置共享文件夹\"><a href=\"#设置共享文件夹\" class=\"headerlink\" title=\"设置共享文件夹\"></a>设置共享文件夹</h3><p>VirtualBox为我们设计了“共享文件夹”，方便Linux与主机之间的文件传输。这一功能需要增强功能包安装完成了才可以使用。</p>\n<p>这一步其实很简单，同样是在VirtualBox上的devices选项中，我们点击“Shared Folders” - “Shared Folders Settings”，点击新建共享文件夹按钮：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/newsf.png\" alt=\"newsf\"><br>在弹出来的界面设置在主机上的共享文件夹，这里我在桌面上创建了一个名为“sharefolder”的文件夹，并选择了它，同时为了方便，文件名我设置为了“sf”。下方第一条“只读”按需勾选（以后可以修改），“Auto-mount”自动挂载选上，方便系统中自动挂载读取，“Make Permanet”永久化一般也选上，以后一直用这个文件夹与虚拟机中的Linux进行文件共享。</p>\n<p>回到Linux中，我们为了方便文件的管理，创建一个名为myshare的文件夹作为挂载点。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir myshare</span></span><br></pre></td></tr></table></figure><br>接下来使用如下的命令将主机上的共享文件夹挂载进来：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mount -t vboxsf sf ./myshare</span></span><br></pre></td></tr></table></figure><br>于是，当我们在主机上往共享文件夹中操作文件的时候，刷新Linux中的文件夹，就可以实时的看到（反之亦然）：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/sharefile.png\" alt=\"sharefile\"><br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2018-03-06-Linux/deleteshare.png\" alt=\"deleteshare\"></p>\n<p>在此基础上，整个使用VirtualBox进行Linux虚拟机的搭建工作完成！</p>\n","categories":[],"tags":["Linux"]},{"title":"Java中的Integer","url":"http://compilemind.com/2017/08/22/2017-08-22-JavaInteger小记/","content":"<a id=\"more\"></a>\n<p>众所周知，在Java中，存在着值比较与应用比较两种情况。例如，如下的比较，可以根据值比较与引用比较来跟容易的判断出结果来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">123</span>;</span><br><span class=\"line\">String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">String s2 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(s1 == s2); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>这里，a与b由于是基本类型，所以Java在比较的时候直接就是按值来比较，而下面的s1与s2则是由于分别指向内容为“123”的字符串对象引用（关于string的细节，见本人的另一篇文章），而这两个字符串的地址并不一样，所以结果是false。</p>\n<p>那么，今天要讨论的是，对于Java自动拆装箱的问题的深入探讨。如下所示，请问结果是什么呢？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"number\">666</span>;</span><br><span class=\"line\">Integer b = <span class=\"number\">666</span>;</span><br><span class=\"line\">System.out.println(a == b);</span><br></pre></td></tr></table></figure></p>\n<p>结果是false，您可能会说，这有什么好问的，Integer对象的比较，引用的比较，而这两个只是值相同，而对象不同的Integer对象罢了，所以当然为false。好，那么我再问你，下面的结果是什么？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer b = <span class=\"number\">100</span>;</span><br><span class=\"line\">System.out.println(a == b);</span><br></pre></td></tr></table></figure><br>您可能说，哇，当我傻吗，当然还是false了。可是，结果是true。</p>\n<p>为什么同样的情况下，当值变小了，结果就变为true了呢。</p>\n<p>其实，Java中，对于可装箱的对象类型，都存在一个1字节的范围：-128到127。在这个范围类的数字，Java认为是常用的数字，所以自动进行了值比较，而不是进行引用的比较。所以，无论是Long还是Integer，只有你的值在-128到127，这两个对象的比较直接按照其所存储的值来进行。就像如下的情况：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer b = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer c = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer d = <span class=\"number\">127</span>;</span><br><span class=\"line\">Long e = -<span class=\"number\">129L</span>;</span><br><span class=\"line\">Long f = -<span class=\"number\">129L</span>;</span><br><span class=\"line\">Long g = -<span class=\"number\">128L</span>;</span><br><span class=\"line\">Long h = -<span class=\"number\">128L</span>;</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(c == d); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(e == f); <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(g == h); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":["Java","Integer"]},{"title":"理解$hadow$ocks与Proxy原理","url":"http://compilemind.com/2017/04/24/2017-04-24-理解$hadow$ocks与Proxy原理/","content":"<a id=\"more\"></a>\n<p><strong>以下所有提到$hadow$ocks的均以ss指代</strong></p>\n<h3 id=\"为什么要用ss呢？\"><a href=\"#为什么要用ss呢？\" class=\"headerlink\" title=\"为什么要用ss呢？\"></a>为什么要用ss呢？</h3><p>在早期（如今绝大多数也是），对于互联网的访问流程是及其简单的：浏览器（或其他客户端）向互联网服务器提出一个请求（request），然后等待互联网服务器回应（response），最后在本地解析渲染。麻烦一点的，中间会有多个代理帮助我们进行数据的请求。<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/requestresponse.png\" alt=\"requestresponse\"></p>\n<p>后来，墙出现了，我们不能再愉快的访问外网了。因为墙相当于一个巨大的墙阻挡着我们和外界，当我们想要访问外网的时候，这个请求数据包必然会经过墙的检查：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/checkbyw.png\" alt=\"checkbyw\"><br>当检查到被墙禁止访问的内容请求的时候，自然会被“过滤”或被“忽视”掉。但，有人还是想要往墙外看看。怎么办呢？有人想出了一个方法，如同最上面图中右边的拓扑，但是中间代理服务器本身就在国外，当我们想要访问外部内容的时候，首先和这个在国外的代理服务器进行ssh通信，告诉它，我想要请求xx资源，再让这台代理服务器去访问目标服务器，得到回应之后，再把我们想要的数据通过ssh传递给我们：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/byssh.png\" alt=\"byssh\"></p>\n<p>刚开始这样还不错。因为ssh本身基于RSA加密，所以首先，墙无法查看其请求内容（ip、内容等），所以也就无法分析你的请求关键词（用于筛选连接），避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh本身的特征是明显的，我们的墙研发人员根据相关的如连接频率、连接时间等进行分析，再通过一定的手段干预连接，于是后来墙愈来越强了。使用ssh tunnel的方式不太灵了！ </p>\n<p>既然ssh你还能看出连接时间、频率等特征值。那我干脆不用了，转换一下，我往外界发送合法的TCP数据包该没有问题吧？好，每次我访问某个资源的时候，首先将请求在本地转换为（拆分、加密等手段）一个个非常规端口的TCP数据包，里面的内容也是加密过的。当我发送给外部服务器的时候，墙只能知道你发送的是合法TCP数据包，它也不敢妄自丢弃和查看特征值，因为他没法保证这个TCP数据包究竟是要请求什么，外面看来本身就是个普通的数据包。等发到外部的代理服务器的时候，我运用相关的协议进行重组解密，得到原始请求。后面就和ssh tunnel有异曲同工之妙。于是，如下的拓扑出现了：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/bysock.png\" alt=\"bysock\"></p>\n<p>理解了这个之后，搭建服务器就是一件很简单的事情了。网上资源很多，这里不再赘述。</p>\n<h3 id=\"Privoxy作用\"><a href=\"#Privoxy作用\" class=\"headerlink\" title=\"Privoxy作用\"></a>Privoxy作用</h3><p>当我们搭建好了ss服务器之后，我们本地需要使用ss客户端监听1080（通常的默认端口），配置相关的命令，从而实现当我们本地机器访问外部网络的时候，请求数据首先经过本的1080端口进行加密拆分为原始的TCP数据包。然而需要注意的是，当我们监听了默认的1080端口之后，并不意味着，我们访问数据的时候，所有网络数据就走1080这个ss客户端监听的端口了。由于Windows和macOS客户端通常包含了相关的代理转发功能，所以我们在进行HTTP或者是HTTPS的时候，会默认的启动一个代理转发的模块，来替我们监听HTTP和HTTPS请求，并将这些请求数据送入1080端口应用（即ss客户端）。</p>\n<p>然而，在Linux下的ss客户端，并没有包含这个功能，所以，但我们进行HTTP(s)请求的时候，需要设置代理，当我们使用Privoxy的时候，安装Privoxy：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo yum -y install epel-release</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo yum -y install privoxy</span></span><br></pre></td></tr></table></figure><br>第一步的安装epel这是因为像centos这类衍生出来的发行版，他们的源有时候内容更新的比较滞后，或者说有时候一些扩展的源根本就没有。EPEL(<a href=\"http://fedoraproject.org/wiki/EPEL\">http://fedoraproject.org/wiki/EPEL</a>) 是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。</p>\n<p>默认的配置文件地址在 /etc/privoxy/config 目录下。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 把本地HTTP流量转发到本地1080 SOCKS5代理</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 即当我们发出HTTP(S)请求的时候，会将请求转为Socks5</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意最后的 <span class=\"string\">&quot;.&quot;</span></span></span><br><span class=\"line\">forward-socks5 / 127.0.0.1:1080 .</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 可选，默认监听本地连接端口为8118</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> listen-address 127.0.0.1:8118</span></span><br></pre></td></tr></table></figure><br>接下里启动：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start privoxy</span><br></pre></td></tr></table></figure><br>配置完成以后还没有结束！请考虑一下，目前我们只是设定了如果有对于所有HTTP(S)的访问（即foward-sock5后面的“/”）都将转为socks5送入被ss客户端监听的1080端口中去，但是并没有设定HTTP(S)代理服务器！，所以，最后你还需要在.bash_profile（或者是.bashrc）中设定代理服务器的环境变量：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy=http://127.0.0.1:8118</span><br><span class=\"line\">export https_proxy=https://127.0.0.1:8118</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 最后再<span class=\"built_in\">source</span>一下</span></span><br></pre></td></tr></table></figure><br>最后，我们再以一个整体拓扑来表达一下我们的访问流程：<br><img src=\"https://cdn.jsdelivr.net/gh/w4ngzhen/CDN/images/post/2017-04-26-ss/flow.png\" alt=\"flow\"></p>\n","categories":[],"tags":["shadowsocks","proxy"]},{"title":"Java String的探讨","url":"http://compilemind.com/2017/04/18/2017-04-18-JavaString探讨/","content":"<p>关于String相关内容的学习，历来都是Java学习必不可少的一个经历。</p>\n<p>以前一直想要好好总结一下String的相关的知识点，苦于没有时间，终于在今天有一个闲暇的时间来好好总结一下，也希望这文章能够加深我对于String相关内容的理解~（ps:在我看来，学习某些知识点的时候把学到的想到的都记录下一方面能够加深自己学习印象，二者能够锻炼锻炼我的文笔~）</p>\n<a id=\"more\"></a>\n<p>首先JVM中存在着一个字符串池String pool，其中保存着很多String对象，这些String对象可以被共享使用，因此这个pool的存在在很多方面提高Java一些String操作的效率。 而这一些都是基于String类是final的，它的值一经创建就不可改变。String pool由String类维护，所以我们可以调用intern()方法来访问字符串池。</p>\n<p>接下里我们来看第一个例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"string\">&quot;abc&quot;</span>;     </span><br><span class=\"line\">String s2 = <span class=\"string\">&quot;abc&quot;</span>;       </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s1 == s2 : &quot;</span>+(s1==s2)); <span class=\"comment\">//true     </span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s1.equals(s2) : &quot;</span> + (s1.equals(s2))); <span class=\"comment\">//true </span></span><br></pre></td></tr></table></figure><br>在这个例子中，虚拟机进行了哪些操作呢？首先，因为在此s1我是直接使用了”abc”，那么系统会在String pool中创建了一个String对象,他的值就是”abc”，s2进行创建的时候，系统先搜索String pool中是否已经存在了”abc”，由于String pool中已经存在了一个”abc”的String对象，很好，系统直接将s2指向了String pool中的那个”abc”地址。所以下面两个输出都是true。<br>上面都是使用””来创建String对象的，第二个例子我们使用new来创建：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s3 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;abc&quot;</span>);   </span><br><span class=\"line\">String s4 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;abc&quot;</span>);   </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s3 == s4 : &quot;</span>+(s3==s4)); <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s3.equals(s4) : &quot;</span>+(s3.equals(s4))); <span class=\"comment\">//true </span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s1 == s3 : &quot;</span>+(s1==s3)); <span class=\"comment\">//false   </span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s1.equals(s3) : &quot;</span>+(s1.equals(s3))); <span class=\"comment\">//true  </span></span><br></pre></td></tr></table></figure><br>在这里，应当要提一点。对于new String来说，该构造函数的对象接收一个String字符串对象。其实这里进行了两件事情：</p>\n<p>步骤一：系统首先会创建一个String对象”abc”，通过String temp = “abc”来创建的（temp只是我自己取得名字，至于到底叫什么，我们是不用关心的），这个创建过程和第一个例子是一样的道理，他会在String pool去寻找’”abc”，然后根据有没有来判断是额外的创建还是直接用String pool中的那个”abc”。</p>\n<p>步骤二：new String接受了刚刚的temp参数以后，在堆上去创建一个对象，把刚刚的temp的值”abc”赋给这个在堆中的String对象的值。</p>\n<p>步骤三：把s3指向刚刚在堆中的这个String对象。</p>\n<p>通过以上的几步我们可以知道，使用new String完全没有直接使用=””来的快。</p>\n<p>s4的创建是同样的道理，所以s3、s4最终都各自指向了内容相同，地址不同的，在堆中的String对象。所以又由于==在对于对象的比较的时候是直接比较的引用的地址。所以第一、三个输出是false。但是equals对于String比较的是内容的是否相等，所以第二、四个输出true。</p>\n<p>接下来是第三种例子，String中 + 的重载：</p>\n<p>由于我们知道，常量的值在编译的时候就已经进行了优化了。所以这一行代码：</p>\n<p> String str1 = “ab” + “cd”;<br>在编译的时候就等价于优化过的</p>\n<p>String str1 = “abcd”;<br>所以执行下面这几行代码的时候，根据常量编译优化，加上我对于第一个例子的讲解，我们可以知道输出是true：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">&quot;ab&quot;</span> + <span class=\"string\">&quot;cd&quot;</span>;  <span class=\"comment\">//1个对象  </span></span><br><span class=\"line\">String str2 = <span class=\"string\">&quot;abcd&quot;</span>;   </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;str1 = str2 : &quot;</span>+ (str1 == str2));  <span class=\"comment\">//输出为true</span></span><br></pre></td></tr></table></figure><br>接下来就是第四种情形了，这种情况依然是String + 的重载，但是比起第三种是有本质的不同的。首先看代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str2 = <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\">String str3 = <span class=\"string\">&quot;cd&quot;</span>;                                       </span><br><span class=\"line\">String str4 = str2 + str3;                                        </span><br><span class=\"line\">String str5 = <span class=\"string\">&quot;abcd&quot;</span>;    </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;str4 = str5 : &quot;</span> + (str4 == str5));</span><br></pre></td></tr></table></figure><br>解读这一段代码，str2、str3就是情况一，我们不再讨论。此刻str4比起第三种的 + 两端都是String常量而言，这里是对于编译器来说是两个变量。这一个部分，系统会干什么呢？首先，系统会new 一个StringBuilder对象，然后调用该对象的append函数，把str2、str3按顺序连接起来。连接好以后，调用StringBuilder的toString方法，该方法内部new 一个String对象，并把它return。得到str2 + str3的结果，接着str4指向堆中的这个String对象。</p>\n<p>注意：对于StringBuilder的创建还有其他的情况。比如假设此处的String str4 = “ab” + “c” + str2 那么，编译器首先会进行一个优化，也就是第三种情况所说的他会优化为String str4 = “abc” + str2 然后，new StringBuilder(“abc”)，然后append(str2)。也就是说，从=号右边开始前部分，他首先会在编译过程判断能否进行优化，可以优化，由优化为最大的常量子串，然后new一个以该最大子串的为初始值的StringBuilder对象，然后再append。</p>\n<p>所以，在以上的这四条String创建语句中，创建了str2、str3、str5三个在String pool中的字符串常量，以及在系统内部进行append的StringBuilder，以及toString函数return的在堆中创建的String对象，一共五个对象。</p>\n<p>那么最终输出结果当然是false，前者是指向堆中的String对象的地址，而后者是S指向tring pool中String对象的地址。</p>\n<p>但是，还有一种变量情况是不一样的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> String str1 = <span class=\"string\">&quot;b&quot;</span>;  </span><br><span class=\"line\">String str2 = <span class=\"string\">&quot;a&quot;</span> + str1;  </span><br><span class=\"line\">String str3 = <span class=\"string\">&quot;ab&quot;</span>;  </span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;str2 = str3 : &quot;</span>+ (str2 == str3)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure><br>这里按照情况四中注意部分来说，输出本来应该是false，但是为什么是true呢？注意看str1前面的修饰符，这里使用了final修饰符，final修饰的变量表示是一个常量，在创建额时候就需要初始化，并且不可修改。在final关键字的修饰下，编译器会在编译过程中就进行优化，其实这里的道理就和例子三是一样的了。这也是为什么这里输出的是true。</p>\n","categories":[],"tags":["Java","String"]},{"title":"修改MySql Root密码（包含忘记密码的方式）","url":"http://compilemind.com/2017/04/04/2017-04-04-修改MysqlRoot密码/","content":"<p>曾几何时，我也是记得MySQL root密码的人，想要修改root密码还不是轻而易举的事？下面前三种修改改方式都是在记得密码的情况下进行修改，如果你忘记了原本的root，请直接跳至 <strong>终极</strong></p>\n<a id=\"more\"></a>\n<p><strong>第一种：</strong><br>在MySQL中修改：mysql&gt; set password for root@localhost = password(‘新密码’);<br>当然，你也可以在root账户下去修改其他账户的密码，只需要将root换为其他账户即可<br>（注意：后面的localhost是指只能在本地登陆的账户，在修改其他账户密码时一定要对应其可登录范围修改@后面的字段属性）</p>\n<p><strong>第二种：</strong><br>直接进入mysql数据库中，修改user表中的root的password。<br>mysql&gt; use mysql;<br>mysql&gt; update user set password = password(‘新密码’) where user = ‘root’ and host = ‘localhost’;<br>(注意：这个host后面的东西的意义和上面一样)<br>mysql&gt; flush privileges; （记得刷新权限）</p>\n<p><strong>第三种：</strong><br>不要忘了mysqladmin<br><figure class=\"highlight plain\"><figcaption><span>-u root -p 123456 password 123``` 就行了</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">然而重点来了，在以上的几种方法，都是针对于我们还记得root用户密码。可是一开始就忘了root密码了怎么办？</span><br><span class=\"line\">**终极：**</span><br><span class=\"line\">1．首先确认服务器出于安全的状态，也就是没有人能够任意地连接MySQL数据库。</span><br><span class=\"line\"></span><br><span class=\"line\">2．修改MySQL的登录设置：</span><br><span class=\"line\">&#96;&#96;&#96;# vi &#x2F;etc&#x2F;my.cnf&#96;&#96;&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">在[mysqld]的段中加上一句：skip-grant-tables （这一句话表示，绕过所有的用户权限）</span><br><span class=\"line\">例如：</span><br></pre></td></tr></table></figure><br>[mysqld]<br>datadir=/var/lib/mysql<br>socket=/var/lib/mysql/mysql.sock<br>skip-grant-tables<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">保存并且退出vi。</span><br><span class=\"line\"></span><br><span class=\"line\">3．重新启动mysqld</span><br><span class=\"line\">&#96;&#96;&#96;service mysqld restart&#96;&#96;&#96;</span><br><span class=\"line\">好了，在此基础上，你就可以直接mysql进入数据库了</span><br><span class=\"line\"></span><br><span class=\"line\">4．登录并修改MySQL的root密码</span><br></pre></td></tr></table></figure><br>mysql<br>mysql&gt; USE mysql ;<br>mysql&gt; UPDATE user SET Password = password ( ‘新密码’ ) WHERE User = ‘root’ ;<br>mysql&gt; flush privileges ;<br>mysql&gt; quit<br>Bye</p>\n<pre><code>5．将MySQL的登录设置修改回来\n```# vi /etc/my.cnf\n</code></pre><p>将刚才在[mysqld]的段中加上的skip-grant-tables删除<br>保存并且退出vi。</p>\n<p>6．重新启动mysqld<br><code>service mysqld restart</code></p>\n<p>好了，重新使用新密码的root账户吧</p>\n","categories":[],"tags":["Mysql"]},{"title":"Java学习路线【转】","url":"http://compilemind.com/2017/02/21/2017-02-21-Java学习路线【转】/","content":"<a id=\"more\"></a>\n<ol>\n<li><strong>第一阶段：JavaSE（Java基础部分）</strong></li>\n</ol>\n<ul>\n<li>Java开发前奏<br>计算机基本原理，Java语言发展简史以及开发环境的搭建，体验Java程序的开发，环境变量的设置，程序的执行过程，相关反编译工具介绍，java开发工具Eclipse的安装和使用，javadoc的说明。</li>\n<li>Java基础语法<br>Java语法格式，常量和变量，变量的作用域，方法和方法的重载，运算符，程序流程控制，数组和操作数组的类，对数组循环遍历以及针对数组的常用查找、排序算法原理，最后使用Java程序进行功能实现。</li>\n<li>面向对象编程<br>理解对象的本质，以及面向对象，类与对象之间的关系，如何用面向对象的思想分析和解决显示生活中的问题，并java程序的手段编写出来。如何设计类，设计类的基本原则，类的实例化过程，类元素：构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类，Java的垃圾对象回收机制。对象的三大特性：封装、继承和多态。子类对象的实例化过程、方法的重写和重载、final关键字、抽象类、接口、继承的优点和缺点。 对象的多态性：子类和父类之间的转换、父类纸箱子类的引用、抽象类和接口在多态中的应用、多态优点。常用设计模式如单利、模版等模式。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用import关键字。</li>\n<li>多线程应用<br>多线程的概念，如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁问题的剖析。</li>\n<li>JavaAPI详解<br>JavaAPI介绍、String和StringBuffer、各种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。常用的集合类使用如下：Java Collections Framework：Collection、Set、List、ArrayList、Vector、LinkedList、Hashset、TreeSet、Map、HashMap、TreeMap、Iterator、Enumeration等常用集合类API。</li>\n<li>IO技术<br>什么是IO，File及相关类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应缓冲流和管道流，字节和字符的转化流，包装流，以及常用包装类使用，分析java的IO性能。</li>\n<li>网络编程<br>Java网络编程，网络通信底层协议TCP/UDP/IP，Socket编程。网络通信常用应用层协议简介：HTTP、FTP等，以及WEB服务器的工作原理。</li>\n<li>Java高级特性<br>递归程序，Java的高级特性：反射、代理和泛型、枚举、Java正则表达式API详解及其应用。</li>\n</ul>\n<ol>\n<li><strong>第二阶段：数据库技术</strong></li>\n</ol>\n<ul>\n<li>ORACLE基础管理<br>Oracle背景简介，数据库的安装，数据库的用户名和密码，客户端登录数据库服务SQLPLUS，数据库基本概。</li>\n<li>SQL语句<br>数据库的创建，表的创建，修改，删除，查询，索引的创建，主从表的建立，数据控制授权和回收，事务控制，查询语句以及运算符的详解，sql中的函数使用。</li>\n<li>多表连接和字查询<br>等值和非等值连接，外连接，自连接；交叉连接，自然连接，using子句连接，完全外连接和左右外连接，子查询使用以及注意事项。</li>\n<li>触发器、存储过程<br>触发器和存储过程使用场合， 通过实例进行详解。</li>\n<li>数据库设计优化<br>WHERE子句中的连接顺序，选择最有效率的表名顺序，SELECT子句中避免使用 ‘ * ’计算记录条数等等。</li>\n<li>数据备份与移植<br>移植技巧，备份方案；导入导出等。</li>\n</ul>\n<ol>\n<li><strong>第三阶段：JDBC技术</strong></li>\n</ol>\n<ul>\n<li>JDBC基础<br>JDBC Connection、Statement、PreparedStatement、CallableStatement、ResultSet等不同类的使用。</li>\n<li>连接池技术<br>了解连接池的概念，掌握连接池的建立、治理、关闭和配置。</li>\n<li>ORM与DAO封装<br>对象关系映射思想，JDBC的DAO封装，实现自己的JDBC。</li>\n</ul>\n<ol>\n<li><strong>第四阶段：WEB基础技术</strong></li>\n</ol>\n<ul>\n<li>XML技术<br>使用jdom和dom4j来对xml文档的解析和生成操作，xml的作用和使用场合。</li>\n<li>HTML/CSS<br>Java掌握基本的html标签的格式和使用，css层叠样式表对div的定义，实现对网站布局的基本实现。</li>\n<li>JavaScript<br>了解javascript的基本语法以及相关函数的使用，并结合html页面实现流程控制和页面效果展示。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用import关键字。</li>\n<li>JSP/Servlet<br>Servlet和JSP技术、上传下载、Tomcat服务器技术、servlet过滤器和监听器。</li>\n<li>JSTL与EL<br>JSTL核心标签库、函数标签库、格式化标签库、自定义标签技术、EL表达式在jsp页面的使用。</li>\n<li>AJAX及框架技术<br>AJAX框架Jquery渲染页面效果和相关的强大的第三方类库，dwr如何和后台服务进行数据传输，以及页面逻辑控制等。</li>\n<li>JSON高级应用<br>Java使用JSON支持的方式对字符串进行封装和解析，实现页面和Java后台服务的数据通信。</li>\n<li>Fckeditor编辑器<br>FCKEditor在线编辑器技术、配置、处理图片和文件上传。</li>\n<li>JavaMail技术<br>了解域名解析与MX记录、电子邮件工作原理、邮件传输协议：SMTP、POP3、IMAP、邮件组织结构：RFC822邮件格式、MIME协议、邮件编码、复合邮件结构分析、JavaMail API及其体系结构、编程创建邮件内容：简单邮件内容、包含内嵌图片的复杂邮件、包含内嵌图片和附件的复杂邮件。</li>\n<li>JfreeChart报表<br>统计报表；图表处理。</li>\n<li>BBS项目实战<br>采用Jquery+dwr+jsp+servlet+Fckeditor+JfreeChart+tomcat+jdbc(oracle)完成BBS项目的实战。学完此实战你至少已经是拥有近1年开发经验的程序员了，但是你不应该满足现状，继续下去！</li>\n</ul>\n<ol>\n<li><strong>第五阶段：WEB主流框架技术（项目实战）</strong></li>\n</ol>\n<ul>\n<li>Struts2.x<br>struts2框架的工作原理和架构分析，struts-default.xml与default.properties文件的作用，struts。Xml中引入多个配置文件。OGNL表达式、Struts2 UI和非UI标签、输入校验、使用通配符定义action、动态方法调用、多文件上传、自定义类型转换器、为Action的属性注入值、自定义拦截器、异常处理、使用struts2实现的CRUD操作的案例。</li>\n<li>Hibernate<br>Hibernate应用开发基础； ORM基础理论； 关系映射技术； 性能调优技术； 性能优化 一级缓存 二级缓存 查询缓存 事务与并发 悲观锁、乐观锁。</li>\n<li>Spring4.x<br>Spring IoC技术；Spring AOP技术；Spring声明事务管理；Spring常用功能说明，spring4.x的新特性，Spring整合Struts2和Hibernate3的运用。</li>\n<li>Log4j与Junit<br>Logging API；JUnit单元测试技术； 压力测试技术：badboy进行测试计划跟踪获取以及JMeter压力测试。</li>\n<li>在线支付技术<br>完成支付宝的支付接口的在线支付功能。</li>\n<li>电子商务网站实战<br>采用Spring4.x + Hibernate3 + Struts2 + Jquery + dwr + FckEditor + Tomcat完成电子商务网站实战开发。</li>\n</ul>\n<ol>\n<li><strong>第六阶段：WEB高级进阶（项目实战）</strong></li>\n</ol>\n<ul>\n<li>OpenJPA技术<br>JPA介绍及开发环境搭建、单表实体映射、一对多/多对一、一对一、多对多关联、实体继承、复合主键、JPQL语句、EntityManager API、事务管理，了解一下jpa2.0的新特性以及应用。</li>\n<li>Lucene搜索引擎<br>了解全文搜索原理、全文搜索引擎、什么是OSEM、OSEM框架Compass、基于使用Lucene使用Compass实现全文增量型索引创建和搜索、探索Lucene 3.0以及API。</li>\n<li>电子商务重构<br>此项目采用了Lucene+compass+openJpa+上一版电子商务网站的技术进行重构。</li>\n<li>Excel/PDF文档处理技术<br>Java对Excel和pdf文档分别利用poi和itext来进行解析和生成。此技术在企业级系统的报表中经常使用。</li>\n<li>OA工作流技术JBPM<br>工作流是什么、JBPM介绍、JBPM的主要用法、各类节点的用法、任务各种分派方式、JBPM的整体架构原理、工作流定义模型分析、运行期工作流实例模型分析、数据库表模型分析、流程定义管理、流程实例监控、对JBPM的相关接口进行封装，构建自己的工作流应用平台等。</li>\n<li>WebService技术<br>WebService技术原理、WebService技术的应用、Soap服务的创建与管理、WSDL描述文档规范、UDDI注册中心运行原理;使用Axis和Xfire创建WEB服务、Webservice客户端的编写、使用TCPMonitor监听SOAP协议、异构平台的整合。</li>\n<li>Linux操作系统<br>Linux系统安装，卸载、linux使用的核心思想、Linux下的用户管理，文件管理,系统管理、程序的安装，使用，卸载。Linux下作为server的基本应用：web服务器，j2ee服务器，ftp服务器的安装和项目的部署。</li>\n<li>CRM项目实战<br>此项目能了解和熟悉客户关系管理的基本流程以及功能的实现，采用上面几个阶段学到的主流框架实现，同时加入了JBPM的技术。！</li>\n</ul>\n<ol>\n<li><strong>第七阶段：大型高并发网站优化解决（项目实战）</strong></li>\n</ol>\n<ul>\n<li>如何构建一个高性能网站详解<br>什么样的网站需要高性能，高性能的指标体系，构建高性能网站需要做哪些工作，注意哪些细节。</li>\n<li>SSI技术<br>什么是SSI，使用他有什么好处，什么样的系统才使用SSI，SSI技术详解和使用，应用到项目中。</li>\n<li>静态页面生成技术<br>什么是静态页，为什么需要静态页以及带来的好处，生成静态页的模版技术Velocity和Freemark，生成静态页的访问规则等。</li>\n<li>缓存技术<br>为什么使用缓存技术，oscache缓存技术的介绍和使用，memcached缓存技术的介绍和使用、两者缓存技术的比较和如何去使用。</li>\n<li>经典WEb服务器<br>什么是web服务器，什么是JavaWeb服务器，他们存在什么关系，当前技术主流中常用的Web服务器有哪些，WEB服务器Apache和Nginx的应用。</li>\n<li>Nginx架构实战<br>什么是反向代理，负载均衡以及集群，在Nginx中如何实现这些高性能的系统架构。</li>\n</ul>\n","categories":[],"tags":["Java"]},{"title":"search","url":"http://compilemind.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://compilemind.com/tags/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://compilemind.com/about/index.html","content":"<h1 id=\"ZHEN\"><a href=\"#ZHEN\" class=\"headerlink\" title=\"ZHEN\"></a>ZHEN</h1><p>1996 Spring</p>\n<p>常用语言：Java、JS、C#</p>\n<p>技术爱好：Java、Scala、C#、JS，喜欢Linux，喜欢VIM，喜欢编译原理</p>\n<p>现居地：成都</p>\n","categories":[],"tags":[]}]